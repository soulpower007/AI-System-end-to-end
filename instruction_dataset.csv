chunk,instruction
"# ROS 2 Documentation

This repository contains the sources for the ROS 2 documentation that is hosted at [https://docs.ros.org/en](https://docs.ros.org/en).
The sources from this repository are built and uploaded to the site nightly by a [Jenkins job](https://build.ros.org/job/doc_ros2doc).

## Contributing to the documentation

Contributions to this site are most welcome.
Please see the [Contributing to ROS 2 Documentation](https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Contributing-To-ROS-2-Documentation.html) page to learn more.

## Contributing to ROS 2

To contribute to the ROS 2 source code project please refer to the [ROS 2 contributing guidelines](https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing.html).

## Prerequisites

To build this you need to install

* make
* graphviz

With [venv](https://docs.python.org/3/library/venv.html)

```
# activate the venv
python3 -m venv ros2doc

# activate venv
source ros2doc/bin/activate

# install required packages
pip install -r requirements.txt -c constraints.txt

# deactivate the venv
(ros2doc) deactivate
```

### Pinned versions

For development we currently use Noble as our build platform.
And all python versions are pinned in the constraints file to make sure that things are reproducible.
To upgrade the system validate that things are working and then use `pip freeze > constraints.txt` to lock in the versions to upgrade.

## Building HTML

### Local development test

For local testing of the current tree use:

`make html`

`sensible-browser build/html/index.html`

### Deployment test

To test building the multisite version deployed to the website use:

`make multiversion`

`sensible-browser build/html/rolling/index.html`

**NB:** This will ignore local workspace changes and build from the branches.
",What prerequisites are needed to build the ROS 2 documentation?
".. _citation:

Citations
=========

If you use ROS 2 in your work please cite the 2022 Science Robotics paper `Robot Operating System 2: Design, architecture, and uses in the wild <https://www.science.org/doi/10.1126/scirobotics.abm6074>`_.

    | S. Macenski, T. Foote, B. Gerkey, C. Lalancette, W. Woodall, ""Robot Operating System 2: Design, architecture, and uses in the wild,"" Science Robotics vol. 7, May 2022.

.. code-block:: bibtex

    @article{doi:10.1126/scirobotics.abm6074,
        author = {Steven Macenski and Tully Foote and Brian Gerkey and Chris Lalancette and William Woodall},
        title = {Robot Operating System 2: Design, architecture, and uses in the wild},
        journal = {Science Robotics},
        volume = {7},
        number = {66},
        pages = {eabm6074},
        year = {2022},
        doi = {10.1126/scirobotics.abm6074},
        URL = {https://www.science.org/doi/abs/10.1126/scirobotics.abm6074}
    }


If you use ROS 2 Composition in your work, please cite the 2023 IEEE RA-L paper `Impact of ROS 2 Node Composition in Robotic Systems <https://arxiv.org/abs/2305.09933>`_.

    | S. Macenski, A. Soragna, M. Carroll, Z. Ge, ""Impact of ROS 2 Node Composition in Robotic Systems"", IEEE Robotics and Autonomous Letters (RA-L), 2023.

.. code-block:: bibtex

    @article{doi:10.48550/arXiv.2305.09933,
        author = {Steven Macenski and Alberto Soragna and Michael Carroll and Zhenpeng Ge},
        title = {Impact of ROS 2 Node Composition in Robotic Systems},
        journal = {IEEE Robotics and Autonomous Letters (RA-L)},
        year = {2023},
        doi = {10.48550/arXiv.2305.09933},
        URL = {https://arxiv.org/abs/2305.09933}
    }
",What citation is recommended for those using ROS 2 Composition in their work?
".. _InstallationGuide:
.. _RollingInstall:

Installation
============

Options for installing ROS 2 {DISTRO_TITLE_FULL}:

.. toctree::
   :hidden:
   :glob:

   Installation/Ubuntu-Install-Debs
   Installation/Windows-Install-Binary
   Installation/RHEL-Install-RPMs
   Installation/Alternatives
   Installation/Maintaining-a-Source-Checkout
   Installation/Testing
   Installation/DDS-Implementations

Binary packages
---------------

Binaries are only created for the Tier 1 operating systems listed in `REP-2000 <https://www.ros.org/reps/rep-2000.html#rolling-ridley-june-2020-ongoing>`__.
Given the nature of Rolling, this list may be updated at any time.
If you are not running any of the following operating systems you may need to build from source or use a :doc:`container solution <How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers>` to run ROS 2 on your platform.

We provide ROS 2 binary packages for the following platforms:

* Ubuntu Linux - Noble Numbat (24.04)

  * :doc:`deb packages <Installation/Ubuntu-Install-Debs>` (recommended)
  * :doc:`binary archive <Installation/Alternatives/Ubuntu-Install-Binary>`

* RHEL 9

  * :doc:`RPM packages <Installation/RHEL-Install-RPMs>` (recommended)
  * :doc:`binary archive <Installation/Alternatives/RHEL-Install-Binary>`

* Windows 10

  * :doc:`Windows Binary (VS 2019) <Installation/Windows-Install-Binary>`

.. _building-from-source:

Building from source
--------------------

We support building ROS 2 from source on the following platforms:

* :doc:`Ubuntu Linux 24.04 <Installation/Alternatives/Ubuntu-Development-Setup>`
* :doc:`Windows 10 <Installation/Alternatives/Windows-Development-Setup>`
* :doc:`RHEL-9/Fedora <Installation/Alternatives/RHEL-Development-Setup>`
* :doc:`macOS <Installation/Alternatives/macOS-Development-Setup>`

Which install should you choose?
--------------------------------

Installing from binary packages or from source will both result in a fully-functional and usable ROS 2 install.
Differences between the options depend on what you plan to do with ROS 2.

**Binary packages** are for general use and provide an already-built install of ROS 2.
This is great for people who want to dive in and start using ROS 2 as-is, right away.

Linux users have two options for installing binary packages:

- Packages (debs or RPMS, depending on the platform)
- binary archive

Installing from packages is the recommended method, as it installs necessary dependencies automatically and also updates alongside regular system updates.
However, you need root access in order to install deb packages.
If you don't have root access, the binary archive is the next best choice.

Windows users who choose to install from binary packages only have the binary archive option
(deb packages are exclusive to Ubuntu/Debian).

**Building from source** is meant for developers looking to alter or explicitly omit parts of ROS 2's base.
It is also recommended for platforms that don't support binaries.
Building from source also gives you the option to install the absolute latest version of ROS 2.

Contributing to ROS 2 core?
^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you plan to contribute directly to ROS 2 core packages, you can install the :doc:`latest development from source <Installation/Alternatives/Latest-Development-Setup>` which shares installation instructions with the :ref:`Rolling distribution <rolling_distribution>`.
",Which options are available for installing ROS 2 {DISTRO_TITLE_FULL} on different platforms according to the document provided?
"
Related Projects
================

Gazebo
------

**Gazebo** `(gazebosim.org) <http://gazebosim.org/>`_ and its predecessor Gazebo Classic are the first open source choice for 3D physics simulation of ROS-based robots.

Large Community Projects
------------------------

Large community projects involve multiple developers from all over the globe and are typically backed by a dedicated working group (cf. :doc:`The-ROS2-Project/Governance`).

* **ros2_control** `(control.ros.org) <https://control.ros.org/>`_: Flexible framework for real-time control of robots implemented with ROS 2.
* **Navigation2** `(nav2.org) <https://nav2.org/>`_: Comprehensive and flexible navigation stack for mobile robots using ROS 2.
* **MoveIt** `(moveit.ai) <https://moveit.ai/>`_: A rich platform for building manipulation applications featuring advanced kinematics, motion planning, control, collision checking, and much more.
* **micro-ROS** `(micro.ros.org) <https://micro.ros.org/>`_: A platform for putting ROS 2 onto microcontrollers, starting at less than 100 kB of RAM.

Further Community Projects
--------------------------

The global ROS community develops and maintains hundreds of further packages on top of the core ROS 2 stack.
Some of them come with their own websites for documentation.
Your best entry point to discover these works is the **ROS Index** `(index.ros.org) <https://index.ros.org/packages/>`_.

*Hint for developers:* If you maintain a ``README.md`` file in the root of your package folder (which is not necessarily the root of your repository), this file is rendered into the overview page of your package at `index.ros.org <https://index.ros.org/packages/>`_.
The file may be used for documenting your package and supersedes the package documentation pages in the ROS Wiki from ROS 1.
See the `fmi_adapter package <https://index.ros.org/p/fmi_adapter/github-boschresearch-fmi_adapter/#foxy>`_ as an example.

Company-driven Projects
-----------------------

.. toctree::
   :maxdepth: 1

   Related-Projects/Intel-ROS2-Projects
   Related-Projects/Nvidia-ROS2-Projects
   Related-Projects/Visualizing-ROS-2-Data-With-Foxglove
","What is the purpose of the Gazebo project and its predecessor, Gazebo Classic?"
"Glossary
========

.. include:: ../global_substitutions.txt

Glossary of terms used throughout this documentation:

.. glossary::

   API
       An API, or Application Programming Interface, is an interface that is provided by an ""application"", which in this case is usually a shared library or other language appropriate shared resource. APIs are made up of files that define a contract between the software using the interface and the software providing the interface. These files typically manifest as header files in C and C++ and as Python files in Python. In either case it is important that APIs are grouped and described in documentation and that they are declared as either public or private. Public interfaces are subject to change rules and changes to the public interfaces prompt a new version number of the software that provides them.

   client_library
       A client library is an :term:`API` that provides access to the ROS graph using primitive middleware concepts like Topics, Services, and Actions.

   package
       A single unit of software, including source code, build system files, documentation, tests, and other associated resources.

   REP
        ROS Enhancement Proposal. A document that describes an enhancement, standardization, or convention for the ROS community.
        The associated REP approval process allows the community to iterate on a proposal until some consensus has been made, at which point it can be ratified and implemented, which then becomes documentation.
        All REPs are viewable from the `REP index <http://www.ros.org/reps/rep-0000.html>`_.

   VCS
       Version Control System, such as CVS, SVN, git, mercurial, etc...

   rclcpp
       The C++ specific :term:`Client Library <client_library>` for ROS. This includes any middleware related APIs as well as the related message generation of C++ data structures based on interface definitions like Messages, Services, and Actions.

   repository
       A collection of packages usually managed using a :term:`VCS` like git or mercurial and usually hosted on a site like GitHub or BitBucket.
       In the context of this document, repositories usually contain one or more |packages| of one type or another.
",What is the definition of a client library according to the provided glossary?
"Concepts
========

Conceptual overviews provide relatively high-level, general background information about key aspects of ROS 2.

.. toctree::
   :maxdepth: 1

   Concepts/Basic
   Concepts/Intermediate
   Concepts/Advanced


Related Content
^^^^^^^^^^^^^^^

:doc:`See the ROS 2 citations <Citations>` for more explanation of concepts and citable resources.

For a brief video introduction to ROS 2, see this community contributed content:

* `Getting started with ROS Part 1: Nodes, Parameters and Topics <https://youtu.be/46TPAKXBOF8>`_
* `Getting started with ROS Part 2: Services and Actions <https://youtu.be/keZAJ83eEoM>`_
",What type of information do conceptual overviews provide about key aspects of ROS 2?
".. _Tutorials:

Tutorials
=========

The tutorials are a collection of step-by-step instructions meant to steadily build skills in ROS 2.

The best way to approach the tutorials is to walk through them for the first time in order, as they build off of each other and are not meant to be comprehensive documentation.

For quick solutions to more specific questions, see the :doc:`How-To-Guides`.

.. toctree::
   :maxdepth: 2

   Tutorials/Beginner-CLI-Tools
   Tutorials/Beginner-Client-Libraries
   Tutorials/Intermediate
   Tutorials/Advanced
   Tutorials/Demos
   Tutorials/Miscellaneous

Examples
--------

* `Python and C++ minimal examples <https://github.com/ros2/examples>`__.
",What is the purpose of the tutorials in ROS 2 and how are they recommended to be approached?
".. redirect-from::

  Guides

.. _How-to Guides:

How-to Guides
=============

How-to Guides provide direct and modular answers to ""How-to"" questions regarding key aspects of ROS 2.
They contain succinct steps to help you accomplish important tasks quickly.

How-to Guides are meant for users who already have some knowledge of ROS 2 and just want to find out how to implement something specific.
They will not go in-depth by providing background information or teaching how a concept ties into the greater ROS 2 ecosystem.

If you are new and looking to learn the ropes, start with the :doc:`Tutorials <Tutorials>` for a more well-rounded progression through ROS 2.



.. toctree::
   :maxdepth: 1

   How-To-Guides/Installation-Troubleshooting
   How-To-Guides/Developing-a-ROS-2-Package
   How-To-Guides/Documenting-a-ROS-2-Package
   How-To-Guides/Ament-CMake-Documentation
   How-To-Guides/Ament-CMake-Python-Documentation
   How-To-Guides/Migrating-from-ROS1
   How-To-Guides/Launch-file-different-formats
   How-To-Guides/Launching-composable-nodes
   How-To-Guides/Node-arguments
   How-To-Guides/Sync-Vs-Async
   How-To-Guides/DDS-tuning
   How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback
   How-To-Guides/Working-with-multiple-RMW-implementations
   How-To-Guides/Cross-compilation
   How-To-Guides/Releasing/Releasing-a-Package
   How-To-Guides/Using-Python-Packages
   How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers
   How-To-Guides/Core-maintainer-guide
   How-To-Guides/Building-a-Custom-Deb-Package
   How-To-Guides/Building-ROS-2-with-Tracing
   How-To-Guides/Topics-Services-Actions
   How-To-Guides/Using-Variants
   How-To-Guides/Using-ros2-param
   How-To-Guides/Using-ros1_bridge-Jammy-upstream
   How-To-Guides/Configure-ZeroCopy-loaned-messages
   How-To-Guides/Installing-on-Raspberry-Pi
   How-To-Guides/Using-callback-groups
   How-To-Guides/Getting-Backtraces-in-ROS-2
   How-To-Guides/ROS-2-IDEs
   How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container
   How-To-Guides/Using-Custom-Rosdistro
",What is the purpose of How-To Guides in relation to ROS 2 users' knowledge levels and objectives?
"The ROS 2 Project
=================

Check out the resources below to learn more about the advancement of the ROS 2 project.

.. toctree::
   :maxdepth: 1

   The-ROS2-Project/Contributing
   The-ROS2-Project/Features
   The-ROS2-Project/Feature-Ideas
   The-ROS2-Project/Roadmap
   The-ROS2-Project/ROSCon-Content
   The-ROS2-Project/Governance
   The-ROS2-Project/Marketing
   The-ROS2-Project/Metrics
",What are the different resources available to learn more about the advancement of the ROS 2 project?
".. _Releases:

Distributions
=============

What is a Distribution?
-----------------------

A ROS distribution is a versioned set of ROS packages.
These are akin to Linux distributions (e.g. Ubuntu).
The purpose of the ROS distributions is to let developers work against a relatively stable codebase until they are ready to roll everything forward.
Therefore once a distribution is released, we try to limit changes to bug fixes and non-breaking improvements for the core packages (every thing under ros-desktop-full).
That generally applies to the whole community, but for ""higher"" level packages, the rules are less strict, and so it falls to the maintainers of a given package to avoid breaking changes.

.. _list_of_distributions:

List of Distributions
---------------------

Below is a list of current and historic ROS 2 distributions.
Rows in the table marked in green are the currently supported distributions.

.. toctree::
   :hidden:

   Releases/Release-Jazzy-Jalisco
   Releases/Release-Iron-Irwini
   Releases/Release-Humble-Hawksbill
   Releases/Release-Rolling-Ridley
   Releases/Development
   Releases/End-of-Life
   Releases/Release-Process

.. raw:: html

   <!--
     This CSS overrides the styles of certain rows to mark them green, indicating they are supported releases.
     For the odd number rows, a line like the following must be used:

       .rst-content table.docutils:not(.field-list) tr:nth-child(1) td {background-color: #33cc66;}

     For the even number rows, a line like the following must be used:

       .rst-content tr:nth-child(2) {background-color: #33cc66;}

     No other combination I've found has worked.  Yes, this is extremely fragile.  No, I don't understand
     why it is like this.
   -->
   <style>
     .rst-content table.docutils:not(.field-list) tr:nth-child(1) td {background-color: #33cc66;}
     .rst-content table.docutils:not(.field-list) tr:nth-child(3) td {background-color: #33cc66;}
     .rst-content tr:nth-child(2) {background-color: #33cc66;}
     .rst-content tr:nth-child(3) {background-color: #33cc66;}
   </style>

.. |rolling| image:: Releases/rolling-small.png
   :alt: Rolling logo

.. |jazzy| image:: Releases/jazzy-small.png
   :alt: Jazzy logo

.. |iron| image:: Releases/iron-small.png
   :alt: Iron logo

.. |humble| image:: Releases/humble-small.png
   :alt: Humble logo

.. |galactic| image:: Releases/galactic-small.png
   :alt: Galactic logo

.. |foxy| image:: Releases/foxy-small.png
   :alt: Foxy logo

.. |eloquent| image:: Releases/eloquent-small.png
   :alt: Eloquent logo

.. |dashing| image:: Releases/dashing-small.png
   :alt: Dashing logo

.. |crystal| image:: Releases/crystal-small.png
   :alt: Crystal logo

.. |bouncy| image:: Releases/bouncy-small.png
   :alt: Bouncy logo

.. |ardent| image:: Releases/ardent-small.png
   :alt: Ardent logo

.. list-table::
   :class: distros
   :header-rows: 1
   :widths: 35 25 30 20 10

   * - Distro
     - Release date
     - Logo
     - EOL date
     - ROS Boss
   * - :doc:`Jazzy Jalisco <Releases/Release-Jazzy-Jalisco>`
     - May 23, 2024
     - |jazzy|
     - May 2029
     - `Marco A. Gutiérrez <https://github.com/marcoag>`_
   * - :doc:`Iron Irwini <Releases/Release-Iron-Irwini>`
     - May 23, 2023
     - |iron|
     - November 2024
     - `Yadunund Vijay <https://github.com/Yadunund>`_
   * - :doc:`Humble Hawksbill <Releases/Release-Humble-Hawksbill>`
     - May 23, 2022
     - |humble|
     - May 2027
     - `Audrow Nash <https://github.com/audrow>`_
   * - :doc:`Galactic Geochelone <Releases/Release-Galactic-Geochelone>`
     - May 23, 2021
     - |galactic|
     - December 9, 2022
     - `Scott Logan <https://github.com/cottsay/>`_
   * - :doc:`Foxy Fitzroy <Releases/Release-Foxy-Fitzroy>`
     - June 5, 2020
     - |foxy|
     - June 20, 2023
     - `Jacob Perron <https://github.com/jacobperron>`_ / `Dharini Dutia <https://github.com/quarkytale>`_
   * - :doc:`Eloquent Elusor <Releases/Release-Eloquent-Elusor>`
     - November 22, 2019
     - |eloquent|
     - November 2020
     - `Michael Carroll <https://github.com/mjcarroll>`_
   * - :doc:`Dashing Diademata <Releases/Release-Dashing-Diademata>`
     - May 31, 2019
     - |dashing|
     - May 2021
     - `Steven! Ragnarök <https://github.com/nuclearsandwich>`_
   * - :doc:`Crystal Clemmys <Releases/Release-Crystal-Clemmys>`
     - December 14, 2018
     - |crystal|
     - December 2019
     - `Steven! Ragnarök <https://github.com/nuclearsandwich>`_
   * - :doc:`Bouncy Bolson <Releases/Release-Bouncy-Bolson>`
     - July 2, 2018
     - |bouncy|
     - July 2019
     - `Mikael Arguedas <https://github.com/mikaelarguedas>`_ / `Steven! Ragnarök <https://github.com/nuclearsandwich>`_
   * - :doc:`Ardent Apalone <Releases/Release-Ardent-Apalone>`
     - December 8, 2017
     - |ardent|
     - December 2018
     - `Steven! Ragnarök <https://github.com/nuclearsandwich>`_
   * - :doc:`beta3 <Releases/Beta3-Overview>`
     - September 13, 2017
     -
     - December 2017
     -
   * - :doc:`beta2 <Releases/Beta2-Overview>`
     - July 5, 2017
     -
     - September 2017
     -
   * - :doc:`beta1 <Releases/Beta1-Overview>`
     - December 19, 2016
     -
     - Jul 2017
     -
   * - :doc:`alpha1 - alpha8 <Releases/Alpha-Overview>`
     - August 31, 2015
     -
     - December 2016
     -

Future Distributions
--------------------

For details on upcoming features see the :doc:`roadmap <The-ROS2-Project/Roadmap>`.

There is a new ROS 2 distribution released yearly on May 23rd (`World Turtle Day <https://www.worldturtleday.org/>`_).

.. list-table::
   :class: future-distros
   :header-rows: 1
   :widths: 35 30 20 15

   * - Distro
     - Release date
     - Logo
     - EOL date
   * - :doc:`Kilted Kaiju <Releases/Release-Kilted-Kaiju>`
     - May 2025
     - TBD
     - Nov 2026


.. _rolling_distribution:

Rolling Distribution
--------------------

:doc:`ROS 2 Rolling Ridley <Releases/Release-Rolling-Ridley>` is the rolling development distribution of ROS 2.
It is described in `REP 2002 <https://www.ros.org/reps/rep-2002.html>`_ and was first introduced in June 2020.

The Rolling distribution of ROS 2 serves two purposes:

1. it is a staging area for future stable distributions of ROS 2, and
2. it is a collection of the most recent development releases.

As the name implies, Rolling is continuously updated and **can have in-place updates that include breaking changes**.
We recommend that most people use the most recent stable distribution instead (see :ref:`list_of_distributions`).

Packages released into the Rolling distribution will be automatically released into future stable distributions of ROS 2.
:doc:`Releasing a ROS 2 package <../How-To-Guides/Releasing/Releasing-a-Package>` into the Rolling distribution follows the same procedures as all other ROS 2 distributions.
",What is the purpose of the ROS Rolling distribution?
".. redirect-from::

  Docs-Guide

ROS 2 Documentation
===================

.. toctree::
   :titlesonly:
   :maxdepth: 1
   :hidden:

   Installation
   Releases
   Tutorials
   How-To-Guides
   Concepts
   Contact
   The-ROS2-Project
   Package-Docs
   Related-Projects
   Glossary
   Citations


**The Robot Operating System (ROS) is a set of software libraries and tools for building robot applications.**
From drivers and state-of-the-art algorithms to powerful developer tools, ROS has the open source tools you need for your next robotics project.

Since ROS was started in 2007, a lot has changed in the robotics and ROS community.
The goal of the ROS 2 project is to adapt to these changes, leveraging what is great about ROS 1 and improving what isn’t.

**Are you looking for documentation for a particular ROS package like MoveIt,  image_proc, or octomap?** Please see `ROS Index <https://index.ros.org/packages/#{DISTRO}>`__  or check out `this index of per-package documentation <https://docs.ros.org/en/{DISTRO}/p/>`__.

This site contains the documentation for ROS 2.
If you are looking for ROS 1 documentation, check out the `ROS wiki <https://wiki.ros.org>`__.

If you use ROS 2 in your work, please see :doc:`Citations <Citations>` to cite ROS 2.

Getting started
---------------

* :doc:`Installation <Installation>`

  - Instructions to set up ROS 2 for the first time

* :doc:`Tutorials <Tutorials>`

  - The best place to start for new users!
  - Hands-on sample projects that help you build a progression of necessary skills

* :doc:`How-To-Guides`

  - Quick answers to your ""How do I...?"" questions without working through the :doc:`Tutorials <Tutorials>`

* :doc:`Concepts <Concepts>`

  - High-level explanations of core ROS 2 concepts covered in the :doc:`Tutorials <Tutorials>`

* :doc:`Contact <Contact>`

  - Answers to your questions or a forum to start a discussion


The ROS 2 project
-----------------

If you're interested in the advancement of the ROS 2 project:

* :doc:`Contributing <The-ROS2-Project/Contributing>`

  - Best practices and methodology for contributing to ROS 2, as well as instructions for migrating existing ROS 1 content to ROS 2

* :doc:`Distributions <Releases>`

  - Past, present and future ROS 2 distributions

* :doc:`Features Status <The-ROS2-Project/Features>`

  - Features in the current release

* :doc:`Feature Ideas <The-ROS2-Project/Feature-Ideas>`

  - Ideas for nice-to-have features that are not under active development

* :doc:`Roadmap <The-ROS2-Project/Roadmap>`

  - Planned work for ROS 2 development

* :doc:`ROSCon Talks <The-ROS2-Project/ROSCon-Content>`

  - Presentations by the community on ROS 2

* :doc:`Project Governance <The-ROS2-Project/Governance>`

  - Information about the ROS Technical Steering Committee, Working Groups, and upcoming events

* :doc:`Marketing <The-ROS2-Project/Marketing>`

  - Downloadable marketing materials
  - `Information about the ROS trademark <https://www.ros.org/blog/media/>`__

ROS community resources
-----------------------

If you need help, have an idea, or would like to contribute to the project, please visit our ROS community resources.

* `Official ROS Discord Channel for discussion and support <https://discord.com/servers/open-robotics-1077825543698927656>`__ (ROS 1, ROS 2)

* `Robotics Stack Exchange - community Q&A website <https://robotics.stackexchange.com/>`__ (ROS 1, ROS 2)

  - See :ref:`Contact Page <Using Robotics Stack Exchange>` for more information

* `ROS Discourse <https://discourse.ros.org/>`__ (ROS 1, ROS 2)

  - Forum for general discussions and announcements for the ROS community
  - See the :ref:`Contact Page <Using ROS Discourse>` for more information

* `ROS Index <https://index.ros.org/>`__ (ROS 1, ROS 2)

  - Indexed list of all packages (i.e. `Python Package Index (PyPI) <https://pypi.org/>`_ for ROS packages)
  - See which ROS distributions a package supports
  - Link to a package's repository, API documentation, or website
  - Inspect a package's license, build type, maintainers, status, and dependencies
  - Get more info for a package on `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__

* `ROS resource status page <https://status.openrobotics.org/>`__ (ROS 1, ROS 2)

  - Check the current status of ROS resources like Discourse or the ROS build farm.

General ROS project resources
-----------------------------

* `ROS Enhancement Proposals (REPs) <https://ros.org/reps/rep-0000.html>`__ (ROS 1, ROS 2)

  - Proposals for new designs and conventions

* `ROS Robots <https://robots.ros.org/>`__ (ROS 1, ROS 2)

  - Showcases robots projects from the community
  - Instructions on how to contribute a robot

* `ROS Wiki <http://wiki.ros.org/>`__ (ROS 1)

  - ROS 1 documentation and user modifiable content
  - Active until at least the last ROS 1 distribution is EOL

* `ROS.org <https://www.ros.org/>`__ (ROS 1, ROS 2)

  - ROS 1 and ROS 2 product landing page, with high-level description of ROS and links to other ROS sites

Events
------

* `Official ROS Vimeo Channel <https://vimeo.com/osrfoundation>`__ (ROS 1, ROS 2)

  - Videos of ROSCon Talks, community and working group meetings, and project demos.

* `ROSCon website <https://roscon.ros.org/>`__ (ROS 1, ROS 2)

  - ROSCon is our annual ROS developer conference.
  - This page also lists regional ROS events like ROSConJP and ROSConFr.

* `Open Source Robotics Foundation official events calendar <https://calendar.google.com/calendar/u/0/embed?src=agf3kajirket8khktupm9go748@group.calendar.google.com&ctz=America/Los_Angeles>`__

  - This calendar is for official OSRF Events and working group meetings.
  - `Submit your events here <https://bit.ly/OSRFCalendarForm>`__.

* `Open Source Robotics Foundation community calendar <https://calendar.google.com/calendar/embed?src=c_3fc5c4d6ece9d80d49f136c1dcd54d7f44e1acefdbe87228c92ff268e85e2ea0%40group.calendar.google.com&ctz=America%2FLos_Angeles>`__

  - This calendar is for unofficial ROS community events.
  - `Submit your events here <https://bit.ly/OSRFCommunityCalendar>`__ .

Miscellaneous
-------------
* `Purchase official ROS swag <https://spring.ros.org/>`__

* ROS on social media

  - `@OpenRoboticsOrg <https://twitter.com/OpenRoboticsOrg>`__ and `@ROSOrg <https://twitter.com/ROSOrg>`__ on Twitter
  - `Open Robotics on LinkedIn <https://www.linkedin.com/company/open-source-robotics-foundation>`__

* Visit the `Open Source Robotics Foundation website <https://www.openrobotics.org/>`__

  - Tax deductible charitable donations to the Open Source Robotics Foundation can be sent via `DonorBox. <https://donorbox.org/support-open-robotics?utm_medium=qrcode&utm_source=qrcode>`__

Deprecated
----------
* `ROS 2 Design <http://design.ros2.org/>`__

  - Early design decisions behind ROS 2 development
  - New design proposals should be submitted via `ROS Enhancement Proposals (REPs) <https://ros.org/reps/rep-0000.html>`__
",What resources are available for contributing to the ROS 2 project and what can be found on the ROSCon website?
".. _Help:

Contact
=======

.. _Using Robotics Stack Exchange:

Support
-------

Different types of questions or discussions correspond to different avenues of communication;
check the descriptions below to ensure you choose the right method.

Need help troubleshooting your system?
First, search `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__ to see if others have had similar issues, and if their solution works for you.

If not, ask a new question on `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__.
Make sure to add tags, at the very least the ``ros2`` tag and the distro version you are running, e.g. ``{DISTRO}``.
If your question is related to the documentation here, add a tag like ``docs``, or more specifically, ``tutorials``.

Please don't contact the developers/maintainers directly.
The community can't see question or answer(s) not asked or answered publicly.
Open Source development works best when the entire community participates in discussions and helps to answer questions.
It's better to send all questions to `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__ and report all issues to the issue tracker.

Contributing support
^^^^^^^^^^^^^^^^^^^^

ROS 2 users come from a wide range of technical backgrounds, use a variety of different operating systems, and don’t necessarily have any prior experience with ROS (1 or 2).
So, it's important for users with any amount of experience to contribute support.

If you see an issue on `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__ that is similar to something you’ve run into yourself, please consider providing some pointers to what helped in your situation.
Don’t worry if you aren't sure if your response is correct.
Simply say so, and other community members will jump in if necessary.

Issues
------

If you identify bugs, have suggestions for improvements, or a question specific to one package, you can open an issue on GitHub.

For example, if you are following the :doc:`tutorials here <Tutorials>` and come across an instruction that doesn't work on your system,
you can open an issue in the `ros2_documentation <https://github.com/ros2/ros2_documentation>`__ repo.

You can search for individual ROS 2 repositories on `ROS 2's GitHub <https://github.com/ros2>`__.

Before opening an issue, check if other users have reported similar issues by searching across the ros2 and ament GitHub organizations: `example search query <https://github.com/search?q=user%3Aros2+user%3Aament+turtlesim&type=Issues>`__.

Next, check `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__ to see if someone else has asked your question or reported your issue.

If it has not been reported, feel free to open an issue in the appropriate repository tracker.
If it's not clear which tracker to use for a particular issue, file it in the `ros2/ros2 repository <https://github.com/ros2/ros2/issues>`__ and we'll have a look at it.

When filing an issue, please make sure to:

* Include enough information for another person to understand the issue.

Describe exactly what you were doing or are trying to do, and exactly what, if anything, went wrong.
If following a tutorial or online instructions provide a link to the specific instructions.

* Use a descriptive headline or subject line. Bad: ""rviz doesn't work"". Good: ""Rviz crashing looking for missing .so after latest apt update""
* Include information about the exact platform, software, versions, and environment relevant to the problem. This includes how you installed the software (from binaries or from source) and which ROS middleware/DDS vendor you are using (if you know it).
* Any warnings or errors. Cut and paste them directly from the terminal window to which they were printed. Please do not re-type or include a screenshot.
* In case of a bug consider providing a `short, self contained, correct (compilable), example <http://sscce.org/>`__.
* When discussing any compiling/linking/installation issues, also provide the compiler version

As appropriate, also include your:

* ROS environment variables (env | grep ROS)
* Backtraces
* Relevant config files
* Graphics card model and driver version
* Ogre.log for rviz, if possible (run with rviz -l)
* Bag files and code samples that can reproduce the problem
* Gifs or movies to demonstrate the problem


Pull requests
-------------

When you feel comfortable enough to suggest a specific change directly to the code, you can submit a pull request.
Pull requests are welcome for any of `the ros2 repositories <https://github.com/ros2>`__.
See the :doc:`Contributing <The-ROS2-Project/Contributing>` page for more details and etiquette on how to contribute.

.. _Using ROS Discourse:

Discussion
----------

To start a discussion with other ROS 2 community members, visit the official `ROS Discourse <https://discourse.ros.org/>`__.
Content on the Discourse should be high-level;
it's not a place to get *questions* about code answered, but it would be suitable to start a conversation about best practices or improving standards.

Discussions about ROS 2 development and plans are happening on the `“Next Generation ROS” Discourse category <https://discourse.ros.org/c/ng-ros>`__.
Participating in these discussions is an important way to have a say on how different features of ROS 2 will work and be implemented.

The diverse community behind the ROS ecosystem is one of its greatest assets.
We encourage all members of the ROS community to participate in these design discussions so that we can leverage the experience of community members, and keep the varied use cases of ROS in mind.

Etiquette
----------

Assume 'good faith': It's easy to mis-interpret the meaning or tone of comments on the internet.
Assuming good faith gives the benefit of the doubt to those trying to help you, avoiding: insulting well meaning community members, and poisoning the mood.
Assuming 'good faith' when responding almost always works better even if the original response was not in fact in good faith.

Please don't send your question more than once: The question was seen.
If you didn't get a response then likely nobody has had time to answer you.
Alternatively, it could be that nobody knows the answer.
In any case, sending it again is poor form and akin to shouting and is likely to aggravate a large number of people.
This also applies to crossposting.
Try to pick the forum which you think matches best and ask there.
If you are referred to a new forum, provide a link to the old discussion.

On `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__ you can edit your question to provide more details.
The more details that you include in your question the easier it is for others to help you find your solution which makes it more likely for you to get a response.

It's considered bad form to list your personal deadlines; community members answering questions also have them.

Do not beg for help.
If there is someone willing and able to help with your problem, you usually get a response.
Asking for faster answers will mostly have a negative effect.

Do not add unrelated content to posts.
The content of posts should be focused on the topic at hand and not include unrelated content.
Content, links, and images unrelated to the topic are considered spam.

For commercial posts, see also `this discussion <https://discourse.ros.org/t/sponsorship-notation-in-posts-on-ros-org/2078>`_.

Minimize references to content behind pay walls.
The content posted on `ROS Discourse <https://discourse.ros.org/>`__ and `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__ should ""generally"" be free and open to all users.
Links to content behind pay walls such as private journal articles, text books, and paid news websites, while helpful and relevant, may not be accessible to all users.
Where possible primary sources should be free and open with paid content playing a supporting role.

Single link posts are to be avoided.
Generally speaking, posting a single link answer is less helpful and can be easily confused with spam.
Moreover, links may degrade over time or be replaced.
Paraphrasing a link's content along with some contextual information and attribution is often much more helpful.

Private contact
---------------

If you'd like to contact us privately (e.g., if your question contains information sensitive to your organization or project, or if it's regarding a security issue), you can email us directly at ``ros@osrfoundation.org``.
",What avenue of communication is recommended for troubleshooting system issues related to ROS 2 according to the text?
".. redirect-from::

Package Docs
============

ROS package documentation, that is to say documentation for specific packages you install via apt or some other tool, can be found in multiple places.
Here is a brief list of where to look for specific ROS package documentation.


* Most ROS 2 packages have their package level documentation `included in this index page <https://docs.ros.org/en/{DISTRO}/p/>`__.
* All ROS 2 package's documentation is hosted alongside its information on the `ROS Index <https://index.ros.org/>`_. Searching for packages on ROS Index will yield their information such as released distributions, ``README.md`` files, URLs, and other important metadata.

Larger Packages
---------------

Larger packages like MoveIt, Nav2, and microROS, are given their own domain or subdomain on ros.org. Here is a short list.

* `MoveIt <https://moveit.ai/>`__
* `Navigation2 <https://nav2.org/>`__
* `Control <https://control.ros.org/master/index.html>`__
* `microROS (embedded systems) <https://micro.ros.org/>`__

API Documentation
-----------------

You can find the API level documentation for the ROS client libraries in the {DISTRO_TITLE} distribution using the links below:

* `rclcpp - C++ client library <http://docs.ros.org/en/{DISTRO}/p/rclcpp/generated/index.html>`_
* `rclcpp_lifecycle - C++ lifecycle library <http://docs.ros.org/en/{DISTRO}/p/rclcpp_lifecycle/generated/index.html>`_
* `rclcpp_components - C++ components library <http://docs.ros.org/en/{DISTRO}/p/rclcpp_components/generated/index.html>`_
* `rclcpp_action - C++ actions library <http://docs.ros.org/en/{DISTRO}/p/rclcpp_action/generated/index.html>`_

Adding Your Package to docs.ros.org
-----------------------------------

All released ROS 2 packages are automatically added to docs.ros.org and `ROS Index <https://index.ros.org/>`_.
If you would like to enable or configure your own package please see: :doc:`./How-To-Guides/Documenting-a-ROS-2-Package`.
",Where can you find the API level documentation for the ROS client libraries in the {DISTRO_TITLE} distribution?
".. redirect-from::

   Alpha-Overview

Alphas
======

.. contents:: Table of Contents
   :depth: 2
   :local:

This is a merged version of the previously separated pages for the 8 alpha releases of ROS 2.

We hope that you try them out and `provide feedback <../../Contact>`.

ROS 2 alpha8 release (code name *Hook-and-Loop*; October 2016)
----------------------------------------------------------------

Changes to supported DDS vendors
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ROS 2 supports multiple middleware implementations (see `this page <../../Concepts/Intermediate/About-Different-Middleware-Vendors>` for more details).
Until Alpha 8, ROS 2 was supporting ROS middleware implementations for eProsima's Fast RTPS, RTI's Connext and PrismTech's OpenSplice.
To streamline our efforts, as of Alpha 8, Fast RTPS and Connext (static) will be supported, with Fast RTPS (`now Apache 2.0-licensed <http://www.eprosima.com/index.php/company-all/news/61-eprosima-goes-apache>`__) shipped as the default.

Scope
^^^^^

As the ""alpha"" qualifier suggests, this release of ROS 2 is far from complete.
You should not expect to switch from ROS 1 to ROS 2, nor should you expect to build a new robot control system with ROS 2.
Rather, you should expect to try out some demos, explore the code, and perhaps write your own demos.

The improvements included in this release are:


* Several improvements to Fast RTPS and its rmw implementation

  * Support for large (image) messages in Fast RTPS
  * ``wait_for_service`` functionality in Fast RTPS

* Support for all ROS 2 message types in Python and C
* Added support for Quality of Service (QoS) settings in Python
* Fixed various bugs with the previous alpha release

Pretty much anything not listed above is not included in this release.
The next steps are described in the `Roadmap <../../The-ROS2-Project/Roadmap>`.

ROS 2 alpha7 release (code name *Glue Gun*\ ; July 2016)
--------------------------------------------------------

.. contents:: Table of Contents
   :local:

New version of Ubuntu required
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Until Alpha 6 ROS 2 was targeting Ubuntu Trusty Tahr (14.04). As of this Alpha ROS 2 is targeting Ubuntu Xenial Xerus (16.04) to benefit from newer versions of the compiler, CMake, Python, etc.

Scope
^^^^^

As the ""alpha"" qualifier suggests, this release of ROS 2 is far from complete.
You should not expect to switch from ROS 1 to ROS 2, nor should you expect to build a new robot control system with ROS 2.
Rather, you should expect to try out some demos, explore the code, and perhaps write your own demos.

The major features included in this release are:


* Graph API functionality: wait_for_service

  * Added interfaces in rclcpp and make use of them in examples, demos, and tests

* Improved support for large messages in both Connext and Fast-RTPS (partial for Fast-RTPS)
* Turtlebot demo using ported code from ROS 1

  * See: https://github.com/ros2/turtlebot2_demo

Pretty much anything not listed above is not included in this release.
The next steps are described in the `Roadmap <../../The-ROS2-Project/Roadmap>`.

ROS 2 alpha6 release (code name *Fastener*; June 2016)
------------------------------------------------------

.. contents:: Table of Contents
   :local:

Scope
^^^^^

As the ""alpha"" qualifier suggests, this release of ROS 2 is far from
complete.
You should not expect to switch from ROS 1 to ROS 2, nor should
you expect to build a new robot control system with ROS 2.
Rather, you
should expect to try out some demos, explore the code, and perhaps write
your own demos.

The major features included in this release are:


* Graph API functionality: wait_for_service

  * Added graph guard condition to nodes for waiting on graph changes
  * Added ``rmw_service_server_is_available`` for verifying if a service is available

* Refactored ``rclcpp`` to use ``rcl``
* Improved support for complex message types in Python

  * Nested messages
  * Arrays
  * Strings

Pretty much anything not listed above is not included in this release.
The next steps are described in the `Roadmap <../../The-ROS2-Project/Roadmap>`.

ROS 2 alpha5 release (code name *Epoxy*; April 2016)
------------------------------------------------------

.. contents:: Table of Contents
   :local:


Scope
^^^^^

As the ""alpha"" qualifier suggests, this release of ROS 2 is far from
complete.
You should not expect to switch from ROS 1 to ROS 2, nor should
you expect to build a new robot control system with ROS 2.
Rather, you
should expect to try out some demos, explore the code, and perhaps write
your own demos.

The major features included in this release are:


* Support for C data structures in Fast RTPS and Connext Dynamic rmw implementations.
* Support services in C.
* Added 32-bit and 64-bit ARM as experimentally supported platforms.

Pretty much anything not listed above is not included in this release.
The next steps are described in the `Roadmap <../../The-ROS2-Project/Roadmap>`.

ROS 2 alpha4 release (code name *Duct tape*; February 2016)
-----------------------------------------------------------

.. contents:: Table of Contents
   :local:

Background
^^^^^^^^^^

As explained in a `design article <https://design.ros2.org/articles/why_ros2.html>`__,
we are engaged in the development of a new major version of ROS, called ""ROS 2.""
While the underlying concepts (e.g., publish / subscribe messaging) and goals
(e.g., flexibility and reusability) are the same as for ROS 1, we are taking this
opportunity to make substantial changes to the system, including changing
some of the core APIs.
For a deeper treatment of those changes and their rationale, consult the other
`ROS 2 design articles <https://design.ros2.org>`__.

Status
^^^^^^

On February 17, 2016, we are releasing ROS 2 alpha4,
code-named **Duct tape**.
Our primary goal with this release is to add more features, while also addressing the feedback we received for the previous releases.
To that end, we built a set of `demos <../../Tutorials>` that
show some of the key features of ROS 2.
We encourage you to try out those
demos, look at the code that implements them, and `provide
feedback <../../Contact>`.
We're especially interested to know how well (or
poorly) we're addressing use cases that are important to you.

Intended audience
^^^^^^^^^^^^^^^^^

While everyone is welcome to try out the demos and look through the code, we're aiming this release at people who are already experienced with ROS 1 development.
At this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.

Scope
^^^^^

As the ""alpha"" qualifier suggests, this release of ROS 2 is far from
complete.
You should not expect to switch from ROS 1 to ROS 2, nor should
you expect to build a new robot control system with ROS 2.
Rather, you
should expect to try out some demos, explore the code, and perhaps write
your own demos.

The major features included in this release are:


* Improved type support infrastructure, including support for C
* Preliminary Python client library, only publishers and subscriptions are supported. Beware, the API is subject to change and is far from complete!
* Added structures for ROS time in C API (still needs C++ API)

  * New concept of extensible ""time sources"" for ROS Time, the default time source will be like ROS 1 (implementation pending)

Pretty much anything not listed above is not included in this release.
The next steps are described in the `Roadmap <../../The-ROS2-Project/Roadmap>`.

ROS 2 alpha3 release (code name *Cement*; December 2015)
----------------------------------------------------------

.. contents:: Table of Contents
   :local:


Background
^^^^^^^^^^

As explained in a `design article <https://design.ros2.org/articles/why_ros2.html>`__,
we are engaged in the development of a new major version of ROS, called ""ROS 2.""
While the underlying concepts (e.g., publish / subscribe messaging) and goals
(e.g., flexibility and reusability) are the same as for ROS 1, we are taking this
opportunity to make substantial changes to the system, including changing
some of the core APIs.
For a deeper treatment of those changes and their rationale, consult the other
`ROS 2 design articles <https://design.ros2.org>`__.

Status
^^^^^^

On December 18, 2015, we are releasing ROS 2 alpha3,
code-named **Cement**.
Our primary goal with this release is to add more features, while also addressing the feedback we received for the previous releases.
To that end, we built a set of `demos <../../Tutorials>` that
show some of the key features of ROS 2.
We encourage you to try out those
demos, look at the code that implements them, and `provide
feedback <../../Contact>`.
We're especially interested to know how well (or
poorly) we're addressing use cases that are important to you.

Intended audience
^^^^^^^^^^^^^^^^^

While everyone is welcome to try out the demos and look through the code, we're aiming this release at people who are already experienced with ROS 1 development.
At this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.

Scope
^^^^^

As the ""alpha"" qualifier suggests, this release of ROS 2 is far from
complete.
You should not expect to switch from ROS 1 to ROS 2, nor should
you expect to build a new robot control system with ROS 2.
Rather, you
should expect to try out some demos, explore the code, and perhaps write
your own demos.

The major features included in this release are:


* Updated ``rcl`` interface.

  * This interface will be wrapped in order to create language bindings, e.g. ``rclpy``.
  * This interface has improved documentation and test coverage over existing interfaces we currently have, e.g. ``rmw`` and ``rclcpp``.
  * See `rcl headers <https://github.com/ros2/rcl/tree/release-alpha3/rcl/include/rcl>`__.

* Added support in rclcpp for using the TLSF (two-level segregate fit) allocator, a memory allocator design for embedded and real-time systems.
* Improved efficiency of MultiThreadedExecutor and fixed numerous bugs with multi-threaded execution, which is now test on CI.
* Added ability to cancel an Executor from within a callback called in spin.
* Added ability for a timer to cancel itself by supporting a Timer callback that accepts a reference to itself as a function parameter.
* Added checks for disallowing multiple threads to enter Executor::spin.
* Improved reliability of numerous tests that had been sporadically failing.
* Added support for using Fast RTPS (instead of, e.g., OpenSplice or Connext).
* A partial port of tf2 including the core libraries and core command line tools.

Pretty much anything not listed above is not included in this release.
The next steps are described in the `Roadmap <../../The-ROS2-Project/Roadmap>`.

ROS 2 alpha2 release (code name *Baling wire*; October 2015)
--------------------------------------------------------------

.. contents:: Table of Contents
   :local:

Background
^^^^^^^^^^

As explained in a `design
article <https://design.ros2.org/articles/why_ros2.html>`__, we are engaged in
the development of a new major version of ROS, called ""ROS 2."" While the
underlying concepts (e.g., publish / subscribe messaging) and goals (e.g.,
flexibility and reusability) are the same as for ROS 1, we are taking this
opportunity to make substantial changes to the system, including changing
some of the core APIs.
For a deeper treatment of those changes and their
rationale, consult the other `ROS 2 design
articles <https://design.ros2.org>`__.


Status
^^^^^^

On November 3, 2015, we are releasing ROS 2 alpha2,
code-named **Baling wire**.
Our primary goal with this release is to add more features, while also addressing the feedback we received for the previous alpha 1 release.
To that end, we built a set of `demos <../../Tutorials>` that
show some of the key features of ROS 2.
We encourage you to try out those
demos, look at the code that implements them, and `provide
feedback <../../Contact>`.
We're especially interested to know how well (or
poorly) we're addressing use cases that are important to you.


Intended audience
^^^^^^^^^^^^^^^^^

While everyone is welcome to try out the demos and look through the code, we're aiming this release at people who are already experienced with ROS 1 development.
At this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.


Scope
^^^^^

As the ""alpha"" qualifier suggests, this release of ROS 2 is far from
complete.
You should not expect to switch from ROS 1 to ROS 2, nor should
you expect to build a new robot control system with ROS 2.
Rather, you
should expect to try out some demos, explore the code, and perhaps write
your own demos.

The major features included in this release are:


* Support for custom allocators in rclcpp, useful for real-time messaging
* Feature parity of Windows with Linux/OSX, including workspace management, services and parameters
* rclcpp API improvements
* FreeRTPS improvements

Pretty much anything not listed above is not included in this release.
The next steps are described in the `Roadmap <../../The-ROS2-Project/Roadmap>`.

ROS 2 alpha1 release (code name *Anchor*; August 2015)
--------------------------------------------------------

.. contents:: Table of Contents
   :local:

Background
^^^^^^^^^^

As explained in a `design
article <https://design.ros2.org/articles/why_ros2.html>`__, we are engaged in
the development of a new major version of ROS, called ""ROS 2."" While the
underlying concepts (e.g., publish / subscribe messaging) and goals (e.g.,
flexibility and reusability) are the same as for ROS 1, we are taking this
opportunity to make substantial changes to the system, including changing
some of the core APIs.
For a deeper treatment of those changes and their
rationale, consult the other `ROS 2 design
articles <https://design.ros2.org>`__.


Status
^^^^^^

On August 31, 2015, we are releasing ROS 2 alpha1,
code-named **Anchor**.
Our primary goal with this release is to give
you the opportunity to understand how ROS 2 works, in particular how it
differs from ROS 1.
To that end, we built a set of `demos <../../Tutorials>` that
show some of the key features of ROS 2.
We encourage you to try out those
demos, look at the code that implements them, and `provide
feedback <../../Contact>`.
We're especially interested to know how well (or
poorly) we're addressing use cases that are important to you.


Intended audience
^^^^^^^^^^^^^^^^^

While everyone is welcome to try out the demos and look through the code, we're aiming this release at people who are already experienced with ROS 1 development.
At this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.


Scope
^^^^^

As the ""alpha"" qualifier suggests, this release of ROS 2 is far from
complete.
You should not expect to switch from ROS 1 to ROS 2, nor should
you expect to build a new robot control system with ROS 2.
Rather, you
should expect to try out some demos, explore the code, and perhaps write
your own demos.

The major features included in this release are:


* Discovery, transport, and serialization `use DDS <https://design.ros2.org/articles/ros_on_dds.html>`__
* Support `multiple DDS vendors <https://design.ros2.org/articles/ros_on_dds.html#vendors-and-licensing>`__
* Support messaging primitives: topics (publish / subscribe), services (request / response), and parameters
* Support Linux (Ubuntu Trusty), OS X (Yosemite) and Windows (8)
* `Use quality-of-service settings to handle lossy networks <../Tutorials/Demos/Quality-of-Service>`
* `Communicate inter-process or intra-process with the same API <../Tutorials/Demos/Intra-Process-Communication>`
* `Write real-time safe code that uses the ROS 2 APIs <../Tutorials/Demos/Real-Time-Programming>`
* `Run ROS 2 on ""bare-metal"" microcontrollers (no operating system) <https://github.com/ros2/freertps/wiki>`__
* `Bridge communication between ROS 1 and ROS 2 <https://github.com/ros2/ros1_bridge/blob/master/README.md>`__

Pretty much anything not listed above is not included in this release.
The next steps are described in the `Roadmap <../../The-ROS2-Project/Roadmap>`.
",What changes were made to the supported DDS vendors in ROS 2 starting from alpha8 release?
".. redirect-from::

  Beta2-Overview

Beta 2 (``r2b2``)
=================

.. contents:: Table of Contents
   :depth: 2
   :local:

Supported Platforms
-------------------

We support ROS 2 Beta 2 on three platforms: Ubuntu 16.04 (Xenial), macOS 10.12 (Sierra), and Windows 10.
We provide both binary packages and instructions for how to compile from source for all 3 platforms (see `install instructions <../../Installation>` as well as `documentation <https://docs.ros2.org/beta2/>`__).

Features
--------

Improvements since Beta 1 release
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* DDS_Security support (aka SROS2, see `sros2 <https://github.com/ros2/sros2>`__)
* Debian packages for Ubuntu Xenial
* Typesupport has been redesigned so that you only build a single executable and can choose one of the available RMW implementations by setting an environment variable (see `documentation <../../How-To-Guides/Working-with-multiple-RMW-implementations>`).
* Namespace support for nodes and topics (see `design article <https://design.ros2.org/articles/topic_and_service_names.html>`__, see known issues below).
* A set of command-line tools using the extensible ``ros2`` command (see `conceptual article <../../Concepts/Basic/About-Command-Line-Tools>`).
* A set of macros for logging messages in C / C++ (see API docs of `rcutils <https://docs.ros2.org/beta2/api/rcutils/index.html>`__).

New demo application
^^^^^^^^^^^^^^^^^^^^

* `Turtlebot 2 demos <https://github.com/ros2/turtlebot2_demo>`__ using the following repositories that have been (partially) converted to ROS 2 (Linux only):

  * `ros_astra_camera <https://github.com/ros2/ros_astra_camera.git>`__
  * `depthimage_to_laserscan <https://github.com/ros2/depthimage_to_laserscan.git>`__
  * `pcl_conversions <https://github.com/ros2/pcl_conversions.git>`__
  * `cartographer <https://github.com/ros2/cartographer.git>`__
  * `cartographer_ros <https://github.com/ros2/cartographer_ros.git>`__
  * `ceres-solver <https://github.com/ros2/ceres-solver.git>`__
  * `navigation <https://github.com/ros2/navigation.git>`__
  * `teleop_twist_keyboard <https://github.com/ros2/teleop_twist_keyboard.git>`__
  * `joystick_drivers <https://github.com/ros2/joystick_drivers.git>`__
  * `teleop_twist_joy <https://github.com/ros2/teleop_twist_joy.git>`__

* `Dummy_robot demo <../Tutorials/Demos/dummy-robot-demo>`:

  * `robot_model <https://github.com/ros2/robot_model>`__
  * `robot_state_publisher <https://github.com/ros2/robot_state_publisher>`__

Selected features from previous Alpha/Beta releases
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For the complete list, see `earlier release notes <../index>`.


* C++ and Python implementations of ROS 2 client libraries including APIs for:

  * Publishing and subscribing to ROS topics
  * Requesting and replying ROS services (synchronous (C++ only) and asynchronous)
  * Getting and setting ROS parameters (C++ only, synchronous and asynchronous)
  * Timer callbacks

* Support for interoperability between multiple DDS/RTPS implementations

  * eProsima Fast RTPS is our default implementation, and is included in the binary packages
  * RTI Connext is supported: build from source to try it out
  * We initially supported PrismTech OpenSplice but support for it is currently on hold

* A graph API for network events
* Distributed discovery
* Realtime safe code paths for publish and subscribe with compatible DDS implementation (only Connext at the moment)

  * Support for custom allocators

* ROS 1 <-> ROS 2 dynamic bridge node
* Executor threading model (C++ only)
* Component model to compose nodes at compile / link / runtime
* Managed component using a standard lifecycle
* Extended ``.msg`` format with new features:

  * Bounded arrays
  * Default values

Known issues
^^^^^^^^^^^^

* We’re tracking issues in various repositories, but the main entry point is the `ros2/ros2 issue tracker <https://github.com/ros2/ros2/issues>`__
* We’d like to highlight a `known issue <https://github.com/ros2/rmw_connext/issues/234>`__ that we are looking into which doesn't allow two topics with the same base name but different namespaces to have a different type when using ``rmw_connext_cpp``.
* Services with long responses are not working with Fast-RTPS. The fix, while not being part of beta2, is available upstream so you can work around this issue by building from source using Fast-RTPS master branch.
",What platforms is ROS 2 Beta 2 supported on?
".. redirect-from::

  Beta1-Overview

Beta 1 (``Asphalt``)
====================

.. contents:: Table of Contents
   :depth: 2
   :local:

Supported Platforms
-------------------

We support ROS 2 Beta 1 on three platforms: Ubuntu 16.04 (Xenial), Mac OS X 10.11 (El Capitan), and Windows 8.1 and 10. We provide both binary packages and instructions for how to compile from source for all 3 platforms.

Features
--------

Improvements since Alpha 8 release
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* Support for node composition at compile, link, or runtime.
* A standard lifecycle for managed nodes.
* Improved support for Quality of Service tuning and tests.
* `New and updated design documents <https://design.ros2.org/>`__
* More `tutorials <../../Tutorials>` and `examples <https://github.com/ros2/examples>`__
* Bridging services to / from ROS 1 (in addition to topics)

Selected features from previous Alpha releases
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For the complete list, see `earlier release notes <../index>`.


* C++ and Python implementations of ROS 2 client libraries including APIs for:

  * Publishing and subscribing to ROS topics
  * Requesting and replying ROS services (synchronous (C++ only) and asynchronous)
  * Getting and setting ROS parameters (C++ only, synchronous and asynchronous)
  * Timer callbacks
  * Support for interoperability between multiple DDS/RTPS implementations
  * eProsima Fast RTPS is our default implementation, and is included in the binary packages
  * RTI Connext is supported: build from source to try it out
  * We initially supported PrismTech OpenSplice but eventually decided to drop it

* A graph API for network events
* Distributed discovery
* Realtime safe code paths for publish and subscribe with compatible DDS implementation (only Connext at the moment)

  * Support for custom allocators

* ROS 1 <-> ROS 2 dynamic bridge node
* Executor threading model in C++
* Extended ``.msg`` format with new features:

  * Bounded arrays
  * Default values

Known issues
^^^^^^^^^^^^

* We’re tracking issues in various repositories, but the main entry point is the `ros2/ros2 issue tracker <https://github.com/ros2/ros2/issues>`__
* We’d like to highlight a `known issue <https://github.com/ros2/rmw_fastrtps/issues/81>`__ that we are working with eProsima to fix that results in significantly degrated performance for large messages under FastRTPS.
  This will be observed when running some of the demos with larger image resolutions.
",What platforms are supported by ROS 2 Beta 1 (Asphalt)?
"Eloquent Elusor (``eloquent``)
==============================

.. contents:: Table of Contents
   :depth: 2
   :local:

*Eloquent Elusor* is the fifth release of ROS 2.

Supported Platforms
-------------------

Eloquent Elusor is primarily supported on the following platforms:

Tier 1 platforms:

* Ubuntu 18.04 (Bionic): ``amd64`` and ``arm64``
* Mac macOS 10.14 (Mojave)
* Windows 10 (Visual Studio 2019)

Tier 2 platforms:

* Ubuntu 18.04 (Bionic): ``arm32``

Tier 3 platforms:

* Debian Stretch (9): ``amd64``, ``arm64`` and ``arm32``
* OpenEmbedded Thud (2.6) / webOS OSE: ``arm32`` and ``x86``

For more information about RMW implementations, compiler / interpreter versions, and system dependency versions see `REP 2000 <https://www.ros.org/reps/rep-2000.html>`__.

Installation
------------

`Install Eloquent Elusor <../../eloquent/Installation.html>`__

New features in this ROS 2 release
----------------------------------

A few features and improvements we would like to highlight:

* `Support for markup-based launch files (XML/YAML) <https://github.com/ros2/launch/pull/226>`__
* `Improved launch-based testing <https://github.com/ros2/ros2/issues/739#issuecomment-555743540>`__
* `Passing key-value parameters on CLI <https://github.com/ros2/design/pull/245>`__
* `Support stream logging macros <https://github.com/ros2/rclcpp/pull/926>`__
* `Per-node logging <https://github.com/ros2/ros2/issues/789>`__ - All stdout/stderr output from nodes are logged in ~/.ros
* `ros2doctor <https://index.ros.org/doc/ros2/Tutorials/Getting-Started-With-Ros2doctor/>`__
* `Improved performance of sourcing setup files <https://github.com/ros2/ros2/issues/764>`__
* rviz: `interactive markers <https://github.com/ros2/rviz/pull/457>`__, `torque ring <https://github.com/ros2/rviz/pull/396>`__, `tf message filters <https://github.com/ros2/rviz/pull/375>`__
* rqt: `parameter plugin <https://github.com/ros-visualization/rqt_reconfigure/pull/31>`__, `tf tree plugin <https://github.com/ros-visualization/rqt_tf_tree/pull/13>`__, `robot steering plugin <https://github.com/ros-visualization/rqt_robot_steering/pull/7>`__ (also backported to Dashing)
* `turtlesim <https://github.com/ros/ros_tutorials/pull/53>`__ (also backported to Dashing)
* RMW implementations:

  * `API to loan message for zero copy <https://github.com/ros2/design/pull/256>`__, used by `rmw_iceoryx <https://github.com/ros2/rmw_iceoryx>`__
  * `Fast RTPS 1.9.3 <https://github.com/ros2/ros2/issues/734#issuecomment-518018479>`__
  * New Tier-2 implementation: `rmw_cyclonedds <https://github.com/ros2/rmw_cyclonedds>`__ (also backported to Dashing)

* Environment variable `ROS_LOCALHOST_ONLY <https://github.com/ros2/ros2/issues/798>`__ to limit communication to localhost
* MacOS Mojave Support
* `Tracing instrumentation <https://github.com/ros2/ros2/pull/748>`__ for rcl and rclcpp


During the development the `Eloquent meta ticket <https://github.com/ros2/ros2/issues/734>`__ on GitHub contains an up-to-date state of the ongoing high level tasks as well as references specific tickets with more details.

Changes since the Dashing release
---------------------------------

geometry_msgs
^^^^^^^^^^^^^

The ``geometry_msgs/msg/Quaternion.msg`` interface now default initializes to a valid quaternion, with the following values:

.. math::

    x = 0 \\
    y = 0 \\
    z = 0 \\
    w = 1

Here is the pull request for more detail: `https://github.com/ros2/common_interfaces/pull/74 <https://github.com/ros2/common_interfaces/pull/74>`_

Static transform broadcasters and listeners now use QoS durability ``transient_local`` on the ``/tf_static`` topic.
Similar to the latched setting in ROS 1, static transforms only need to be published once.
New listeners will receive transforms from all static broadcasters that are alive and have published before.
All publishers must be updated to use this durability setting or their messages won't be received by transform listeners.
See this pull request for more detail: `https://github.com/ros2/geometry2/pull/160 <https://github.com/ros2/geometry2/pull/160>`_

rclcpp
^^^^^^

API Break with ``get_actual_qos()``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Introduced in Dashing, the ``get_actual_qos()`` method on the ``PublisherBase`` and ``SubscriptionBase`` previously returned an rmw type, ``rmw_qos_profile_t``, but that made it awkward to reuse with the creation of other entities.
Therefore it was updated to return a ``rclcpp::QoS`` instead.

Existing code will need to use the ``rclcpp::QoS::get_rmw_qos_profile()`` method if the rmw profile is still required.
For example:

.. code-block:: cpp

    void my_func(const rmw_qos_profile_t & rmw_qos);

    /* Previously: */
    // my_func(some_pub->get_actual_qos());
    /* Now: */
    my_func(some_pub->get_actual_qos()->get_rmw_qos_profile());

The rationale for breaking this directly rather than doing a tick-tock is that it is a new function and is expected to be used infrequently by users.
Also, since only the return type is changing, adding a new function with a different would be to only way to do a deprecation cycle and ``get_actual_qos()`` is the most appropriate name, so we would be forced to pick a less obvious name for the method.

API Break with Publisher and Subscription Classes
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

In an effort to streamline the construction of Publishers and Subscriptions, the API of the constructors were changed.

It would be impossible to support a deprecation cycle, because the old signature takes an rcl type and the new one takes the ``NodeBaseInterface`` type so that it can get additional information it now needs, and there's no way to get the additional information needed from just the rcl type.
The new signature could possibly be backported if that would help contributors, but since the publishers and subscriptions are almost always created using the factory functions or some other higher level API, we do not expect this to be a problem for most users.

Please see the original pr for more detail and comment there if this causes issues:

`https://github.com/ros2/rclcpp/pull/867 <https://github.com/ros2/rclcpp/pull/867>`_

Compiler warning about unused result of ``add_on_set_parameters_callback``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

*Since Eloquent Patch Release 2 (2020-12-04)*

Users should retain the  handle returned by ``rclcpp::Node::add_on_set_parameters_callback``, otherwise their callback may be unregistered.
A warning has been added to help identify bugs where the returned handle is not used.

`https://github.com/ros2/rclcpp/pull/1243 <https://github.com/ros2/rclcpp/pull/1243>`_

rmw
^^^

API Break Due to Addition of Publisher and Subscription Options
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``rmw_create_publisher()`` method had a new argument added of type ``const rmw_publisher_options_t *``.
This new structure holds options (beyond the typesupport, topic name, and QoS) for new publishers.

The ``rmw_create_subscription()`` method had one argument removed, ``bool ignore_local_publications``, and replaced by the new options of type ``const rmw_subscription_options_t *``.
The ``ignore_local_publications`` option was moved into the new ``rmw_subscription_options_t`` type.

In both cases the new argument, which are pointers, may never be null, and so the rmw implementations should check to make sure the options are not null.
Additionally, the options should be copied into the corresponding rmw structure.

See this pull request, and the associated pull requests for more details:

`https://github.com/ros2/rmw/pull/187 <https://github.com/ros2/rmw/pull/187>`_

ros2cli
^^^^^^^

ros2msg and ros2srv deprecated
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The CLI tools ``ros2msg`` and ``ros2srv`` are deprecated.
They have been replaced by the tool ``ros2interface``, which also supports action and IDL interfaces.
You can run ``ros2 interface --help`` for usage.

ros2node
""""""""""""""""

Service clients have been added to ros2node info.
As part of that change the Python function ``ros2node.api.get_service_info``
has been renamed to ``ros2node.api.get_service_server_info``.

rviz
^^^^

Renamed '2D Nav Goal' tool
""""""""""""""""""""""""""""""""""""""""""""""""""""

The tool was renamed to '2D Goal Pose' and the default topic was changed from ``/move_base_simple/goal`` to ``/goal_pose``.

Here is the related pull request:

`https://github.com/ros2/rviz/pull/455 <https://github.com/ros2/rviz/pull/455>`_

TF2 Buffer
^^^^^^^^^^

TF2 buffers now have to be given a timer interface.

If a timer interface is not given, an exception will be thrown.

For example:

.. code-block:: cpp

    tf = std::make_shared<tf2_ros::Buffer>(get_clock());
    // The next two lines are new in Eloquent
    auto timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
      this->get_node_base_interface(),
      this->get_node_timers_interface());
    tf->setCreateTimerInterface(timer_interface);
    // Pass the Buffer to the TransformListener as before
    transform_listener = std::make_shared<tf2_ros::TransformListener>(*tf);

rcl
^^^

ROS command line argument changes
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

To cope with an increasingly complex interface, with a now extended set of configuration options, ROS CLI syntax has been changed.
As an example, a command line using Dashing syntax like:

.. code-block:: console

    ros2 run some_package some_node foo:=bar __params:=/path/to/params.yaml __log_level:=WARN --user-flag

is written using Eloquent (and onwards) syntax as:

.. code-block:: console

    ros2 run some_package some_node --ros-args --remap foo:=bar --params-file /path/to/params.yaml --log-level WARN -- --user-flag

This explicit syntax affords new features, like single parameter assignment ``--param name:=value``.
For further reference and rationale, check the `ROS command line arguments design document <https://design.ros2.org/articles/ros_command_line_arguments.html>`__.

.. warning::

   Former syntax has been deprecated and is due for removal in the next release.

Known Issues
------------

* `[ros2/rosidl#402] <https://github.com/ros2/rosidl/issues/402>`_ ``find_package(PCL)`` interferes with ROS interface generation.
  Workaround: invoke ``find_package(PCL)`` *after* ``rosidl_generate_interfaces()``.
* `[ros2/rclcpp#893] <https://github.com/ros2/rclcpp/issues/893>`_ ``rclcpp::Context`` is not destroyed because of a reference cycle with ``rclcpp::GraphListener``. This causes a memory leak. A fix has not been backported because of the risk of breaking ABI.

Timeline before the release
---------------------------

A few milestones leading up to the release:

    Mon. Sep 30th (alpha)
        First releases of core packages available.
        Testing can happen from now on (some features might not have landed yet).

    Fri. Oct 18th
        API and feature freeze for core packages
        Only bug fix releases should be made after this point.
        New packages can be released independently.

    Thu. Oct 24th (beta)
        Updated releases of core packages available.
        Additional testing of the latest features.

    Wed. Nov 13th (release candidate)
        Updated releases of core packages available.

    Tue. Nov 19th
        Freeze rosdistro.
        No PRs for Eloquent on the `rosdistro` repo will be merged (reopens after the release announcement).
",What are the Tier 1 platforms supported by Eloquent Elusor?
".. _galactic-release:

Galactic Geochelone (``galactic``)
==================================

.. toctree::
   :hidden:

   Galactic-Geochelone-Complete-Changelog

.. contents:: Table of Contents
   :depth: 2
   :local:

*Galactic Geochelone* is the seventh release of ROS 2.
What follows is highlights of the important changes and features in Galactic Geochelone since the last release.
For a list of all of the changes since Foxy, see the `long form changelog <Galactic-Geochelone-Complete-Changelog>`.

Supported Platforms
-------------------

Galactic Geochelone is primarily supported on the following platforms:

Tier 1 platforms:

* Ubuntu 20.04 (Focal): ``amd64`` and ``arm64``
* Windows 10 (Visual Studio 2019): ``amd64``

Tier 2 platforms:

* RHEL 8: ``amd64``

Tier 3 platforms:

* Ubuntu 20.04 (Focal): ``arm32``
* Debian Bullseye (11): ``amd64``, ``arm64`` and ``arm32``
* OpenEmbedded Thud (2.6) / webOS OSE: ``arm32`` and ``arm64``
* Mac macOS 10.14 (Mojave): ``amd64``

For more information about RMW implementations, compiler / interpreter versions, and system dependency versions see `REP 2000 <https://www.ros.org/reps/rep-2000.html>`__.

Installation
------------

`Install Galactic Geochelone <../../galactic/Installation.html>`__

New features in this ROS 2 release
----------------------------------

Ability to specify per-logger log levels
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is now possible to specify different logging levels for different loggers on the command line:

.. code-block:: bash

   ros2 run demo_nodes_cpp talker --ros-args --log-level WARN --log-level talker:=DEBUG

The above command sets a global log level of WARN, but sets the log level of the talker node messages to DEBUG.
The ``--log-level`` command-line option can be passed an arbitrary number of times to set different log levels for each logger.

Ability to configure logging directory through environment variables
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is now possible to configure the logging directory through two environment variables: ``ROS_LOG_DIR`` and ``ROS_HOME``.
The logic is as follows:

* Use ``$ROS_LOG_DIR`` if ``ROS_LOG_DIR`` is set and not empty.
* Otherwise, use ``$ROS_HOME/log``, using ``~/.ros`` for ``ROS_HOME`` if not set or if empty.

Thus the default value stays the same: ``~/.ros/log``.

Related PRs: `ros2/rcl_logging#53 <https://github.com/ros2/rcl_logging/pull/53>`_ and `ros2/launch#460 <https://github.com/ros2/launch/pull/460>`_.

For example:

.. code-block:: bash

  ROS_LOG_DIR=/tmp/foo ros2 run demo_nodes_cpp talker

Will place all logs in ``/tmp/foo``.

.. code-block:: bash

  ROS_HOME=/path/to/home ros2 run demo_nodes_cpp talker

Will place all logs in ``/path/to/home/log``.

Ability to invoke ``rosidl`` pipeline outside CMake
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is now straightforward to invoke the ``rosidl`` interface generation pipeline outside CMake.
Source code generators and interface definition translators are accessible through a unified command line interface.

For example, given a ``Demo`` message in some ``demo`` package like:

.. code-block:: bash

  mkdir -p demo/msg
  cd demo
  cat << EOF > msg/Demo.msg
  std_msgs/Header header
  geometry_msgs/Twist twist
  geometry_msgs/Accel accel
  EOF

it is easy to generate C, C++, and Python support source code:

.. code-block:: bash

  rosidl generate -o gen -t c -t cpp -t py -I$(ros2 pkg prefix --share std_msgs)/.. \
    -I$(ros2 pkg prefix --share geometry_msgs)/.. demo msg/Demo.msg

Generated source code will be put in the ``gen`` directory.

One may also translate the message definition to a different format for a third-party code generation tool to consume:

.. code-block:: bash

  rosidl translate -o gen --to idl -I$(ros2 pkg prefix --share std_msgs)/.. \
    -I$(ros2 pkg prefix --share geometry_msgs)/.. demo msg/Demo.msg

The translated message definition will be put in the ``gen`` directory.

Note that these tools generate sources but do not build it -- that responsibility is still on the caller.
This is a first step towards enabling ``rosidl`` interface generation in build systems other than CMake.
See the `design document <https://github.com/ros2/design/pull/310>`_ for further reference and next steps.

Externally configure QoS at start-up
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is now possible to externally configure the QoS settings for a node at start-up time.
QoS settings are **not** configurable during runtime; they are only configurable at start-up.
Node authors must opt-in to enable changing QoS settings at start-up.
If the feature is enabled on a node, then QoS settings can be set with ROS parameters when a node first starts.

`Demos in C++ and Python can be found here. <https://github.com/ros2/demos/tree/a66f0e894841a5d751bce6ded4983acb780448cf/quality_of_service_demo#qos-overrides>`_

See the `design document for more details <http://design.ros2.org/articles/qos_configurability.html>`_.

Note, user code handling parameter changes with registered callbacks should avoid rejecting updates for unknown parameters.
It was considered bad practice prior to Galactic, but with externally configurable QoS enabled it will result in a hard failure.

Related PRs: `ros2/rclcpp#1408 <https://github.com/ros2/rclcpp/pull/1408>`_ and `ros2/rclpy#635 <https://github.com/ros2/rclpy/pull/635>`_

Python point_cloud2 utilities available
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Several utilities for interacting with `PointCloud2 messages <https://github.com/ros2/common_interfaces/blob/galactic/sensor_msgs/msg/PointCloud2.msg>`__ in Python were `ported to ROS 2 <https://github.com/ros2/common_interfaces/pull/128>`__.
These utilities allow one to get a list of points from a PointCloud2 message (``read_points`` and ``read_points_list``), and to create a PointCloud2 message from a list of points (``create_cloud`` and ``create_cloud_xyz32``).

An example of creating PointCloud 2 message, then reading it back:

.. code-block:: python

  import sensor_msgs_py.point_cloud2
  from std_msgs.msg import Header

  pointlist = [[0.0, 0.1, 0.2]]

  pointcloud = sensor_msgs_py.point_cloud2.create_cloud_xyz32(Header(frame_id='frame'), pointlist)

  for point in sensor_msgs_py.point_cloud2.read_points(pointcloud):
      print(point)

RViz2 Time Panel
^^^^^^^^^^^^^^^^

The Rviz2 Time Panel, which shows the current Wall and ROS time, along with the elapsed Wall and ROS time, has been `ported to RViz2 <https://github.com/ros2/rviz/pull/599>`__.
To enable the Time Panel, click on Panels -> Add New Panel, and select ""Time"".
A panel that looks like the following will appear:

.. image:: rviz2-time-panel-2021-05-17.png

ros2 topic echo can print serialized data
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When debugging middleware issues, it can be useful to see the raw serialized data that the RMW is sending.
The `--raw command-line flag <https://github.com/ros2/ros2cli/pull/470>`__ was added to ``ros2 topic echo`` to show this data.
To see this in action, run the following commands.

Terminal 1:

.. code-block:: bash

  $ ros2 topic pub /chatter std_msgs/msg/String ""data: 'hello'""

Terminal 2:

.. code-block:: bash

  $ ros2 topic echo --raw /chatter
  b'\x00\x01\x00\x00\x06\x00\x00\x00hello\x00\x00\x00'
  ---

Get the YAML representation of messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is now possible to get a YAML representation of all messages in C++ using the `to_yaml <https://github.com/ros2/rosidl/issues/523>`__ function.
An example of code that prints out the YAML representation:

.. code-block:: c++

  #include <cstdio>

  #include <std_msgs/msg/string.hpp>

  int main()
  {
    std_msgs::msg::String msg;
    msg.data = ""hello world"";
    printf(""%s"", rosidl_generator_traits::to_yaml(msg).c_str());
    return 0;
  }

Ability to load parameter files at runtime through the ros2 command
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ROS 2 has long had the ability to specify parameter values at startup (through command-line arguments or a YAML file), and to dump current parameters out to a file (through ``ros2 param dump``).
Galactic adds the ability to `load parameter values at runtime <https://github.com/ros2/ros2cli/pull/590>`__ from a YAML file using the ``ros2 param load`` verb.
For example:

Terminal 1:

.. code-block:: bash

  $ ros2 run demo_nodes_cpp parameter_blackboard

Terminal 2:

.. code-block:: bash

  $ ros2 param set /parameter_blackboard foo bar  # sets 'foo' parameter to value 'bar'
  $ ros2 param dump /parameter_blackboard  # dumps current value of parameters to ./parameter_blackboard.yaml
  $ ros2 param set /parameter_blackboard foo different  # sets 'foo' parameter to value 'different'
  $ ros2 param load /parameter_blackboard ./parameter_blackboard.yaml  # reloads previous state of parameters, 'foo' is back to 'bar'

Tools to check for QoS incompatibilities
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Built on top of new QoS compatibility check APIs, ``ros2doctor`` and ``rqt_graph`` can now detect and report QoS incompatibilities between publishers and subscriptions.

Given a publisher and a subscription with `incompatible QoS settings <../../Concepts/Intermediate/About-Quality-of-Service-Settings>`:

Terminal 1:

.. code-block:: bash

  $ ros2 run demo_nodes_py talker_qos -n 1000  # i.e. best_effort publisher

Terminal 2:

.. code-block:: bash

  $ ros2 run demo_nodes_py listener_qos --reliable -n 1000  # i.e. reliable subscription

``ros2doctor`` reports:

.. code-block:: bash

  $ ros2 doctor --report
  # ...
     QOS COMPATIBILITY LIST
  topic [type]            : /chatter [std_msgs/msg/String]
  publisher node          : talker_qos
  subscriber node         : listener_qos
  compatibility status    : ERROR: Best effort publisher and reliable subscription;
  # ...

while ``rqt_graph`` shows:

.. image:: images/rqt_graph-qos-incompatibility-2021-05-17.png

Related PRs: `ros2/ros2cli#621 <https://github.com/ros2/ros2cli/pull/621>`_, `ros-visualization/rqt_graph#61 <https://github.com/ros-visualization/rqt_graph/pull/61>`_

Use launch substitutions in parameter files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Just like ``rosparam`` tags in ROS 1 ``roslaunch``, ``launch_ros`` can now evaluate substitutions in parameter files.

For example, given some ``parameter_file_with_substitutions.yaml`` like the following:

.. code-block:: yaml

  /**:
    ros__parameters:
      launch_date: $(command date)

Set ``allow_substs`` to ``True`` to get substitutions evaluated upon ``Node`` launch:

.. code-block:: python

  import launch
  import launch_ros.parameter_descriptions
  import launch_ros.actions

  def generate_launch_description():
      return launch.LaunchDescription([
          launch_ros.actions.Node(
              package='demo_nodes_cpp',
              executable='parameter_blackboard',
              parameters=[
                  launch_ros.parameter_descriptions.ParameterFile(
                      param_file='parameter_file_with_substitutions.yaml',
                      allow_substs=True)
              ]
          )
      ])

XML launch files also support this.

.. code-block:: xml

  <launch>
    <node pkg=""demo_nodes_cpp"" exec=""parameter_blackboard"">
      <param from=""parameter_file_with_substitutions.yaml"" allow_substs=""true""/>
    </node>
  </launch>

Related PR: `ros2/launch_ros#168 <https://github.com/ros2/launch_ros/pull/168>`_

Support for unique network flows
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Applications may now require UDP/TCP and IP-based RMW implementations to provide unique *network flows* (i.e. unique `Differentiated Services Code Points <https://tools.ietf.org/html/rfc2474>`_ and/or unique `IPv6 Flow Labels <https://tools.ietf.org/html/rfc6437>`_ and/or unique ports in IP packet headers) for publishers and subscriptions, enabling QoS specifications for these IP streams in network architectures that support such a feature, like 5G networks.

To see this in action, you may run these C++ examples (to be found in the `ros2/examples <https://github.com/ros2/examples>`__ repository):

Terminal 1:

.. code-block:: bash

  ros2 run examples_rclcpp_minimal_publisher publisher_member_function_with_unique_network_flow_endpoints


Terminal 2:

.. code-block:: bash

  ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function_with_unique_network_flow_endpoints


See the `Unique Network Flows design document <https://github.com/ros2/design/pull/304>`_ for further reference.

Rosbag2 New Features
^^^^^^^^^^^^^^^^^^^^

Split recording by time
""""""""""""""""""""""""""""""""""""""""""""""

In Foxy, you could only split bags as they were recording by the size of the bag, now you can also split by the elapsed time.
The following command will split bagfiles into 100-second chunks.

.. code-block:: bash

  ros2 bag record --all --max-bag-duration 100

ros2 bag list
""""""""""""""""""""""""""

This new command lists installed plugins of various types that rosbag2 uses.

.. code-block:: bash

  $ ros2 bag list storage
  rosbag2_v2
  sqlite3

  $ ros2 bag list converter
  rosbag_v2_converter


Compression implementation is a plugin
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

In Foxy, rosbag2 compression was hardcoded with a Zstd library implementation.
This has been rearchitected so that compression implementations are a plugin, and can be swapped out without modifying the core rosbag2 codebase.
The default plugin that ships with ``ros-galactic-rosbag2`` is still the Zstd plugin - but now more can be released and used, and by selectively installing packages Zstd could be excluded from an installation.


Compress per-message
""""""""""""""""""""""""""""""""""""""""

In Foxy, you could automatically compress each rosbag file as it was split (per-file compression), but now you can also specify per-message compression.

.. code-block:: bash

  ros2 bag record --all --compression-format zstd --compression-mode message


Rosbag2 Python API
""""""""""""""""""""""""""""""""""""""""""

A new package ``rosbag2_py`` has been released in Galactic, which provides a Python API.
This package is a ``pybind11`` binding around the C++ API.
As of the initial Galactic release, it does not yet expose all functionality available via the ``rosbag2_cpp`` API, but it is the sole connection for the ``ros2 bag`` CLI tool, so a good deal of functionality is available.


performance testing package and performance improvements
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

A thorough performance analysis project was performed on rosbag2 since the Foxy release.
The full initial report is available at https://github.com/ros2/rosbag2/blob/galactic/rosbag2_performance/rosbag2_performance_benchmarking/docs/rosbag2_performance_improvements.pdf .
The package ``rosbag2_performance_benchmarking`` provides tools to run performance analyses, especially on recording, which helps us maintain and improve the performance of rosbag2.

Following this report, key work was done do improve the performance to a much more usable state for actual robot workflows.
To highlight a key metric - in a high bandwidth stress test (200Mbps), the Foxy release dropped up to 70% of messages, whereas the Galactic version was approximately 100% retention.
Please see the linked report for more details.

``--regex`` and ``--exclude`` options for topic selection
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The new recording options ``--regex`` and ``--exclude`` allow for fine-tuning the topics recorded in a bag, without having to explicitly list all topics.
These options may be used together or separately, and in conjunction with ``--all``

The following command will record only topics with ""scan"" in the name.

.. code-block:: bash

  ros2 bag record --regex ""*scan*""

The following command will record all topics except for ones in ``/my_namespace/``

.. code-block:: bash

  ros2 bag record --all --exclude ""/my_namespace/*""


``ros2 bag reindex``
""""""""""""""""""""""""""""""""""""""""

ROS 2 bags are represented by a directory, instead of a single file.
This directory contains a ``metadata.yaml`` file, and one or more bag files.
When the ``metadata.yaml`` file is lost or missing, ``ros2 bag reindex $bag_dir`` will attempt to reconstruct it by reading all the bag files in the directory.

Playback time control
""""""""""""""""""""""""""""""""""""""""""

New controls have been added for rosbag2 playback - pause & resume, change rate, and play-next.
As of the Galactic release, these controls are exposed only as services on the rosbag2 player node.
Development is in progress to expose them to keyboard controls as well in ``ros2 bag play``, but until then a user application with buttons or keyboard controls may be trivially implemented to call these services.

.. code-block:: bash

  # In one shell
  $ ros2 bag play my_bag

  # In another shell
  $ ros2 service list -t
  /rosbag2_player/get_rate [rosbag2_interfaces/srv/GetRate]
  /rosbag2_player/is_paused [rosbag2_interfaces/srv/IsPaused]
  /rosbag2_player/pause [rosbag2_interfaces/srv/Pause]
  /rosbag2_player/play_next [rosbag2_interfaces/srv/PlayNext]
  /rosbag2_player/resume [rosbag2_interfaces/srv/Resume]
  /rosbag2_player/set_rate [rosbag2_interfaces/srv/SetRate]
  /rosbag2_player/toggle_paused [rosbag2_interfaces/srv/TogglePaused]

  # Check if playback is paused
  $ ros2 service call /rosbag2_player/is_paused rosbag2_interfaces/IsPaused

  # Pause playback
  $ ros2 service call /rosbag2_player/pause rosbag2_interfaces/Pause

  # Resume playback
  $ ros2 service call /rosbag2_player/resume rosbag2_interfaces/Resume

  # Change the paused state of playback to its opposite. If playing, pauses. If paused, resumes.
  $ ros2 service call /rosbag2_player/toggle_paused rosbag2_interfaces/TogglePaused

  # Get the current playback rate
  $ ros2 service call /rosbag2_player/get_rate

  # Set the current playback rate (must be > 0)
  $ ros2 service call /rosbag2_player/set_rate rosbag2_interfaces/SetRate ""rate: 0.1""

  # Play a single next message (only works while paused)
  $ ros2 service call /rosbag2_player/play_next rosbag2_interfaces/PlayNext


Playback publishes /clock
""""""""""""""""""""""""""""""""""""""""""""""""""

Rosbag2 can also dictate ""simulation time"" by publishing to the ``/clock`` topic during playback.
The following commands will publish the clock message at a regular interval.

.. code-block:: bash

  # Publish at default rate - 40Hz
  ros2 bag play my_bag --clock

  # Publish at specific rate - 100Hz
  ros2 bag play my_bag --clock 100

Changes since the Foxy release
------------------------------

Default RMW changed to Eclipse Cyclone DDS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

During the Galactic development process, the ROS 2 Technical Steering Committee `voted <https://discourse.ros.org/t/ros-2-galactic-default-middleware-announced/18064>`__ to change the default ROS middleware (RMW) to `Eclipse Cyclone DDS <https://github.com/eclipse-cyclonedds/cyclonedds>`__ project of `Eclipse Foundation <https://www.eclipse.org>`__.
Without any configuration changes, users will get Eclipse Cyclone DDS by default.
Fast DDS and Connext are still Tier-1 supported RMW vendors, and users can opt-in to use one of these RMWs at their discretion by using the ``RMW_IMPLEMENTATION`` environment variable.
See the `Working with multiple RMW implementations guide <../../How-To-Guides/Working-with-multiple-RMW-implementations>` for more information.

Connext RMW changed to rmw_connextdds
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A new RMW for Connext called `rmw_connextdds <https://github.com/ros2/rmw_connextdds>`_ was merged for Galactic.
This RMW has better performance and fixes many of the issues with the older RMW ``rmw_connext_cpp``.

Large improvements in testing and overall quality
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Galactic contains many changes that fix race conditions, plug memory leaks, and fix user reported problems.
Besides these changes, there was a concerted effort during Galactic development to improve overall quality of the system by implementing `REP 2004 <https://www.ros.org/reps/rep-2004.html>`__.
The ``rclcpp`` package and all of its dependencies (which include most of the ROS 2 non-Python core packages) were brought up to `Quality Level 1 <https://www.ros.org/reps/rep-2004.html#quality-level-1>`__ by:

* Having a version policy (QL1 requirement 1)
* Having a documented change control process (QL1 requirement 2)
* Documenting all features and public APIs (QL1 requirement 3)
* Adding many additional tests (QL1 requirement 4):

  * System tests for all features
  * Unit tests for all public APIs
  * Nightly performance tests
  * Code coverage at 95%

* Having all runtime dependencies of packages be at least as high as the package (QL1 requirement 5)
* Supporting all of the REP-2000 platforms (QL1 requirement 6)
* Having a vulnerability disclosure policy (QL1 requirement 7)

rmw
^^^

New API for checking QoS profile compatibility
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``rmw_qos_profile_check_compatible`` is a new function for checking the compatibility of two QoS profiles.

RMW vendors should implement this API for QoS debugging and introspection features in tools such as ``rqt_graph`` to work correctly.

Related PR: `ros2/rmw#299 <https://github.com/ros2/rmw/pull/299>`_

ament_cmake
^^^^^^^^^^^

``ament_install_python_package()`` now installs a Python egg
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

By installing a flat Python egg, Python packages installed using ``ament_install_python_package()`` can be discovered using modules such as ``pkg_resources`` and ```importlib.metadata``. Also, additional metadata can be provided in a ``setup.cfg`` file (including entry points).

Related PR: `ament/ament_cmake#326 <https://github.com/ament/ament_cmake/pull/326>`_

``ament_target_dependencies()`` handles SYSTEM dependencies
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Some package dependencies can now be marked as SYSTEM dependencies, helping to cope with warnings in external code. Typically, SYSTEM dependencies are also excluded from dependency calculations -- use them with care.

Related PR: `ament/ament_cmake#297 <https://github.com/ament/ament_cmake/pull/297>`_

nav2
^^^^

Changes include, but are not limited to, a number of stability improvements, new plugins, interface changes, costmap filters.
See `Migration Guides <https://navigation.ros.org/migration/Foxy.html>`_ for full list

tf2_ros Python split out of tf2_ros
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The Python code that used to live in tf2_ros has been moved into its own package named tf2_ros_py.
Any existing Python code that depends on tf2_ros will continue to work, but the package.xml of those packages should be amended to ``exec_depend`` on tf2_ros_py.

tf2_ros Python TransformListener uses global namespace
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The Python ``TransformListener`` now subscribes to ``/tf`` and ``/tf_static`` in the global namespace.
Previously, it was susbcribing in the node's namespace.
This means that the node's namespace will no longer have an effect on the ``/tf`` and ``/tf_static`` subscriptions.

For example:

.. code-block:: bash

  ros2 run tf2_ros tf2_echo --ros-args -r __ns:=/test -- odom base_link

will subscribe to ``/tf`` and ``/tf_static``, as ``ros2 topic list`` will show.

Related PR: `ros2/geometry2#390 <https://github.com/ros2/geometry2/pull/390>`_

rclcpp
^^^^^^

Change in spin_until_future_complete template parameters
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The first template parameter of ``Executor::spin_until_future_complete`` was the future result type ``ResultT``, and the method only accepted a ``std::shared_future<ResultT>``.
In order to accept other types of futures (e.g.: ``std::future``), that parameter was changed to the future type itself.

In places where a ``spin_until_future_complete`` call was relying on template argument deduction, no change is needed.
If not, this is an example diff:

.. code-block:: dpatch

   std::shared_future<MyResultT> future;
   ...
   -executor.spin_until_future_complete<MyResultT>(future);
   +executor.spin_until_future_complete<std::shared_future<MyResultT>>(future);


For more details, see `ros2/rclcpp#1160 <https://github.com/ros2/rclcpp/pull/1160>`_.
For an example of the needed changes in user code, see `ros-visualization/interactive_markers#72 <https://github.com/ros-visualization/interactive_markers/pull/72>`_.

Change in default ``/clock`` subscription QoS profile
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The default was changed from a reliable communication with history depth 10 to a best effort communication with history depth 1.
See `ros2/rclcpp#1312 <https://github.com/ros2/rclcpp/pull/1312>`_.

Waitable API
""""""""""""""""""""""""

Waitable API was modified to avoid issues with the ``MultiThreadedExecutor``.
This only affects users implementing a custom waitable.
See `ros2/rclcpp#1241 <https://github.com/ros2/rclcpp/pull/1241>`_ for more details.

Change in ``rclcpp``'s logging macros
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Previously, the logging macros were vulnerable to a `format string attack <https://owasp.org/www-community/attacks/Format_string_attack>`_, where the format string is evaluated and can potentially execute code, read the stack, or cause a segmentation fault in the running program.
To address this security issue, the logging macro now accepts only string literals for it's format string argument.

If you previously had code like:

.. code-block::

  const char *my_const_char_string format = ""Foo"";
  RCLCPP_DEBUG(get_logger(), my_const_char_string);

you should now replace it with:

.. code-block::

  const char *my_const_char_string format = ""Foo"";
  RCLCPP_DEBUG(get_logger(), ""%s"", my_const_char_string);

or:

.. code-block::

  RCLCPP_DEBUG(get_logger(), ""Foo"");


This change removes some convenience from the logging macros, as ``std::string``\s are no longer accepted as the format argument.


If you previously had code with no format arguments like:

.. code-block::

  std::string my_std_string = ""Foo"";
  RCLCPP_DEBUG(get_logger(), my_std_string);

you should now replace it with:

.. code-block::

    std::string my_std_string = ""Foo"";
    RCLCPP_DEBUG(get_logger(), ""%s"", my_std_string.c_str());

.. note::
    If you are using a ``std::string`` as a format string with format arguments, converting that string to a ``char *`` and using it as the format string will yield a format security warning. That's because the compiler has no way at compile to introspect into the ``std::string`` to verify the arguments.  To avoid the security warning, we recommend you build the string manually and pass it in with no format arguments like the previous example.

``std::stringstream`` types are still accepted as arguments to the stream logging macros.
See `ros2/rclcpp#1442 <https://github.com/ros2/rclcpp/pull/1442>`_ for more details.

Parameter types are now static by default
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Previously, the type of a parameter could be changed when a parameter was set.
For example, if a parameter was declared as an integer, a later call to set the parameter could change that type to a string.
This behavior could lead to bugs, and is rarely what the user wants.
As of Galactic parameter types are static by default, and attempts to change the type will fail.
If the previous dynamic behavior is desired, there is an mechanism to opt it in (see the code below).

.. code-block:: cpp

    // declare integer parameter with default value, trying to set it to a different type will fail.
    node->declare_parameter(""my_int"", 5);
    // declare string parameter with no default and mandatory user provided override.
    // i.e. the user must pass a parameter file setting it or a command line rule -p <param_name>:=<value>
    node->declare_parameter(""string_mandatory_override"", rclcpp::PARAMETER_STRING);
    // Conditionally declare a floating point parameter with a mandatory override.
    // Useful when the parameter is only needed depending on other conditions and no default is reasonable.
    if (mode == ""modeA"") {
        node->declare_parameter(""conditionally_declare_double_parameter"", rclcpp::PARAMETER_DOUBLE);
    }
    // You can also get the old dynamic typing behavior if you want:
    rcl_interfaces::msg::ParameterDescriptor descriptor;
    descriptor.dynamic_typing = true;
    node->declare_parameter(""dynamically_typed_param"", rclcpp::ParameterValue{}, descriptor);

For more details see https://github.com/ros2/rclcpp/blob/galactic/rclcpp/doc/notes_on_statically_typed_parameters.md.

New API for checking QoS profile compatibility
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``qos_check_compatible`` is a new function for checking the compatibility of two QoS profiles.

Related PR: `ros2/rclcpp#1554 <https://github.com/ros2/rclcpp/pull/1554>`_

rclpy
^^^^^

Removal of deprecated Node.set_parameters_callback
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The method ``Node.set_parameters_callback`` was `deprecated in ROS Foxy <https://github.com/ros2/rclpy/pull/504>`_ and has been `removed in ROS Galactic <https://github.com/ros2/rclpy/pull/633>`_.
Use ``Node.add_on_set_parameters_callback()`` instead.
Here is some example code using it.

.. code-block:: python

    import rclpy
    import rclpy.node
    from rcl_interfaces.msg import ParameterType
    from rcl_interfaces.msg import SetParametersResult


    rclpy.init()
    node = rclpy.node.Node('callback_example')
    node.declare_parameter('my_param', 'initial value')


    def on_parameter_event(parameter_list):
        for parameter in parameter_list:
            node.get_logger().info(f'Got {parameter.name}={parameter.value}')
        return SetParametersResult(successful=True)


    node.add_on_set_parameters_callback(on_parameter_event)
    rclpy.spin(node)

Run this command to see the parameter callback in action.

.. code-block::

    ros2 param set /callback_example my_param ""Hello World""

Parameter types are now static by default
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

In Foxy and earlier a call to set a parameter could change its type.
As of Galactic parameter types are static and cannot be changed by default.
If the previous behavior is desired, then set ``dynamic_typing`` to true in the parameter descriptor.
Here is an example.

.. code-block:: python

  import rclpy
  import rclpy.node
  from rcl_interfaces.msg import ParameterDescriptor

  rclpy.init()
  node = rclpy.node.Node('static_param_example')
  node.declare_parameter('static_param', 'initial value')
  node.declare_parameter('dynamic_param', 'initial value', descriptor=ParameterDescriptor(dynamic_typing=True))
  rclpy.spin(node)

Run these commands to see how statically and dynamically typed parameters are different.

.. code-block:: console

    $ ros2 param set /static_param_example dynamic_param 42
    Set parameter successful
    $ ros2 param set /static_param_example static_param 42
    Setting parameter failed: Wrong parameter type, expected 'Type.STRING' got 'Type.INTEGER'

For more details see https://github.com/ros2/rclcpp/blob/galactic/rclcpp/doc/notes_on_statically_typed_parameters.md.

New API for checking QoS profile compatibility
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``rclpy.qos.qos_check_compatible`` is `a new function <https://github.com/ros2/rclpy/pull/708>`_ for checking the compatibility of two QoS profiles.
If the profiles are compatible, then a publisher and subscriber using them will be able to talk to each other.

.. code-block:: python

    import rclpy.qos

    publisher_profile = rclpy.qos.qos_profile_sensor_data
    subscription_profile = rclpy.qos.qos_profile_parameter_events

    print(rclpy.qos.qos_check_compatible(publisher_profile, subscription_profile))

.. code-block:: console

    $ python3 qos_check_compatible_example.py
    (QoSCompatibility.ERROR, 'ERROR: Best effort publisher and reliable subscription;')

rclcpp_action
^^^^^^^^^^^^^

Action client goal response callback signature changed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The goal response callback should now take a shared pointer to a goal handle, instead of a future.

For `example <https://github.com/ros2/examples/pull/291>`_, old signature:

.. code-block:: c++

   void goal_response_callback(std::shared_future<GoalHandleFibonacci::SharedPtr> future)

New signature:

.. code-block:: c++

   void goal_response_callback(GoalHandleFibonacci::SharedPtr goal_handle)

Related PR: `ros2/rclcpp#1311 <https://github.com/ros2/rclcpp/pull/1311>`_

rosidl_typesupport_introspection_c
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

API break in function that gets an element from an array
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The signature of the function was changed because it was semantically different to all the other functions used to get an element from an array or sequence.
This only affects authors of rmw implementations using the introspection typesupport.

For further details, see `ros2/rosidl#531 <https://github.com/ros2/rosidl/pull/531>`_.

rcl_lifecycle and rclcpp_lifecycle
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

RCL's lifecycle state machine gets new init API
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The lifecycle state machine in rcl_lifecycle was modified to expect a newly introduced options struct, combining general configurations for the state machine.
The option struct allows to indicate whether the state machine shall be initialized with default values, whether its attached services are active and which allocator to be used.

.. code-block:: c

  rcl_ret_t
  rcl_lifecycle_state_machine_init(
    rcl_lifecycle_state_machine_t * state_machine,
    rcl_node_t * node_handle,
    const rosidl_message_type_support_t * ts_pub_notify,
    const rosidl_service_type_support_t * ts_srv_change_state,
    const rosidl_service_type_support_t * ts_srv_get_state,
    const rosidl_service_type_support_t * ts_srv_get_available_states,
    const rosidl_service_type_support_t * ts_srv_get_available_transitions,
    const rosidl_service_type_support_t * ts_srv_get_transition_graph,
    const rcl_lifecycle_state_machine_options_t * state_machine_options);

RCL's lifecycle state machine stores allocator instance
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The options struct (discussed above) entails an instance of the allocator being used for initializing the state machine.
This options struct and there the embodied allocator are being stored within the lifecycle state machine.
As a direct consequence, the ``rcl_lifecycle_fini function`` no longer expects an allocator in its fini function but rather uses the allocator set in the options struct for deallocating its internal data structures.

.. code-block:: c

  rcl_ret_t
  rcl_lifecycle_state_machine_fini(
    rcl_lifecycle_state_machine_t * state_machine,
    rcl_node_t * node_handle);

RCLCPP's lifecycle node exposes option to not instantiate services
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

In order to use rclcpp's lifecycle nodes without exposing its internal services such as ``change_state``, ``get_state`` et. al., the constructor of a lifecycle node has a newly introduced parameter indicating whether or not the services shall be available.
This boolean flag is set to true by default, not requiring any changes to existing API if not wished.

.. code-block:: c++

  explicit LifecycleNode(
    const std::string & node_name,
    const rclcpp::NodeOptions & options = rclcpp::NodeOptions(),
    bool enable_communication_interface = true);

Related PRs: `ros2/rcl#882 <https://github.com/ros2/rcl/pull/882>`_ and `ros2/rclcpp#1507 <https://github.com/ros2/rclcpp/pull/1507>`_

rcl_lifecycle and rclcpp_lifecycle
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Recording - Split by time
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""



Known Issues
------------

ros2cli
^^^^^^^

Daemon slows down CLI on Windows
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

As a workaround, CLI commands may be used without a daemon e.g.:

.. code-block:: bash

  ros2 topic list --no-daemon


Issue is tracked by `ros2/ros2cli#637 <https://github.com/ros2/ros2cli/issues/637>`_.

rqt
^^^

Some rqt_bag icons are missing
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The icons to ""Zoom In"", ""Zoom Out"", ""Zoom Home"", and ""Toggle Thumbnails"" are missing in ``rqt_bag``.
The issue is tracked in `ros-visualization/rqt_bag#102 <https://github.com/ros-visualization/rqt_bag/issues/102>`_

Most rqt utilities don't work standalone on Windows
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Launching the rqt utilities ""standalone"" on Windows (like ``ros2 run rqt_graph rqt_graph``) generally doesn't work.
The workaround is to launch the rqt container process (``rqt``), and then insert the plugins to be used.

rviz2
^^^^^

RViz2 panel close buttons are blank
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The upper right-hand corner of every RViz2 panel should contain an ""X"" to allow one to close the panel.
Those buttons are there, but the ""X"" inside of them is missing on all platforms.
The issue is being tracked in `ros2/rviz2#692 <https://github.com/ros2/rviz/issues/692>`__.

Timeline before the release
---------------------------

    Mon. March 22, 2021 - Alpha
        Preliminary testing and stabilization of ROS Core [1]_ packages.

    Mon. April 5, 2021 - Freeze
        API and feature freeze for ROS Core [1]_ packages in Rolling Ridley.
        Note that this includes ``rmw``, which is a recursive dependency of ``ros_core``.
        Only bug fix releases should be made after this point.
        New packages can be released independently.

    Mon. April 19, 2021 - Branch
        Branch from Rolling Ridley.
        ``rosdistro`` is reopened for Rolling PRs for ROS Core [1]_ packages.
        Galactic development shifts from ``ros-rolling-*`` packages to ``ros-galactic-*`` packages.

    Mon. April 26, 2021 - Beta
        Updated releases of ROS Desktop [2]_ packages available.
        Call for general testing.

    Mon. May 17, 2021 - RC
      Release Candidate packages are built.
        Updated releases of ROS Desktop [2]_ packages available.

    Thu. May 20, 2021 - Distro Freeze
        Freeze rosdistro.
        No PRs for Galactic on the ``rosdistro`` repo will be merged (reopens after the release announcement).

    Sun. May 23, 2021 - General Availability
      Release announcement.
        ``rosdistro`` is reopened for Galactic PRs.

.. [1] The ``ros_core`` variant is described in `REP 2001 (ros-core) <https://www.ros.org/reps/rep-2001.html#ros-core>`_.
.. [2] The ``desktop`` variant is described in `REP 2001 (desktop-variants) <https://www.ros.org/reps/rep-2001.html#desktop-variants>`_.
",What platforms are primarily supported in the Galactic Geochelone release of ROS 2?
"Foxy Fitzroy (``foxy``)
=======================

.. contents:: Table of Contents
   :depth: 2
   :local:

*Foxy Fitzroy* is the sixth release of ROS 2.

Supported Platforms
-------------------

Foxy Fitzroy is primarily supported on the following platforms:

Tier 1 platforms:

* Ubuntu 20.04 (Focal): ``amd64`` and ``arm64``
* Mac macOS 10.14 (Mojave)
* Windows 10 (Visual Studio 2019)

Tier 3 platforms:

* Ubuntu 20.04 (Focal): ``arm32``
* Debian Buster (10): ``amd64``, ``arm64`` and ``arm32``
* OpenEmbedded Thud (2.6) / webOS OSE: ``arm32`` and ``x86``

For more information about RMW implementations, compiler / interpreter versions, and system dependency versions see `REP 2000 <https://www.ros.org/reps/rep-2000.html>`__.

Installation
------------

`Install Foxy Fitzroy <../../foxy/Installation.html>`__

New features in this ROS 2 release
----------------------------------

During the development the `Foxy meta-ticket <https://github.com/ros2/ros2/issues/830>`__ on GitHub contains an up-to-date state of the ongoing high-level tasks as well as references specific tickets with more details.

Changes in Patch Release 8 (2022-09-28)
---------------------------------------

Launch GroupAction scopes environment
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``SetEnvironmentVariable`` action is now scoped to any ``GroupAction`` it is returned from.

For example, consider the following launch files,

.. tabs::

   .. group-tab:: Python

      .. code-block:: python

         import launch
         from launch.actions import SetEnvironmentVariable
         from launch.actions import GroupAction
         from launch_ros.actions import Node


         def generate_launch_description():
             return launch.LaunchDescription([
                 SetEnvironmentVariable(name='my_env_var', value='1'),
                 Node(package='foo', executable='foo', output='screen'),
                 GroupAction([
                     SetEnvironmentVariable(name='my_env_var', value='2'),
                 ]),
             ])

   .. group-tab:: XML

      .. code-block:: xml

         <launch>
           <set_env name=""my_env_var"" value=""1""/>
           <node pkg=""foo"" exec=""foo"" output=""screen"" />
           <group>
             <set_env name=""my_env_var"" value=""2""/>
           </group>
         </launch>

Before patch release 8, the node ``foo`` will start with ``my_env_var=2``, but now it will start with ``my_env_var=1``.

To opt-out of the new behavior, you can set the argument ``scoped=False`` on the ``GroupAction``.

Related tickets:


* `ros2#1244 <https://github.com/ros2/ros2/issues/1244>`_
* `launch#630 <https://github.com/ros2/launch/pull/630>`_

Changes in Patch Release 7 (2022-02-08)
---------------------------------------

Launch set_env frontend behavior change
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`launch#468 <https://github.com/ros2/launch/pull/468>`_ inadvertently changed behavior to the scope of the ``set_env`` action in frontend launch files.
Changes to environment variables using the ``set_env`` action are no longer scoped to parent ``group`` actions, and instead apply globally.
Since it was backported, the change affects this release.

We consider this change a regression and intend to fix the behavior in the next patch release and in future ROS distributions.
We also plan to fix the behavior in Python launch files, which have never scoped setting environment variables properly.

Related issues:

* `ros2#1244 <https://github.com/ros2/ros2/issues/1244>`_
* `launch#597 <https://github.com/ros2/launch/issues/597>`_

Fix launch frontend parser
^^^^^^^^^^^^^^^^^^^^^^^^^^

A refactor of the launch frontend parser fixed some `issues parsing special characters <https://github.com/ros2/launch_ros/issues/214>`_.
As a result, there has been a small behavior change when it comes to parsing strings.
For example, previously to pass a number as a string you would have to add extra quotation marks (two sets of quotation marks were needed if using a substitution):

.. code-block:: xml

   <!-- results in the string value ""'3'"" -->
   <param name=""foo"" value=""''3''""/>

After the refactor, the above will result in the the string ``""''3''""`` (note the extra set of quotation marks).
Now, users should use the ``type`` attribute to signal that the value should be interpreted as a string:

.. code-block:: xml

   <param name=""foo"" value=""3"" type=""str""/>

Related pull requests:

* `launch#530 <https://github.com/ros2/launch/pull/530>`_
* `launch_ros#265 <https://github.com/ros2/launch_ros/pull/265>`_

Fix memory leaks and undefined behavior in rmw_fastrtps_dynamic_cpp
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

API was changed in the following header files:

- ``rmw_fastrtps_dynamic_cpp/TypeSupport.hpp``
- ``rmw_fastrtps_dynamic_cpp/TypeSupport_impl.hpp``

Though technically they are publically accessible, it is unlikely people are using them directly.
Therefore, we decided to break API in order to fix memory leaks and undefined behavior.

The fix was originally submitted in `rmw_fastrtps#429 <https://github.com/ros2/rmw_fastrtps/pull/429>`_ and later backported to Foxy in `rmw_fastrtps#577 <https://github.com/ros2/rmw_fastrtps/pull/577>`_.

Changes in Patch Release 2 (2020-08-07)
---------------------------------------

Bug in static_transform_publisher
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
During the development of Foxy, a bug was introduced into the tf2_ros static_transform_publisher program.
The implementation of the order of the Euler angles passed to static_transform_publisher disagrees with the documentation.
Foxy patch release 2 `fixes <https://github.com/ros2/geometry2/pull/296>`_ the order so that the implementation agrees with the documentation (yaw, pitch, roll).
For users who have started using the initial Foxy release or patch release 1, this means that any launch files that use static_transform_publisher will have to have the command-line order swapped according to the new order.
For users who are coming from ROS 2 Dashing, ROS 2 Eloquent, or ROS 1, no changes need to be made to port to Foxy patch release 2.

Changes since the Eloquent release
----------------------------------

Classic CMake vs. modern CMake
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In ""classic"" CMake a package provides CMake variables like ``<pkgname>_INCLUDE_DIRS`` and ``<pkgname>_LIBRARIES`` when being ``find_package()``-ed.
With ``ament_cmake`` that is achieved by calling ``ament_export_include_directories`` and ``ament_export_libraries``.
In combination with ``ament_export_dependencies``, ``ament_cmake`` ensures that all include directories and libraries of recursive dependencies are concatenated and included in these variables.

In ""modern"" CMake a package provides an interface target instead (commonly named ``<pkgname>::<pkgname>``) which in itself encapsulates all recursive dependencies.
In order to export a library target to use modern CMake ``ament_export_targets`` needs to be called with an export name which is also used when installing the libraries using ``install(TARGETS <libA> <libB> EXPORT <export_name> ...)``.
The exported interface targets are available through the CMake variable ``<pkgname>_TARGETS``.
For library targets to be exportable like this they must not rely on classic functions affecting global state like ``include_directories()`` but set the include directories on the target itself - for the build as well as install environment - using generator expressions, e.g. ``target_include_directories(<target> PUBLIC ""$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/include>"" ""$<INSTALL_INTERFACE:include>"")``.

When ``ament_target_dependencies`` is used to add dependencies to a library target the function uses modern CMake targets when they are available.
Otherwise it falls back to using classic CMake variables.
As a consequence you should only export modern CMake targets if all dependencies are also providing modern CMake targets.
**Otherwise the exported interface target will contain the absolute paths to include directories / libraries in the generated CMake logic which makes the package non-relocatable.**

For examples how packages have been updated to modern CMake in Foxy see `ros2/ros2#904 <https://github.com/ros2/ros2/issues/904>`_.

ament_export_interfaces replaced by ament_export_targets
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The CMake function ``ament_export_interfaces`` from the package ``ament_cmake_export_interfaces`` has been deprecated in favor of the function ``ament_export_targets`` in the new package ``ament_cmake_export_targets``.
See the GitHub ticket `ament/ament_cmake#237 <https://github.com/ament/ament_cmake/issues/237>`_ for more context.

rosidl_generator_c|cpp namespace / API changes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The packages ``rosidl_generator_c`` and ``rosidl_generator_cpp`` have been refactored with many headers and sources moved into the new packages ``rosidl_runtime_c`` and ``rosidl_runtime_cpp``.
The intention is to remove run dependencies on the generator packages and therefore the code generation tools using Python.
While moving the headers the include paths / namespaces were updated accordingly so in many cases changing include directives from the generator package to the runtime package is sufficient.

The generated C / C++ code has also been refactored.
The files ending in ``__struct.h|hpp``, ``__functions.h``, ``__traits.hpp``, etc. have been moved into a subdirectory ``detail`` but most code only includes the header named after the interface without any of these suffixes.

Some types regarding string and sequence bounds have also been renamed to match the naming conventions but they aren't expected to be used in user code (above RMW implementation and type support packages)

For more information see `ros2/rosidl#446 (for C) <https://github.com/ros2/rosidl/issues/446>`_ and `ros2/rosidl#447 (for C++) <https://github.com/ros2/rosidl/issues/447>`_.

Default working directory for ament_add_test
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default working directory for tests added with ``ament_add_test`` has been changed to ``CMAKE_CURRENT_BINARY_DIR`` to match the behavior of CMake ``add_test``.
Either update the tests to work with the new default or pass ``WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}`` to restore the previous value.

Default Console Logging Format
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default console logging output format was changed to include the timestamp by default, see:

- `https://github.com/ros2/rcutils/pull/190 <https://github.com/ros2/rcutils/pull/190>`_
- `https://discourse.ros.org/t/ros2-logging-format/11549 <https://discourse.ros.org/t/ros2-logging-format/11549>`_

Default Console Logging Output Stream
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As of Foxy, all logging messages at all severity levels get logged to stderr by default.
This ensures that logging messages come out immediately, and brings the ROS 2 logging system into alignment with most other logging systems.
It is possible to change the stream to stdout at runtime via the RCUTILS_LOGGING_USE_STDOUT environment variable, but all logging messages will still go to the same stream.
See `https://github.com/ros2/rcutils/pull/196 <https://github.com/ros2/rcutils/pull/196>`_ for more details.

launch_ros
^^^^^^^^^^

Node name and namespace parameters changed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``Node`` action parameters related to naming have been changed:

- ``node_name`` has been renamed to ``name``
- ``node_namespace`` has been renamed to ``namespace``
- ``node_executable`` has been renamed to ``executable``
- ``exec_name`` has been added for naming the process associated with the node.
  Previously, users would have used the ``name`` keyword argument.

The old parameters have been deprecated.

These changes were made to make the launch frontend more idiomatic.
For example, instead of

.. code-block:: xml

   <node pkg=""demo_nodes_cpp"" exec=""talker"" node-name=""foo"" />

we can now write

.. code-block:: xml

   <node pkg=""demo_nodes_cpp"" exec=""talker"" name=""foo"" />

This change also applies to ``ComposableNodeContainer``, ``ComposableNode``, and ``LifecycleNode``.
For examples, see the `relevant changes to the demos. <https://github.com/ros2/demos/pull/431>`_

`Related pull request in launch_ros. <https://github.com/ros2/launch_ros/pull/122>`_

rclcpp
^^^^^^

Change in Advanced Subscription Callback Signature
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

With the pull request `https://github.com/ros2/rclcpp/pull/1047 <https://github.com/ros2/rclcpp/pull/1047>`_ the signature of callbacks which receive the message info with the message has changed.
Previously it used the ``rmw`` type ``rmw_message_info_t``, but now uses the ``rclcpp`` type ``rclcpp::MessageInfo``.
The required changes are straightforward, and can be seen demonstrated in these pull requests:

- `https://github.com/ros2/system_tests/pull/423/files <https://github.com/ros2/system_tests/pull/423/files>`_
- `https://github.com/ros2/rosbag2/pull/375/files <https://github.com/ros2/rosbag2/pull/375/files>`_
- `https://github.com/ros2/ros1_bridge/pull/253/files <https://github.com/ros2/ros1_bridge/pull/253/files>`_

Change in Serialized Message Callback Signature
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The pull request `ros2/rclcpp#1081 <https://github.com/ros2/rclcpp/pull/1081>`_ introduces a new signature of the callbacks for retrieving ROS messages in serialized form.
The previously used C-Struct `rcl_serialized_message_t <https://github.com/ros2/rmw/blob/foxy/rmw/include/rmw/serialized_message.h>`_ is being superseded by a C++ data type `rclcpp::SerializedMessage <https://github.com/ros2/rclcpp/blob/foxy/rclcpp/include/rclcpp/serialized_message.hpp>`_.

The example nodes in ``demo_nodes_cpp``, namely ``talker_serialized_message`` as well as ``listener_serialized_message`` reflect these changes.

Breaking change in Node Interface getters' signature
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

With pull request `ros2/rclcpp#1069 <https://github.com/ros2/rclcpp/pull/1069>`_, the signature of node interface getters has been modified to return shared ownership of node interfaces (i.e. an ``std::shared_ptr``) instead of a non-owning raw pointer.
Required changes in downstream packages that relied on the previous signature are simple and straightforward: use the ``std::shared_ptr::get()`` method.

Deprecate set_on_parameters_set_callback
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Instead, use the ``rclcpp::Node`` methods ``add_on_set_parameters_callback`` and ``remove_on_set_parameters_callback`` for adding and removing functions that are called when parameters are set.

Related pull request: https://github.com/ros2/rclcpp/pull/1123

Breaking change in Publisher getter signature
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

With pull request `ros2/rclcpp#1119 <https://github.com/ros2/rclcpp/pull/1119>`_, the signature of publisher handle getter has been modified to return shared ownership of the underlying rcl structure (i.e. an ``std::shared_ptr``) instead of a non-owning raw pointer.
This was necessary to fix a segfault in certain circumstances.
Required changes in downstream packages that relied on the previous signature are simple and straightforward: use the ``std::shared_ptr::get()`` method.

rclcpp_action
^^^^^^^^^^^^^

Deprecate ClientGoalHandle::async_result()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Using this API, it is possible to run into a race condition causing an exception to be thrown.
Instead, prefer to use ``Client::async_get_result()``, which is safer.

See `ros2/rclcpp#1120 <https://github.com/ros2/rclcpp/pull/1120>`_ and the connected issue for more info.

rclpy
^^^^^

Support for multiple on parameter set callbacks
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Use the ``Node`` methods ``add_on_set_parameters_callback`` and ``remove_on_set_parameters_callback`` for adding and removing functions that are called when parameters are set.

The method ``set_parameters_callback`` has been deprecated.

Related pull requests: https://github.com/ros2/rclpy/pull/457, https://github.com/ros2/rclpy/pull/504

rmw_connext_cpp
^^^^^^^^^^^^^^^

Connext 5.1 locator kinds compatibility mode
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Up to and including ``Eloquent``, ``rmw_connext_cpp`` was setting ``dds.transport.use_510_compatible_locator_kinds`` property to ``true``.
This property is not being forced anymore, and shared transport communication between ``Foxy`` and previous releases will stop working.
Logs similar to:

.. code-block:: bash

  PRESParticipant_checkTransportInfoMatching:Warning: discovered remote participant 'RTI Administration Console' using the 'shmem' transport with class ID 16777216.
  This class ID does not match the class ID 2 of the same transport in the local participant 'talker'.
  These two participants will not communicate over the 'shmem' transport.
  Check the value of the property 'dds.transport.use_510_compatible_locator_kinds' in the local participant.
  See https://community.rti.com/kb/what-causes-error-discovered-remote-participant for additional info.

will be observed when this incompatibility happens.

If compatibility is needed, it can be set up in an external QoS profiles files containing:

.. code-block:: xml

   <participant_qos>
      <property>
         <value>
               <element>
                  <name>
                     dds.transport.use_510_compatible_locator_kinds
                  </name>
                  <value>1</value>
               </element>
         </value>
      </property>
   </participant_qos>

Remember to set the ``NDDS_QOS_PROFILES`` environment variable to the QoS profiles file path.
For more information, see ``How to Change Transport Settings in 5.2.0 Applications for Compatibility with 5.1.0`` section of `Transport_Compatibility <https://community.rti.com/static/documentation/connext-dds/5.2.0/doc/manuals/connext_dds/html_files/RTI_ConnextDDS_CoreLibraries_ReleaseNotes/Content/ReleaseNotes/Transport_Compatibility.htm>`_.

rviz
^^^^

Tools timestamp messages using ROS time
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

'2D Pose Estimate', '2D Nav Goal', and 'Publish Point' tools now timestamp their messages using ROS time instead of system time, in order for the ``use_sim_time`` parameter to have an effect on them.

Related pull request: https://github.com/ros2/rviz/pull/519

std_msgs
^^^^^^^^

Deprecation of messages
""""""""""""""""""""""""""""""""""""""""""""""

Although discouraged for a long time we have officially deprecated the following messages in ``std_msgs``.
There are copies in `example_interfaces <https://index.ros.org/p/example_interfaces>`_

- ``std_msgs/msg/Bool``
- ``std_msgs/msg/Byte``
- ``std_msgs/msg/ByteMultiArray``
- ``std_msgs/msg/Char``
- ``std_msgs/msg/Float32``
- ``std_msgs/msg/Float32MultiArray``
- ``std_msgs/msg/Float64``
- ``std_msgs/msg/Float64MultiArray``
- ``std_msgs/msg/Int16``
- ``std_msgs/msg/Int16MultiArray``
- ``std_msgs/msg/Int32``
- ``std_msgs/msg/Int32MultiArray``
- ``std_msgs/msg/Int64``
- ``std_msgs/msg/Int64MultiArray``
- ``std_msgs/msg/Int8``
- ``std_msgs/msg/Int8MultiArray``
- ``std_msgs/msg/MultiArrayDimension``
- ``std_msgs/msg/MultiArrayLayout``
- ``std_msgs/msg/String``
- ``std_msgs/msg/UInt16``
- ``std_msgs/msg/UInt16MultiArray``
- ``std_msgs/msg/UInt32``
- ``std_msgs/msg/UInt32MultiArray``
- ``std_msgs/msg/UInt64``
- ``std_msgs/msg/UInt64MultiArray``
- ``std_msgs/msg/UInt8``
- ``std_msgs/msg/UInt8MultiArray``

Security features
^^^^^^^^^^^^^^^^^

Use of security enclaves
""""""""""""""""""""""""""""""""""""""""""""""""

As of Foxy, domain participants are no longer mapped directly to ROS nodes.
As a result, ROS 2 security features (which are specific to domain participants) are also no longer mapped directly to ROS nodes.
Instead, Foxy introduces the concept of a security ""enclave"", where an ""enclave"" is a process or group of processes that will share the same identity and access control rules.

This means that security artifacts are **not** retrieved based on the node name anymore but based on the Security enclave name.
A node enclave name can be set by using the ROS argument ``--enclave``, e.g. ``ros2 run demo_nodes_py talker --ros-args --enclave /my_enclave``

Related design document: https://github.com/ros2/design/pull/274

Note that permissions files are limited by the underlying transport packet size, so grouping many permissions under the same enclave will **not** work if the resulting permissions file exceed 64kB.
Related issue `[ros2/sros2#228] <https://github.com/ros2/sros2/issues/228>`_

Renaming of the environment variables
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. list-table:: Environment variables renaming
   :widths: 25 25
   :header-rows: 1

   * - Name in Eloquent
     - Name in Foxy
   * - ROS_SECURITY_ROOT_DIRECTORY
     - ROS_SECURITY_KEYSTORE
   * - ROS_SECURITY_NODE_DIRECTORY
     - ROS_SECURITY_ENCLAVE_OVERRIDE


Known Issues
------------

* `[ros2/ros2#922] <https://github.com/ros2/ros2/issues/922>`_ Services' performance is flaky for ``rclcpp`` nodes using eProsima Fast-RTPS or ADLINK CycloneDDS as RMW implementation.
  Specifically, service clients sometimes do not receive the response from servers.

* `[ros2/rclcpp#1212] <https://github.com/ros2/rclcpp/issues/1212>`_ Ready reentrant Waitable objects can attempt to execute multiple times.


Timeline before the release
---------------------------

A few milestones leading up to the release:

    .. note::

      The dates below reflect an extension by roughly two weeks due to the coronavirus pandemic.

    Wed. April 22nd, 2020
        API and feature freeze for ``ros_core`` [1]_ packages.
        Note that this includes ``rmw``, which is a recursive dependency of ``ros_core``.
        Only bug fix releases should be made after this point.
        New packages can be released independently.

    Mon. April 29th, 2020 (beta)
        Updated releases of ``desktop`` [2]_ packages available.
        Testing of the new features.

    Wed. May 27th, 2020 (release candidate)
        Updated releases of ``desktop`` [2]_ packages available.

    Wed. June 3rd, 2020
        Freeze rosdistro.
        No PRs for Foxy on the `rosdistro` repo will be merged (reopens after the release announcement).

.. [1] The ``ros_core`` variant described in the `variants <https://github.com/ros2/variants>`_ repository.
.. [2] The ``desktop`` variant described in the `variants <https://github.com/ros2/variants>`_ repository.
",What are the Tier 1 platforms supported by Foxy Fitzroy?
".. redirect-from::

  Release-Ardent-Apalone

Ardent Apalone (``ardent``)
===========================

.. contents:: Table of Contents
   :depth: 2
   :local:

Welcome to the first non-beta release of ROS 2 software named *Ardent Apalone*!

Supported Platforms
-------------------

This version of ROS 2 is supported on three platforms:


* Ubuntu 16.04 (Xenial)
* Mac macOS 10.12 (Sierra)
* Windows 10

Binary packages as well as instructions for how to compile from source are provided for all 3 platforms (see `install instructions <../../Installation>` as well as `documentation <https://docs.ros2.org/ardent/>`__).

Features
--------

New features in this ROS 2 release
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


* Distributed discovery, publish / subscribe, request / response communication

  * Provided by a C API
  * Implemented using different vendors:

    * eProsima's Fast RTPS as well as ADLINK's OpenSplice (from binary and source)
    * RTI's Connext (only from source)

  * Numerous quality of service settings for handling non-ideal networks
  * DDS Security support (with Connext and Fast RTPS)

* C++ and Python 3 client libraries

  * Sharing common code in C to unify the implementation
  * Execution model separated from the nodes, composable nodes
  * Node-specific parameters (only in C++ atm)
  * Life cycle (only in C++ atm)
  * Optionally intra-process communication using the same API (only in C++)

* Message definitions (with bounded arrays and strings as well as default values)
* Command line tools (e.g. ``ros2 run``)
* ``rviz`` with a few display types (the Windows version will likely follow in a few weeks)
* File system-based resource index (querying information without recursive crawling)
* Realtime safe code paths for pub / sub (with compatible DDS implementations only)
* Bridge between ROS 1 and ROS 2
* HSR demo `see Beta 3 <Beta3-Overview>`
* Turtlebot demo `see Beta 2 <Beta2-Overview>`

For a more detailed description please see the `Features <../../The-ROS2-Project/Features>` page.

Changes since Beta 3 release
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Improvements since the Beta 3 release:


* ``rviz``
* Different initialization options for message data structures in C++ (see `design doc <https://design.ros2.org/articles/generated_interfaces_cpp.html#constructors>`__)
* Logging API improvements, now also used in the demos
* Time support in C++ with different clocks
* wait-for-service support in the Python client library
* Draft implementation of `REP 149 <https://www.ros.org/reps/rep-0149.html>`__ specifying format 3 of the package manifest files

Known Issues
------------


* Fast RTPS performance with larger data like the image demo
* Using Connext it is currently not allowed for two topics with the same base name but different namespaces to have a different type (see `issue <https://github.com/ros2/rmw_connext/issues/234>`__).
* Listing of node names (e.g. using ``ros2 node list``) does not work across some rmw implementations.
* On Windows Python launch files might hang when trying to abort using ``Ctrl-C`` (see `issue <https://github.com/ros2/launch/issues/64>`__). In order to continue using the shell which is blocked by the hanging command you might want to end the hanging Python process using the process monitor.
",What are the three platforms supported by the Ardent Apalone release of ROS 2 software?
"Development process for a release
=================================

.. contents:: Table of Contents
   :depth: 2
   :local:

Each ROS 2 distribution goes through a process of development more than a year long that begins prior to the release of the previous distribution.
Below is a high-level view of this development process.
There is no specific due date for the items in this process, but in general earlier items should be completed before later items can be completed.

For the progress through this process for a specific release, see that release's documentation page.

.. list-table::
   :class: release-process
   :header-rows: 1
   :widths: 30 70

   * - Item
     - Notes
   * - Find the ROS Boss
     - The ""ROS Boss"" is the person in charge of shepherding a distribution through the development, release, update, and EOL'ing stages of its life. They are chosen from the internal ROS 2 team at Open Robotics.
   * - Run process to choose the distribution name
     - The ROS Boss curates the process of choosing the distribution's name, using input from sources such as the community and potential naming conflicts.
   * - Create distribution's documentation page
     - Every distribution has a documentation page that lists its vital statistics, such as planned release date, EOL date, and significant changes since the previous release.
   * - Set release timeline
     - The final weeks leading up to release day (usually, World Turtle Day) are hectic and full of deadlines, such as when to freeze the default RMW implementation. These deadlines must be planned well in advance.
   * - Produce roadmap
     - While every contributor to ROS has their own planned features for each distribution, we try to maintain an overall roadmap of the new features and significant changes we expect to see in the distribution. The ROS Boss and the leader of the ROS 2 development team at Open Robotics work together with the ROS 2 TSC and other interested parties to produce a roadmap that is achievable in the time available and meets the needs of the ROS community.
   * - Announce roadmap
     - The list of planned features and significant changes is made public, via a GitHub issue that will track the progress on developing each item in the roadmap. Of course, this does not mean that the roadmap is fixed at this point, as development plans can change and we always (and frequently do) welcome new contributions even if they are not on the planned roadmap.
   * - Set target platforms and major dependencies
     - The target platforms, in terms of operating system, distribution and version, must be set far enough in advance for development work on the infrastructure (such as support in the build farm) to proceed. Similarly, the versions of each major dependency (which Python version, which compiler(s), which version of Eigen, etc.) must also be fixed. This is done via an update to `REP-2000 <https://ros.org/reps/rep-2000.html>`__.
   * - Add platform support to the build farm
     - The build farm is a critical part of the infrastructure supporting a ROS 2 distribution. It provides continuous integration facilities that help us maintain quality, and it builds the binary packages the community relies on to avoid building ROS 2 and packages from source. If the target platforms differ from the previous ROS 2 distribution, then the necessary support must be added to the build farm.
   * - Commission logo and related artwork
     - A well-loved part of every ROS 2 distribution (and ROS distribution!) is the logo. The logo is commissioned from a professional artist based on the chosen distribution name. Based on the logo, other artwork such as the turtlesim icon are also produced.
   * - Create mailing list for the distribution
     - Vital for making critical announcements, a mailing list must be set up to contact people interested in knowing something about the distribution, such as that their package is failing to build into a binary on the build farm.
   * - Create test cases
     - As the development process enters the final few months, testing begins in earnest. The integration test cases that will be used during the final stages of development must be produced and provided to the release team who will be responsible for executing them.
   * - Announce upcoming RMW freeze
     - The RMW freeze is the point at which the default RMW implementation for the new distribution is feature-frozen. This gives developers a stable target to test their packages with, which is particularly important for the client library developers, who need to know what features of the RMW layer will be available for use by client libraries.
   * - Upgrade dependency packages
     - Packages depended on by ROS but not ROS software and not available in the platform package manager (such as aptitude for Ubuntu), the so-called ""vendor packages"", must be updated to the versions specified in REP-2000 (or an appropriate version, for those not listed in REP-2000). This is particularly important on Windows.
   * - Create a detailed release plan
     - Planning for the final two months of the development process is performed. This produces a detailed test plan, timelines of when certain packages must be available, and so on. It enables the finding of dependencies between steps in the release process and finding people to perform each of those steps.
   * - Freeze RMW
     - The RMW implementation is now feature-frozen. In theory, it can now be exhaustively tested to ensure it is working correctly by release day.
   * - Announce upcoming overall freeze
     - The next freeze after freezing the RMW implementation is to freeze the distribution as a whole. This is the point at which the core ROS packages become feature-frozen, giving developers of non-core packages a stable target to test their packages against, and giving distribution testers something to test that won't change right after they've tested it.
   * - Freeze distribution
     - From this point on, no new features can be added to any of the core ROS packages. Only bug fixes for the (inevitable) bugs found during the intensive integration test phases of development can be incorporated into the codebase. This means that Rolling Ridley is effectively frozen, temperarily.
   * - Announce upcoming branch
     - The branching of the new ROS 2 distribution from Rolling Ridley is an important moment. It is worth preparing for.
   * - Announce upcoming beta
     - When the distribution enters beta, it is ready for wider testing by the ROS community. This beta happens soon after the distribution is branched from Rolling Ridely.
   * - Branch from Rolling Ridley
     - The new ROS 2 distribution is created by making a new branch from Rolling Ridley. In effect, the new distribution is born at this point in time. Meanwhile, Rolling Ridley is free from the development process and can roll on into the future, once again receiving new features.
   * - Add distribution to CI
     - The continuous integration system is updated to allow building using the new distribution's branches and core ROS packages. This means that package developers can run CI for their packages against the new distribution, rather than Rolling Ridley.
   * - Begin building interim testing tarballs
     - The elite team of testers who will put the new distribution through its paces need something to test without compiling ROS 2 from source constantly. The build farm is used to produce a set of tarballs containing the distribution at a point in time for the testers to test.
   * - Add distribution documentation
     - Detailed documentation about the distribution, such as the significant changes since the previous distribution, is added to the ROS 2 documentation site.
   * - Announce beta
     - The beta release of the distribution is made and the ROS community as a whole is invited to contribute to testing it (for those who aren't already doing so). At this point, the more testers the better, because the distribution needs to be put through as wide a range of scenarios as possible to find bugs before the release.
   * - Final release preparations
     - As the new distribution enters is absolutely-completely-everything-frozen phase, the final preparations are made for the release. These include things like producing binary packages using the build farm so there will be something to release.
   * - Release
     - The big day, which if all goes to plan coincides with World Turtle Day on May 23rd. The distribution's binary packages are made available in the release repository, and an announcement is made. Parties are held and the ROS 2 development team takes a well-earned break.
","What is the role of the ""ROS Boss"" in the development process for a ROS 2 distribution release?"
".. _latest-release:

.. _jazzy-release:

Jazzy Jalisco (``jazzy``)
=========================

.. toctree::
   :hidden:

   Jazzy-Jalisco-Complete-Changelog

.. contents:: Table of Contents
   :depth: 2
   :local:

*Jazzy Jalisco* is the tenth release of ROS 2.
What follows is highlights of the important changes and features in Jazzy Jalisco since the last release.
For a list of all of the changes since Iron, see the :doc:`long form changelog <Jazzy-Jalisco-Complete-Changelog>`

Supported Platforms
-------------------

Jazzy Jalisco is primarily supported on the following platforms:

Tier 1 platforms:

* Ubuntu 24.04 (Noble): ``amd64`` and ``arm64``
* Windows 10 (Visual Studio 2019): ``amd64``

Tier 2 platforms:

* RHEL 9: ``amd64``

Tier 3 platforms:

* macOS: ``amd64``
* Debian Bookworm: ``amd64``

For more information about RMW implementations, compiler / interpreter versions, and system dependency versions see `REP 2000 <https://www.ros.org/reps/rep-2000.html>`__.

Installation
------------

`Install Jazzy Jalisco <../../jazzy/Installation.html>`__

Changes to how ROS 2 and Gazebo integrate
-----------------------------------------

Starting with Jazzy Jalisco, we are streamlining how ROS 2 and `Gazebo <https://gazebosim.org>`__ integrate.
For every ROS 2 release, there will be a recommended, supported Gazebo release that goes along with that release.
For Jazzy Jalisco, the recommended Gazebo release will be Harmonic.

To make it easier for ROS 2 packages to consume Gazebo packages, there are now ``gz_*_vendor`` packages.
Those packages are:

* gz_common_vendor: https://github.com/gazebo-release/gz_common_vendor
* gz_cmake_vendor: https://github.com/gazebo-release/gz_cmake_vendor
* gz_math_vendor: https://github.com/gazebo-release/gz_math_vendor
* gz_transport_vendor: https://github.com/gazebo-release/gz_transport_vendor
* gz_sensor_vendor: https://github.com/gazebo-release/gz_sensor_vendor
* gz_sim_vendor: https://github.com/gazebo-release/gz_sim_vendor
* gz_tools_vendor: https://github.com/gazebo-release/gz_tools_vendor
* gz_utils_vendor: https://github.com/gazebo-release/gz_utils_vendor
* sdformat_vendor: https://github.com/gazebo-release/sdformat_vendor

ROS 2 packages can use the functionality in these packages by adding dependencies in ``package.xml``, e.g.:

.. code::

   <depend>gz_math_vendor</depend>

And then using them in ``CMakeLists.txt``, e.g.:

.. code::

   find_package(gz_math_vendor REQUIRED)
   find_package(gz-math)

   add_executable(my_executable src/exe.cpp)
   target_link_libraries(my_executable gz-math::core)

.. note::

   It will still be possible to use alternate Gazebo versions with Jazzy Jalisco.  But those will not be as well tested or integrated with ROS 2.  See https://gazebosim.org/docs/harmonic/ros_installation for more information.

New features in this ROS 2 release
----------------------------------

``common_interfaces``
^^^^^^^^^^^^^^^^^^^^^

New VelocityStamped message
""""""""""""""""""""""""""""""""""""""""""""""""""""""

Added a new message with all fields needed to define a velocity and transform it.

See https://github.com/ros2/common_interfaces/pull/240 for more details.

Adds ARROW_STRIP to Marker.msg
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Added new type of Marker, ``ARROW_STRIP``, to Marker.msg.

See https://github.com/ros2/common_interfaces/pull/242 for more details.

``image_transport``
^^^^^^^^^^^^^^^^^^^

Support lazy subscribers
""""""""""""""""""""""""""""""""""""""""""""""""

See https://github.com/ros-perception/image_common/issues/272 for more details.

Expose option to set callback groups
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

See https://github.com/ros-perception/image_common/issues/274 for more details.

Enable allow list
""""""""""""""""""""""""""""""""""

Added parameter so users can selectively disable ``image_transport`` plugins at runtime.

See https://github.com/ros-perception/image_common/issues/264 for more details.

Advertise and subscribe with custom QoS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Allow users to pass in a custom quality-of-service when creating ``image_transport`` publishers and subscribers.

See https://github.com/ros-perception/image_common/issues/288 for more detatils.

Added rclcpp component to Republish
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Users can now start the ``image_transport`` republisher node as an rclcpp_component.

See https://github.com/ros-perception/image_common/issues/275 for more details.


``message_filters``
^^^^^^^^^^^^^^^^^^^

TypeAdapters support
""""""""""""""""""""""""""""""""""""""""

Allows users to use Type Adaptation within message_filters.

See https://github.com/ros2/message_filters/pull/96 for more information.

``rcl``
^^^^^^^

Add get type description service
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Implements the ``~/get_type_description`` service which allows external users to get descriptions of each type that a node offers.
This is offered by each node according to `REP 2016 <https://github.com/ros-infrastructure/rep/pull/381>`__.

See https://github.com/ros2/rcl/pull/1052 for more details.

``rclcpp``
^^^^^^^^^^

Type support helper for services
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

New type support helper for services ``rclcpp::get_service_typesupport_handle`` is added to extract service type support handle.

See https://github.com/ros2/rclcpp/pull/2209 for more details.

``rclpy``
^^^^^^^^^^

ParameterEventHandler
""""""""""""""""""""""""""""""""""""""""""

New class ``ParameterEventHandler`` allows us to monitor and respond changes to parameters via parameter events.

See https://github.com/ros2/rclpy/pull/1135 for more details.

``ros2cli``
^^^^^^^^^^^

Added a ``--log-file-name`` command line argument
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to use ``--log-file-name`` command line argument to specify the log file name prefix.

.. code-block:: bash

   ros2 run demo_nodes_cpp talker --ros-args --log-file-name filename

See https://github.com/ros2/ros2cli/issues/856 for more information.

Added QoS to subscription options
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

A user-settable QoS parameter was added to the ``TopicStatisticsOptions``, which allows the statistics to have a different QoS from the subscription itself.

See https://github.com/ros2/rclcpp/pull/2323 for more details.

Add clients and services count
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to get the number of clients created by a service.

``ros2action``
^^^^^^^^^^^^^^

``type`` sub-command supported
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to use the ``type`` sub-command to check the action type.

.. code-block:: bash

   ros2 action type /fibonacci
   action_tutorials_interfaces/action/Fibonacci

See https://github.com/ros2/ros2cli/pull/894 for more information.

``rosbag2``
^^^^^^^^^^^

Service recording and playback
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to record and play service data with the ``ros2bag`` command line interface.

This features builds on `Service Introspection <https://github.com/ros2/ros2/issues/1285>`__, which has been available since Iron Irwini.
`Service recording and display <https://github.com/ros2/rosbag2/pull/1480>`__ adds the ability to record service data into a bag file.
And `Service playback <https://github.com/ros2/rosbag2/pull/1481>`__ can play that service data from the bag file.

Record all services data:

.. code-block:: bash

   ros2 bag record --all-services

Record all services and all topic data:

.. code-block:: bash

   ros2 bag record --all

Play service data from bag file:

.. code-block:: bash

   ros2 bag play --publish-service-requests bag_path

See the `design document <https://github.com/ros2/rosbag2/blob/rolling/docs/design/rosbag2_record_replay_service.md>`__ for more information.

New filter modes
""""""""""""""""""""""""""""""""

It is now possible to filter by topic type.

.. code-block:: bash

    ros2 bag record --topic_types sensor_msgs/msg/Image sensor_msgs/msg/CameraInfo

.. code-block:: bash

    ros2 bag record --topic_types sensor_msgs/msg/Image

See more details https://github.com/ros2/rosbag2/pull/1577 and https://github.com/ros2/rosbag2/pull/1582.

Player and Recorder are now exposed as rclcpp components
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

This allows a ""zero-copy"" when using intra-process communication during data record or reply.
This can significantly reduce CPU load during recording or reply when dealing with high-bandwidth data streams and will help to avoid data loss in the transport layer.
It also provides the ability to use YAML configuration files for ``rosbag2_transport::Player`` and ``rosbag2_transport::Recorder`` composable nodes.

See https://github.com/ros2/rosbag2/tree/jazzy?tab=readme-ov-file#using-with-composition for more details.

Added option to disable recorder keyboard controls
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

See https://github.com/ros2/rosbag2/pull/1607 for more details.

Use middleware send and receive timestamps from ``message_info`` during recording
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Where available, ``rosbag2`` now uses the send and receive timestamps as provided by the middleware.
These timestamps are more indicative of when the data was actually sent and received, respectively.
Note that saving the timestamp into a bag is currently only supported for MCAP files (the default).

See https://github.com/ros2/rosbag2/pull/1531 for more details.

Added compression threads priority to record options
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to specify the priority of the thread that performs compression.

See https://github.com/ros2/rosbag2/pull/1457 for more details.

Added ability to split already existing ros2 bags by time
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Added ``start_time_ns`` and ``end_time_ns`` to the ``StorageOptions`` to exclude messages not in
``[start_time;end_time]`` during the ``ros2 bag convert`` operation.

See https://github.com/ros2/rosbag2/pull/1455 for more details.

Store serialized metadata in bag files directly
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``rosbag2`` has always stored metadata in the ``metadata.yaml`` file associated with a bag file.
Now the metadata is also stored in each bag file, once when opening the file and a second time when closing the written bag file.
This allows bag files to be self-contained, and used without the ``metadata.yaml`` file in the rosbag2 player or third-party applications.
``ros2 bag reindex`` can still be used to restore the ``metadata.yaml`` file, if desired.

Store ROS_DISTRO name in the metadata
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

See https://github.com/ros2/rosbag2/pull/1241 for more details.

Added introspection QoS methods to Python bindings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to instrospect QoS setting from Python bindings.

See https://github.com/ros2/rosbag2/pull/1648 for more details.

``rosidl``
^^^^^^^^^^

Added interfaces to support key annotation
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``key`` annotation allows indicating that a data member is part of the key, which can have zero or more key fields and can be applied to structure fields of various types.

See https://github.com/ros2/rosidl/pull/796 and https://github.com/ros2/rosidl_typesupport_fastrtps/pull/116 for more details.

``rviz2``
^^^^^^^^^

Added regex filter field for TF display
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

When there are many frames on ``/tf`` it can be hard to properly visualize them in RViz, especially if frames overlap.
The usual solution to this is to enable and disable desired frames in Frames field of the TF display.
Now it is possible to filter frames using regular expressions.

See https://github.com/ros2/rviz/pull/1032 for more details.

Append measured subscription frequency to topic status
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is possible to visualize Hz in the topic status widget.

See https://github.com/ros2/rviz/issues/1113 for more details.

Reset functionality
""""""""""""""""""""""""""""""""""""""

It is possible to reset Time using a new service or using the keyboard shortcut ``R``.

See https://github.com/ros2/rviz/issues/1109 and https://github.com/ros2/rviz/issues/1088 for more details.

Added support for point_cloud_transport
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is possible to subscribe to point clouds using the ``point_cloud_transport`` package.

See https://github.com/ros2/rviz/pull/1008 for more details.

Feature parity with RViz for ROS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is possible to use the same plugins available in the ROS 1 version.

* DepthCloud
* AccelStamped
* TwistStamped
* WrenchStamped
* Effort

Camera info display
""""""""""""""""""""""""""""""""""""""

It is possible to visualize CameraInfo messages in the 3D scene.

See https://github.com/ros2/rviz/pull/1166 for more details.

``rcpputils``
^^^^^^^^^^^^^

Added tl_expected
""""""""""""""""""""""""""""""""""

`std::expected <https://en.cppreference.com/w/cpp/utility/expected>`__ is C++23 feature, which is not yet supported in ROS 2.
However, it is possible to use ``tl::expected`` from rcpputils via a backported implementation.

See https://github.com/ros2/rcpputils/pull/185 for more details.

``rcutils``
^^^^^^^^^^^

Add human readable date to logging formats
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to output dates in a human readable format when using console logging by using the ``{date_time_with_ms}`` token in the ``RCUTILS_CONSOLE_OUTPUT_FORMAT`` environment variable.

See https://github.com/ros2/rcutils/pull/441 for more details.

Changes since the Iron release
------------------------------

``common_interfaces``
^^^^^^^^^^^^^^^^^^^^^

Added IDs to geometry_msgs/Polygon and PolygonStamped
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Polygons are often used to represent specific objects but are difficult to rectify currently without any kind of specific identification.
This feature adds an ID field to disambiguate polygons.

See https://github.com/ros2/common_interfaces/pull/232 for more details.


``geometry2``
^^^^^^^^^^^^^

Removed deprecated headers
""""""""""""""""""""""""""""""""""""""""""""""""""""

In Humble, the headers: ``tf2_bullet/tf2_bullet.h``, ``tf2_eigen/tf2_eigen.h``, ``tf2_geometry_msgs/tf2_geometry_msgs.h``,
``tf2_kdl/tf2_kdl.h``, ``tf2_sensor_msgs/tf2_sensor_msgs.h``  were deprecated in favor of: ``tf2_bullet/tf2_bullet.hpp``,
``tf2_eigen/tf2_eigen.hpp``, ``tf2_geometry_msgs/tf2_geometry_msgs.hpp``, ``tf2_kdl/tf2_kdl.hpp``, ``tf2_sensor_msgs/tf2_sensor_msgs.hpp``
In Jazzy, the ``tf2_bullet/tf2_bullet.h``, ``tf2_eigen/tf2_eigen.h``, ``tf2_geometry_msgs/tf2_geometry_msgs.h``,
``tf2_kdl/tf2_kdl.h``, ``tf2_sensor_msgs/tf2_sensor_msgs.h`` headers have been completely removed.

Changed return types of ``wait_for_transform_async`` and ``wait_for_transform_full_async``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Previously ``wait_for_transform_async`` and ``wait_for_transform_full_async`` of the ``Buffer`` class returned a future containing true or false
In Jazzy, the future will contain the information of the transform being waited on.

Enabled Twist interpolator
""""""""""""""""""""""""""""""""""""""""""""""""""""

Included new API to lookup the velocity of the moving frame in the reference frame.

See https://github.com/ros2/geometry2/pull/646 for more information.

``rcl``
^^^^^^^

Actual and expected call time when timer is called
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

New timer API ``rcl_timer_call_with_info`` is added to collect actual and expected call time when the timer is called.
This allows users to get the timer information when the timer is expected to be called and actual time that timer is called.

See https://github.com/ros2/rcl/pull/1113 for more details.

Improved rcl_wait in the area of timeout computation and spurious wakeups
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Added special handling for timers with a clock that has time override enabled.
For these timer we should not compute a timeout, as the waitset is woken up by the associated guard condition.

See https://github.com/ros2/rcl/issues/1146 for more details.

``rclcpp``
^^^^^^^^^^

Fixed data race conditions
""""""""""""""""""""""""""""""""""""""""""""""""""""

Fixed data race conditions in executors.

See https://github.com/ros2/rclcpp/issues/2500 for more details.

Utilize ``rclcpp::WaitSet`` as part of the executors
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Improve the number of ``rcl_wait_set`` creations and deletions by making the default Single/Multithreaded executors work like the static single threaded executor
in terms of entity collection rebuilding.

See https://github.com/ros2/rclcpp/pull/2142 for more details.

Due to this change, callbacks in the executor are no longer ordered consistently, even within the same entity.

See https://github.com/ros2/rclcpp/issues/2532 for more details.

``rclcpp::get_typesupport_handle`` is deprecated
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``rclcpp::get_typesupport_handle`` that extracts message type support handle is deprecated, and will be removed in a future release.
Instead, ``rclcpp::get_message_typesupport_handle`` should be used.

See https://github.com/ros2/rclcpp/pull/2209 for more details.

Deprecated ``rclcpp/qos_event.hpp`` header was removed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

In Iron, the header ``rclcpp/qos_event.hpp`` was deprecated in favor of ``rclcpp/event_handler.hpp``.
In Jazzy, the ``rclcpp/qos_event.hpp`` header has been completely removed.

Deprecated subscription callback signatures were removed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Back in Humble, subscription signatures of the form ``void callback(std::shared_ptr<MessageT>)`` and ``void callback(std::shared_ptr<MessageT>, const rclcpp::MessageInfo &)`` were deprecated.

In Jazzy, these subscription signatures have been removed.
Users should switch to using ``void callback(std::shared_ptr<const MessageT>)`` or ``void callback(std::shared_ptr<const MessageT>, const rclcpp MessageInfo &)``.

Actual and expected call time when timer is called
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``rclcpp::TimerInfo`` argument is added to the timer callback to collect actual and expected call time when the timer is called.
This allows users to get the timer information when the timer is expected to be called and actual time that timer is called.

See https://github.com/ros2/rclcpp/pull/2343 for more details.

``rclcpp_action``
^^^^^^^^^^^^^^^^^

Callback after cancel
""""""""""""""""""""""""""""""""""""""""""

Added a function to stop callbacks of a goal handle after it has gone out of scope.
This function allows us to drop the handle in a locked context.

See https://github.com/ros2/rclcpp/pull/2281 for more details.

``rclcpp_lifecycle``
^^^^^^^^^^^^^^^^^^^^

Add new node interface TypeDescriptionsInterface
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Add new node interface ``TypeDescriptionsInterface`` to provide the ``GetTypeDescription`` service.

See https://github.com/ros2/rclcpp/pull/2224 for more details.

``rclpy``
^^^^^^^^^

``rclpy.node.Node.declare_parameter``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``rclpy.node.Node.declare_parameter`` does not allow statically typing parameter without a default value.

See https://github.com/ros2/rclpy/pull/1216 for more details.

Added types to method arguments
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Added type checking to improve the experience for anyone using static type checking.

See https://github.com/ros2/rclcpp/pull/2224, https://github.com/ros2/rclpy/issues/1240, https://github.com/ros2/rclpy/issues/1237, https://github.com/ros2/rclpy/issues/1231, https://github.com/ros2/rclpy/issues/1241, and https://github.com/ros2/rclpy/issues/1233.

``rosbag2``
^^^^^^^^^^^

Rename of the ``--exclude`` CLI option
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``--exclude`` CLI option was renamed to the ``--exclude-regex`` to better reflect what it does.

See https://github.com/ros2/rosbag2/pull/1480 for more information.

Changes in representation of the ``offered_qos_profiles``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Enum values are now used for ``offered_qos_profiles`` in the code, in human-readable string values for QoS settings in the metadata, and in the overriding QoS profile YAML files.

See https://github.com/ros2/rosbag2/tree/jazzy?tab=readme-ov-file#overriding-qos-profiles for an example.

Added node name to the read and write bag split event messages
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

See https://github.com/ros2/rosbag2/pull/1609 for more details.

Added ``BagSplitInfo`` service call on bag close
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

See https://github.com/ros2/rosbag2/pull/1422 for more details.

Resolved multiple issues related to the handling SIGINT and SIGTERM signals in rosbag2
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

See https://github.com/ros2/rosbag2/pull/1557, https://github.com/ros2/rosbag2/pull/1301 and
https://github.com/ros2/rosbag2/pull/1464 for more details.

Added ``topic_id`` returned by storage to the ``TopicMetadata``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

See https://github.com/ros2/rosbag2/pull/1538 for more details.

Added Python bindings for CompressionOptions and CompressionMode structures
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

See https://github.com/ros2/rosbag2/pull/1425 for more details.

Improve performance in ``SqliteStorage::get_bagfile_size()``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

This minimizes the probability of losing messages during bag split operation when recording with the SQLite3 storage plugin.

See https://github.com/ros2/rosbag2/pull/1516 for more details.

``rqt_bag``
^^^^^^^^^^^

Improved performance and updated rosbag API
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

There are some breaking changes in the rosbag2 API and Ubuntu Noble library versions that required some changes to ``rqt_bag``.

See https://github.com/ros-visualization/rqt_bag/pull/156 for more details.

Development progress
--------------------

For progress on the development of Jazzy Jalisco, see `this project board <https://github.com/orgs/ros2/projects/52>`__.

For the broad process followed by Jazzy Jalisco, see the :doc:`process description page <Release-Process>`.

Known Issues
------------

To come.

Release Timeline
----------------

    November, 2023 - Platform decisions
        REP 2000 is updated with the target platforms and major dependency versions.

    By January, 2024 - Rolling platform shift
        Build farm is updated with the new platform versions and dependency versions for Jazzy Jalisco.

    Mon. April 8, 2024 - Alpha + RMW freeze
        Preliminary testing and stabilization of ROS Base [1]_ packages, and API and feature freeze for RMW provider packages.

    Mon. April 15, 2024 - Freeze
        API and feature freeze for ROS Base [1]_ packages in Rolling Ridley.
        Only bug fix releases should be made after this point.
        New packages can be released independently.

    Mon. April 22, 2024 - Branch
        Branch from Rolling Ridley.
        ``rosdistro`` is reopened for Rolling PRs for ROS Base [1]_ packages.
        Jazzy development shifts from ``ros-rolling-*`` packages to ``ros-jazzy-*`` packages.

    Mon. April 29, 2024 - Beta
        Updated releases of ROS Desktop [2]_ packages available.
        Call for general testing.

    Wed, May 1, 2024 - Kick off of Tutorial Party
        Tutorials hosted at https://github.com/osrf/ros2_test_cases are open for community testing.

    Mon. May 13, 2024 - Release Candidate
        Release Candidate packages are built.
        Updated releases of ROS Desktop [2]_ packages available.

    Mon. May 20, 2024 - Distro Freeze
        Freeze all Jazzy branches on all `ROS 2 desktop packages <https://www.ros.org/reps/rep-2001.html#jazzy-jalisco-may-2024-may-2029>`__ and ``rosdistro``.
        No pull requests for any ``jazzy`` branch or targeting ``jazzy/distribution.yaml`` in ``rosdistro`` repo will be merged.

    Thu. May 23, 2024 - General Availability
        Release announcement.
        `ROS 2 desktop packages <https://www.ros.org/reps/rep-2001.html#jazzy-jalisco-may-2024-may-2029>`__ source freeze is lifted and ``rosdistro`` is reopened for Jazzy pull requests.

.. [1] The ``ros_base`` variant is described in `REP 2001 (ros-base) <https://www.ros.org/reps/rep-2001.html#ros-base>`_.
.. [2] The ``desktop`` variant is described in `REP 2001 (desktop-variants) <https://www.ros.org/reps/rep-2001.html#desktop-variants>`_.
",What changes were made to the ROS 2 and Gazebo integration starting with the Jazzy Jalisco release?
"Development Distribution
========================

Below is the ROS 2 distribution that is currently in development.

.. toctree::
   :maxdepth: 1

   Release-Kilted-Kaiju
",What is the name of the ROS 2 distribution currently in development?
".. redirect-from::

  Release-Crystal-Clemmys

Crystal Clemmys (``crystal``)
=============================

.. contents:: Table of Contents
   :depth: 2
   :local:

*Crystal Clemmys* is the third release of ROS 2.

Supported Platforms
-------------------

Crystal Clemmys is primarily supported on the following platforms (see `REP 2000 <https://www.ros.org/reps/rep-2000.html#crystal-clemmys-december-2018-december-2019>`__ for full details):

Tier 1 platforms:

* Ubuntu 18.04 (Bionic)
* Mac macOS 10.12 (Sierra)
* Windows 10

Tier 2 platforms:

* Ubuntu 16.04 (Xenial)


New features in this ROS 2 release
----------------------------------

* Actions in C / C++ (`server <https://github.com/ros2/examples/tree/af08e6f7ac50f7808dbe6165f1adfd8e6cd3a79c/rclcpp/minimal_action_server>`__ / `client <https://github.com/ros2/examples/tree/af08e6f7ac50f7808dbe6165f1adfd8e6cd3a79c/rclcpp/minimal_action_client>`__ examples)
* `gazebo_ros_pkgs <http://gazebosim.org/tutorials?tut=ros2_overview>`__
* `image_transport <https://github.com/ros-perception/image_common/wiki/ROS2-Migration>`__
* `navigation2 <https://github.com/ros-planning/navigation2/blob/master/README.md>`__
* `rosbag2 <https://index.ros.org/r/rosbag2/github-ros2-rosbag2/#crystal>`__
* `rqt <../../Concepts/Intermediate/About-RQt>`
* Improvement in memory management
* Introspection information about nodes
* Launch system improvements

  * `Arguments <https://github.com/ros2/launch/pull/123>`__
  * `Nested launch files <https://github.com/ros2/launch/issues/116>`__
  * `Conditions <https://github.com/ros2/launch/issues/105>`__
  * `Pass params to Nodes <https://github.com/ros2/launch/issues/117>`__

* Laid the groundwork for `file-based logging and /rosout publishing <https://github.com/ros2/rcl/pull/327>`__
* `Time and Duration API in Python <https://github.com/ros2/rclpy/issues/186>`__
* `Parameters work with Python nodes <https://github.com/ros2/rclpy/issues/202>`__


Changes since the Bouncy release
--------------------------------

Changes since the `Bouncy Bolson <Release-Bouncy-Bolson>` release:

* geometry2 - ``tf2_ros::Buffer`` API Change

  ``tf2_ros::Buffer`` now uses ``rclcpp::Time``, with the constructor requiring a ``shared_ptr`` to a ``rclcpp::Clock`` instance.
  See https://github.com/ros2/geometry2/pull/67 for details, with example usage:

  .. code-block:: c++

    #include <tf2_ros/transform_listener.h>
    #include <rclcpp/rclcpp.hpp>
    ...
    # Assuming you have a rclcpp::Node my_node
    tf2_ros::Buffer buffer(my_node.get_clock());
    tf2_ros::TransformListener tf_listener(buffer);

* All ``rclcpp`` and ``rcutils`` logging macros require semicolons.

  See https://github.com/ros2/rcutils/issues/113 for details.

* ``rcutils_get_error_string_safe()`` and ``rcl_get_error_string_safe()`` have been replaced with ``rcutils_get_error_string().str`` and ``rcl_get_error_string().str``.

  See https://github.com/ros2/rcutils/pull/121 for details.

* rmw - ``rmw_init`` API Change

  There are two new structs, the ``rcl_context_t`` and the ``rcl_init_options_t``, which are used with ``rmw_init``.
  The init options struct is used to pass options down to the middleware and is an input to ``rmw_init``.
  The context is a handle which is an output of ``rmw_init`` function is used to identify which init-shutdown cycle each entity is associated with, where an ""entity"" is anything created like a node, guard condition, etc.

  This is listed here because maintainers of alternative rmw implementations will need to implement these new functions to have their rmw implementation work in Crystal.

  This is the function that had a signature change:

  * `rmw_init <https://github.com/ros2/rmw/blob/b7234243588a70fce105ea20b073f5ef6c1b685c/rmw/include/rmw/init.h#L54-L82>`__

  Additionally, there are these new functions which need to be implemented by each rmw implementation:

  * `rmw_shutdown <https://github.com/ros2/rmw/blob/b7234243588a70fce105ea20b073f5ef6c1b685c/rmw/include/rmw/init.h#L84-L109>`__
  * `rmw_init_options_init <https://github.com/ros2/rmw/blob/b7234243588a70fce105ea20b073f5ef6c1b685c/rmw/include/rmw/init_options.h#L62-L92>`__
  * `rmw_init_options_copy <https://github.com/ros2/rmw/blob/b7234243588a70fce105ea20b073f5ef6c1b685c/rmw/include/rmw/init_options.h#L94-L128>`__
  * `rmw_init_options_fini <https://github.com/ros2/rmw/blob/b7234243588a70fce105ea20b073f5ef6c1b685c/rmw/include/rmw/init_options.h#L130-L153>`__

  Here's an example of what minimally needs to be changed in an rmw implementation to adhere to this API change:

  * `rmw_fastrtps pr <https://github.com/ros2/rmw_fastrtps/pull/237/files>`_

* rcl - ``rcl_init`` API Change

  Like the ``rmw`` change above, there's two new structs in ``rcl`` called ``rcl_context_t`` and ``rcl_init_options_t``.
  The init options are passed into ``rcl_init`` as an input and the context is passed in as an output.
  The context is used to associate all other rcl entities to a specific init-shutdown cycle, effectively making init and shutdown no longer global functions, or rather those functions no longer use an global state and instead encapsulate all state within the context type.

  Any maintainers of a client library implementation (that also uses ``rcl`` under the hood) will need to make changes to work with Crystal.

  These functions were removed:

  * ``rcl_get_global_arguments``
  * ``rcl_get_instance_id``
  * ``rcl_ok``

  These functions had signature changes:

  * `rcl_init <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/init.h#L30-L82>`__
  * `rcl_shutdown <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/init.h#L84-L111>`__
  * `rcl_guard_condition_init <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/guard_condition.h#L54-L99>`__
  * `rcl_guard_condition_init_from_rmw <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/guard_condition.h#L101-L140>`__
  * `rcl_node_init <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/node.h#L100-L194>`__
  * `rcl_timer_init <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/timer.h#L64-L159>`__

  These are the new functions and types:

  * `rcl_context_t <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/context.h#L36-L136>`__
  * `rcl_get_zero_initialized_context <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/context.h#L138-L142>`__
  * `rcl_context_fini <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/context.h#L146-L171>`__
  * `rcl_context_get_init_options <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/context.h#L175-L205>`__
  * `rcl_context_get_instance_id <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/context.h#L207-L233>`__
  * `rcl_context_is_valid <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/context.h#L235-L255>`__
  * `rcl_init_options_t <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/init_options.h#L32-L37>`__
  * `rcl_get_zero_initialized_init_options <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/init_options.h#L39-L43>`__
  * `rcl_init_options_init <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/init_options.h#L45-L73>`__
  * `rcl_init_options_copy <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/init_options.h#L75-L105>`__
  * `rcl_init_options_fini <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/init_options.h#L107-L128>`__
  * `rcl_init_options_get_rmw_init_options <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/init_options.h#L130-L153>`__
  * `rcl_node_is_valid_except_context <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/node.h#L288-L299>`__
  * `rcl_publisher_get_context <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/publisher.h#L378-L404>`__
  * `rcl_publisher_is_valid_except_context <https://github.com/ros2/rcl/blob/657d9e84c73e4268176efd163e96fda73c1a76d9/rcl/include/rcl/publisher.h#L428-L439>`__

  These new and changed functions will impact how you handle init and shutdown in your client library.
  For examples, look at the following ``rclcpp`` and ``rclpy`` PR's:

  * `rclcpp <https://github.com/ros2/rclcpp/pull/587>`__
  * `rclpy <https://github.com/ros2/rclpy/pull/249>`__

  However, you may just continue to offer a single, global init and shutdown in your client library, and just store a single global context object.

Known Issues
------------

* A race condition in Fast-RTPS 1.7.0 may cause messages to drop under stress (`Issue <https://github.com/ros2/rmw_fastrtps/issues/258>`__).
* Using the TRANSIENT_LOCAL QoS setting with rmw_fastrtps_cpp can crash applications with large messages (`Issue <https://github.com/ros2/rmw_fastrtps/issues/257>`__).
* Cross-vendor communication between rmw_fastrtps_cpp and other implementations is not functioning on Windows (`Issue <https://github.com/ros2/rmw_fastrtps/issues/246>`__).
* When using OpenSplice (version < 6.9.190227) on macOS and Windows you might experience naming conflicts when when referencing field types with names from other packages if the same name also exist in the current package (`Issue <https://github.com/ros2/rmw_opensplice/issues/259>`__).
  By updating to a newer OpenSplice version as well as at least the third patch release of Crystal the problem should be resolved.
  On Linux updating to the latest Debian packages will include the newest OpenSplice version.
",What are the Tier 1 platforms supported by the Crystal Clemmys release of ROS 2?
"Rolling Ridley (``rolling``)
============================

.. contents:: Table of Contents
   :depth: 2
   :local:

*Rolling Ridley* is a rolling development release of ROS 2.

.. warning::

  Rolling Ridley is continuously updated and is subject to in-place updates which will at times include breaking changes.
  It is used for ROS 2 development and by maintainers who want their packages released and ready for the next stable distribution.
  We recommend that most users of ROS 2 use the latest `stable distribution <latest-release>`.

For more information see `REP-2002 <https://www.ros.org/reps/rep-2002.html>`_

Currently Supported Platforms
-----------------------------

Rolling Ridley is currently supported on the following platforms:

Tier 1 platforms:

* Ubuntu 24.04 (Noble): ``amd64`` and ``arm64``
* Windows 10 (Visual Studio 2019)

Tier 3 platforms:

* Debian Buster (10): ``amd64``, ``arm64`` and ``arm32``
* Mac macOS 10.14 (Mojave)
* OpenEmbedded Thud (2.6) / webOS OSE: ``arm32`` and ``x86``

Installation
------------

`Install Rolling Ridley <../../Installation>`

New features and changes in this release
----------------------------------------

Rolling Ridley is an ongoing development distribution.
Changes between the current stable release and the upcoming one can be found on the page for the `upcoming release <upcoming-release>`.
",What caution is given regarding the use of Rolling Ridley in ROS 2 development?
".. _upcoming-release:

.. _kilted-release:

Kilted Kaiju (codename 'kilted'; May, 2025)
===========================================

.. contents:: Table of Contents
   :depth: 2
   :local:

*Kilted Kaiju* is the eleventh release of ROS 2.
What follows is highlights of the important changes and features in Kilted Kaiju since the last release.

Supported Platforms
-------------------

Kilted Kaiju is primarily supported on the following platforms:

Tier 1 platforms:

* TODO

Tier 2 platforms:

* TODO

Tier 3 platforms:

* TODO

For more information about RMW implementations, compiler / interpreter versions, and system dependency versions see `REP 2000 <https://www.ros.org/reps/rep-2000.html>`__.

Installation
------------

TODO

New features in this ROS 2 release
----------------------------------

Development progress
--------------------

For progress on the development of Kiltled Kaiju, see `this project board <https://github.com/orgs/ros2/projects/63>`__.

For the broad process followed by Kilted Kaiju, see the :doc:`process description page <Release-Process>`.
",What is the code name of the eleventh release of ROS 2 mentioned in the text?
".. redirect-from::

  Beta3-Overview

Beta 3 (``r2b3``)
=================

.. contents:: Table of Contents
   :depth: 2
   :local:

Supported Platforms
-------------------

We support ROS 2 Beta 3 on three platforms: Ubuntu 16.04 (Xenial), macOS 10.12 (Sierra), and Windows 10.
We provide both binary packages and instructions for how to compile from source for all 3 platforms (see `install instructions <../../Installation>` as well as `documentation <https://docs.ros2.org/beta3/>`__).

Features
--------

Improvements since Beta 2 release
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* Execution model in Python, many fixes to memory management in Python C extension
* Experimental rewrite of `ros_control <https://github.com/ros2/ros2_control>`__
* Exposure of DDS implementation-specific symbols to users (for Fast RTPS and Connext) (see `example <https://github.com/ros2/demos/blob/6363be2efe2fea799d92bc22a66e776b2ca9c5d0/demo_nodes_cpp_native/src/talker.cpp>`__)
* Logging `API <https://github.com/ros2/rclpy/blob/1ef2924ef8e154c0553edf0fdba4840b08b728f8/rclpy/rclpy/logging.py>`__ in Python
* Fixed several memory leaks and race conditions in various packages
* Readded support for OpenSplice (on Linux and Windows atm) provided by PrismTech
* Use bloom (without patches) to make ROS 2 releases

New demo application
^^^^^^^^^^^^^^^^^^^^

* `HSR demo <https://github.com/ruffsl/hsr_demo>`__

  * Remote control a HSR robot using a ROS 2 joystick controller
  * Running the ``ros1_bridge`` in a Docker container on the HSR (since the robot is running ROS 1 on Ubuntu Trusty)
  * Run a ROS 2 development version of `rviz <https://github.com/ros2/rviz>`__ to visualize sensor data from the robot etc. (see `video <https://vimeo.com/237016358>`__)

Selected features from previous Alpha/Beta releases
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For the complete list, see `earlier release notes <../index>`.

* C++ and Python implementations of ROS 2 client libraries including APIs for:

  * Publishing and subscribing to ROS topics
  * Requesting and replying ROS services (synchronous (C++ only) and asynchronous)
  * Getting and setting ROS parameters (C++ only, synchronous and asynchronous)
  * Timer callbacks

* Support for interoperability between multiple DDS/RTPS implementations

  * eProsima Fast RTPS is our default implementation, and is included in the binary packages
  * RTI Connext is supported: build from source to try it out
  * PrismTech OpenSplice: see limitations below

* A graph API for network events
* Distributed discovery
* Realtime safe code paths for publish and subscribe with compatible DDS implementation (only Connext at the moment)

  * Support for custom allocators

* ROS 1 <-> ROS 2 dynamic bridge node
* Executor threading model (C++ and Python)
* Component model to compose nodes at compile / link / runtime
* Managed component using a standard lifecycle
* Extended ``.msg`` format with new features:

  * Bounded arrays
  * Default values

Known issues
------------

* On Windows Python launch files might hang when trying to abort using ``Ctrl-C`` (see `issue <https://github.com/ros2/launch/issues/64>`__). In order to continue using the shell which is blocked by the hanging command you might want to end the hanging Python process using the process monitor.
* OpenSplice support is currently not available for MacOS. Also `access to native handles <https://github.com/ros2/rmw_opensplice/issues/182>`__ is not yet implemented.
* Using Connext it is currently not allowed for two topics with the same base name but different namespaces to have a different type (see `issue <https://github.com/ros2/rmw_connext/issues/234>`__).
",What platforms does ROS 2 Beta 3 support?
"End-of-Life Distributions
=========================

Below is a list of historic ROS 2 distributions that are no longer supported.

.. toctree::
   :maxdepth: 1

   Release-Galactic-Geochelone
   Release-Foxy-Fitzroy
   Release-Eloquent-Elusor
   Release-Dashing-Diademata
   Release-Crystal-Clemmys
   Release-Bouncy-Bolson
   Release-Ardent-Apalone
   Beta3-Overview
   Beta2-Overview
   Beta1-Overview
   Alpha-Overview
",What are some historic ROS 2 distributions that are no longer supported?
".. redirect-from::

  Release-Bouncy-Bolson

Bouncy Bolson (``bouncy``)
==========================

.. contents:: Table of Contents
   :depth: 2
   :local:

*Bouncy Bolson* is the second release of ROS 2.

Supported Platforms
-------------------

This version of ROS 2 is supported on four platforms (see `REP 2000 <https://www.ros.org/reps/rep-2000.html#bouncy-bolson-june-2018-june-2019>`__ for full details):


* Ubuntu 18.04 (Bionic)

  * Debian packages for amd64 as well as arm64

* Ubuntu 16.04 (Xenial)

  * no Debian packages but building from source is supported

* Mac macOS 10.12 (Sierra)
* Windows 10 with Visual Studio 2017

Binary packages as well as instructions for how to compile from source are provided (see `install instructions <../../Installation>` as well as `documentation <https://docs.ros2.org/bouncy/>`__).

Features
--------

New features in this ROS 2 release
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


* `New launch system <../Tutorials/Intermediate/Launch/Launch-system>` featuring a much more capable and flexible Python API.
* Parameters can be passed as `command line arguments <../How-To-Guides/Node-arguments>` to C++ executables.
* Static remapping via `command line arguments <../How-To-Guides/Node-arguments>`.
* Various improvements to the Python client library.
* Support for publishing and subscribing to serialized data.
  This is the foundation for the upcoming work towards a native rosbag implementation.
* More `command line tools <../../Concepts/Basic/About-Command-Line-Tools>`\ , e.g. for working with parameters and lifecycle states.
* Binary packages / fat archives support three RMW implementations by default (without the need to build from source):

  * eProsima's Fast RTPS (default)
  * RTI's Connext
  * ADLINK's OpenSplice

For an overview of all features available, including those from earlier releases, please see the `Features <../../The-ROS2-Project/Features>` page.

Changes since the Ardent release
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Changes since the `Ardent Apalone <Release-Ardent-Apalone>` release:


* The Python package ``launch`` has been redesigned.
  The previous Python API has been moved into a submodule ``launch.legacy``.
  You can update existing launch files to continue to use the legacy API if a transition to the new Python API is not desired.
* The ROS topic names containing namespaces are mapped to DDS topics including their namespaces.
  DDS partitions are not being used anymore for this.
* The recommended build tool is now ``colcon`` instead of ``ament_tools``.
  This switch has no `implications <https://design.ros2.org/articles/build_tool.html#implications>`__ for the code in each ROS 2 package.
  The install instructions have been updated and the `read-the-docs page <https://colcon.readthedocs.io/en/main/migration/ament_tools.html>`__ describes how to map an existing ``ament_tools`` call to ``colcon``.
* The argument order of `this rclcpp::Node::create_subscription() signature <https://docs.ros2.org/bouncy/api/rclcpp/classrclcpp_1_1_node.html#a283fb006c46470cf43a4ae5ef4a16ccd>`__ has been modified.

Known Issues
------------


* New-style launch files `may hang on shutdown <https://github.com/ros2/launch/issues/89>`__ for some combinations of platform and RMW implementation.
* Static remapping of namespaces `not working correctly <https://github.com/ros2/rcl/issues/262>`__ when addressed to a particular node.
* `Opensplice error messages may be printed <https://github.com/ros2/rmw_opensplice/issues/237>`__ when using ``ros2 param`` and ``ros2 lifecycle`` command-line tools.
",What are some of the new features introduced in the Bouncy Bolson release of ROS 2?
".. _humble-release:

Humble Hawksbill (``humble``)
=============================

.. toctree::
   :hidden:

   Humble-Hawksbill-Complete-Changelog

.. contents:: Table of Contents
   :depth: 2
   :local:

*Humble Hawksbill* is the eighth release of ROS 2.
What follows is highlights of the important changes and features in Humble Hawksbill since the last release.
For a list of all of the changes since Galactic, see the `long form changelog <Humble-Hawksbill-Complete-Changelog>`.

Supported Platforms
-------------------

Humble Hawksbill is primarily supported on the following platforms:

Tier 1 platforms:

* Ubuntu 22.04 (Jammy): ``amd64`` and ``arm64``
* Windows 10 (Visual Studio 2019): ``amd64``

Tier 2 platforms:

* RHEL 8: ``amd64``

Tier 3 platforms:

* Ubuntu 20.04 (Focal): ``amd64``
* macOS: ``amd64``
* Debian Bullseye: ``amd64``

For more information about RMW implementations, compiler / interpreter versions, and system dependency versions see `REP 2000 <https://www.ros.org/reps/rep-2000.html>`__.

Installation
------------

`Install Humble Hawksbill <../../humble/Installation.html>`__

Changes in Patch Release 1 (2022-11-23)
---------------------------------------

ros2topic
^^^^^^^^^

``now`` as keyword for ``builtin_interfaces.msg.Time`` and ``auto`` for ``std_msgs.msg.Header``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
``ros2 topic pub`` now allows to set a ``builtin_interfaces.msg.Time`` message to the current time via the ``now`` keyword.
Similarly, a ``std_msg.msg.Header`` message will be automatically generated when passed the keyword ``auto``.
This behavior matches that of ROS 1's ``rostopic`` (http://wiki.ros.org/ROS/YAMLCommandLine#Headers.2Ftimestamps)

Related PR: `ros2/ros2cli#751 <https://github.com/ros2/ros2cli/pull/751>`_

New features in this ROS 2 release
----------------------------------

ament_cmake_gen_version_h
^^^^^^^^^^^^^^^^^^^^^^^^^

Generating a C/C++ header with version info
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
A new CMake function to generate a header with the package version info was added to the ``ament_cmake_gen_version_h`` in `ament/ament_cmake#377 <https://github.com/ament/ament_cmake/pull/377>`__.
Here's the simplest use case:

.. code-block:: CMake

    project(my_project)
    add_library(my_lib ...)
    ament_generate_version_header(my_lib)

It will generate a header with version info from the ``package.xml`` and make it available to targets that link against the ``my_lib`` library.

How to include the header:

.. code-block:: C

    #include <my_project/version.h>

Where the header is installed to:

.. code-block:: cmake

    set(VERSION_HEADER ${CMAKE_INSTALL_PREFIX}/include/my_project/my_project/version.h)

launch
^^^^^^

Scoping environment variables in group actions
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Similar to launch configurations, now by default, the state of environment variables are scoped to group actions.

For example, in the following launch files the executed processe will echo the value ``1`` (before Humble it would echo ``2``):

.. tabs::

   .. group-tab:: XML

    .. code-block:: xml

      <launch>
        <set_env name=""FOO"" value=""1"" />
        <group>
          <set_env name=""FOO"" value=""2"" />
        </group>
        <executable cmd=""echo $FOO"" output=""screen"" shell=""true"" />
      </launch>

   .. group-tab:: Python

      .. code-block:: python

        import launch
        import launch.actions

        def generate_launch_description():
            return launch.LaunchDescription([
                launch.actions.SetEnvironmentVariable(name='FOO', value='1'),
                launch.actions.GroupAction([
                    launch.actions.SetEnvironmentVariable(name='FOO', value='2'),
                ]),
                launch.actions.ExecuteProcess(cmd=['echo', '$FOO'], output='screen', shell=True),
            ])

If you would like disable scoping for launch configurations and and environment variables you can set the ``scoped`` argument (or attribute) to false.

Related PR: `ros2/launch#601 <https://github.com/ros2/launch/pull/601>`_

launch_pytest
""""""""""""""""""""""""""

We've added a new package, ``launch_pytest``, that acts as an alternative to ``launch_testing``.
``launch_pytest`` is a simple pytest plugin that provides pytest fixtures to manage the lifetime of a launch service.

Check out the `package README for details and examples. <https://github.com/ros2/launch/tree/humble/launch_pytest>`_

Related PR: `ros2/launch#528 <https://github.com/ros2/launch/pull/528>`_

Allow matching target actions with a callable
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Event handlers that take a target action object to match can now also take a callable instead to do the matching.

Related PR: `ros2/launch#540 <https://github.com/ros2/launch/pull/540>`_

Access to math module when evaluating Python expressions
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Inside ``PythonExpression`` substitutions (``eval``) we can now use symbols from Python's math module.
For example,

.. code-block:: xml

   <launch>
     <log message=""$(eval 'ceil(pi)')"" />
   </launch>

Related PR: `ros2/launch#557 <https://github.com/ros2/launch/pull/557>`_

Boolean substitutions
""""""""""""""""""""""""""""""""""""""""""

New substitutions ``NotSubstitution``, ``AndSubstitution``, and ``OrSubstitution`` provide a convenient way to perform logical operations, for example

.. code-block:: xml

   <launch>
     <let name=""p"" value=""true"" />
     <let name=""q"" value=""false"" />
     <group if=""$(or $(var p) $(var q))"">
       <log message=""The first condition is true"" />
     </group>
     <group unless=""$(and $(var p) $(var q))"">
       <log message=""The second condition is false"" />
     </group>
     <group if=""$(not $(var q))"">
       <log message=""The third condition is true"" />
     </group>
   </launch>

Related PR: `ros2/launch#598 <https://github.com/ros2/launch/pull/598>`_

New actions
""""""""""""""""""""""

* ``AppendEnvironmentVariable`` appends a value to an existing environment variable.

  * Related PR: `ros2/launch#543 <https://github.com/ros2/launch/pull/543>`_

* ``ResetLaunchConfigurations`` resets any configuration applied to the launch configuration.

  * Related PR: `ros2/launch#515 <https://github.com/ros2/launch/pull/515>`_

launch_ros
^^^^^^^^^^

Passing ROS arguments to node actions
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to provide `ROS-specific node arguments <../../How-To-Guides/Node-arguments>` directly, without needing to use ``args`` with a leading ``--ros-args`` flag:

.. tabs::

   .. group-tab:: XML

    .. code-block:: xml

      <launch>
        <node pkg=""demo_nodes_cpp"" exec=""talker"" ros_args=""--log-level debug"" />
      </launch>

   .. group-tab:: YAML

      .. code-block:: yaml

        launch:
        - node:
            pkg: demo_nodes_cpp
            exec: talker
            ros_args: '--log-level debug'

The corresponding parameter for the ``Node`` action in Python launch files is ``ros_arguments``:

.. code-block:: python

  from launch import LaunchDescription
  import launch_ros.actions

  def generate_launch_description():
      return LaunchDescription([
          launch_ros.actions.Node(
              package='demo_nodes_cpp',
              executable='talker',
              ros_arguments=['--log-level', 'debug'],
          ),
      ])

Related PRs: `ros2/launch_ros#249 <https://github.com/ros2/launch_ros/pull/249>`_ and `ros2/launch_ros#253 <https://github.com/ros2/launch_ros/pull/253>`_.

Frontend support for composable nodes
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

We can now start node containers and load components into them from frontend launch files, for example:

.. tabs::

   .. group-tab:: XML

    .. code-block:: xml

       <launch>
         <node_container pkg=""rclcpp_components"" exec=""component_container"" name=""my_container"" namespace="""">
           <composable_node pkg=""composition"" plugin=""composition::Talker"" name=""talker"" />
         </node_container>
         <load_composable_node target=""my_container"">
           <composable_node pkg=""composition"" plugin=""composition::Listener"" name=""listener"" />
         </load_composable_node>
       </launch>

   .. group-tab:: YAML

      .. code-block:: yaml

         launch:
           - node_container:
               pkg: rclcpp_components
               exec: component_container
               name: my_container
               namespace: ''
               composable_node:
                 - pkg: composition
                   plugin: composition::Talker
                   name: talker
           - load_composable_node:
               target: my_container
               composable_node:
                 - pkg: composition
                   plugin: composition::Listener
                   name: listener

Related PR: `ros2/launch_ros#235 <https://github.com/ros2/launch_ros/pull/235>`_

Parameter substitution
""""""""""""""""""""""""""""""""""""""""""""

The new ``ParameterSubstitution`` lets you substitute the value of a parameter set previously in launch with the ``SetParameter`` action.
For example,

.. code-block:: xml

   <launch>
     <set_parameter name=""foo"" value=""bar"" />
     <log message=""Parameter foo has value $(param foo)"" />
   </launch>

Related PR: `ros2/launch_ros#297 <https://github.com/ros2/launch_ros/pull/297>`_

New actions
""""""""""""""""""""""

* ``RosTimer`` acts like the launch ``TimerAction``, but uses a ROS clock (so it can use simulation time, for example).

  * Related PRs: `ros2/launch_ros#244 <https://github.com/ros2/launch_ros/pull/244>`_ and `ros2/launch_ros#264 <https://github.com/ros2/launch_ros/pull/264>`_

* ``SetParametersFromFile`` passes a ROS parameters file to all nodes in a launch file (including node components).

  * Related PRs: `ros2/launch_ros#260 <https://github.com/ros2/launch_ros/pull/260>`_ and `ros2/launch_ros#281 <https://github.com/ros2/launch_ros/pull/281>`_

SROS2 Security enclaves support Certificate Revocation Lists
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Certificate Revocation Lists (CRLs) are a concept where particular certificates can be revoked before their expiration.
As of Humble, it is now possible to put a CRL in an SROS2 security enclave and have it be honored.
See `the SROS2 tutorials <https://github.com/ros2/sros2/blob/humble/SROS2_Linux.md#certificate-revocation-lists>`__ for an example of how to use it.

Content Filtered Topics
^^^^^^^^^^^^^^^^^^^^^^^

Content Filtered Topics supports a more sophisticated subscription that indicates the subscriber does not want to necessarily see all values of each instance published under the Topic.
Content Filtered Topics can be used to request content-based subscriptions when underlying RMW implementation supports this feature.

.. list-table:: RMW Content Filtered Topics support
   :widths: 25 25

   * - rmw_fastrtps
     - supported
   * - rmw_connextdds
     - supported
   * - rmw_cyclonedds
     - not supported

To learn more, see the `content_filtering <https://github.com/ros2/examples/blob/humble/rclcpp/topics/minimal_subscriber/content_filtering.cpp>`_ examples.

Related design PR: `ros2/design#282 <https://github.com/ros2/design/pull/282>`_.

ros2cli
^^^^^^^

``ros2 launch`` has a ``--launch-prefix`` argument
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

This allows passing a prefix to all executables in a launch file, which is useful in many debugging situations.
See the associated `pull request <https://github.com/ros2/launch_ros/pull/254>`__, as well as the :ref:`tutorial <launch-prefix-example>` for more information.

Relatedly, the ``--launch-prefix-filter`` command-line option was added to selectively add the prefix from ``--launch-prefix`` to executables.
See the `pull request <https://github.com/ros2/launch_ros/pull/261>`__ for more information.

``ros2 topic echo`` has a ``--flow-style`` argument
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

This allows the user to force ``flow style`` for the YAML representation of data on a topic.
Without this option, the output from ``ros2 topic echo /tf_static`` could look something like:

.. code-block::

  transforms:
  - header:
      stamp:
        sec: 1651172841
        nanosec: 433705575
      frame_id: single_rrbot_link3
    child_frame_id: single_rrbot_camera_link
    transform:
      translation:
        x: 0.05
        y: 0.0
        z: 0.9
      rotation:
        x: 0.0
        y: 0.0
        z: 0.0
        w: 1.0

With this option, the output would look something like:

.. code-block::

  transforms: [{header: {stamp: {sec: 1651172841, nanosec: 433705575}, frame_id: single_rrbot_link3}, child_frame_id: single_rrbot_camera_link, transform: {translation: {x: 0.05, y: 0.0, z: 0.9}, rotation: {x: 0.0, y: 0.0, z: 0.0, w: 1.0}}}]

See the `PyYAML documentation <https://pyyaml.docsforge.com/master/documentation/#dictionaries-without-nested-collections-are-not-dumped-correctly>`__ for more information.

``ros2 topic echo`` can filter data based on message contents
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

This allows the user to only print out data on a topic that matches a certain Python expression.
For instance, using the following argument will only print out string messages that start with 'foo':

.. code-block::

   ros2 topic echo --filter 'm.data.startswith(""foo"")` /chatter

See the `pull request <https://github.com/ros2/ros2cli/pull/654>`__ for more information.


rviz2
^^^^^

Apply textures to arbitrary triangle lists
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

We've added `the ability to apply textures defined via URI to arbitrary triangle lists using UV Coordinates <https://github.com/ros2/rviz/pull/719>`__.
Now we can create a gradient pull from a texture map instead of the default grayscale.
This will enable complex coloring of markers.
To use this, you should use the ``visualization_msgs/Marker.msg`` and fill the ``texture_resource``, ``texture``, ``uv_coordinates`` and ``mesh_file`` fields.
You can find more information `here <https://github.com/ros2/common_interfaces/pull/153>`__.

.. image:: images/triangle_marker_with_gradient.png

Visualization of mass properties (including inertia)
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

We also added the ability to visualize inertias. To do this, you select enable 'Inertia' in the 'Mass Properties' under the robot model:

.. image:: images/rviz_mass_inertia.png

You can see an image of an inertia below.

.. image:: images/tb4_inertia.png

Visualize YUV images in RViz
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to directly visualize YUV images inside of RViz, rather than having to convert to RGB first.
See `ros2/rviz#701 <https://github.com/ros2/rviz/pull/701>`__ for details.

Allow rendering of objects > 100 meters
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

By default, RViz only renders objects that are within 100 meters of a camera.
A new configuration property called ""Far Plane Distance"" in the rviz camera plugin allows that rendering distance to be configured.

.. image:: images/rviz2-far-plane-distance.png

See `ros2/rviz#849 <https://github.com/ros2/rviz/pull/849>`__ for more information.

Changes since the Galactic release
----------------------------------

C++ headers are installed in a subdirectory
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In ROS 2 releases prior to Humble, C++ headers for all packages were installed into a single include directory.
For instance, in Galactic, the directory structure looks like this (reduced for brevity):

.. code::

    /opt/ros/galactic/include/
    ├── rcl
    │   ├── node.h
    ├── rclcpp
    │   ├── node.hpp


This structure can cause serious problems when trying to use overlays.
That is, it is very possible to get the wrong set of header files due to include directory order.
See https://colcon.readthedocs.io/en/released/user/overriding-packages.html for a detailed explanation of the problems.

To help combat this, in Humble (and in all ROS 2 releases going forward), the directory structure has changed:

.. code::

    /opt/ros/humble/include
    ├── rcl
    │   └── rcl
    │       ├── node.h
    ├── rclcpp
    │   └── rclcpp
    │       ├── node.hpp

Note that downstream packages that use these headers do *not* have to change; using ``#include <rclcpp/node.hpp>`` works as it always did before.
However, when using IDEs that are looking for include directories, it may be necessary to add the individual include directories to the search path.

See https://github.com/ros2/ros2/issues/1150 for more information, including the reasoning behind this change.

common_interfaces
^^^^^^^^^^^^^^^^^

Support Textures and Embedded Meshes for Marker Messages
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

These two additions will improve the ability to both visualize data in new ways with standard messages and, simultaneously, enable the ability to track this data in rosbag.

**Textures** bring the addition of three new fields to markers:

.. code-block:: bash

   # Texture resource is a special URI that can either reference a texture file in
   # a format acceptable to (resource retriever)[https://index.ros.org/p/resource_retriever/]
   # or an embedded texture via a string matching the format:
   #   ""embedded://texture_name""
   string texture_resource
   # An image to be loaded into the rendering engine as the texture for this marker.
   # This will be used iff texture_resource is set to embedded.
   sensor_msgs/CompressedImage texture
   # Location of each vertex within the texture; in the range: [0.0-1.0]
   UVCoordinate[] uv_coordinates

RViz will fully support texture rendering through the embedded format.

To those familiar with ``mesh_resource``, ``resource_retriever`` should be familiar.
This will allow the programmer to choose where they want to load data from, either a local file or a networked file.
In the interest of being able to record all data in a rosbag, the ability to embed the texture image is included.

**Meshes** were modified in a similar way to add the ability to embed a raw Mesh file for the purpose of recording and are modified in a similar way. The Meshfile message has two fields:

.. code-block:: bash

   # The filename is used for both debug purposes and to provide a file extension
   # for whatever parser is used.
   string filename

   # This stores the raw text of the mesh file.
   uint8[] data

The embedded ``Meshfile`` message is not yet supported in implementation.

Related PRs: `ros2/common_interfaces#153 <https://github.com/ros2/common_interfaces/pull/153>`_ `ros2/rviz#719 <https://github.com/ros2/rviz/pull/719>`_

Added ``PRISM`` type to SolidPrimitive
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``SolidPrimitive`` message had a new ``PRISM`` type added, along with the appropriate metadata.
See `ros2/common_interfaces#167 <https://github.com/ros2/common_interfaces/pull/167>`_ for more information.

rmw
^^^

``struct`` type name suffix changed from ``_t`` to ``_s``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

To avoid type name duplication errors between ``struct`` type names and their ``typedef``-ed aliases when generating code documentation, the suffix for all ``struct`` type names has been changed from ``_t`` to ``_s``.
Aliases with ``_t`` suffixes remain in place.
Thus, this change is a breaking change only for code that uses full ``struct`` type specifiers i.e. ``struct type_name_t``.

See `ros2/rmw#313 <https://github.com/ros2/rmw/pull/313>`__ for more details.

rmw_connextdds
^^^^^^^^^^^^^^

Use Connext 6 by default
""""""""""""""""""""""""""""""""""""""""""""""""

By default, Humble Hawksbill uses Connext 6.0.1 as the DDS implementation for ``rmw_connextdds``.
It is still possible to use Connext 5.3.1 with ``rmw_connextdds``, but it must be rebuilt from source.

rcl
^^^

``struct`` type name suffix changed from ``_t`` to ``_s``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

To avoid type name duplication errors between ``struct`` type names and their ``typedef``-ed aliases when generating code documentation, the suffix for all ``struct`` type names has been changed from ``_t`` to ``_s``.
Aliases with ``_t`` suffixes remain in place.
Thus, this change is a breaking change only for code that uses full ``struct`` type specifiers i.e. ``struct type_name_t``.

See `ros2/rcl#932 <https://github.com/ros2/rcl/pull/932>`__ for more details.

ROS_DISABLE_LOANED_MESSAGES environment variable added
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

This environment variable can be used to disable loaned messages support, independently if the rmw supports them or not.
For more details, see the guide :doc:`Configure Zero Copy Loaned Messages <../How-To-Guides/Configure-ZeroCopy-loaned-messages>`.

rclcpp
^^^^^^

Support Type Adaption for Publishers and Subscriptions
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

After defining a type adapter, custom data structures can be used directly by publishers and subscribers, which helps to avoid additional work for the programmer and potential sources of errors.
This is especially useful when working with complex data types, such as when converting OpenCV's ``cv::Mat`` to ROS's ``sensor_msgs/msg/Image`` type.

Here is an example of a type adapter that converts ``std_msgs::msg::String`` to ``std::string``:

.. code-block:: cpp

   template<>
   struct rclcpp::TypeAdapter<
      std::string,
      std_msgs::msg::String
   >
   {
     using is_specialized = std::true_type;
     using custom_type = std::string;
     using ros_message_type = std_msgs::msg::String;

     static
     void
     convert_to_ros_message(
       const custom_type & source,
       ros_message_type & destination)
     {
       destination.data = source;
     }

     static
     void
     convert_to_custom(
       const ros_message_type & source,
       custom_type & destination)
     {
       destination = source.data;
     }
   };

And an example of how the type adapter can be used:

.. code-block:: cpp

   using MyAdaptedType = TypeAdapter<std::string, std_msgs::msg::String>;

   // Publish a std::string
   auto pub = node->create_publisher<MyAdaptedType>(...);
   std::string custom_msg = ""My std::string""
   pub->publish(custom_msg);

   // Pass a std::string to a subscription's callback
   auto sub = node->create_subscription<MyAdaptedType>(
     ""topic"",
     10,
     [](const std::string & msg) {...});

To learn more, see the `publisher <https://github.com/ros2/examples/blob/b83b18598b198b4a5ba44f9266c1bb39a393fa17/rclcpp/topics/minimal_publisher/member_function_with_type_adapter.cpp>`_ and `subscription <https://github.com/ros2/examples/blob/b83b18598b198b4a5ba44f9266c1bb39a393fa17/rclcpp/topics/minimal_subscriber/member_function_with_type_adapter.cpp>`_ examples, as well as a more complex `demo <https://github.com/ros2/demos/pull/482>`_.
For more details, see `REP 2007 <https://ros.org/reps/rep-2007.html>`_.

``Client::asnyc_send_request(request)`` returns a ``std::future`` instead of a ``std::shared_future``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

This change was implemented in `rclcpp#1734 <https://github.com/ros2/rclcpp/pull/1734>`_.
This breaks API, as ``std::future::get()`` methods extracts the value from the future.
That means, if that method is called for a second time it will throw an exception.
That doesn't happen with a ``std::shared_future``, as its ``get()`` method returns a ``const &``.
Example:

.. code-block:: cpp

    auto future = client->async_send_request(req);
    ...
    do_something_with_response(future.get());
    ...
    do_something_else_with_response(future.get());  // this will throw an exception now!!

should be updated to:

.. code-block:: cpp

    auto future = client->async_send_request(req);
    ...
    auto response = future.get();
    do_something_with_response(response);
    ...
    do_something_else_with_response(response);

If a shared future is needed, the ``std::future::share()`` method can be used.

``wait_for_all_acked`` method added to ``Publisher``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

This new method will block until all messages in the publisher queue are acked by the matching subscriptions or the specified timeout expires.
It is only useful for reliable publishers, as in the case of best effort QoS there's no acking.
Examples:

.. code-block:: cpp

   auto pub = node->create_publisher<std_msgs::msg::String>(...);
   ...
   pub->publish(my_msg);
   ...
   pub->wait_for_all_acked(); // or pub->wait_for_all_acked(timeout)

For a more complete example, see `here <https://github.com/ros2/examples/blob/humble/rclcpp/topics/minimal_publisher/member_function_with_wait_for_all_acked.cpp>`__.

``get_callback_groups`` method removed from ``NodeBase`` and ``Node`` classes
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``for_each_callback_group()`` method has replaced ``get_callback_groups()`` by providing a thread-safe way to access ``callback_groups_`` vector.
``for_each_callback_group()`` accepts a function as an argument, iterates over the stored callback groups, and calls the passed function to ones that are valid.

For more details, please refer to this `pull request <https://github.com/ros2/rclcpp/pull/1723>`_.

``add_to_wait_set`` method from ``Waitable`` class changes its return type from ``bool`` to ``void``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Before, classes derived from ``Waitable`` overriding ``add_to_wait_set`` were returning false when failing to add elements to the wait set, so the caller had to check this return value and throw or handle the error.
This error handling should now be done directly on ``add_to_wait_set`` method, throwing if necessary.
It is not required to return anything if no errors happened.
Thus, this is a breaking change for downstream uses of ``Waitable``.

See `ros2/rclcpp#1612 <https://github.com/ros2/rclcpp/pull/1612>`__ for more details.

``get_notify_guard_condition`` method return type from ``NodeBaseInterface`` class changed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Now ``rclcpp`` uses the ``GuardCondition`` class wrapper around ``rcl_guard_condition_t``, so ``get_notify_guard_condition`` returns a reference to the node's ``rclcpp::GuardCondition``.
Thus, this is a breaking change for downstream uses of ``NodeBaseInterface`` and ``NodeBase``.

See `ros2/rclcpp#1612 <https://github.com/ros2/rclcpp/pull/1612>`__ for more details.

``sleep_until`` and ``sleep_for`` methods added to ``Clock``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Two new methods were added to allow sleeping on a particular clock in `ros2/rclcpp#1814 <https://github.com/ros2/rclcpp/pull/1814>`__ and `ros2/rclcpp#1828 <https://github.com/ros2/rclcpp/pull/1828>`__.
``Clock::sleep_until`` will suspend the current thread until the clock reaches a particular time.
``Clock::sleep_for`` will suspend the current thread until the clock advances a certain amount of time from when the method was called.
Both methods will wake early if the ``Context`` is shutdown.

rclcpp_lifecycle
^^^^^^^^^^^^^^^^

Active and deactivate transitions of publishers will be triggered automatically
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Before, users needed to override ``LifecylceNode::on_activate()`` and ``LifecylceNode::on_deactivate()`` and call the similarly named methods on ``LifecyclePublisher`` to make the transition actually happen.
Now, ``LifecylceNode`` provides a default interface of these methods that already do this.
See the implementation of the ``lifecycle_talker`` node `here <https://github.com/ros2/demos/tree/humble/lifecycle>`__.

rclpy
^^^^^

Managed nodes
""""""""""""""""""""""""""

Lifecycle nodes support was added to rclpy.
A complete demo can be found `here <https://github.com/ros2/demos/tree/humble/lifecycle_py>`__.

``wait_for_all_acked`` method added to ``Publisher``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Similar to the feature added to rclcpp.

``sleep_until`` and ``sleep_for`` methods added to ``Clock``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Two new methods were added to allow sleeping on a particular clock in `ros2/rclpy#858 <https://github.com/ros2/rclpy/pull/858>`__ and `ros2/rclpy#864 <https://github.com/ros2/rclpy/pull/864>`__.
``sleep_until`` will suspend the current thread until the clock reaches a particular time.
``sleep_for`` will suspend the current thread until the clock advances a certain amount of time from when the method was called.
Both methods will wake early if the ``Context`` is shutdown.

ros1_bridge
^^^^^^^^^^^

Since there is no official ROS 1 distribution on Ubuntu Jammy and forward, ``ros1_bridge`` is now compatible with the Ubuntu-packaged versions of ROS 1.
More details about using ``ros1_bridge`` with Jammy packages are available in :doc:`the how-to guides <../How-To-Guides/Using-ros1_bridge-Jammy-upstream>`.

ros2cli
^^^^^^^

``ros2`` commands disable output buffering by default
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Prior to this release, running a command like

.. code-block::

  ros2 echo /chatter | grep ""Hello""

would not print any data until the output buffer was full.
Users could work around this by setting ``PYTHONUNBUFFERED=1``, but that was not very user friendly.

Instead, all ``ros2`` commands now do line-buffering by default, so commands like the above work as soon as a newline is printed.
To disable this behavior and use default python buffering rules, use the option ``--use-python-default-buffering``.
See the `original issue <https://github.com/ros2/ros2cli/issues/595>`__ and the `pull request <https://github.com/ros2/ros2cli/pull/659>`__ for more information.

``ros2 topic pub`` will wait for one matching subscription when using ``--times/--once/-1``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

When using ``--times/--once/-1`` flags, ``ros2 topic pub`` will wait for one matching subscription to be found before starting to publish.
This avoids the issue of the ros2cli node starting to publish before discovering a matching subscription, which results in some of the first messages being lost.
This is particularly unexpected when using a reliable qos profile.

The number of matching subscriptions to wait before starting publishing can be configured with the ``-w/--wait-matching-subscriptions`` flags, e.g.:

.. code-block:: console

   ros2 topic pub -1 -w 3 /chatter std_msgs/msg/String ""{data: 'foo'}""

to wait for three matching subscriptions before starting to publish.

``-w`` can also be used independently of ``--times/--once/-1`` but it only defaults to one when combined with them, otherwise the ``-w`` default is zero.

See https://github.com/ros2/ros2cli/pull/642 for more details.

``ros2 param dump`` default output changed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

  * ``--print`` option for dump command was `deprecated <https://github.com/ros2/ros2cli/pull/638>`_.

    It prints to stdout by default:

    .. code-block:: bash

      ros2 param dump /my_node_name

  * ``--output-dir`` option for dump command was `deprecated <https://github.com/ros2/ros2cli/pull/638>`_.

    To dump parameters to a file, run:

    .. code-block:: bash

      ros2 param dump /my_node_name > my_node_name.yaml

``ros2 param set`` now accepts more YAML syntax
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Previously, attempting to set a string like ""off"" to a parameter that was of string type did not work.
That's because ``ros2 param set`` interprets the command-line arguments as YAML, and YAML considers ""off"" to be a boolean type.
As of https://github.com/ros2/ros2cli/pull/684 , ``ros2 param set`` now accepts the YAML escape sequence of ""!!str off"" to ensure that the value is considered a string.

``ros2 pkg create`` can automatically generate a LICENSE file
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

If the ``--license`` flag is passed to ``ros2 pkg create``, and the license is one of the known licenses, ``ros2 pkg create`` will now automatically generate a LICENSE file in the root of the package.
For a list of known licenses, run ``ros2 pkg create --license ? <package_name>``.
See the associated `pull request <https://github.com/ros2/ros2cli/pull/650>`__ for more information.

robot_state_publisher
^^^^^^^^^^^^^^^^^^^^^

Added ``frame_prefix`` parameter
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
A new parameter ``frame_prefix`` was added in `ros/robot_state_publisher#159 <https://github.com/ros/robot_state_publisher/pull/159>`__.
This parameter is a string which is prepended to all frame names published by ``robot_state_publisher``.
Similar to ``tf_prefix`` in the original ``tf`` library in ROS 1, this parameter can be used to publish the same robot description multiple times with different frame names.

Removal of deprecated ``use_tf_static`` parameter
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The deprecated ``use_tf_static`` parameter has been removed from ``robot_state_publisher``.
This means that static transforms are unconditionally published to the ``/tf_static`` topic, and that the static transforms are published in a ``transient_local`` Quality of Service.
This was the default behavior, and the behavior which the ``tf2_ros::TransformListener`` class expected before, so most code will not have to be changed.
Any code that was relying on ``robot_state_publisher`` to periodically publish static transforms to ``/tf`` will have to be updated to subscribe to ``/tf_static`` as a ``transient_local`` subscription instead.


rosidl_cmake
^^^^^^^^^^^^

Deprecation of ``rosidl_target_interfaces()``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The CMake function ``rosidl_target_interfaces()`` has been deprecated, and now issues a CMake warning when called.
Users wanting to use messages/services/actions in the same ROS package that generated them should instead call ``rosidl_get_typesupport_target()`` and then ``target_link_libraries()`` to make their targets depend on the returned typesupport target.
See https://github.com/ros2/rosidl/pull/606 for more details, and https://github.com/ros2/demos/pull/529 for an example of using the new function.


rviz2
^^^^^

* `improved the efficiency of 3-bytes pixel formats <https://github.com/ros2/rviz/pull/743>`__
* `changed the way inertias are computed to use ignition math rather than Ogre's math libraries <https://github.com/ros2/rviz/pull/751>`__.


geometry2
^^^^^^^^^

Deprecation of TF2Error::NO_ERROR, etc
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``tf2`` library uses an enumeration called ``TF2Error`` to return errors.
Unfortunately, one of the enumerators in there is called ``NO_ERROR``, which conflicts with a macro on Windows.
To remedy this, a new set of enumerators in ``TF2Error`` were created, each with a ``TF2`` prefix.
The previous enumerators are still available, but are now deprecated and will print a deprecation warning if used.
All code that uses the ``TF2Error`` enumerator should be updated to use the new ``TF2`` prefixed errors.
See https://github.com/ros2/geometry2/pull/349 for more details.

More intuitive command-line arguments for static_transform_publisher
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``static_transform_publisher`` program used to take arguments like: ``ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 1 foo bar``.
The first three numbers are the translation x, y, and z, the next 4 are the quaternion x, y, z, and w, and the last two arguments are the parent and child frame IDs.
While this worked, it had a couple of problems:

* The user had to specify *all* of the arguments, even if only setting one number
* Reading the command-line to figure out what it was publishing was tricky

To fix both of these issues, the command-line handling has been changed to use flags instead, and all flags except for ``--frame-id`` and ``--child-frame-id`` are optional.
Thus, the above command-line can be simplified to: ``ros2 run tf2_ros static_transform_publisher --frame-id foo --child-frame-id bar``
To change just the translation x, the command-line would be: ``ros2 run tf2_ros static_transform_publisher --x 1.5 --frame-id foo --child-frame-id bar``.

The old-style arguments are still allowed in this release, but are deprecated and will print a warning.
They will be removed in future releases.
See https://github.com/ros2/geometry2/pull/392 for more details.

Transform listener spin thread no longer executes node callbacks
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``tf2_ros::TransformListener`` no longer spins on the provided node object.
Instead, it creates a callback group to execute callbacks on the entities it creates internally.
This means if you have set the parameter ``spin_thread=true`` when creating a transform listener, you
can no longer depend on your own callbacks to be executed.
You must call a ``spin`` function on your node (e.g. ``rclcpp::spin``), or add your node to your own executor.

Related pull request: `geometry2#442 <https://github.com/ros2/geometry2/pull/442>`_

rosbag2
^^^^^^^

New playback and recording controls
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Several pull requests have been added to enhance the user's control over playback of bags.
Pull request `931 <https://github.com/ros2/rosbag2/pull/931>`_ adds the ability to specify a time stamp to begin playing from.
Due to pull request `789 <https://github.com/ros2/rosbag2/pull/789>`_ it is now possible to delay the start of playback by a specified interval.

Relatedly, ``rosbag2`` has gained new ways for users to control playback as it is happening.
Pull request `847 <https://github.com/ros2/rosbag2/pull/847>`_ adds keyboard controls for pausing, resuming, and playing the next message during playback from a terminal.
It is also possible to start playback paused thanks to pull requests `905 <https://github.com/ros2/rosbag2/pull/905>`_ and `904 <https://github.com/ros2/rosbag2/pull/904>`_, which makes it easy for the user to initiate playback and then step through messages, such as when debugging a pipeline.
Pull request `836 <https://github.com/ros2/rosbag2/pull/836>`_ adds an interface for seeking within bags, allowing the user to move around within a bag during playback.

Finally, a new snapshot mode has been added to recording in pull request `851 <https://github.com/ros2/rosbag2/pull/851>`_.
This mode, useful for incident recording, allows recording to begin filling up buffers, but not begin writing data to disc until a service is called.

Burst-mode playback
""""""""""""""""""""""""""""""""""""""

While the playback of data from a bag in real-time is the most well-known use case for bag files, there are situations where you want the data in the bag as fast as possible.
With pull request `977 <https://github.com/ros2/rosbag2/pull/977>`_, ``rosbag2`` has gained the ability to ""burst"" data from the bag.
In burst mode, the data is played back as fast as possible.
This is useful in applications such as machine learning.

Zero-Copy playback
""""""""""""""""""""""""""""""""""""

By default, if loaned message can be used, playback messages are published as loaned message.
This can help to reduce the number of data copies, so there is a greater benefit for sending big data.
Pull request `981 <https://github.com/ros2/rosbag2/pull/981>`_ adds ``--disable-loan-message`` option for playback.

Wait for an acknowledgment
""""""""""""""""""""""""""""""""""""""""""""""""""""

This new option will wait until all published messages are acknowledged by all subscribers or until the timeout elapses in millisecond before play is terminated.
Especially for the case of sending message with big size in a short time.
This option is valid only if the publisher's QOS profile is RELIABLE.
Pull request `951 <https://github.com/ros2/rosbag2/pull/951>`_ adds ``--wait-for-all-acked`` option for playback.

Bag editing
""""""""""""""""""""""

``rosbag2`` is taking steps towards enabling the editing of bags, such as removing all messages for one topic or merging multiple bags into a single bag.
Pull request `921 <https://github.com/ros2/rosbag2/pull/921>`_ adds bag rewriting and the ``ros2 bag convert`` verb.

Other changes
""""""""""""""""""""""""""

Pull request `925 <https://github.com/ros2/rosbag2/pull/925>`_ makes ``rosbag2`` ignore ""leaf topics"" (topics without a publisher) when recording.
These topics will no longer be automatically added to the bag.

Known Issues
------------

* When `installing ROS 2 on an Ubuntu 22.04 Jammy host <../../humble/Installation/Ubuntu-Install-Debians.html>`__ it is important to update your system before installing ROS 2 packages.
  It is *particularly* important to make sure that ``systemd`` and ``udev`` are updated to the latest available version otherwise installing ``ros-humble-desktop``, which depends on ``libudev1``, could cause the removal of system critical packages.
  Details can be found in `ros2/ros2#1272 <https://github.com/ros2/ros2/issues/1272>`_ and `Launchpad #1974196 <https://bugs.launchpad.net/ubuntu/+source/systemd/+bug/1974196>`_

* When ROS 2 apt repositories are available, ROS 1 packages in Ubuntu are not installable.  See the :doc:`ros1_bridge on Ubuntu Jammy <../How-To-Guides/Using-ros1_bridge-Jammy-upstream>` document for more information.

* Some major Linux distributions have started patching Python to install packages to ``/usr/local``, which is breaking some parts of ``ament_package`` and builds with ``colcon``.
  In particular, using Ubuntu Jammy with ``setuptools`` installed from pip will manifest this misbehavior, and is therefore not recommended.
  There is currently a `proposed solution <https://github.com/colcon/colcon-core/pull/512>`_ which requires further testing before widespread release.

* ROS 2 bags that are split by size or duration are not played correctly.
  Only the last bag recorded is played.
  It is recommended to avoid splitting bags by size or duration.
  Details can be found in `ros2/rosbag2#966 <https://github.com/ros2/rosbag2/issues/966>`__.

Release Timeline
----------------

    Mon. March 21, 2022 - Alpha + RMW freeze
        Preliminary testing and stabilization of ROS Base [1]_ packages, and API and feature freeze for RMW provider packages.

    Mon. April 4, 2022 - Freeze
        API and feature freeze for ROS Base [1]_ packages in Rolling Ridley.
        Only bug fix releases should be made after this point.
        New packages can be released independently.

    Mon. April 18, 2022 - Branch
        Branch from Rolling Ridley.
        ``rosdistro`` is reopened for Rolling PRs for ROS Base [1]_ packages.
        Humble development shifts from ``ros-rolling-*`` packages to ``ros-humble-*`` packages.

    Mon. April 25, 2022 - Beta
        Updated releases of ROS Desktop [2]_ packages available.
        Call for general testing.

    Mon. May 16, 2022 - Release Candidate
        Release Candidate packages are built.
        Updated releases of ROS Desktop [2]_ packages available.

    Thu. May 19, 2022 - Distro Freeze
        Freeze rosdistro.
        No PRs for Humble on the ``rosdistro`` repo will be merged (reopens after the release announcement).

    Mon. May 23, 2022 - General Availability
        Release announcement.
        ``rosdistro`` is reopened for Humble PRs.

.. [1] The ``ros_base`` variant is described in `REP 2001 (ros-base) <https://www.ros.org/reps/rep-2001.html#ros-base>`_.
.. [2] The ``desktop`` variant is described in `REP 2001 (desktop-variants) <https://www.ros.org/reps/rep-2001.html#desktop-variants>`_.
",What is the purpose of the `Humble Hawksbill` release of ROS 2?
".. _iron-release:

Iron Irwini (``iron``)
======================

.. toctree::
   :hidden:

   Iron-Irwini-Complete-Changelog

.. contents:: Table of Contents
   :depth: 2
   :local:

*Iron Irwini* is the ninth release of ROS 2.
What follows is highlights of the important changes and features in Iron Irwini since the last release.
For a list of all of the changes since Humble, see the :doc:`long form changelog <Iron-Irwini-Complete-Changelog>`.

Supported Platforms
-------------------

Iron Irwini is primarily supported on the following platforms:

Tier 1 platforms:

* Ubuntu 22.04 (Jammy): ``amd64`` and ``arm64``
* Windows 10 (Visual Studio 2019): ``amd64``

Tier 2 platforms:

* RHEL 9: ``amd64``

Tier 3 platforms:

* macOS: ``amd64``
* Debian Bullseye: ``amd64``

For more information about RMW implementations, compiler / interpreter versions, and system dependency versions see `REP 2000 <https://www.ros.org/reps/rep-2000.html>`__.

Installation
------------

`Install Iron Irwini <../../iron/Installation.html>`__

New features in this ROS 2 release
----------------------------------

API documentation generation for Python packages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ROS 2 has had automatic API documentation for C++ packages for several releases, e.g. https://docs.ros.org/en/rolling/p/rclcpp/generated/index.html.
Iron adds automatic API documentation for Python packages as well, e.g. https://docs.ros.org/en/rolling/p/rclpy/rclpy.html.

See https://github.com/ros-infrastructure/rosdoc2/pull/28, https://github.com/ros-infrastructure/rosdoc2/pull/49, https://github.com/ros-infrastructure/rosdoc2/pull/51, and https://github.com/ros-infrastructure/rosdoc2/pull/52 for more details.

Service introspection
^^^^^^^^^^^^^^^^^^^^^

It is now possible to enable service introspection on a per-service basis.
When enabled, this allows users to see the metadata associated with the client requesting a service, the server accepting the request, the server sending the response, and the client accepting the response.
Optionally, the contents of the client/server requests/responses can also be introspected.
All of the information is published on a hidden topic generated from the name of the service.
So if the service is called ``/myservice``, then the information will be published on ``/myservice/_service_event``.

Note that this functionality is disabled by default; to enable it, users must call ``configure_introspection`` after creating a server client or server.
There are examples showing how to do this in https://github.com/ros2/demos/tree/iron/demo_nodes_cpp/src/services (C++) and https://github.com/ros2/demos/blob/iron/demo_nodes_py/demo_nodes_py/services/introspection.py (Python).

See `REP 2012 <https://github.com/ros-infrastructure/rep/pull/360>`__ and the tracking bug at https://github.com/ros2/ros2/issues/1285 for more information.

Pre and post set parameter callback support
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For many releases now, users could register a callback to be called when parameters on a node were changed by an external entity (like ``ros2 param set``).
This callback could examine the changed parameter types and values, and reject the whole lot if one of them didn't meet certain criteria.
However, it could not modify the parameter list, nor should it have modified state (since there might be other callbacks after the set one that would reject the parameters).

This release adds in a pre and post callback.
The callbacks are called in this order:

* The ""pre"" set parameter callback, which can modify the list of parameters based on arbitrary criteria.
* The ""set"" parameter callback, which cannot modify the list and should only accept or reject the parameters based on their type and value (this is the existing callback).
* The ""post"" set parameter callback, which can make state changes based on parameters and is only called if the previous two callbacks are successful.

There are examples of this in action in https://github.com/ros2/demos/blob/iron/demo_nodes_cpp/src/parameters/set_parameters_callback.cpp (C++) and https://github.com/ros2/demos/blob/iron/demo_nodes_py/demo_nodes_py/parameters/set_parameters_callback.py (Python).

See https://github.com/ros2/rclcpp/pull/1947, https://github.com/ros2/rclpy/pull/966, and https://github.com/ros2/demos/pull/565 for more information.

Improved discovery options
^^^^^^^^^^^^^^^^^^^^^^^^^^

Previous ROS 2 versions offered limited discovery options.
The default behavior for DDS based RMW implementations was to discover any node reachable via multicast.
It could be limited to the same machine by setting the environment variable ``ROS_LOCALHOST_ONLY``, but any additional configuration required configuring the middleware directly, usually via middleware specific XML files and environment variables.
ROS Iron retains the same default discovery behavior, but deprecates ``ROS_LOCALHOST_ONLY`` in favor of more granular options.

* ``ROS_AUTOMATIC_DISCOVERY_RANGE`` controls how far ROS nodes will try to discover each other. Valid options are:

  * ``SUBNET`` - The default, and for DDS-based middlewares it will discover any node reachable via multicast.
  * ``LOCALHOST`` - Will only try to discover other nodes on the same machine.
  * ``OFF`` - Will not attempt to discover any other nodes automatically, even on the same machine.
  * ``SYSTEM_DEFAULT`` - Will not change any discovery settings.  This is useful when you already have custom settings for your middleware and don't want ROS to change them.

* ``ROS_STATIC_PEERS`` - A semicolon (``;``) separated list of addresses that ROS should try to discover nodes on.  This allows the user to connect to nodes on specifc machines (as long as their discovery range is not set to ``OFF``).

For example, you might have several robots with ``ROS_AUTOMATIC_DISCOVERY_RANGE`` set to ``LOCALHOST`` so they don't communicate with each other.
When you want to connect RViz to one of them, you add it's address to ``ROS_STATIC_PEERS`` in your terminal.
Now you can use ROS 2 CLI and visualization tools to interact with the robot.

See https://github.com/ros2/ros2/issues/1359 for more information about this feature.

Matched events
^^^^^^^^^^^^^^

In addition to QoS events, matched events can be generated when any publisher and subscription establishes or drops the connection between them.
Users can provide each publisher and subscription with callback functions that are triggered by matched events and handle them in a way they see fit, similar to how messages received on a topic are handled.

* publisher: this event happens when it finds a subscription which matches the topic and has compatible QoS or a connected subscription is disconnected.
* subscription: this event happens when it finds a publisher which matches the topic and has compatible QoS or a connected publisher is disconnected.

See the tracking issue at https://github.com/ros2/rmw/issues/330 for more information.

* C++ Demo of Matched Events: https://github.com/ros2/demos/blob/iron/demo_nodes_cpp/src/events/matched_event_detect.cpp
* Python Demo of Matched Events: https://github.com/ros2/demos/blob/iron/demo_nodes_py/demo_nodes_py/events/matched_event_detect.py

External configuration services of loggers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is now possible to configure node logger levels remotely via a service.
When the ``enable_logger_service`` option is enabled during node creation, the ``set_logger_levels`` and ``get_logger_levels`` services will be available.

Be advised that the ``enable_logger_service`` option is disabled by default, so the user needs to enable this option on node creation.

See https://github.com/ros2/ros2/issues/1355 for more information.

Type Description Distribution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is now possible to communicate information about the types of ROS 2 messages, so that systems with potentially-different types of the same name may discover their compatibility more transparently.
This umbrella of capabilities, which is defined by a subset of REP-2011: Evolving Message Types, has had many parts land in Iron.

First, the introduction of the new package `type_description_interfaces <https://index.ros.org/p/type_description_interfaces/github-ros2-rcl_interfaces/#iron>`__ provides a common way to communicate the descriptions of ROS 2 communication interface types (msg, srv, action).

Next, a method to hash type descriptions has been decided on, the ROS Interface Hashing Standard (RIHS) - starting with the first version RIHS01.
RIHS hashes are automatically calculated for all compiled ROS types at build time, and baked into the generated code so that they can be inspected.
These hashes are also communicated automatically during discovery, and included in ``rmw_topic_endpoint_info_t`` for graph introspection queries such as ``get_publishers_info_by_topic``.

The full ``TypeDescription`` data structure, as well as the raw source text (such as ``.msg`` file) that were used to generate it are now baked in by default to the message libraries, so they can be used by ``typesupport`` or end users.
While we expect this data to provide value to most users, some users trying to minimize bytes in their install space can disable the feature when building ROS 2 Core by defining the CMake variable ``ROSIDL_GENERATOR_C_DISABLE_TYPE_DESCRIPTION_CODEGEN``.

Finally, the new service ``type_description_interfaces/GetTypeDescription.srv`` has been defined to allow nodes, on encountering an unknown RIHS type hash, to request the full definition from the node advertising that type.
Work is in progress to provide this feature natively in ROS 2 Nodes, as an optional switch on node construction.
This feature has not yet shipped, but is expected to be backported into Iron sometime mid-2023.
Meanwhile, user nodes could implement this service indepedently, using the stable service interface.

See `REP 2011 <https://github.com/ros-infrastructure/rep/pull/358>`__ for the design proposal.
See `Type Description Distribution <https://github.com/ros2/ros2/issues/1159>`__ for tracking development on the feature set.

Dynamic Types and Dynamic Messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Alongside the type description distribution feature mentioned above, is the ability to construct and access dynamically created types at runtime (i.e., dynamic types).
This feature is available in Iron for Fast DDS and ``rcl``, with new ``rmw`` interfaces for supporting the taking of messages as dynamic messages (i.e., messages built from or following the structure of the dynamic type).

First, utilities were introduced into `rosidl <https://index.ros.org/r/rosidl/github-ros2-rosidl/#iron>`__ to aid in the construction and manipulation of type descriptions.

Next, the `rosidl_dynamic_typesupport <https://index.ros.org/r/rosidl_dynamic_typesupport/github-ros2-rosidl_dynamic_typesupport/#iron>`__ package was written and provides a middleware-agnostic interface to construct dynamic types and dynamic messages at runtime.
Types can be constructed at runtime either programmatically, or by parsing a ``type_description_interfaces/TypeDescription`` message.

.. note::

   The ``rosidl_dynamic_typesupport`` library requires serialization support libraries to implement the middleware-specific dynamic type behavior.
   A serialization support library for Fast DDS was implemented in `rosidl_dynamic_typesupport_fastrtps <https://index.ros.org/r/rosidl_dynamic_typesupport_fastrtps/github-ros2-rosidl_dynamic_typesupport_fastrtps/#iron>`__.
   Ideally more middlewares will implement support libraries, expanding the number of middlewares that support this feature.

Finally, to support the use of dynamic types and dynamic messages, new methods were added to `rmw <https://index.ros.org/r/rmw/github-ros2-rmw/#iron>`__ and `rcl <https://index.ros.org/r/rcl/github-ros2-rcl/#iron>`__ that support:

- The ability to obtain of middleware-specific serialization support
- The ability to construct message type support at runtime that use dynamic types
- The ability to take dynamic messages using dynamic type

Work is in progress to enable the use of dynamic types to create subscriptions in the client libraries (see the ``rclcpp`` issue below), though it is uncertain when the feature will land or be backported.
This will allow users to subscribe to topics whose type descriptions are only known at runtime.
In the meantime, users may write their own subscriptions that subscribe to dynamic types by using the new ``rmw`` and ``rcl`` features introduced as part of this feature set.

See `REP 2011 <https://github.com/ros-infrastructure/rep/pull/358>`__ for the design proposal.
See `Dynamic Subscription <https://github.com/ros2/ros2/issues/1374>`__ for tracking development on the feature set, with `rclcpp <https://github.com/ros2/rclcpp/pull/2176>`__ needing the bulk of the work.

``launch``
^^^^^^^^^^

``PythonExpression`` now supports importing modules
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to have a launch ``PythonExpression`` import modules before performing the evaluation.
This can be useful for pulling in additional functionality to be used when evaluating an expression.

See https://github.com/ros2/launch/pull/655 for more information.

``ReadyToTest`` can be called from an event handler
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to register an event handler that uses ``ReadyToTest`` in its output.
This can be useful for doing things like downloading an asset before allowing a test to run.

See https://github.com/ros2/launch/pull/665 for more information.

Addition of ``AnySubstitution`` and ``AllSubstitution``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to specify a substitution to happen when any of the input arguments are true (``AnySubstitution``), or when all of the input arguments are true (``AllSubstitution``).

See https://github.com/ros2/launch/pull/649 for more details.

Addition of a new substitution to get the launch logging directory
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to use a substitution called ``LaunchLogDir`` to get the current logging directory for launch.

See https://github.com/ros2/launch/pull/652 for more details.

``launch_ros``
^^^^^^^^^^^^^^

Add a ``LifecycleTransition`` action
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to send a transition signal to a lifecycle node via the new ``LifeCycleTransition`` action.

See https://github.com/ros2/launch_ros/pull/317 for more information.

Add a ``SetROSLogDir`` action
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to configure the directory used for logging via the ``SetROSLogDir`` action.

See https://github.com/ros2/launch_ros/pull/325 for more information.

Ability to specify a condition to a ``ComposableNode``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to specify a condition that must be satisfied in order for a ``ComposableNode`` to be inserted into its container.

See https://github.com/ros2/launch_ros/pull/311 for more information.

``launch_testing``
^^^^^^^^^^^^^^^^^^

Timeout for process startup is now configurable
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Prior to this release, the ``ReadyToTest`` action would wait exactly 15 seconds for processes to start up.
If the processes took longer than that, they would fail.
There is now a new decorator called ``ready_to_test_action_timeout`` that allows the user to configure the amount of time to wait for the processes to start.

See https://github.com/ros2/launch/pull/625 for more information.

``rclcpp``
^^^^^^^^^^

Addition of a new paradigm for handling ``Node`` and ``LifecycleNode``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``Node`` and ``LifecycleNode`` classes are related in that they both provide the same base set of methods (though ``LifecycleNode`` provides additional methods as well).
Due to various implementation considerations, they are not derived from a common base class.

This has led to some trouble for downstream code that wants to accept either a ``Node`` or a ``LifecycleNode``.
One solution is to have two method signatures, one that accepts a ``Node`` and one that accepts a ``LifecycleNode``.
The other, recommended solution is to have a method that accepts the ""node interfaces"" pointers that can be accessed from both classes, e.g.

.. code-block:: C++

   void do_thing(rclcpp::node_interfaces::NodeGraphInterface graph)
   {
     fprintf(stderr, ""Doing a thing\n"");
   }

   void do_thing(rclcpp::Node::SharedPtr node)
   {
     do_thing(node->get_node_graph_interface());
   }

   void do_thing(rclcpp::LifecycleNode::SharedPtr node)
   {
     do_thing(node->get_node_graph_interface());
   }

This works, but can get a bit unwieldy when many node interfaces are needed.
To make this a bit better, there is now a new ``NodeInterfaces`` class that can be constructed to contain the interfaces, and then be used by other code.

There are examples on how to use this in https://github.com/ros2/rclcpp/pull/2041.

Introduction of a new executor type: the Events Executor
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``EventsExecutor`` from iRobot has been merged into the main ``rclcpp`` codebase.
This alternative executor implementation uses event-driven callbacks from the middleware implementations to fire callbacks at the ``rclcpp`` layer.
In addition to the push-based model, the ``EventsExecutor`` also moves timer management into a separate thread, which can allow for more accurate results and lower overhead, especially with many timers.

The ``EventsExecutor`` has a substantial set of documentation and use-in-practice that make it a strong candidate for inclusion in the ``rclcpp`` codebase.
For information about the initial implementation proposal as well as performance benchmarks, see https://discourse.ros.org/t/ros2-middleware-change-proposal/15863.
For more information about the design, see the design PR: https://github.com/ros2/design/pull/305.

Since the API is the same, trying the ``EventsExecutor`` is as straightforward as replacing your current Executor implementation (eg. ``SingleThreadedExecutor``):

.. code-block:: C++

    #include <rclcpp/experimental/executors/events_executor/events_executor.hpp>
    using rclcpp::experimental::executors::EventsExecutor;

    EventsExecutor executor;
    executor.add_node(node);
    executor.spin();

**Note** The ``EventsExecutor`` and ``TimersManager`` are currently in the ``experimental`` namespace.
While it has been used as a standalone implementation for some time https://github.com/irobot-ros/events-executor, it was decided to use the ``experimental`` namespace for at least one release to give latitude in changing the API within the release.
Use caution as it will not be subject to the same API/ABI guarantees that the non-experimental code has.

``rclpy``
^^^^^^^^^

Ability to wait for another node to join the graph
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to wait for another node to join the network graph with code like the following:

.. code-block:: Python

  node.wait_for_node('/fully_qualified_node_name')

See https://github.com/ros2/rclpy/pull/930 for more information.

Implementation of ``AsyncParameterClient``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``rclpy`` now has an ``AsyncParameterClient`` class, bringing it to feature parity with ``rclcpp``.
This class is used to perform parameter actions on a remote node without blocking the calling node.

See https://github.com/ros2/rclpy/pull/959 for more information and examples.

Subscription callbacks can now optionally get the message info
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to register for a subscription callback with a function signature that takes both the message, and the message info, like:

.. code-block:: Python

  def msg_info_cb(msg, msg_info):
      print('Message info:', msg_info)

  node.create_subscription(msg_type=std_msgs.msg.String, topic='/chatter', qos_profile=10, callback=msg_info_cb)

The message info structure contains various pieces of information like the sequence number of the message, the source and received timestamps, and the GID of the publisher.

See https://github.com/ros2/rclpy/pull/922 for more information.

Optional argument that hides assertions for messages class
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
All message classes now include a new optional argument that allows the hiding of assertions for each field type from the message.
By default, assertions are hidden, which provides a performance improvement during runtime.
In order to enable the assertions for development/debugging purposes, you are given two choices:

1. Define the environment variable ``ROS_PYTHON_CHECK_FIELDS`` to ``'1'`` (this would affect all the messages in your project):

.. code-block:: Python

  import os
  from std_msgs.msg import String

  os.environ['ROS_PYTHON_CHECK_FIELDS'] = '1'
  new_message=String()

2. Select the specific behavior for a single message by explicitly defining the new argument in the constructor:

.. code-block:: Python

  from std_msgs.msg import String

  new_message=String(check_fields=True)

See https://github.com/ros2/rosidl_python/pull/194 for more information.

``ros2param``
^^^^^^^^^^^^^

Option to timeout when waiting for a node with ``ros2 param``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to have the various ``ros2 param`` commands timeout by passing ``--timeout`` to the command.

See https://github.com/ros2/ros2cli/pull/802 for more information.

Deprecated options were removed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``--output-dir`` and ``--print`` options with ``dump`` command have been removed.

See https://github.com/ros2/ros2cli/pull/824 for more information.

``ros2topic``
^^^^^^^^^^^^^

``now`` as keyword for ``builtin_interfaces.msg.Time`` and ``auto`` for ``std_msgs.msg.Header``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``ros2 topic pub`` now allows to set a ``builtin_interfaces.msg.Time`` message to the current time via the ``now`` keyword.
Similarly, a ``std_msg.msg.Header`` message will be automatically generated when passed the keyword ``auto``.
This behavior matches that of ROS 1's ``rostopic`` (http://wiki.ros.org/ROS/YAMLCommandLine#Headers.2Ftimestamps)

Related PR: `ros2/ros2cli#749 <https://github.com/ros2/ros2cli/pull/749>`_

``ros2 topic pub`` can be configured to wait a maximum amount of time
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The command ``ros2 topic pub -w 1`` will wait for at least that number of subscribers before publishing a message.
This release adds in a ``--max-wait-time`` option so that the command will only wait a maximum amount of time before quitting if no subscribers are seen.

See https://github.com/ros2/ros2cli/pull/800 for more information.

``ros2 topic echo`` can be configured to wait a maximum amount of time
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The command ``ros2 topic echo`` now accepts a ``--timeout`` option, which controls the maximum amount of time that the command will wait for a publication to happen.

See https://github.com/ros2/ros2cli/pull/792 for more information.

Deprecated option was removed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``--lost-messages`` option with ``echo`` command has been removed.

See https://github.com/ros2/ros2cli/pull/824 for more information.

Changes since the Humble release
--------------------------------

Change to the default console logging file flushing behavior
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This specifically applies to the default ``spdlog`` based logging backend in ROS 2, implemented in ``rcl_logging_spdlog``.
Log file flushing was changed to flush every time an ""error"" log message is used, e.g. each ``RCLCPP_ERROR()`` call, and also periodically every five seconds.

Previously, ``spdlog`` was used without configuring anything other than creating the sink for logging to a file.

We tested the change and did not find that the CPU overhead was significant, even on machines with slow disks (e.g. sd cards).
However, if this change is causing you problems, you can get the old behavior by setting the ``RCL_LOGGING_SPDLOG_EXPERIMENTAL_OLD_FLUSHING_BEHAVIOR=1`` environment variable.

Later we would like to have support for a full configuration file (see: https://github.com/ros2/rcl_logging/issues/92), giving you more flexibility in how the logging is done, but that is work that is only planned right now.

  Therefore, **this environment variable should be considered experimental and subject to removal without deprecation in the future**, when we add config file support for the ``rcl_logging_spdlog`` logging backend.

See this pull request for more details about the change: https://github.com/ros2/rcl_logging/pull/95

``ament_cmake_auto``
^^^^^^^^^^^^^^^^^^^^

Include dependencies are now marked as SYSTEM
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

When using ``ament_auto_add_executable`` or ``ament_auto_add_library``, dependencies are now automatically added as ``SYSTEM``.
This means that warnings in the header files of the dependencies will not be reported.

See https://github.com/ament/ament_cmake/pull/385 for more details.

``ament_cmake_nose``
^^^^^^^^^^^^^^^^^^^^

Package has been deprecated and removed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The Python ``nose`` package has long been deprecated.
Since none of the open-source packages currently released into Humble or Rolling currently depend on it, this release deprecates and removes the ament wrapper around it.

See https://github.com/ament/ament_cmake/pull/415 for more information.

``ament_lint``
^^^^^^^^^^^^^^

Files can be excluded from linter checks
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Certain files can now be excluded from linter checks by setting the ``AMENT_LINT_AUTO_FILE_EXCLUDE`` CMake variable before calling ``ament_lint_auto_find_test_dependencies``.

See https://github.com/ament/ament_lint/pull/386 for more information.

``camera_info_manager``
^^^^^^^^^^^^^^^^^^^^^^^

Lifecycle node support
""""""""""""""""""""""""""""""""""""""""""""

``camera_info_manager`` now supports lifecycle nodes in additional to regular ROS 2 nodes.

See https://github.com/ros-perception/image_common/pull/190 for more information.

``launch``
^^^^^^^^^^

``LaunchConfigurationEquals`` and ``LaunchConfigurationNotEquals`` are deprecated
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``LaunchConfigurationEquals`` and ``LaunchConfigurationNotEquals`` conditions are deprecated, and will be removed in a future release.
Instead, the more universal ``Equals`` and ``NotEquals`` substitutions should be used instead.

See https://github.com/ros2/launch/pull/649 for more details.

``launch_ros``
^^^^^^^^^^^^^^

Renamed classes which used ``Ros`` in the name to use ``ROS`` in line with PEP8
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Classes that were changed:

* ``launch_ros.actions.RosTimer`` -> ``launch_ros.actions.ROSTimer``
* ``launch_ros.actions.PushRosNamespace`` -> ``launch.actions.PushROSNamespace``

The old class names are still there, but will be deprecated.

See https://github.com/ros2/launch_ros/pull/326 for more information.

``launch_xml``
^^^^^^^^^^^^^^

Expose ``emulate_tty`` to XML frontend
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It has been possible for several releases to have the ``launch`` Python code use pseudo-terminals to emulate a TTY (and hence do things like print colors).
That functionality is now available in the XML frontend by passing the ``emulate_tty`` argument to an executable command.

See https://github.com/ros2/launch/pull/669 for more information.

Expose ``sigterm_timeout`` and ``sigkill_timeout`` to XML frontend
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It has been possible for several releases to configure the maximum timeout value for the SIGTERM and SIGKILL signals in the ``launch`` Python code.
That functionality is now available in the XML frontend by passing the ``sigterm_timeout`` or ``sigkill_timeout`` argument to an executable command.

See https://github.com/ros2/launch/pull/667 for more information.

``launch_yaml``
^^^^^^^^^^^^^^^

Expose ``emulate_tty`` to YAML frontend
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It has been possible for several releases to have the ``launch`` Python code use pseudo-terminals to emulate a TTY (and hence do things like print colors).
That functionality is now available in the YAML frontend by passing the ``emulate_tty`` argument to an executable command.

See https://github.com/ros2/launch/pull/669 for more information.

Expose ``sigterm_timeout`` and ``sigkill_timeout`` to YAML frontend
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It has been possible for several releases to configure the maximum timeout value for the SIGTERM and SIGKILL signals in the ``launch`` Python code.
That functionality is now available in the YAML frontend by passing the ``sigterm_timeout`` or ``sigkill_timeout`` argument to an executable command.

See https://github.com/ros2/launch/pull/667 for more information.

``message_filters``
^^^^^^^^^^^^^^^^^^^

New approximate time policy
""""""""""""""""""""""""""""""""""""""""""""""""""""""

Add in a simpler approximate time policy called ``ApproximateEpsilonTime``.
This time policy works like ``ExactTime``, but allows timestamps being within a epsilon tolerance.
See https://github.com/ros2/message_filters/pull/84 for more information.

New upsampling time policy
""""""""""""""""""""""""""""""""""""""""""""""""""""

Adds in a new time policy called ``LatestTime``.
It can synchronize up to 9 messages by their rates with upsampling via zero-order-hold.
See https://github.com/ros2/message_filters/pull/73 for more information.

``rcl_yaml_param_parser``
^^^^^^^^^^^^^^^^^^^^^^^^^

Support for YAML ``!!str`` syntax in parameter files
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to force the ROS parameter file parser to interpret a field as a string using the YAML ``!!str`` syntax.
See https://github.com/ros2/rcl/pull/999 for more information.

``rclcpp``
^^^^^^^^^^

Default number of threads for multi-threaded executor has been changed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

If the user doesn't specify otherwise, the default number of threads for the multi-threaded executor will be set to the number of CPUs on the machine.
If the underlying OS doesn't support getting this information, it will be set to 2.

See https://github.com/ros2/rclcpp/pull/2032 for more information.

A warning is now printed when QoS of KEEP_LAST is specified with a depth of 0
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Specifying a QoS of KEEP_LAST with a depth of 0 is a nonsensical arrangement, since the entity wouldn't be able to send or receive any data.
``rclcpp`` will now print a warning if this combination is specified, but will still continue on and let the underlying middleware choose a sane value (generally a depth of 1).

See https://github.com/ros2/rclcpp/pull/2048 for more information.

Deprecated ``RCLCPP_SCOPE_EXIT`` macro was removed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

In Humble, the macro ``RCLCPP_SCOPE_EXIT`` was deprecated in favor of ``RCPPUTILS_SCOPE_EXIT``.
In Iron, the ``RCLCPP_SCOPE_EXIT`` macro has been completely removed.

``rclpy``
^^^^^^^^^

Default number of threads for multi-threaded executor has been changed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

If the user doesn't specify otherwise, the default number of threads for the multi-threaded executor will be set to the number of CPUs on the machine.
If the underlying OS doesn't support getting this information, it will be set to 2.

See https://github.com/ros2/rclpy/pull/1031 for more information.

A warning is now printed when QoS of KEEP_LAST is specified with a depth of 0
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Specifying a QoS of KEEP_LAST with a depth of 0 is a nonsensical arrangement, since the entity wouldn't be able to send or receive any data.
``rclpy`` will now print a warning if this combination is specified, but will still continue on and let the underlying middleware choose a sane value (generally a depth of 1).

See https://github.com/ros2/rclpy/pull/1048 for more information.

Time and Duration no longer raise exception when compared to another type
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

It is now possible to compare ``rclpy.time.Time`` and ``rclpy.duration.Duration`` to other types without getting exceptions.
If the types are not comparable, the comparison returns ``False``.
Note that this is a behavior change from previous releases.

.. code-block:: Python

  print(None in [rclpy.time.Time(), rclpy.duration.Duration()])  # Prints ""False"" instead of raising TypeError

See https://github.com/ros2/rclpy/pull/1007 for more information.

``rcutils``
^^^^^^^^^^^

Improve the performance of message logging
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The code used to output a log message when ``RCUTILS_LOG_*`` or ``RCLCPP_*`` was optimized to reduce overhead.
These log messages should now be more efficient, though they should still not be called at high rates.
See https://github.com/ros2/rcutils/pull/381, https://github.com/ros2/rcutils/pull/372, https://github.com/ros2/rcutils/pull/369, and https://github.com/ros2/rcutils/pull/367 for more information.

Deprecated ``rcutils/get_env.h`` header was removed
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

In Humble, the header ``rcutils/get_env.h`` was deprecated in favor of ``rcutils/env.h``.
In Iron, the ``rcutils/get_env.h`` header been completely removed.

``rmw``
^^^^^^^

Change the GID storage to 16 bytes
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The GID in the RMW layer is meant to be a globally unique identifier for writers in the ROS graph.
Previously, this was erroneously set to 24 bytes based on a bug in an old RMW implementation.
But the ``rmw`` package should define this, and all of the implementations should conform to that.
Thus, this release defines it as 16 bytes (the DDS standard), and changes all implementations to use that definition.

See https://github.com/ros2/rmw/pull/345 and the (closed, but relevant) https://github.com/ros2/rmw/pull/328 for more information.

``rmw_dds_common``
^^^^^^^^^^^^^^^^^^

Change the GID storage to 16 bytes
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Along with the change in the ``rmw`` layer, change the message that sends out GID information to 16 bytes.

See https://github.com/ros2/rmw_dds_common/pull/68 for more information.

``ros2topic``
^^^^^^^^^^^^^

``ros2 topic hz/bw/pub`` now respect ``use_sim_time``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

When running under simulation, the ROS 2 ecosystem generally gets its time from a ``/clock`` topic published by the simulator (rather than using the system clock).
ROS 2 nodes are typically informed of this change by setting the ``use_sim_time`` parameter on the node.
The node created by the ``ros2 topic`` commands ``hz``, ``bw``, and ``pub`` now respect that parameter and will use simulation time as appropriate.

See https://github.com/ros2/ros2cli/pull/754 for more information.

``rosbag2``
^^^^^^^^^^^

Change default bag file type to ``mcap``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Prior to this release, by default rosbag2 would record data into sqlite3 databases.
During testing, it was found that in many cases this was not performant enough and lacked certain features desirable for offline processing.

To meet these needs, a new bag format (influenced by the original ROS 1 bag file format) called ``mcap`` was developed.
This bag file format has many of the missing features from the sqlite3 file format, and should also be more performant.

This release switches to using ``mcap`` as the default file format for writing new bags.
The old ``sqlite3`` file format is still available and can be selected by the user for writing if desired.
This release also allows playing back data from either the ``sqlite3`` file format or the ``mcap`` file format.

See https://github.com/ros2/rosbag2/pull/1160 for more information.

Store message definitions in bag files with SQLite3 plugin
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Now we support saving message definitions to the ``sqlite3`` database file in the same format
as we are saving it to the ``mcap`` file.
This opens an opportunity for third-party tools to have
the ability to deserialize rosbag2 files without having the correct version of all the original
.msg files on the machine that is decoding the bag file recorded with ``sqlite3`` plugin.

See https://github.com/ros2/rosbag2/issues/782 and https://github.com/ros2/rosbag2/pull/1293 for
more information.


New playback and recording controls
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Several pull requests have been added to enhance the user's control over playback of bags.
Pull request `960 <https://github.com/ros2/rosbag2/pull/960>`_ adds the ability to play bag for
a specified number of seconds.
And pull request `1005 <https://github.com/ros2/rosbag2/pull/1005>`_ allows to play bag until specified timestamp.
Another pull request `1007 <https://github.com/ros2/rosbag2/pull/1007>`_ adds the ability to
stop playback remotely via service call.
Stop will unpause player if it was in pause mode, stop playback and force exit from play() method if it was in progress.

Managing recording via service calls
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

There are new options to control the recording process from remote nodes.
The pull request `1131 <https://github.com/ros2/rosbag2/pull/1131>`_ adds the ability to pause and
resume recording via service calls.
Another pull request `1115 <https://github.com/ros2/rosbag2/pull/1115>`_ adds the ability to split
bags during recording by sending service call.

Filtering topics via regular expression during playback
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Users sometimes need to replay only a subset of topics from recorded bags and the following two pull request
adds such capability.
Pull request `1034 <https://github.com/ros2/rosbag2/pull/1034>`_ adds a new option
``--topics-regex`` that allows filtering topics via regular expressions.
The ``--topics-regex`` option accepts multiple regular expressions separated by space.
And pull request `1046 <https://github.com/ros2/rosbag2/pull/1046>`_ adds the ability to exclude some
certain topics from being replayed by providing regular expression in a new ``--exclude``
(and ``-x``) option.

Allow plugins to register their own CLI verb arguments
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Pull request `1209 <https://github.com/ros2/rosbag2/pull/1209>`_ adds the ability for ``rosbag2`` plugins to
register an optional Python entrypoint providing plugin-specific CLI argument values.
As a result the command line option ``--storage-preset-profile`` for ``ros2 bag record`` verb will have
different valid options depending on the underlying storage plugin.

Other changes
""""""""""""""""""""""""""

The pull request `1038 <https://github.com/ros2/rosbag2/pull/1038>`_ adds the ability to record
any key/value pair in 'custom' field in metadata.yaml file.
It is useful when users need to save some hardware specific id or coordinates where the recording was captured.
And pull request `1180 <https://github.com/ros2/rosbag2/pull/1180>`_ adds an option to change the underlying
node name for the recorder via providing the new command line ``--node-name`` option.
This option might be used for creating remote distributed recording with multiple rosbag2 recorder instances.
It provides the ability to send service calls for managing the recording process to the dedicated
rosbag2 recorder instances.

``rosidl_python``
^^^^^^^^^^^^^^^^^

Modification of content of ``__slots__`` attribute
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

So far, the attribute ``__slots__`` from the python message classes, have been used as the member that contains the field names of the message.
In Iron, this attribute no longer contains only the field names from the message structure, but the field names for all the class members.
Therefore, users shouldn't rely on this attribute to retrieve the field names information, instead, users should retrieve it using the method ``get_field_and_field_types()``.

See https://github.com/ros2/rosidl_python/pull/194 for more information.

``rviz``
^^^^^^^^

Map display can now be shown as binary
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The RViz map display can now display the map as binary, with a settable threshold.
This is useful in some cases to inspect maps or in combination with planners that have a settable threshold.

See https://github.com/ros2/rviz/pull/846 for more information.

Camera display plugin respects the ROI in the CameraInfo message
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The CameraDisplay plugin now honors the region-of-interest (ROI) settings in the CameraInfo message, if it is provided.
This accounts for the fact that an image was cropped by the camera driver to reduce the bandwidth.

See https://github.com/ros2/rviz/pull/864 for more information.

Binary STL files from SOLIDWORKS work without error
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

A change was made to the STL loader such that it accepts binary STL files from SOLIDWORKS that have the word ""solid"" in them.
This technically violates the STL specification, but is common enough that a special case is added to handle these files.

See https://github.com/ros2/rviz/pull/917 for more information.

``tracetools``
^^^^^^^^^^^^^^

Tracing instrumentation is now included by default on Linux
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ROS 2 core has had tracing instrumentation for a while now.
However, it was compiled out by default.
To get the instrumentation, the LTTng tracer had to be manually installed before rebuilding ROS 2 from source.
In Iron, the tracing instrumentation and tracepoints are included by default; the LTTng tracer is therefore now a ROS 2 dependency.

Note that this only applies to Linux.

See https://github.com/ros2/ros2_tracing/pull/31 and https://github.com/ros2/ros2/issues/1177 for more information.
See :doc:`this how-to guide to remove the instrumentation (or add the instrumentation with Humble and older) <../How-To-Guides/Building-ROS-2-with-Tracing>`.

New tracepoints for ``rclcpp`` intra-process are added
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

New tracepoints have been added to support ``rclcpp`` intra-process communication.
This allows the evaluation of the time between the message publishing and the callback start in intra-process communication.

See https://github.com/ros2/ros2_tracing/pull/30 and https://github.com/ros2/rclcpp/pull/2091 for more information.

Known Issues
------------

* ``rmw_connextdds`` does not work with Windows Binary release packages.
  RTI is not longer distributing ``RTI ConnextDDS 6.0.1`` which was used by the packaging jobs to create the binaries for Windows.
  Instead they now distribute ``RTI ConnextDDS 6.1.0`` which is ABI incompatible with the generated binaries.
  The solution is to rely on source builds of ROS 2 and ``rmw_connextdds`` on Windows.

* ``sros2`` on Windows requires users to downgrade the ``cryptography`` python module to ``cryptography==38.0.4`` as discussed `here <https://github.com/ros2/sros2/issues/285>`_.

* ``ros1_bridge`` does not work with ROS Noetic packages from `upstream Ubuntu <https://packages.ubuntu.com/jammy/ros-core-dev>`_.  The suggested workaround is to build ROS Noetic from sources, then build the ``ros1_bridge`` using that.

Release Timeline
----------------

    November, 2022 - Platform decisions
        REP 2000 is updated with the target platforms and major dependency versions.

    By January, 2023 - Rolling platform shift
        Build farm is updated with the new platform versions and dependency versions for Iron Irwini (if necessary).

    Mon. April 10, 2023 - Alpha + RMW freeze
        Preliminary testing and stabilization of ROS Base [1]_ packages, and API and feature freeze for RMW provider packages.

    Mon. April 17, 2023 - Freeze
        API and feature freeze for ROS Base [1]_ packages in Rolling Ridley.
        Only bug fix releases should be made after this point.
        New packages can be released independently.

    Mon. April 24, 2023 - Branch
        Branch from Rolling Ridley.
        ``rosdistro`` is reopened for Rolling PRs for ROS Base [1]_ packages.
        Iron development shifts from ``ros-rolling-*`` packages to ``ros-iron-*`` packages.

    Mon. May 1, 2023 - Beta
        Updated releases of ROS Desktop [2]_ packages available.
        Call for general testing.

    Mon. May 15, 2023 - Release Candidate
        Release Candidate packages are built.
        Updated releases of ROS Desktop [2]_ packages available.

    Thu. May 18, 2023 - Distro Freeze
        Freeze rosdistro.
        No PRs for Iron on the ``rosdistro`` repo will be merged (reopens after the release announcement).

    Tue. May 23, 2023 - General Availability
        Release announcement.
        ``rosdistro`` is reopened for Iron PRs.

.. [1] The ``ros_base`` variant is described in `REP 2001 (ros-base) <https://www.ros.org/reps/rep-2001.html#ros-base>`_.
.. [2] The ``desktop`` variant is described in `REP 2001 (desktop-variants) <https://www.ros.org/reps/rep-2001.html#desktop-variants>`_.

Development progress
--------------------

For progress on the development and release of Iron Irwini, see `the tracking GitHub issue <https://github.com/ros2/ros2/issues/1298>`__.

For the broad process followed by Iron Irwini, see the :doc:`process description page <Release-Process>`.
","What is the main purpose of adding the ""RightToTest"" in the launch plugin control options in the latest release?"
"Dashing Diademata (``dashing``)
===============================

.. contents:: Table of Contents
   :depth: 2
   :local:

*Dashing Diademata* is the fourth release of ROS 2.

Supported Platforms
-------------------

Dashing Diademata is primarily supported on the following platforms:

Tier 1 platforms:

* Ubuntu 18.04 (Bionic): ``amd64`` and ``arm64``
* Mac macOS 10.12 (Sierra)
* Windows 10 (Visual Studio 2019)

Tier 2 platforms:

* Ubuntu 18.04 (Bionic): ``arm32``

Tier 3 platforms:

* Debian Stretch (9): ``amd64``, ``arm64`` and ``arm32``
* OpenEmbedded Thud (2.6) / webOS OSE: ``arm32`` and ``x86``

For more information about RMW implementations, compiler / interpreter versions, and system dependency versions see `REP 2000 <https://www.ros.org/reps/rep-2000.html#dashing-diademata-may-2019-may-2021>`__.

Installation
------------

`Install Dashing Diademata <../../dashing/Installation.html>`__

New features in this ROS 2 release
----------------------------------

A few features and improvements we would like to highlight:

* :doc:`Components <../Tutorials/Intermediate/Composition>` are now the recommended way to write your node.
  They can be used standalone as well as being composed within a process and both ways are fully support from ``launch`` files.
* The :doc:`intra-process communication <../Tutorials/Demos/Intra-Process-Communication>` (C++ only) has been improved - both in terms of latency as well as minimizing copies.
* The Python client library has been updated to match most of the C++ equivalent and some important bug fixes and improvements have landed related to memory usage and performance.
* Parameters are now a complete alternative to ``dynamic_reconfigure`` from ROS 1 including constraints like ranges or being read-only.
* By relying on (a subset of) `IDL 4.2 <https://www.omg.org/spec/IDL/4.2>`__ for the message generation pipeline it is now possible to use ``.idl`` files (beside ``.msg`` / ``.srv`` / ``.action`` files).
  This change comes with support for optional UTF-8 encoding for ordinary strings as well as UTF-16 encoded multi-byte strings (see `wide strings design article <https://design.ros2.org/articles/wide_strings.html>`__).
* Command line tools related to ``actions`` and ``components``.
* Support for Deadline, Lifespan & Liveliness quality of service settings.
* MoveIt 2 `alpha release <https://github.com/AcutronicRobotics/moveit2/releases/tag/moveit_2_alpha>`__.

Please see the `Dashing meta ticket <https://github.com/ros2/ros2/issues/607>`__ on GitHub, which contains more information as well as references to specific tickets with additional details.


Changes since the Crystal release
---------------------------------

Declaring Parameters
^^^^^^^^^^^^^^^^^^^^

There have been some changes to the behavior of parameters starting in Dashing, which have also lead to some new API's and the deprecation of other API's.
See the ``rclcpp`` and ``rclpy`` sections below for more information about API changes.

Getting and Setting Undeclared Parameters
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

As of Dashing, parameters now need to be declared before being accessed or set.

Before Dashing, you could call ``get_parameter(name)`` and get either a value, if it had been previously set, or a parameter of type ``PARAMETER_NOT_SET``.
You could also call ``set_parameter(name, value)`` at any point, even if the parameter was previously unset.

Since Dashing, you need to first declare a parameter before getting or setting it.
If you try to get or set an undeclared parameter you will either get an exception thrown, e.g. ParameterNotDeclaredException, or in certain cases you will get an unsuccessful result communicated in a variety of ways (see specific functions for more details).

However, you can get the old behavior (mostly, see the note in the next paragraph) by using the ``allow_undeclared_parameters`` option when creating your node.
You might want to do this in order to avoid code changes for now, or in order to fulfill some uncommon use cases.
For example, a ""global parameter server"" or ""parameter blackboard"" may want to allow external nodes to set new parameters on itself without first declaring them, so it may use the ``allow_undeclared_parameters`` option to accomplish that.
In most cases, however, this option is not recommended because it makes the rest of the parameter API less safe to bugs like parameter name typos and ""use before set"" logical errors.

Note that using ``allow_undeclared_parameters`` will get you most of the old behavior specifically for ""get"" and ""set"" methods, but it will not revert all the behavior changes related to parameters back to how it was for ROS Crystal.
For that you need to also set the ``automatically_declare_parameters_from_overrides`` option to ``true``, which is described below in :ref:`Parameter Configuration using a YAML File <parameter-configuration-using-a-yaml-file>`.

Declaring a Parameter with a ParameterDescriptor
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Another benefit to declaring your parameters before using them, is that it allows you to declare a parameter descriptor at the same time.

Now when declaring a parameter you may include a custom ``ParameterDescriptor`` as well as a name and default value.
The ``ParameterDescriptor`` is defined as a message in ``rcl_interfaces/msg/ParameterDescriptor`` and contains meta data like ``description`` and constraints like ``read_only`` or ``integer_range``.
These constraints can be used to reject invalid values when setting parameters and/or as hints to external tools about what values are valid for a given parameter.
The ``read_only`` constraint will prevent the parameter's value from changing after being declared, as well as prevent if from being undeclared.

For reference, here's a link to the ``ParameterDescriptor`` message as of the time of writing this:

https://github.com/ros2/rcl_interfaces/blob/0aba5a142878c2077d7a03977087e7d74d40ee68/rcl_interfaces/msg/ParameterDescriptor.msg#L1

.. _parameter-configuration-using-a-yaml-file:

Parameter Configuration using a YAML File
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

As of Dashing, parameters in a YAML configuration file, e.g. passed to the node via the command line argument ``__params:=``, are only used to override a parameter's default value when declaring the parameter.

Before Dashing, any parameters you passed via a YAML file would be implicitly set on the node.

Since Dashing, this is no longer the case, as parameters need to be declared in order to appear on the node to external observers, like ``ros2 param list``.

The old behavior may be achieved using the ``automatically_declare_parameters_from_overrides`` option when creating a node.
This option, if set to ``true``, will automatically declare all parameters in the input YAML file when the node is constructed.
This may be used to avoid major changes to your existing code or to serve specific use cases.
For example, a ""global parameter server"" may want to be seeded with arbitrary parameters on launch, which it could not have declared ahead of time.
Most of the time, however, this option is not recommended, as it may lead to setting a parameter in a YAML file with the assumption that the node will use it, even if the node does not actually use it.

In the future we hope to have a checker that will warn you if you pass a parameter to a node that it was not expecting.

The parameters in the YAML file will continue to influence the value of parameters when they are first declared.

ament_cmake
^^^^^^^^^^^

The CMake function ``ament_index_has_resource`` was returning either ``TRUE`` or ``FALSE``.
As of `this release <https://github.com/ament/ament_cmake/pull/155>`_ it returns either the prefix path in case the resource was found or ``FALSE``.

If you are using the return value in a CMake condition like this:

.. code-block:: cmake

   ament_index_has_resource(var ...)
   if(${var})

you need to update the condition to ensure it considers a string value as ``TRUE``:

.. code-block:: cmake

   if(var)

rclcpp
^^^^^^

Behavior Change for ``Node::get_node_names()``
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The function ``NodeGraph::get_node_names()``, and therefore also ``Node::get_node_names()``, now returns a ``std::vector<std::string>`` containing fully qualified node names with their namespaces included, instead of just the node names.

Changed the Way that Options are Passed to Nodes
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Extended arguments (beyond name and namespace) to the ``rclcpp::Node()`` constructor have been replaced with a ``rclcpp::NodeOptions`` structure.
See `ros2/rclcpp#622 <https://github.com/ros2/rclcpp/pull/622/files>`__ for details about the structure and default values of the options.

If you are using any of the extended arguments to ``rclcpp::Node()`` like this:

.. code-block:: cpp

  auto context = rclcpp::contexts::default_context::get_global_default_context();
  std::vector<std::string> args;
  std::vector<rclcpp::Parameter> params = { rclcpp::Parameter(""use_sim_time"", true) };
  auto node = std::make_shared<rclcpp::Node>(""foo_node"", ""bar_namespace"", context, args, params);

You need to update to use the ``NodeOptions`` structure

.. code-block:: cpp

  std::vector<std::string> args;
  std::vector<rclcpp::Parameter> params = { rclcpp::Parameter(""use_sim_time"", true) };
  rclcpp::NodeOptions node_options;
  node_options.arguments(args);
  node_options.parameter_overrides(params);
  auto node = std::make_shared<rclcpp::Node>(""foo_node"", ""bar_namespace"", node_options);

Changes to Creating Publishers and Subscriptions
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

There have been a few changes to creating publishers and subscriptions which are new in Dashing:

- QoS settings are now passed using the new ``rclcpp::QoS`` class, and the API encourages the user to specify at least the history depth.
- Options are now passed as an object, i.e. ``rclcpp::PublisherOptions`` and ``rclcpp::SubscriptionOptions``.

All changes are backwards compatible (no code changes are required), but several existing call styles have been deprecated.
Users are encouraged to update to the new signatures.

----

In the past, when creating a publisher or subscription, you could either not specify any QoS settings (e.g. just provide topic name for a publisher) or you could specify a ""qos profile"" data structure (of type ``rmw_qos_profile_t``) with all the settings already set.
Now you must use the new ``rclcpp::QoS`` object to specify your QoS and at least the history settings for your QoS.
This encourages the user to specify a history depth when using ``KEEP_LAST``, rather than defaulting it to a value that may or may not be appropriate.

In ROS 1, this was known as the ``queue_size`` and it was required in both C++ and Python.
We're changing the ROS 2 API to bring this requirement back.

----

Also, any options which could previously be passed during creation of a publisher or subscription have now been encapsulated in an ``rclcpp::PublisherOptions`` and ``rclcpp::SubscriptionOptions`` class respectively.
This allows for shorter signatures, more convenient use, and for adding new future options without breaking API.

----

Some signatures for creating publishers and subscribers are now deprecated, and new signatures have been added to allow you to use the new ``rclcpp::QoS`` and publisher/subscription option classes.

These are the new and recommended API's:

.. code-block:: cpp

  template<
    typename MessageT,
    typename AllocatorT = std::allocator<void>,
    typename PublisherT = ::rclcpp::Publisher<MessageT, AllocatorT>>
  std::shared_ptr<PublisherT>
  create_publisher(
    const std::string & topic_name,
    const rclcpp::QoS & qos,
    const PublisherOptionsWithAllocator<AllocatorT> & options =
    PublisherOptionsWithAllocator<AllocatorT>()
  );

  template<
    typename MessageT,
    typename CallbackT,
    typename AllocatorT = std::allocator<void>,
    typename SubscriptionT = rclcpp::Subscription<
      typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, AllocatorT>>
  std::shared_ptr<SubscriptionT>
  create_subscription(
    const std::string & topic_name,
    const rclcpp::QoS & qos,
    CallbackT && callback,
    const SubscriptionOptionsWithAllocator<AllocatorT> & options =
    SubscriptionOptionsWithAllocator<AllocatorT>(),
    typename rclcpp::message_memory_strategy::MessageMemoryStrategy<
      typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, AllocatorT
    >::SharedPtr
    msg_mem_strat = nullptr);

And these are the deprecated ones:

.. code-block:: cpp

  template<
    typename MessageT,
    typename AllocatorT = std::allocator<void>,
    typename PublisherT = ::rclcpp::Publisher<MessageT, AllocatorT>>
  [[deprecated(""use create_publisher(const std::string &, const rclcpp::QoS &, ...) instead"")]]
  std::shared_ptr<PublisherT>
  create_publisher(
    const std::string & topic_name,
    size_t qos_history_depth,
    std::shared_ptr<AllocatorT> allocator);

  template<
    typename MessageT,
    typename AllocatorT = std::allocator<void>,
    typename PublisherT = ::rclcpp::Publisher<MessageT, AllocatorT>>
  [[deprecated(""use create_publisher(const std::string &, const rclcpp::QoS &, ...) instead"")]]
  std::shared_ptr<PublisherT>
  create_publisher(
    const std::string & topic_name,
    const rmw_qos_profile_t & qos_profile = rmw_qos_profile_default,
    std::shared_ptr<AllocatorT> allocator = nullptr);

  template<
    typename MessageT,
    typename CallbackT,
    typename Alloc = std::allocator<void>,
    typename SubscriptionT = rclcpp::Subscription<
      typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, Alloc>>
  [[deprecated(
    ""use create_subscription(const std::string &, const rclcpp::QoS &, CallbackT, ...) instead""
  )]]
  std::shared_ptr<SubscriptionT>
  create_subscription(
    const std::string & topic_name,
    CallbackT && callback,
    const rmw_qos_profile_t & qos_profile = rmw_qos_profile_default,
    rclcpp::callback_group::CallbackGroup::SharedPtr group = nullptr,
    bool ignore_local_publications = false,
    typename rclcpp::message_memory_strategy::MessageMemoryStrategy<
      typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, Alloc>::SharedPtr
    msg_mem_strat = nullptr,
    std::shared_ptr<Alloc> allocator = nullptr);

  template<
    typename MessageT,
    typename CallbackT,
    typename Alloc = std::allocator<void>,
    typename SubscriptionT = rclcpp::Subscription<
      typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, Alloc>>
  [[deprecated(
    ""use create_subscription(const std::string &, const rclcpp::QoS &, CallbackT, ...) instead""
  )]]
  std::shared_ptr<SubscriptionT>
  create_subscription(
    const std::string & topic_name,
    CallbackT && callback,
    size_t qos_history_depth,
    rclcpp::callback_group::CallbackGroup::SharedPtr group = nullptr,
    bool ignore_local_publications = false,
    typename rclcpp::message_memory_strategy::MessageMemoryStrategy<
      typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, Alloc>::SharedPtr
    msg_mem_strat = nullptr,
    std::shared_ptr<Alloc> allocator = nullptr);

----

The change to how QoS is passed is most likely to impact users.

A typical change for a publisher looks like this:

.. code-block:: diff

  - pub_ = create_publisher<std_msgs::msg::String>(""chatter"");
  + pub_ = create_publisher<std_msgs::msg::String>(""chatter"", 10);

And for a subscription:

.. code-block:: diff

  - sub_ = create_subscription<std_msgs::msg::String>(""chatter"", callback);
  + sub_ = create_subscription<std_msgs::msg::String>(""chatter"", 10, callback);

If you have no idea what depth to use and don't care right now (maybe just prototyping), then we recommend using ``10``, as that was the default before and should preserve existing behavior.

More in depth documentation about how to select an appropriate depth is forthcoming.

This is an example of a slightly more involved change to avoid the newly deprecated API's:

.. code-block:: diff

  - // Creates a latched topic
  - rmw_qos_profile_t qos = rmw_qos_profile_default;
  - qos.depth = 1;
  - qos.durability = RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL;
  -
    model_xml_.data = model_xml;
    node_handle->declare_parameter(""robot_description"", model_xml);
    description_pub_ = node_handle->create_publisher<std_msgs::msg::String>(
  -   ""robot_description"", qos);
  +   ""robot_description"",
  +   // Transient local is similar to latching in ROS 1.
  +   rclcpp::QoS(1).transient_local());

See the pull request (and connected pull requests) that introduced the QoS change for more examples and details:

- https://github.com/ros2/rclcpp/pull/713

  - https://github.com/ros2/demos/pull/332
  - https://github.com/ros2/robot_state_publisher/pull/19
  - and others...


Changes Due to Declare Parameter Change
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

For details about the actual behavior change, see `Declaring Parameters`_ above.

There are several new API calls in the ``rclcpp::Node``'s interface:

- Methods that declare parameters given a name, optional default value, optional descriptor, and return the value actually set:

  .. code-block:: c++

    const rclcpp::ParameterValue &
    rclcpp::Node::declare_parameter(
      const std::string & name,
      const rclcpp::ParameterValue & default_value = rclcpp::ParameterValue(),
      const rcl_interfaces::msg::ParameterDescriptor & parameter_descriptor =
      rcl_interfaces::msg::ParameterDescriptor());

    template<typename ParameterT>
    auto
    rclcpp::Node::declare_parameter(
      const std::string & name,
      const ParameterT & default_value,
      const rcl_interfaces::msg::ParameterDescriptor & parameter_descriptor =
      rcl_interfaces::msg::ParameterDescriptor());

    template<typename ParameterT>
    std::vector<ParameterT>
    rclcpp::Node::declare_parameters(
      const std::string & namespace_,
      const std::map<std::string, ParameterT> & parameters);

    template<typename ParameterT>
    std::vector<ParameterT>
    rclcpp::Node::declare_parameters(
      const std::string & namespace_,
      const std::map<
        std::string,
        std::pair<ParameterT, rcl_interfaces::msg::ParameterDescriptor>
      > & parameters);

- A method to undeclare parameters and to check if a parameter has been declared:

  .. code-block:: c++

    void
    rclcpp::Node::undeclare_parameter(const std::string & name);

    bool
    rclcpp::Node::has_parameter(const std::string & name) const;

- Some convenience methods that did not previously exist:

  .. code-block:: c++

    rcl_interfaces::msg::SetParametersResult
    rclcpp::Node::set_parameter(const rclcpp::Parameter & parameter);

    std::vector<rclcpp::Parameter>
    rclcpp::Node::get_parameters(const std::vector<std::string> & names) const;

    rcl_interfaces::msg::ParameterDescriptor
    rclcpp::Node::describe_parameter(const std::string & name) const;

- A new method to set the callback which is called anytime a parameter will be changed, giving you the opportunity to reject it:

  .. code-block:: c++

    using OnParametersSetCallbackType =
      rclcpp::node_interfaces::NodeParametersInterface::OnParametersSetCallbackType;

    OnParametersSetCallbackType
    rclcpp::Node::set_on_parameters_set_callback(
      OnParametersSetCallbackType callback);

There were also several deprecated methods:

  .. code-block:: c++

    template<typename ParameterT>
    [[deprecated(""use declare_parameter() instead"")]]
    void
    rclcpp::Node::set_parameter_if_not_set(
      const std::string & name,
      const ParameterT & value);

    template<typename ParameterT>
    [[deprecated(""use declare_parameters() instead"")]]
    void
    rclcpp::Node::set_parameters_if_not_set(
      const std::string & name,
      const std::map<std::string, ParameterT> & values);

    template<typename ParameterT>
    [[deprecated(""use declare_parameter() and it's return value instead"")]]
    void
    rclcpp::Node::get_parameter_or_set(
      const std::string & name,
      ParameterT & value,
      const ParameterT & alternative_value);

    template<typename CallbackT>
    [[deprecated(""use set_on_parameters_set_callback() instead"")]]
    void
    rclcpp::Node::register_param_change_callback(CallbackT && callback);

Memory Strategy
""""""""""""""""""""""""""""""

The interface ``rclcpp::memory_strategy::MemoryStrategy`` was using the typedef ``WeakNodeVector`` in various method signatures.
As of Dashing the typedef has been been changed to ``WeakNodeList`` and with it the type of the parameter in various methods.
Any custom memory strategy needs to be updated to match the modified interface.

The relevant API change can be found in `ros2/rclcpp#741 <https://github.com/ros2/rclcpp/pull/741>`__.

rclcpp_components
^^^^^^^^^^^^^^^^^

The correct way to implement composition in Dashing is by utilizing the ``rclcpp_components`` package.

The following changes must be made to nodes in order to correctly implement runtime composition:

The Node must have a constructor that takes ``rclcpp::NodeOptions``:

.. code-block:: cpp

  class Listener: public rclcpp::Node {
    Listener(const rclcpp::NodeOptions & options)
    : Node(""listener"", options)
    {
    }
  };

C++ registration macros (if present) need to be updated to use the ``rclcpp_components`` equivalent.
If not present, registration macros must be added in one translation unit.

.. code-block:: cpp

  // Insert at bottom of translation unit, e.g. listener.cpp
  #include ""rclcpp_components/register_node_macro.hpp""
  // Use fully-qualifed name in registration
  RCLCPP_COMPONENTS_REGISTER_NODE(composition::Listener);

CMake registration macros (if present) need to be updated.
If not present, registration macros must be added to the project's CMake.

.. code-block:: cmake

  add_library(listener src/listener.cpp)
  rclcpp_components_register_nodes(listener ""composition::Listener"")

For more information on composition, see `the tutorial <../Tutorials/Intermediate/Writing-a-Composable-Node>`

rclpy
^^^^^

Changes to Creating Publishers, Subscriptions, and QoS Profiles
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Prior to Dashing, you could optionally provide a ``QoSProfile`` object when creating a publisher or subscription.
In an effort to encourage users to specify a history depth for message queues, we now **require** that a depth value or ``QoSProfile`` object is given when creating publishers or subscriptions.

To create a publisher, previously you would have written:

.. code-block:: python

  node.create_publisher(Empty, 'chatter')
  # Or using a keyword argument for QoSProfile
  node.create_publisher(Empty, 'chatter', qos_profile=qos_profile_sensor_data)

In Dashing, prefer the following API that provides a depth value or ``QoSProfile`` object as a third positional argument:

.. code-block:: python

  # Assume a history setting of KEEP_LAST with depth 10
  node.create_publisher(Empty, 'chatter', 10)
  # Or pass a QoSProfile object directly
  node.create_publisher(Empty, 'chatter', qos_profile_sensor_data)

Likewise for subscriptions, previously you would have written:

.. code-block:: python

  node.create_subscription(BasicTypes, 'chatter', lambda msg: print(msg))
  # Or using a keyword argument for QoSProfile
  node.create_subscription(BasicTypes, 'chatter', lambda msg: print(msg), qos_profile=qos_profile_sensor_data)

In Dashing:

.. code-block:: python

  # Assume a history setting of KEEP_LAST with depth 10
  node.create_subscription(BasicTypes, 'chatter', lambda msg: print(msg), 10)
  # Or pass a QoSProfile object directly
  node.create_subscription(BasicTypes, 'chatter', lambda msg: print(msg), qos_profile_sensor_data)

To ease the transition, users who do not use the new API will see deprecation warnings.

Furthermore, we also require that when constructing ``QoSProfile`` objects that a history policy and/or depth is set.
If a history policy of ``KEEP_LAST`` is provided, then a depth argument is also required.
For example, these calls are valid:

.. code-block:: python

  QoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_ALL)
  QoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST, depth=10)
  QoSProfile(depth=10)  # equivalent to the previous line

And these calls will cause a deprecation warning:

.. code-block:: python

  QoSProfile()
  QoSProfile(reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT)
  # KEEP_LAST but no depth
  QoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST)

See the issue and pull request related to introducing this change for more details:

- https://github.com/ros2/rclpy/issues/342
- https://github.com/ros2/rclpy/pull/344


Changes Due to Declare Parameter Change
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

For details about the actual behavior change, see `Declaring Parameters`_ above. The changes are analogous to the ones in ``rclcpp``.

These are the new API methods available in ``rclpy.node.Node`` interface:

- To declare parameters given a name, an optional default value (supported by ``rcl_interfaces.msg.ParameterValue``) and an optional descriptor, returning the value actually set:

  .. code-block:: python

      def declare_parameter(
          name: str,
          value: Any = None,
          descriptor: ParameterDescriptor = ParameterDescriptor()
      ) -> Parameter

      def declare_parameters(
        namespace: str,
        parameters: List[Union[
            Tuple[str],
            Tuple[str, Any],
            Tuple[str, Any, ParameterDescriptor],
        ]]
      ) -> List[Parameter]

- To undeclare previously declared parameters and to check if a parameter has been declared beforehand:

  .. code-block:: python

      def undeclare_parameter(name: str) -> None

      def has_parameter(name: str) -> bool

- To get and set parameter descriptors:

  .. code-block:: python

      def describe_parameter(name: str) -> ParameterDescriptor

      def describe_parameters(names: List[str]) -> List[ParameterDescriptor]

      def set_descriptor(
          name: str,
          descriptor: ParameterDescriptor,
          alternative_value: Optional[ParameterValue] = None
      ) -> ParameterValue

- A convenience method to get parameters that may not have been declared:

  .. code-block:: python

      def get_parameter_or(name: str, alternative_value: Optional[Parameter] = None) -> Parameter

Other changes
""""""""""""""""""""""""""

``rclpy.parameter.Parameter`` can now guess its type without explicitly setting it (as long as it's one of the supported ones by ``rcl_interfaces.msg.ParameterValue``).
For example, this code:

  .. code-block:: python

      p = Parameter('myparam', Parameter.Type.DOUBLE, 2.41)

Is equivalent to this code:

  .. code-block:: python

      p = Parameter('myparam', value=2.41)

This change does not break existing API.

rosidl
^^^^^^

Until Crystal each message generator package registered itself using the ``ament_cmake`` extension point ``rosidl_generate_interfaces`` and was passed a set of ``.msg`` / ``.srv`` / ``.action`` files.
As of Dashing the message generation pipeline is based on ``.idl`` files instead.

Any message generator package needs to change and register itself using the new extension point ``rosidl_generate_idl_interfaces`` which passes only ``.idl`` files instead.
The message generators for the commonly supported languages C, C++, and Python as well as the typesupport packages for introspection, Fast RTPS, Connext and OpenSplice have already been updated (see `ros2/rosidl#334 <https://github.com/ros2/rosidl/pull/334/files>`__).
The CMake code calling ``rosidl_generate_interfaces()`` can either pass ``.idl`` files directly or pass ``.msg`` / ``.srv`` / ``.action`` which will then internally be converted into ``.idl`` files before being passed to each message generator.

The format of ``.msg`` / ``.srv`` / ``.action`` files is not being evolved in the future.
The mapping between ``.msg`` / ``.srv`` / ``.action`` files and ``.idl`` files is described in `this design article <https://design.ros2.org/articles/legacy_interface_definition.html>`__.
A `second design article <https://design.ros2.org/articles/idl_interface_definition.html>`__ describes the supported features in ``.idl`` files.
In order to leverage any of the new features existing interfaces need to be converted (e.g. using the command line tools  ``msg2idl`` / ``srv2idl`` / ``action2idl``).

To distinguish same type names, but with different namespaces, the introspection structs now contain a namespace field that replaces the package name (see `ros2/rosidl#335 <https://github.com/ros2/rosidl/pull/355/files>`_).

Mapping of char in .msg files
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

In `ROS 1 <https://wiki.ros.org/msg#Fields>`__ ``char`` has been deprecated for a long time and is being mapped to ``uint8``.
In ROS 2 until Crystal ``char`` was mapped to a single character (``char`` in C / C++, ``str`` with length 1 in Python) in an effort to provide a more natural mapping.
As of Dashing the ROS 1 semantic has been restored and ``char`` maps to ``uint8`` again.

rosidl_generator_cpp
^^^^^^^^^^^^^^^^^^^^

The C++ data structures generated for messages, services and actions provide setter methods for each field.
Until Crystal each setter returned a pointer to the data structure itself to enable the named parameter idiom.
As of Dashing these setters `return a reference <https://github.com/ros2/rosidl/pull/353>`__ instead since that seems to be the more common signature as well as it clarifies that the returned value can't be a ``nullptr``.

rosidl_generator_py
^^^^^^^^^^^^^^^^^^^

Until Crystal an array (fixed size) or sequence (dynamic size, optionally with an upper boundary) field in a message was stored as a ``list`` in Python.
As of Dashing the Python type for arrays / sequences of numeric values has been changed:

* an array of numeric values is stored as a ``numpy.ndarray`` (the ``dtype`` is chosen to match the type of the numeric value)
* a sequence of numeric values is stored as an ``array.array`` (the ``typename`` is chosen to match the type of the numeric value)

As before an array / sequence of non-numeric types is still represented as a ``list`` in Python.

This change brings a number of benefits:

* The new data structures ensure that each item in the array / sequence complies with the value range restrictions of the numeric type.
* The numeric values can be stored more efficiently in memory which avoid the overhead of Python objects for each item.
* The memory layout of both data structures allows to read and write all items of the array / sequence in a single operation which makes the conversion from and to Python significantly faster / more efficient.

launch
^^^^^^

The ``launch_testing`` package caught up with the ``launch`` package redesign done in Bouncy Bolson.
The legacy Python API, already moved into the ``launch.legacy`` submodule, has thus been deprecated and removed.

See ``launch`` `examples <https://github.com/ros2/launch/tree/dashing/launch/examples>`__ and `documentation <https://github.com/ros2/launch/tree/dashing/launch/doc>`__ for reference on how to use its new API.

See `demos tests <https://github.com/ros2/demos>`__ for reference on how to use the new ``launch_testing`` API.

rmw
^^^

Changes since the `Crystal Clemmys <Release-Crystal-Clemmys>` release:

* New API in ``rmw``, a fini function for ``rmw_context_t``:

 * `rmw_context_fini <https://github.com/ros2/rmw/blob/c518842f6f82910482470b40c221c268d30691bd/rmw/include/rmw/init.h#L111-L136>`_

* Modification of ``rmw``, now passes ``rmw_context_t`` to ``rmw_create_wait_set``:

 * `rmw_create_wait_set <https://github.com/ros2/rmw/blob/c518842f6f82910482470b40c221c268d30691bd/rmw/include/rmw/rmw.h#L522-L543>`_

* New APIs in ``rmw`` for preallocating space for published and subscribed messages:

 * `rmw_init_publisher_allocation <https://github.com/ros2/rmw/blob/dc7b2f49f1f961d6cf2c173adc54736451be8938/rmw/include/rmw/rmw.h#L262>`_
 * `rmw_fini_publisher_allocation <https://github.com/ros2/rmw/blob/dc7b2f49f1f961d6cf2c173adc54736451be8938/rmw/include/rmw/rmw.h#L279>`_
 * `rmw_init_subscription_allocation <https://github.com/ros2/rmw/blob/dc7b2f49f1f961d6cf2c173adc54736451be8938/rmw/include/rmw/rmw.h#L489>`_
 * `rmw_fini_subscription_allocation <https://github.com/ros2/rmw/blob/dc7b2f49f1f961d6cf2c173adc54736451be8938/rmw/include/rmw/rmw.h#L506>`_
 * `rmw_serialized_message_size <https://github.com/ros2/rmw/blob/dc7b2f49f1f961d6cf2c173adc54736451be8938/rmw/include/rmw/rmw.h#L395>`_

* Modification of ``rmw``, now passes ``rmw_publisher_allocation_t`` or ``rmw_subscription_allocation_t`` to ``rmw_publish`` and ``rmw_take``, respectively.
  Note that this argument can be ``NULL`` or ``nullptr``, which keeps existing Crystal behavior.

 * `rmw_publish <https://github.com/ros2/rmw/blob/dc7b2f49f1f961d6cf2c173adc54736451be8938/rmw/include/rmw/rmw.h#L310>`_
 * `rmw_take <https://github.com/ros2/rmw/blob/dc7b2f49f1f961d6cf2c173adc54736451be8938/rmw/include/rmw/rmw.h#L556>`_

* Type names returned by ``rmw_get_*_names_and_types*`` functions should have a fully-qualified namespace.
  For example, instead of ``rcl_interfaces/Parameter`` and ``rcl_interfaces/GetParameters``, the returned type names should be ``rcl_interface/msg/Parameter`` and ``rcl_interfaces/srv/GetParameters``.

actions
^^^^^^^

* Changes to ``rclcpp_action::Client`` signatures:

  The signature of `rclcpp_action::Client::async_send_goal <https://github.com/ros2/rclcpp/blob/ef41059a751702274667e2164182c062b47c453d/rclcpp_action/include/rclcpp_action/client.hpp#L343>`_ has changed.
  Now users can optionally provide callback functions for the **goal response** and the **result** using the new
  `SendGoalOptions <https://github.com/ros2/rclcpp/blob/ef41059a751702274667e2164182c062b47c453d/rclcpp_action/include/rclcpp_action/client.hpp#L276>`_ struct.
  The goal response callback is called when an action server accepts or rejects the goal and the result callback is called when the result for the goal is received.
  Optional callbacks were also added to `rclcpp_action::Client::async_cancel_goal <https://github.com/ros2/rclcpp/blob/ef41059a751702274667e2164182c062b47c453d/rclcpp_action/include/rclcpp_action/client.hpp#L432-L434>`_
  and `rclcpp_action::Client::async_get_result <https://github.com/ros2/rclcpp/blob/ef41059a751702274667e2164182c062b47c453d/rclcpp_action/include/rclcpp_action/client.hpp#L399-L401>`_.

* Changes to goal transition names:

  The names of goal state transitions have been refactored to reflect the design documention.
  This affects ``rcl_action``, ``rclcpp_action``, and ``rclpy``.
  Here is a list of the event name changes (*Old name -> New name*):

  * GOAL_EVENT_CANCEL -> GOAL_EVENT_CANCEL_GOAL
  * GOAL_EVENT_SET_SUCCEEDED -> GOAL_EVENT_SUCCEED
  * GOAL_EVENT_SET_ABORTED -> GOAL_EVENT_ABORT
  * GOAL_EVENT_SET_CANCELED -> GOAL_EVENT_CANCELED

* Changes to ``CancelGoal.srv``:

  A ``return_code`` field was added to the response message of the ``CancelGoal`` service.
  This is to better communicate a reason for a failed service call.
  See the `pull request <https://github.com/ros2/rcl_interfaces/pull/76>`_ and connected issue for details.

rviz
^^^^

* Plugins should use fully qualified type names otherwise a warning will be logged.
  For `example <https://github.com/ros2/rviz/blob/dfceae319d49546f1e4ad39689853c18fef0001e/rviz_default_plugins/plugins_description.xml#L13>`_, use the type ``sensor_msgs/msg/Image`` instead of ``sensor_msgs/Image``.
  See `PR introducing this change <https://github.com/ros2/rviz/pull/387>`_ for more details.

Known Issues
------------

* `[ros2/rclcpp#715] <https://github.com/ros2/rclcpp/issues/715>`_ There is an inconsistency in the way that parameter YAML files are loaded between standalone ROS 2 nodes and composed ROS 2 nodes.
  Currently available workarounds are noted in an `issue comment <https://github.com/ros2/rclcpp/issues/715#issuecomment-497392626>`_
* `[ros2/rclpy#360] <https://github.com/ros2/rclpy/issues/360>`_ rclpy nodes ignore :kbd:`ctrl-c` when using OpenSplice on Windows.
* `[ros2/rosidl_typesupport_opensplice#30] <https://github.com/ros2/rosidl_typesupport_opensplice/issues/30>`_ There is a bug preventing nesting a message inside of a service or action definition with the same name when using OpenSplice.
* `[ros2/rclcpp#781] <https://github.com/ros2/rclcpp/pull/781>`_ Calling ``get_parameter``/``list_parameter`` from within ``on_set_parameter_callback`` causes a deadlock on Dashing.  This is fixed for Eloquent, but is an ABI break so has not been backported to Dashing.
* `[ros2/rclcpp#912] <https://github.com/ros2/rclcpp/issues/912>`_ Inter-process communication forces a message copy when intra-process communication takes place between an ``std::unique_ptr`` publisher and a single ``std::unique_ptr`` subscription (published ``std::unique_ptr`` is internally being promoted to an ``std::shared_ptr``).
* `[ros2/rosbag2#125] <https://github.com/ros2/rosbag2/issues/125>`_ Topics with unreliable QOS are not recorded.
* `[ros2/rclcpp#715] <https://github.com/ros2/rclcpp/issues/715>`_ Composable nodes cannot receive parameters via remapping. Supplying parameters to composable nodes can be accomplished using the methods described in `[this comment] <https://github.com/ros2/rclcpp/issues/715#issuecomment-497392626>`_.
* `[ros2/rclcpp#893] <https://github.com/ros2/rclcpp/issues/893>`_ ``rclcpp::Context`` is not destroyed because of a reference cycle with ``rclcpp::GraphListener``. This causes a memory leak. A fix has not been backported because of the risk of breaking ABI.

Timeline before the release
---------------------------

A few milestones leading up to the release:

    Mon. Apr 8th (alpha)
        First releases of core packages available.
        Testing can happen from now on (some features might not have landed yet).

    Thu. May 2nd
        API freeze for core packages

    Mon. May 6th (beta)
        Updated releases of core packages available.
        Additional testing of the latest features.

    Thu. May 16th
        Feature freeze.
        Only bug fix releases should be made after this point.
        New packages can be released independently.

    Mon. May 20th (release candidate)
        Updated releases of core packages available.

    Wed. May 29th
        Freeze rosdistro.
        No PRs for Dashing on the `rosdistro` repo will be merged (reopens after the release announcement).
",What is the recommended way to write a node in ROS 2 Dashing Diademata according to the text document provided?
".. redirect-from::

  Guides/Installation-Troubleshooting
  Troubleshooting/Installation-Troubleshooting

Installation troubleshooting
============================

Troubleshooting techniques for installation are sorted by the platforms they apply to.

.. contents:: Platforms
   :depth: 1
   :local:

General
-------

General troubleshooting techniques apply to all platforms.

Enable multicast
^^^^^^^^^^^^^^^^

In order to communicate successfully via DDS, the used network interface has to be multicast enabled.
We've seen in past experiences that this might not necessarily be enabled by default (on Ubuntu or OSX) when using the loopback adapter.
See the `original issue <https://github.com/ros2/ros2/issues/552>`__ or a `conversation on ros-answers <https://answers.ros.org/question/300370/ros2-talker-cannot-communicate-with-listener/>`__.
You can verify that your current setup allows multicast with the ROS 2 tool:

In Terminal 1:

.. code-block:: bash

   ros2 multicast receive

In Terminal 2:

.. code-block:: bash

   ros2 multicast send

If the first command did not return a response similar to:

.. code-block:: bash

   Received from xx.xxx.xxx.xx:43751: 'Hello World!'

then you will need to update your firewall configuration to allow multicast using `ufw <https://help.ubuntu.com/community/UFW>`__.

.. code-block:: bash

   sudo ufw allow in proto udp to 224.0.0.0/4
   sudo ufw allow in proto udp from 224.0.0.0/4


You can check if the multicast flag is enabled for your network interface using the :code:`ifconfig` tool and looking for :code:`MULITCAST` in the flags section:

.. code-block:: bash

   eno1: flags=4163<...,MULTICAST>
      ...

Import failing without library present on the system
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sometimes ``rclpy`` fails to be imported because the expected C extension libraries are not found.
If so, compare the libraries present in the directory with the one mentioned in the error message.
Assuming a file with a similar name exists (same prefix like ``_rclpy.`` and same suffix like ``.so`` but a different Python version / architecture) you are using a different Python interpreter than which was used to build the C extension.
Be sure to use the same Python interpreter as the one used to build the binary.

For example, such a mismatch can crop up after an update of the OS. Then, rebuilding the workspace may fix the issue.

.. _linux-troubleshooting:

Linux
-----

Internal compiler error
^^^^^^^^^^^^^^^^^^^^^^^

If you experience an ICE when trying to compile on a memory constrained platform like a Raspberry PI you might want to build single threaded (prefix the build invocation with ``MAKEFLAGS=-j1``).

Out of memory
^^^^^^^^^^^^^

The ``ros1_bridge`` in its current form requires 4Gb of free RAM to compile.
If you don't have that amount of RAM available it's suggested to use ``COLCON_IGNORE`` in that folder and skip its compilation.

Multiple host interference
^^^^^^^^^^^^^^^^^^^^^^^^^^

If you're running multiple instances on the same network you may get interference.
To avoid this you can set the environment variable ``ROS_DOMAIN_ID`` to a different integer, the default is zero.
This will define the DDS domain id for your system.

Exception sourcing setup.bash
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. only relevant to Eloquent and Foxy

If you encounter exceptions when trying to source the environment after building from source, try to upgrade ``colcon`` related packages using

.. code-block:: bash

   colcon version-check  # check if newer versions available
   sudo apt install python3-colcon* --only-upgrade  # upgrade installed colcon packages to latest version

Anaconda Python Conflict
^^^^^^^^^^^^^^^^^^^^^^^^

``conda`` does not work in conjunction with ROS 2.
Make sure that your ``PATH`` environment variable does not have any conda paths in it.
You may have to check your ``.bashrc`` for this line and comment it out.

Cannot start rviz2
^^^^^^^^^^^^^^^^^^

``rviz2`` may fail to start on a Wayland display system with errors like:

.. code-block::

   QSocketNotifier: Can only be used with threads started with QThread
   [INFO] [1714730141.758659580] [rviz2]: Stereo is NOT SUPPORTED
   [INFO] [1714730141.758813709] [rviz2]: OpenGl version: 3.1 (GLSL 1.4)
   [ERROR] [1714730141.797879232] [rviz2]: rviz::RenderSystem: error creating render window: RenderingAPIException: Invalid parentWindowHandle (wrong server or screen) in GLXWindow::create at ./.obj-aarch64-linux-gnu/ogre_vendor-prefix/src/ogre_vendor/RenderSystems/GLSupport/src/GLX/OgreGLXWindow.cpp (line 246)
   ...
   [ERROR] [1714730141.808124283] [rviz2]: Unable to create the rendering window after 100 tries
   terminate called after throwing an instance of 'std::runtime_error'
     what():  Unable to create the rendering window after 100 tries
   Aborted (core dumped)

This is due to an incompatibility between Wayland and RViz2.
You may be able to workaround this problem by running RViz2 in X11 compatibility mode:

.. code-block::

   QT_QPA_PLATFORM=xcb rviz2

.. _macOS-troubleshooting:

macOS
-----

Segmentation fault when using ``pyenv``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``pyenv`` seems to default to building Python with ``.a`` files, but that causes issues with ``rclpy``, so it's recommended to build Python with Frameworks enabled on macOS when using ``pyenv``:

https://github.com/pyenv/pyenv/wiki#how-to-build-cpython-with-framework-support-on-os-x

Library not loaded; image not found
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you are seeing library loading issues at runtime (either running tests or running nodes), such as the following:

.. code-block:: bash

   ImportError: dlopen(.../ros2_<distro>/ros2-osx/lib/python3.7/site-packages/rclpy/_rclpy.cpython-37m-darwin.so, 2): Library not loaded: @rpath/librcl_interfaces__rosidl_typesupport_c.dylib
     Referenced from: .../ros2_<distro>/ros2-osx/lib/python3.7/site-packages/rclpy/_rclpy.cpython-37m-darwin.so
     Reason: image not found

Then you probably have System Integrity Protection enabled.
Follow `these instructions <https://developer.apple.com/library/content/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html>`__ to disable System Integrity Protection (SIP).

Qt build error: ``unknown type name 'Q_ENUM'``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you see build errors related to Qt, e.g.:

.. code-block:: bash

   In file included from /usr/local/opt/qt/lib/QtGui.framework/Headers/qguiapplication.h:46:
   /usr/local/opt/qt/lib/QtGui.framework/Headers/qinputmethod.h:87:5: error:
         unknown type name 'Q_ENUM'
       Q_ENUM(Action)
       ^

you may be using qt4 instead of qt5: see https://github.com/ros2/ros2/issues/441

Missing symbol when opencv (and therefore libjpeg, libtiff, and libpng) are installed with Homebrew
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you have opencv installed you might get this:

.. code-block:: bash

   dyld: Symbol not found: __cg_jpeg_resync_to_restart
     Referenced from: /System/Library/Frameworks/ImageIO.framework/Versions/A/ImageIO
     Expected in: /usr/local/lib/libJPEG.dylib
    in /System/Library/Frameworks/ImageIO.framework/Versions/A/ImageIO
   /bin/sh: line 1: 25274 Trace/BPT trap: 5       /usr/local/bin/cmake

If so, to build you'll have to do this:

.. code-block:: bash

   $ brew unlink libpng libtiff libjpeg

But this will break opencv, so you'll also need to update it to continue working:

.. code-block:: bash

   $ sudo install_name_tool -change /usr/local/lib/libjpeg.8.dylib /usr/local/opt/jpeg/lib/libjpeg.8.dylib /usr/local/lib/libopencv_highgui.2.4.dylib
   $ sudo install_name_tool -change /usr/local/lib/libpng16.16.dylib /usr/local/opt/libpng/lib/libpng16.16.dylib /usr/local/lib/libopencv_highgui.2.4.dylib
   $ sudo install_name_tool -change /usr/local/lib/libtiff.5.dylib /usr/local/opt/libtiff/lib/libtiff.5.dylib /usr/local/lib/libopencv_highgui.2.4.dylib
   $ sudo install_name_tool -change /usr/local/lib/libjpeg.8.dylib /usr/local/opt/jpeg/lib/libjpeg.8.dylib /usr/local/Cellar/libtiff/4.0.4/lib/libtiff.5.dylib

The first command is necessary to avoid things built against the system libjpeg (etc.) from getting the version in /usr/local/lib.
The others are updating things built by Homebrew so that they can find the version of libjpeg (etc.) without having them in /usr/local/lib.

Xcode-select error: tool ``xcodebuild`` requires Xcode, but active developer directory is a command line instance
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. only relevant to Eloquent and Foxy

If you recently installed Xcode, you may encounter this error:

.. code-block:: bash

   Xcode: xcode-select: error: tool 'xcodebuild' requires Xcode,
   but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance

To resolve this error, you will need to:

1. Double check that you have the command line tool installed:

.. code-block:: bash

   $ xcode-select --install

2. Accept the terms and conditions of Xcode by typing in terminal:

.. code-block:: bash

   $ sudo xcodebuild -license accept

3. Ensure Xcode app is in the ``/Applications`` directory (NOT ``/Users/{user}/Applications``)

4. Point ``xcode-select`` to the Xcode app Developer directory using the following command:

.. code-block:: bash

   $ sudo xcode-select -s /Applications/Xcode.app/Contents/Developer

rosdep install error ``homebrew: Failed to detect successful installation of [qt5]``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
While following the :doc:`Creating a workspace <../Tutorials/Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace>` tutorial, you might encounter the following error stating that ``rosdep`` failes to install Qt5.

.. code-block:: bash

   $ rosdep install -i --from-path src --rosdistro {DISTRO} -y
   executing command [brew install qt5]
   Warning: qt 5.15.0 is already installed and up-to-date
   To reinstall 5.15.0, run `brew reinstall qt`
   ERROR: the following rosdeps failed to install
     homebrew: Failed to detect successful installation of [qt5]

This error seems to stem from a `linking issue <https://github.com/ros-infrastructure/rosdep/issues/490#issuecomment-334959426>`__ and can be resolved by running the following command.

.. code-block:: bash

   $ cd /usr/local/Cellar
   $ sudo ln -s qt qt5

Running the ``rosdep`` command should now execute normally:

.. code-block:: bash

   $ rosdep install -i --from-path src --rosdistro {DISTRO} -y
   #All required rosdeps installed successfully


.. _windows-troubleshooting:

Windows
-------

Import failing even with library present on the system
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sometimes ``rclpy`` fails to be imported because of some missing DLLs on your system.
If so, make sure to install all the dependencies listed in the ""Installing prerequisites"" sections of the :ref:`installation instructions <windows-install-binary-installing-prerequisites>`).

If you are installing from binaries, you may need to update your dependencies: they must be the same version as those used to build the binaries.

If you are still having issues, you can use the `Dependencies <https://github.com/lucasg/Dependencies>`_ tool to determine which dependencies are missing on your system.
Use the tool to load the corresponding ``.pyd`` file, and it should report unavailable ``DLL`` modules.
Be sure that the current workspace is sourced before you execute the tool, otherwise there will be unresolved ROS DLL files.
Use this information to install additional dependencies or adjust your path as necessary.

CMake error setting modification time
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you run into the CMake error ``file INSTALL cannot set modification time on ...`` when installing files it is likely that an anti virus software or Windows Defender are interfering with the build. E.g. for Windows Defender you can list the workspace location to be excluded to prevent it from scanning those files.

260 character path limit
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: bash

   The input line is too long.
   The syntax of the command is incorrect.

Depending on your directory hierarchy, you may see path length limit errors when building ROS 2 from source or your own libraries.

To allow deeper path lengths:

Run ``regedit.exe``, navigate to ``Computer\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem``, and set ``LongPathsEnabled`` to 0x00000001 (1).

Hit the windows key and type ``Edit Group Policy``.
Navigate to Local Computer Policy > Computer Configuration > Administrative Templates > System > Filesystem.
Right click ``Enable Win32 long paths``, click Edit.
In the dialog, select Enabled and click OK.

Close and open your terminal to reset the environment and try building again.

CMake packages unable to find asio, tinyxml2, tinyxml, or eigen
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We've seen that sometimes the chocolatey packages for ``asio``, ``tinyxml2``, etc. do not add important registry entries and CMake will be unable to find them when building ROS 2.
We've not yet been able to identify the root cause, but uninstalling the chocolatey packages (with ``-n`` if the uninstall fails the first time), and then reinstalling them will fix the issue.

patch.exe opens a new command window and asks for administrator
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This will also cause the build of packages which need to use patch to fail, even you allow it to use administrator rights.

- ``choco uninstall patch; colcon build --cmake-clean-cache`` - This is a bug in the `GNU Patch For Windows package <https://chocolatey.org/packages/patch>`_. If this package is not installed, the build process will instead use the version of Patch distributed with git.

Failed to load Fast RTPS shared library
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. does not apply to Crystal

Fast RTPS requires ``msvcr20.dll``, which is part of the ``Visual C++ Redistributable Packages for Visual Studio 2013``.
Although it is usually installed by default in Windows 10, we know that some Windows 10-like versions don't have it installed by default (e.g.: Windows Server 2019).
In case you don't have it installed, you can download it from `here <https://www.microsoft.com/en-us/download/details.aspx?id=40784>`_.

Failed to create process
^^^^^^^^^^^^^^^^^^^^^^^^

If running a ROS binary gives the error:

.. code-block::

   | failed to create process.

It is likely the Python interpreter was not found.
For each executable, the shebang (first line) of the accompanying script is used, so make sure Python is available under the expected path (default: ``C:\Python38\``).

Binary installation specific
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* If your example does not start because of missing DLLs, please verify that all libraries from external dependencies such as OpenCV are located inside your ``PATH`` variable.
* If you forget to call the ``local_setup.bat`` file from your terminal, the demo programs will most likely crash immediately.

Running RViz with WSL2
^^^^^^^^^^^^^^^^^^^^^^

If you are using `WSL2 <https://learn.microsoft.com/en-us/windows/wsl/install>`__ to run ROS 2 on Windows, you may run into an issue running RViz that looks like:

.. code-block:: console

   $ rviz2
   [INFO] [1695823660.091830699] [rviz2]: Stereo is NOT SUPPORTED
   [INFO] [1695823660.091943524] [rviz2]: OpenGl version: 4.1 (GLSL 4.1)
   D3D12: Removing Device.
   Segmentation fault

One possible solution to this is to force RViz to use software rendering:

.. code-block:: console

   $ export LIBGL_ALWAYS_SOFTWARE=true
   $ rviz2
   [INFO] [1695823660.091830699] [rviz2]: Stereo is NOT SUPPORTED
",What troubleshooting steps can be taken if ``rviz2`` fails to start on a Wayland display system on macOS?
"Using Callback Groups
=====================

When running a node in a Multi-Threaded Executor, ROS 2 offers callback
groups as a tool for controlling the execution of different callbacks.
This page is meant as a guide on how to use callback groups efficiently.
It is assumed that the reader has a basic understanding
about the concept of :doc:`executors <../Concepts/Intermediate/About-Executors>`.

.. contents:: Table of Contents
   :local:

Basics of callback groups
-------------------------

When running a node in a Multi-Threaded Executor,
ROS 2 offers two different types of callback groups for controlling
execution of callbacks:

* Mutually Exclusive Callback Group
* Reentrant Callback Group

These callback groups restrict the execution of their callbacks in
different ways.
In short:

* Mutually Exclusive Callback Group prevents its callbacks from being
  executed in parallel - essentially making it as if the callbacks in the group
  were executed by a SingleThreadedExecutor.
* Reentrant Callback Group allows the executor to schedule and execute
  the group's callbacks in any way it sees fit, without restrictions.
  This means that, in addition to different callbacks being run parallel
  to each other, different instances of the same callback may also be
  executed concurrently.
* Callbacks belonging to different callback groups (of any type) can always
  be executed parallel to each other.

It is also important to keep in mind that different ROS 2 entities relay
their callback group to all callbacks they spawn.
For example, if one assigns a callback group to an action client,
all callbacks created by the client will be assigned to that callback group.

Callback groups can be created by a node's ``create_callback_group``
function in rclcpp and by calling the constructor of the group in rclpy.
The callback group can then be passed as argument/option when creating a subscription, timer, etc.

.. tabs::

  .. group-tab:: C++

    .. code-block:: cpp

      my_callback_group = create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);

      rclcpp::SubscriptionOptions options;
      options.callback_group = my_callback_group;

      my_subscription = create_subscription<Int32>(""/topic"", rclcpp::SensorDataQoS(),
                                                    callback, options);

  .. group-tab:: Python

    .. code-block:: python

      my_callback_group = MutuallyExclusiveCallbackGroup()
      my_subscription = self.create_subscription(Int32, ""/topic"", self.callback, qos_profile=1,
                                                  callback_group=my_callback_group)

If the user does not specify any callback group when creating a subscription,
timer, etc., this entity will be assigned to the node's default callback group.
The default callback group is a Mutually Exclusive Callback Group and it can be
queried via ``NodeBaseInterface::get_default_callback_group()`` in rclcpp and
via ``Node.default_callback_group`` in rclpy.

About callbacks
^^^^^^^^^^^^^^^

In the context of ROS 2 and executors, a callback means a function whose
scheduling and execution is handled by an executor.
Examples of callbacks in this context are

* subscription callbacks (receiving and handling data from a topic),
* timer callbacks,
* service callbacks (for executing service requests in a server),
* different callbacks in action servers and clients,
* done-callbacks of Futures.

Below are a couple important points about callbacks that should be kept
in mind when working with callback groups.

* Almost everything in ROS 2 is a callback!
  Every function that is run by an executor is, by definition, a callback.
  The non-callback functions in a ROS 2 system are found mainly at
  the edge of the system (user and sensor inputs etc).
* Sometimes the callbacks are hidden and their presence may not be obvious
  from the user/developer API.
  This is the case especially with any kind of “synchronous” call to a
  service or an action (in rclpy).
  For example, the synchronous call ``Client.call(request)`` to a service
  adds a Future's done-callback that needs to be executed during the
  execution of the function call, but this callback is not directly
  visible to the user.


Controlling execution
---------------------

In order to control execution with callback groups, one can consider the
following guidelines.

For the interaction of an individual callback with itself:

* Register it to a Reentrant Callback Group if it should be executed in parallel to itself.
  An example case could be an action/service server that needs to be able to
  process several action calls in parallel to each other.

* Register it to a Mutually Exclusive Callback Group if it should **never** be executed in parallel to itself.
  An example case could be a timer callback that runs a control loop that publishes control commands.

For the interaction of different callbacks with each other:

* Register them to the same Mutually Exclusive Callback Group if they should **never** be executed in parallel.
  An example case could be that the callbacks are accessing shared critical and non-thread-safe resources.

If they should be executed in parallel, you have two options,
depending on whether the individual callbacks should be able to overlap themselves or not:

* Register them to different Mutually Exclusive Callback Groups (no overlap of the individual callbacks)

* Register them to a Reentrant Callback Group (overlap of the individual callbacks)

An example case of running different callbacks in parallel is a Node that has
a synchronous service client and a timer calling this service.
See the detailed example below.

Avoiding deadlocks
------------------

Setting up callback groups of a node incorrectly can lead to deadlocks (or
other unwanted behavior), especially if one desires to use synchronous calls to
services or actions.
Indeed, even the API documentation of ROS 2 mentions that
synchronous calls to actions or services should not be done in callbacks,
because it can lead to deadlocks.
While using asynchronous calls is indeed safer in this regard, synchronous
calls can also be made to work.
On the other hand, synchronous calls also have their advantages, such as
making the code simpler and easier to understand.
Hence, this section provides some guidelines on how to set up a node's
callback groups correctly in order to avoid deadlocks.

First thing to note here is that every node's default callback group is a
Mutually Exclusive Callback Group.
If the user does not specify any other callback group when creating a timer,
subscription, client etc., any callbacks created then or later by these
entities will use the node's default callback group.
Furthermore, if everything in a node uses the same Mutually Exclusive
Callback Group, that node essentially acts as if it was handled
by a Single-Threaded Executor, even if a multi-threaded one is specified!
Thus, whenever one decides to use a Multi-Threaded Executor,
some callback group(s) should always be specified in order for the
executor choice to make sense.

With the above in mind, here are a couple guidelines to help avoid deadlocks:

* If you make a synchronous call in any type of a callback, this callback and
  the client making the call need to belong to

  * different callback groups (of any type), or
  * a Reentrant Callback Group.

* If the above configuration is not possible due to other requirements - such
  as thread-safety and/or blocking of other callbacks while waiting for the
  result (or if you want to make absolutely sure that there is never a
  possibility of a deadlock), use asynchronous calls.

Failing the first point will always cause a deadlock.
An example of such a case would be making a synchronous service call
in a timer callback (see the next section for an example).


Examples
--------

Let us look at some simple examples of different callback group setups.
The following demo code considers calling a service synchronously in a timer
callback.

Demo code
^^^^^^^^^

We have two nodes - one providing a simple service:

.. tabs::

   .. group-tab:: C++

      .. code-block:: cpp

        #include <memory>
        #include ""rclcpp/rclcpp.hpp""
        #include ""std_srvs/srv/empty.hpp""

        using namespace std::placeholders;

        namespace cb_group_demo
        {
        class ServiceNode : public rclcpp::Node
        {
        public:
            ServiceNode() : Node(""service_node"")
            {
                auto service_callback = [this](
                    const std::shared_ptr<rmw_request_id_t> request_header,
                    const std::shared_ptr<std_srvs::srv::Empty::Request> request,
                    const std::shared_ptr<std_srvs::srv::Empty::Response> response)
                {
                    (void)request_header;
                    (void)request;
                    (void)response;
                    RCLCPP_INFO(this->get_logger(), ""Received request, responding..."");
                };
                service_ptr_ = this->create_service<std_srvs::srv::Empty>(
                        ""test_service"",
                        service_callback
                );
            }

        private:
            rclcpp::Service<std_srvs::srv::Empty>::SharedPtr service_ptr_;

        };  // class ServiceNode
        }   // namespace cb_group_demo

        int main(int argc, char* argv[])
        {
            rclcpp::init(argc, argv);
            auto service_node = std::make_shared<cb_group_demo::ServiceNode>();

            RCLCPP_INFO(service_node->get_logger(), ""Starting server node, shut down with CTRL-C"");
            rclcpp::spin(service_node);
            RCLCPP_INFO(service_node->get_logger(), ""Keyboard interrupt, shutting down.\n"");

            rclcpp::shutdown();
            return 0;
        }

   .. group-tab:: Python

      .. code-block:: python

        import rclpy
        from rclpy.executors import ExternalShutdownException
        from rclpy.node import Node
        from std_srvs.srv import Empty

        class ServiceNode(Node):
            def __init__(self):
                super().__init__('service_node')
                self.srv = self.create_service(Empty, 'test_service', callback=self.service_callback)

            def service_callback(self, request, result):
                self.get_logger().info('Received request, responding...')
                return result


        if __name__ == '__main__':
            try:
                with rclpy.init():
                    node = ServiceNode()
                    node.get_logger().info(""Starting server node, shut down with CTRL-C"")
                    rclpy.spin(node)
            except (KeyboardInterrupt, ExternalShutdownException):
                pass

and another containing a client to the service along with a timer for making
service calls:

.. tabs::

  .. group-tab:: C++

    *Note:* The API of service client in rclcpp does not offer a
    synchronous call method similar to the one in rclpy, so we
    wait on the future object to simulate the effect of a
    synchronous call.

    .. code-block:: cpp

      #include <chrono>
      #include <memory>
      #include ""rclcpp/rclcpp.hpp""
      #include ""std_srvs/srv/empty.hpp""

      using namespace std::chrono_literals;

      namespace cb_group_demo
      {
      class DemoNode : public rclcpp::Node
      {
      public:
          DemoNode() : Node(""client_node"")
          {
              client_cb_group_ = nullptr;
              timer_cb_group_ = nullptr;
              client_ptr_ = this->create_client<std_srvs::srv::Empty>(""test_service"", rmw_qos_profile_services_default,
                                                                      client_cb_group_);

              auto timer_callback = [this](){
                  RCLCPP_INFO(this->get_logger(), ""Sending request"");
                  auto request = std::make_shared<std_srvs::srv::Empty::Request>();
                  auto result_future = client_ptr_->async_send_request(request);
                  std::future_status status = result_future.wait_for(10s);  // timeout to guarantee a graceful finish
                  if (status == std::future_status::ready) {
                      RCLCPP_INFO(this->get_logger(), ""Received response"");
                  }
              };

              timer_ptr_ = this->create_wall_timer(1s, timer_callback, timer_cb_group_);
          }

      private:
          rclcpp::CallbackGroup::SharedPtr client_cb_group_;
          rclcpp::CallbackGroup::SharedPtr timer_cb_group_;
          rclcpp::Client<std_srvs::srv::Empty>::SharedPtr client_ptr_;
          rclcpp::TimerBase::SharedPtr timer_ptr_;

      };  // class DemoNode
      }   // namespace cb_group_demo

      int main(int argc, char* argv[])
      {
          rclcpp::init(argc, argv);
          auto client_node = std::make_shared<cb_group_demo::DemoNode>();
          rclcpp::executors::MultiThreadedExecutor executor;
          executor.add_node(client_node);

          RCLCPP_INFO(client_node->get_logger(), ""Starting client node, shut down with CTRL-C"");
          executor.spin();
          RCLCPP_INFO(client_node->get_logger(), ""Keyboard interrupt, shutting down.\n"");

          rclcpp::shutdown();
          return 0;
      }

  .. group-tab:: Python

    .. code-block:: python

      import rclpy
      from rclpy.executors import ExternalShutdownException, MultiThreadedExecutor
      from rclpy.callback_groups import MutuallyExclusiveCallbackGroup, ReentrantCallbackGroup
      from rclpy.node import Node
      from std_srvs.srv import Empty


      class CallbackGroupDemo(Node):
          def __init__(self):
              super().__init__('client_node')

              client_cb_group = None
              timer_cb_group = None
              self.client = self.create_client(Empty, 'test_service', callback_group=client_cb_group)
              self.call_timer = self.create_timer(1, self._timer_cb, callback_group=timer_cb_group)

          def _timer_cb(self):
              self.get_logger().info('Sending request')
              _ = self.client.call(Empty.Request())
              self.get_logger().info('Received response')


      if __name__ == '__main__':
          try:
              with rclpy.init():
                  node = CallbackGroupDemo()
                  executor = MultiThreadedExecutor()
                  executor.add_node(node)

                  node.get_logger().info('Beginning client, shut down with CTRL-C')
                  executor.spin()
          except (KeyboardInterrupt, ExternalShutdownException):
              pass

The client node's constructor contains options for setting the
callback groups of the service client and the timer.
With the default setting above (both being ``nullptr`` / ``None``),
both the timer and the client will use the node's default
Mutually Exclusive Callback Group.

The problem
^^^^^^^^^^^

Since we are making service calls with a 1 second timer, the
expected outcome is that the service gets called once a second,
the client always gets a response and prints ``Received response``.
If we try running the server and client nodes
in terminals, we get the following outputs.

.. tabs::

  .. group-tab:: Client

    .. code-block:: console

      [INFO] [1653034371.758739131] [client_node]: Starting client node, shut down with CTRL-C
      [INFO] [1653034372.755865649] [client_node]: Sending request
      ^C[INFO] [1653034398.161674869] [client_node]: Keyboard interrupt, shutting down.

  .. group-tab:: Server

    .. code-block:: console

      [INFO] [1653034355.308958238] [service_node]: Starting server node, shut down with CTRL-C
      [INFO] [1653034372.758197320] [service_node]: Received request, responding...
      ^C[INFO] [1653034416.021962246] [service_node]: Keyboard interrupt, shutting down.

So, it turns out that instead of the service being called repeatedly,
the response of the first call is never received, after which the
client node seemingly gets stuck and does not make further calls.
That is, the execution stopped at a deadlock!

The reason for this is that the timer callback and the client are
using the same Mutually Exclusive Callback Group (the node's default).
When the service call is made, the client then passes its callback
group to the Future object (hidden inside the call-method in the
Python version) whose done-callback needs to execute for the result
of the service call to be available.
But because this done-callback and the timer callback are in the
same Mutually Exclusive group and the timer callback is still
executing (waiting for the result of the service call),
the done-callback never gets to execute.
The stuck timer callback also blocks any other executions of itself, so the
timer does not fire for a second time.

Solution
^^^^^^^^

We can fix this easily - for example - by assigning the timer and client
to different callback groups.
Thus, let us change the first two lines of the client node's constructor
to be as follows (everything else shall stay the same):

.. tabs::

  .. group-tab:: C++

    .. code-block:: cpp

      client_cb_group_ = this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);
      timer_cb_group_ = this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);

  .. group-tab:: Python

    .. code-block:: python

      client_cb_group = MutuallyExclusiveCallbackGroup()
      timer_cb_group = MutuallyExclusiveCallbackGroup()

Now we get the expected result, i.e. the timer fires repeatedly and
each service call gets the result as it should:

.. tabs::

  .. group-tab:: Client

    .. code-block:: console

      [INFO] [1653067523.431731177] [client_node]: Starting client node, shut down with CTRL-C
      [INFO] [1653067524.431912821] [client_node]: Sending request
      [INFO] [1653067524.433230445] [client_node]: Received response
      [INFO] [1653067525.431869330] [client_node]: Sending request
      [INFO] [1653067525.432912803] [client_node]: Received response
      [INFO] [1653067526.431844726] [client_node]: Sending request
      [INFO] [1653067526.432893954] [client_node]: Received response
      [INFO] [1653067527.431828287] [client_node]: Sending request
      [INFO] [1653067527.432848369] [client_node]: Received response
      ^C[INFO] [1653067528.400052749] [client_node]: Keyboard interrupt, shutting down.

  .. group-tab:: Server

    .. code-block:: console

      [INFO] [1653067522.052866001] [service_node]: Starting server node, shut down with CTRL-C
      [INFO] [1653067524.432577720] [service_node]: Received request, responding...
      [INFO] [1653067525.432365009] [service_node]: Received request, responding...
      [INFO] [1653067526.432300261] [service_node]: Received request, responding...
      [INFO] [1653067527.432272441] [service_node]: Received request, responding...
      ^C[INFO] [1653034416.021962246] [service_node]: KeyboardInterrupt, shutting down.

One might consider if just avoiding the node's default callback group
is enough.
This is not the case: replacing the default group by a
different Mutually Exclusive group changes nothing.
Thus, the following configuration also leads to the previously
discovered deadlock.

.. tabs::

  .. group-tab:: C++

    .. code-block:: cpp

      client_cb_group_ = this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);
      timer_cb_group_ = client_cb_group_;

  .. group-tab:: Python

    .. code-block:: python

      client_cb_group = MutuallyExclusiveCallbackGroup()
      timer_cb_group = client_cb_group

In fact, the exact condition with which everything works in this case
is that the timer and client must not belong to the same
Mutually Exclusive group.
Hence, all of the following configurations (and some others as well)
produce the desired outcome where the timer fires
repeatedly and service calls are completed.

.. tabs::

  .. group-tab:: C++

    .. code-block:: cpp

      client_cb_group_ = this->create_callback_group(rclcpp::CallbackGroupType::Reentrant);
      timer_cb_group_ = client_cb_group_;

    or

    .. code-block:: cpp

      client_cb_group_ = this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);
      timer_cb_group_ = nullptr;

    or

    .. code-block:: cpp

      client_cb_group_ = nullptr;
      timer_cb_group_ = this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);

    or

    .. code-block:: cpp

      client_cb_group_ = this->create_callback_group(rclcpp::CallbackGroupType::Reentrant);
      timer_cb_group_ = nullptr;

  .. group-tab:: Python

    .. code-block:: python

      client_cb_group = ReentrantCallbackGroup()
      timer_cb_group = client_cb_group

    or

    .. code-block:: python

      client_cb_group = MutuallyExclusiveCallbackGroup()
      timer_cb_group = None

    or

    .. code-block:: python

      client_cb_group = None
      timer_cb_group = MutuallyExclusiveCallbackGroup()

    or

    .. code-block:: python

      client_cb_group = ReentrantCallbackGroup()
      timer_cb_group = None
",What are the two different types of callback groups offered by ROS 2 for controlling the execution of callbacks?
".. redirect-from::

  Guides/Ament-CMake-Python-Documentation

ament_cmake_python user documentation
=====================================

``ament_cmake_python`` is a package that provides CMake functions for packages of the ``ament_cmake`` build type that contain Python code.
See the :doc:`ament_cmake user documentation <Ament-CMake-Documentation>` for more information.

.. note::

   Pure Python packages should use the ``ament_python`` build type in most cases.
   To create an ``ament_python`` package, see :doc:`Creating your first ROS 2 package <../Tutorials/Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>`.
   ``ament_cmake_python`` should only be used in cases where that is not possible, like when mixing C/C++ and Python code.


.. contents:: Table of Contents
   :depth: 2
   :local:

Basics
------

Basic project outline
^^^^^^^^^^^^^^^^^^^^^

The outline of a package called ""my_project"" with the ``ament_cmake`` build type that uses ``ament_cmake_python`` looks like:

.. code-block::

   .
   └── my_project
       ├── CMakeLists.txt
       ├── package.xml
       └── my_project
           ├── __init__.py
           └── my_script.py

The ``__init__.py`` file can be empty, but it is needed to `make Python treat the directory containing it as a package <https://docs.python.org/3/tutorial/modules.html#packages>`__.
There can also be a ``src`` or ``include`` directory alongside the ``CMakeLists.txt`` which holds C/C++ code.

Using ament_cmake_python
^^^^^^^^^^^^^^^^^^^^^^^^

The package must declare a dependency on ``ament_cmake_python`` in its ``package.xml``.

.. code-block:: xml

   <buildtool_depend>ament_cmake_python</buildtool_depend>

The ``CMakeLists.txt`` should contain:

.. code-block:: cmake

   find_package(ament_cmake_python REQUIRED)
   # ...
   ament_python_install_package(${PROJECT_NAME})

The argument to ``ament_python_install_package()`` is the name of the directory alongside the ``CMakeLists.txt`` that contains the Python file.
In this case, it is ``my_project``, or ``${PROJECT_NAME}``.

.. warning::

   Calling ``rosidl_generate_interfaces`` and ``ament_python_install_package`` in the same CMake project does not work.
   See this `Github issue <https://github.com/ros2/rosidl_python/issues/141>`_ for more info. It is best practice to instead
   separate out the message generation into a separate package.

Then, another Python package that correctly depends on ``my_project`` can use it as a normal Python module:

.. code-block:: python

   from my_project.my_script import my_function

Assuming ``my_script.py`` contains a function called ``my_function()``.

Using ament_cmake_pytest
^^^^^^^^^^^^^^^^^^^^^^^^

The package ``ament_cmake_pytest`` is used to make tests discoverable to ``cmake``.
The package must declare a test dependency on ``ament_cmake_pytest`` in its ``package.xml``.

.. code-block:: xml

   <test_depend>ament_cmake_pytest</test_depend>

Say the package has a file structure like below, with tests in the ``tests`` folder.

.. code-block::

   .
   ├── CMakeLists.txt
   ├── my_project
   │   └── my_script.py
   ├── package.xml
   └── tests
       ├── test_a.py
       └── test_b.py

The ``CMakeLists.txt`` should contain:

.. code-block:: cmake

   if(BUILD_TESTING)
     find_package(ament_cmake_pytest REQUIRED)
     set(_pytest_tests
       tests/test_a.py
       tests/test_b.py
       # Add other test files here
     )
     foreach(_test_path ${_pytest_tests})
       get_filename_component(_test_name ${_test_path} NAME_WE)
       ament_add_pytest_test(${_test_name} ${_test_path}
         APPEND_ENV PYTHONPATH=${CMAKE_CURRENT_BINARY_DIR}
         TIMEOUT 60
         WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
       )
     endforeach()
   endif()

Compared to the usage of ament_python, which supports automatic test discovery, ament_cmake_pytest must be called with the path to each test file.
The timeout can be reduced as needed.

Now, you can invoke your tests with the :doc:`standard colcon testing commands <../Tutorials/Intermediate/Testing/CLI>`.
","What is the purpose of using the package ""ament_cmake_python"" in a ROS 2 project?"
"ROS 2 on Raspberry Pi
=====================

ROS 2 is supported on both 32 bit (arm32) and 64 bit (arm64) ARM processors.
However, you can see `here <https://www.ros.org/reps/rep-2000.html>`__ that arm64 receives Tier 1 support, while arm32 is Tier 3.
Tier 1 support means distribution specific packages and binary archives are available, while Tier 3 requires the user to compile ROS 2 from source.

The fastest and simplest way to use ROS 2 is to use a Tier 1 supported configuration.

This would mean either installing 64 bit Ubuntu on to the Raspberry Pi, or using the 64 bit version of Raspberry Pi OS and running ROS 2 in Docker.

Ubuntu Linux on Raspberry Pi with binary ROS 2 install
------------------------------------------------------

Ubuntu for Raspberry Pi is available `here <https://ubuntu.com/download/raspberry-pi>`__.

Make sure to confirm that you have selected the correct version as described in `REP-2000 <https://www.ros.org/reps/rep-2000.html>`__.

You can now install ROS 2 using the normal binary installation instructions for Ubuntu Linux.

Raspberry Pi OS with ROS 2 in docker
------------------------------------

Raspberry Pi OS 64 bit version is `available here <https://www.raspberrypi.com/software/operating-systems/>`__.

Raspberry Pi OS is based on Debian which receives Tier 3 support, but it can run Ubuntu docker containers for Tier 1 support.

After flashing the OS, `install Docker <https://docs.docker.com/engine/install/debian/#install-using-the-convenience-script>`__.

The official ROS 2 Docker images can be found `here <https://hub.docker.com/_/ros/tags>`__.

You may choose from ros-core, ros-base, or perception. See `here <https://www.ros.org/reps/rep-2001.html>`__ for more information on these variants.

Fetch and run an image:

.. code-block:: bash

    docker pull ros:{DISTRO}-ros-core
    docker run -it --rm ros:{DISTRO}-ros-core

You can also build images yourself:

Clone the `docker_images git repo <https://github.com/osrf/docker_images>`__ onto the Raspberry Pi, change in to the directory linked above, then to the directory with your preferred variant.

Inside of the directory, build the container with:

.. code-block:: bash

    docker build -t ros_docker .

On a supported system it will only take a minute or two to build the docker containers, as the source code is already built in to binaries.
",What are the differences between Tier 1 and Tier 3 support for ARM processors in ROS 2?
".. redirect-from::

  Guides/Ament-CMake-Documentation
  Tutorials/Ament-CMake-Documentation

ament_cmake user documentation
==============================

``ament_cmake`` is the build system for CMake based packages in ROS 2 (in particular, it will be used for most C/C++ projects).
It is a set of scripts enhancing CMake and adding convenience functionality for package authors.
Before using ``ament_cmake``, it is very helpful to know the basics of `CMake <https://cmake.org/cmake/help/v3.8/>`__.
An official tutorial can be found `here <https://cmake.org/cmake/help/latest/guide/tutorial/index.html>`__.

.. contents:: Table of Contents
   :depth: 2
   :local:

Basics
------

A basic CMake outline can be produced using ``ros2 pkg create <package_name>`` on the command line.
The build information is then gathered in two files: the ``package.xml`` and the ``CMakeLists.txt``, which must be in the same directory.
The ``package.xml`` must contain all dependencies and a bit of metadata to allow colcon to find the correct build order for your packages, to install the required dependencies in CI, and to provide the information for a release with ``bloom``.
The ``CMakeLists.txt`` contains the commands to build and package executables and libraries and will be the main focus of this document.

Basic project outline
^^^^^^^^^^^^^^^^^^^^^

The basic outline of the ``CMakeLists.txt`` of an ament package contains:

.. code-block:: cmake

    cmake_minimum_required(VERSION 3.8)
    project(my_project)

    ament_package()

The argument to ``project`` will be the package name and must be identical to the package name in the ``package.xml``.

The project setup is done by ``ament_package()`` and this call must occur exactly once per package.
``ament_package()`` installs the ``package.xml``, registers the package with the ament index, and installs configuration (and possibly target) files for CMake so that it can be found by other packages using ``find_package``.
Since ``ament_package()`` gathers a lot of information from the ``CMakeLists.txt`` it should be the last call in your ``CMakeLists.txt``.

``ament_package`` can be given additional arguments:

- ``CONFIG_EXTRAS``: a list of CMake files (``.cmake`` or ``.cmake.in`` templates expanded by ``configure_file()``) which should be available to clients of the package.
  For an example of when to use these arguments, see the discussion in `Adding resources`_.
  For more information on how to use template files, see `the official documentation <https://cmake.org/cmake/help/v3.8/command/configure_file.html>`__.

- ``CONFIG_EXTRAS_POST``: same as ``CONFIG_EXTRAS``, but the order in which the files are added differs.
  While ``CONFIG_EXTRAS`` files are included before the files generated for the ``ament_export_*`` calls the files from ``CONFIG_EXTRAS_POST`` are included afterwards.

Instead of adding to ``ament_package``, you can also add to the variable ``${PROJECT_NAME}_CONFIG_EXTRAS`` and ``${PROJECT_NAME}_CONFIG_EXTRAS_POST`` with the same effect.
The only difference is again the order in which the files are added with the following total order:

- files added by ``CONFIG_EXTRAS``

- files added by appending to ``${PROJECT_NAME}_CONFIG_EXTRAS``

- files added by appending to ``${PROJECT_NAME}_CONFIG_EXTRAS_POST``

- files added by ``CONFIG_EXTRAS_POST``

Compiler and linker options
^^^^^^^^^^^^^^^^^^^^^^^^^^^

ROS 2 targets compilers which comply with the C++17 and C99 standard.
Newer versions might be targeted in the future and are referenced `here <https://www.ros.org/reps/rep-2000.html>`__.
Therefore it is customary to set the corresponding CMake flags:

.. code-block:: cmake

    if(NOT CMAKE_C_STANDARD)
      set(CMAKE_C_STANDARD 99)
    endif()
    if(NOT CMAKE_CXX_STANDARD)
      set(CMAKE_CXX_STANDARD 17)
    endif()

To keep the code clean, compilers should throw warnings for questionable code and these warnings should be fixed.

It is recommended to at least cover the following warning levels:

- For Visual Studio: the default ``W1`` warnings

- For GCC and Clang: ``-Wall -Wextra -Wpedantic`` are highly recommended and ``-Wshadow`` is advisable

It is currently recommended to use ``add_compile_options`` to add these options for all targets.
This avoids cluttering the code with target-based compile options for all executables, libraries, and tests:

.. code-block:: cmake

    if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES ""Clang"")
      add_compile_options(-Wall -Wextra -Wpedantic)
    endif()

Finding dependencies
^^^^^^^^^^^^^^^^^^^^

Most ``ament_cmake`` projects will have dependencies on other packages.
In CMake, this is accomplished by calling ``find_package``.
For instance, if your package depends on ``rclcpp``, then the ``CMakeLists.txt`` file should contain:

.. code-block:: cmake

    find_package(rclcpp REQUIRED)

.. note::

    It should never be necessary to ``find_package`` a library that is not explicitly needed but is a dependency of another dependency that is explicitly needed.
    If that is the case, file a bug against the corresponding package.

Adding targets
^^^^^^^^^^^^^^

In CMake nomenclature, ``targets`` are the artifacts that this project will create.
Either libraries or executables can be created, and a single project can contain zero or many of each of them.

.. tabs::

    .. group-tab:: Libraries

        These are created with a call to ``add_library``, which should contain both the name of the target and the source files that should be compiled to create the library.

        With the separation of header files and implementation in C/C++, it is not usually necessary to add header files as arguments to ``add_library``.

        The following best practice is proposed:

        - Put all headers which should be usable by clients of this library (and therefore must be installed) into a subdirectory of the ``include`` folder named like the package, while all other files (``.c/.cpp`` and header files which should not be exported) are inside the ``src`` folder

        - Only ``.c/.cpp`` files are explicitly referenced in the call to ``add_library``

        - Find headers to your library ``my_library`` via

        .. code-block:: cmake

            target_include_directories(my_library
              PUBLIC
                ""$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>""
                ""$<INSTALL_INTERFACE:include/${PROJECT_NAME}>"")

        This adds all files in the folder ``${CMAKE_CURRENT_SOURCE_DIR}/include`` to the public interface during build time and all files in the include folder (relative to ``${CMAKE_INSTALL_DIR}``) when being installed.

        ``ros2 pkg create`` creates a package layout that follows these rules.

        .. note::

            Since Windows is one of the officially supported platforms, to have maximum impact, any package should also build on Windows.
            The Windows library format enforces symbol visibility; that is, every symbol which should be used from a client has to be explicitly exported by the library (and symbols need to be implicitly imported).

            Since GCC and Clang builds do not generally do this, it is advised to use the logic in `the GCC wiki <https://gcc.gnu.org/wiki/Visibility>`__.
            To use it for a package called ``my_library``:

            - Copy the logic in the link into a header file called ``visibility_control.hpp``.

            - Replace ``DLL`` by ``MY_LIBRARY`` (for an example, see visibility control of `rviz_rendering <https://github.com/ros2/rviz/blob/ros2/rviz_rendering/include/rviz_rendering/visibility_control.hpp>`__).

            - Use the macros ""MY_LIBRARY_PUBLIC"" for all symbols you need to export (i.e. classes or functions).

            - In the project ``CMakeLists.txt`` use:

              .. code-block:: cmake

                  target_compile_definitions(my_library PRIVATE ""MY_LIBRARY_BUILDING_LIBRARY"")

            For more details, see :ref:`Windows Symbol Visibility in the Windows Tips and Tricks document <Windows_Symbol_Visibility>`.

    .. group-tab:: Executables

        These should be created with a call to ``add_executable``, which should contain both the name of the target and the source files that should be compiled to create the executable.
        The executable may also have to be linked with any libraries created in this package by using ``target_link_libraries``.

        Since executables aren't generally used by clients as a library, no header files need to be put in the ``include`` directory.

In the case that a package has both libraries and executables, make sure to combine the advice from both ""Libraries"" and ""Executables"" above.

Linking to dependencies
^^^^^^^^^^^^^^^^^^^^^^^

There are two ways to link your targets against a dependency.

The first and recommended way is to use the ament macro ``ament_target_dependencies``.
As an example, suppose we want to link ``my_library`` against the linear algebra library Eigen3.

.. code-block:: cmake

    find_package(Eigen3 REQUIRED)
    ament_target_dependencies(my_library PUBLIC Eigen3)

It includes the necessary headers and libraries and their dependencies to be correctly found by the project.

The second way is to use ``target_link_libraries``.

Modern CMake prefers to use only targets, exporting and linking against them.
CMake targets may be namespaced, similar to C++.
Prefer to use the namespaced targets if they are available.
For instance, ``Eigen3`` defines the target ``Eigen3::Eigen``.

In the example of Eigen3, the call should then look like

.. code-block:: cmake

    target_link_libraries(my_library PUBLIC Eigen3::Eigen)

This will also include necessary headers, libraries and their dependencies.
Note that this dependency must have been previously discovered via a call to ``find_package``.

Installing
^^^^^^^^^^

.. tabs::

    .. group-tab:: Libraries

        When building a reusable library, some information needs to be exported for downstream packages to easily use it.

        First, install the headers files which should be available to clients.
        The include directory is custom to support overlays in ``colcon``; see https://colcon.readthedocs.io/en/released/user/overriding-packages.html#install-headers-to-a-unique-include-directory for more information.

        .. code-block:: cmake

            install(
              DIRECTORY include/
              DESTINATION include/${PROJECT_NAME}
            )

        Next, install the targets and create the export target (``export_${PROJECT_NAME}``) that other code will use to find this package.
        Note that you can use a single ``install`` call to install all of the libraries in the project.

        .. code-block:: cmake

            install(
              TARGETS my_library
              EXPORT export_${PROJECT_NAME}
              LIBRARY DESTINATION lib
              ARCHIVE DESTINATION lib
              RUNTIME DESTINATION bin
            )

            ament_export_targets(export_${PROJECT_NAME} HAS_LIBRARY_TARGET)
            ament_export_dependencies(some_dependency)

        Here is what's happening in the snippet above:

        - The ``ament_export_targets`` macro exports the targets for CMake.
          This is necessary to allow your library's clients to use the ``target_link_libraries(client PRIVATE my_library::my_library)`` syntax.
          If the export set includes a library, add the option ``HAS_LIBRARY_TARGET`` to ``ament_export_targets``, which adds potential libraries to environment variables.

        - The ``ament_export_dependencies`` exports dependencies to downstream packages.
          This is necessary so that the user of the library does not have to call ``find_package`` for those dependencies, too.

        .. warning::

            Calling ``ament_export_targets``, ``ament_export_dependencies``, or other ament commands from a CMake subdirectory will not work as expected.
            This is because the CMake subdirectory has no way of setting necessary variables in the parent scope where ``ament_package`` is called.

        .. note::

            Windows DLLs are treated as runtime artifacts and installed into the ``RUNTIME DESTINATION`` folder.
            It is therefore advised to keep the ``RUNTIME`` install even when developing libraries on Unix based systems.

        - The ``EXPORT`` notation of the install call requires additional attention:
          It installs the CMake files for the ``my_library`` target.
          It must be named exactly the same as the argument in ``ament_export_targets``.
          To ensure that it can be used via ``ament_target_dependencies``, it should not be named exactly the same as the library name, but instead should have a prefix like ``export_`` (as shown above).

        - All install paths are relative to ``CMAKE_INSTALL_PREFIX``, which is already set correctly by colcon/ament.

        There are two additional functions which are available, but are superfluous for target based installs:

        .. code-block:: cmake

            ament_export_include_directories(""include/${PROJECT_NAME}"")
            ament_export_libraries(my_library)

        The first macro marks the directory of the exported include directories.
        The second macro marks the location of the installed library (this is done by the ``HAS_LIBRARY_TARGET`` argument in the call to ``ament_export_targets``).
        These should only be used if the downstream projects can't or don't want to use CMake target based dependencies.

        Some of the macros can take different types of arguments for non-target exports, but since the recommended way for modern Make is to use targets, we will not cover them here.
        Documentation of these options can be found in the source code itself.

    .. group-tab:: Executables

        When installing an executable, the following stanza *must be followed exactly* for the rest of the ROS tooling to find it:

        .. code-block:: cmake

            install(TARGETS my_exe
                DESTINATION lib/${PROJECT_NAME})

In the case that a package has both libraries and executables, make sure to combine the advice from both ""Libraries"" and ""Executables"" above.

Linting and Testing
-------------------

In order to separate testing from building the library with colcon, wrap all calls to linters and tests in a conditional:

.. code-block:: cmake

    if(BUILD_TESTING)
      find_package(ament_cmake_gtest REQUIRED)
      ament_add_gtest(<tests>)
    endif()

Linting
^^^^^^^

It's advised to use the combined call from `ament_lint_auto <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_lint_auto/doc/index.rst#ament_lint_auto>`_:

.. code-block:: cmake

    find_package(ament_lint_auto REQUIRED)
    ament_lint_auto_find_test_dependencies()

This will run linters as defined in the ``package.xml``.
It is recommended to use the set of linters defined by the package ``ament_lint_common``.
The individual linters included there, as well as their functions, can be seen in the `ament_lint_common docs <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_lint_common/doc/index.rst>`_.

Linters provided by ament can also be added separately, instead of running ``ament_lint_auto``.
One example of how to do so can be found in the `ament_cmake_lint_cmake documentation <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_cmake_lint_cmake/doc/index.rst>`_.

Testing
^^^^^^^

Ament contains CMake macros to simplify setting up GTests. Call:

.. code-block:: cmake

    find_package(ament_cmake_gtest)
    ament_add_gtest(some_test <test_sources>)

to add a GTest.
This is then a regular target which can be linked against other libraries (such as the project library).
The macros have additional parameters:

- ``APPEND_ENV``: append environment variables.
  For instance you can add to the ament prefix path by calling:

.. code-block:: cmake

    find_package(ament_cmake_gtest REQUIRED)
    ament_add_gtest(some_test <test_sources>
      APPEND_ENV PATH=some/addtional/path/for/testing/resources)

- ``APPEND_LIBRARY_DIRS``: append libraries so that they can be found by the linker at runtime.
  This can be achieved by setting environment variables like ``PATH`` on Windows and ``LD_LIBRARY_PATH`` on Linux, but this makes the call platform specific.

- ``ENV``: set environment variables (same syntax as ``APPEND_ENV``).

- ``TIMEOUT``: set a test timeout in second. The default for GTests is 60 seconds.  For example:

.. code-block:: cmake

    ament_add_gtest(some_test <test_sources> TIMEOUT 120)

- ``SKIP_TEST``: skip this test (will be shown as ""passed"" in the console output).

- ``SKIP_LINKING_MAIN_LIBRARIES``: Don't link against GTest.

- ``WORKING_DIRECTORY``: set the working directory for the test.

The default working directory otherwise is the ``CMAKE_CURRENT_BINARY_DIR``, which is described in the `CMake documentation <https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_BINARY_DIR.html>`_.

Similarly, there is a CMake macro to set up GTest including GMock:

.. code-block:: cmake

    find_package(ament_cmake_gmock REQUIRED)
    ament_add_gmock(some_test <test_sources>)

It has the same additional parameters as ``ament_add_gtest``.

Extending ament
---------------

It is possible to register additional macros/functions with ``ament_cmake`` and extend it in several ways.

Adding a function/macro to ament
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Extending ament will often times mean that you want to have some functions available to other packages.
The best way to provide the macro to client packages is to register it with ament.

This can be done by appending the ``${PROJECT_NAME}_CONFIG_EXTRAS`` variable, which is used by ``ament_package()`` via

.. code-block:: cmake

    list(APPEND ${PROJECT_NAME}_CONFIG_EXTRAS
      path/to/file.cmake""
      other/pathto/file.cmake""
    )

Alternatively, you can directly add the files to the ``ament_package()`` call:

.. code-block:: cmake

    ament_package(CONFIG_EXTRAS
      path/to/file.cmake
      other/pathto/file.cmake
    )

Adding to extension points
^^^^^^^^^^^^^^^^^^^^^^^^^^

In addition to simple files with functions that can be used in other packages, you can also add extensions to ament.
Those extensions are scripts which are executed with the function which defines the extension point.
The most common use-case for ament extensions is probably registering rosidl message generators:
When writing a generator, you normally want to generate all messages and services with your generator also without modifying the code for the message/service definition packages.
This is possible by registering the generator as an extension to ``rosidl_generate_interfaces``.

As an example, see

.. code-block:: cmake

    ament_register_extension(
      ""rosidl_generate_interfaces""
      ""rosidl_generator_cpp""
      ""rosidl_generator_cpp_generate_interfaces.cmake"")

which registers the macro ``rosidl_generator_cpp_generate_interfaces.cmake`` for the package ``rosidl_generator_cpp`` to the extension point ``rosidl_generate_interfaces``.
When the extension point gets executed, this will trigger the execution of the script ``rosidl_generator_cpp_generate_interfaces.cmake`` here.
In particular, this will call the generator whenever the function ``rosidl_generate_interfaces`` gets executed.

The most important extension point for generators, aside from ``rosidl_generate_interfaces``, is ``ament_package``, which will simply execute scripts with the ``ament_package()`` call.
This extension point is useful when registering resources (see below).

``ament_register_extension`` is a function which takes exactly three arguments:

- ``extension_point``: The name of the extension point (most of the time this will be one of ``ament_package`` or ``rosidl_generate_interfaces``)

- ``package_name``: The name of the package containing the CMake file (i.e. the project name of the project where the file is written to)

- ``cmake_filename``: The CMake file executed when the extension point is run

.. note::

    It is possible to define custom extension points in a similar manner to ``ament_package`` and ``rosidl_generate_interfaces``, but this should hardly be necessary.

Adding extension points
^^^^^^^^^^^^^^^^^^^^^^^

Very rarely, it might be interesting to define a new extension point to ament.

Extension points can be registered within a macro so that all extensions will be executed when the corresponding macro is called.
To do so:

- Define and document a name for your extension (e.g. ``my_extension_point``), which is the name passed to the ``ament_register_extension`` macro when using the extension point.

- In the macro/function which should execute the extensions call:

.. code-block:: cmake

    ament_execute_extensions(my_extension_point)

Ament extensions work by defining a variable containing the name of the extension point and filling it with the macros to be executed.
Upon calling ``ament_execute_extensions``, the scripts defined in the variable are then executed one after another.

Adding resources
----------------

Especially when developing plugins or packages which allow plugins it is often essential to add resources to one ROS package from another (e.g. a plugin).
Examples can be plugins for tools using the pluginlib.

This can be achieved using the ament index (also called ""resource index"").

The ament index explained
^^^^^^^^^^^^^^^^^^^^^^^^^

For details on the design and intentions, see `here <https://github.com/ament/ament_cmake/blob/{REPOS_FILE_BRANCH}/ament_cmake_core/doc/resource_index.md>`__

In principle, the ament index is contained in a folder within the install/share folder of your package.
It contains shallow subfolders named after different types of resources.
Within the subfolder, each package providing said resource is referenced by name with a ""marker file"".
The file may contain whatever content necessary to obtain the resources, e.g. relative paths to the installation directories of the resource, it may also be simply empty.

To give an example, consider providing display plugins for RViz:
When providing RViz plugins in a project named ``my_rviz_displays`` which will be read by the pluginlib, you will provide a ``plugin_description.xml`` file, which will be installed and used by the pluginlib to load the plugins.
To achieve this, the plugin_description.xml is registered as a resource in the resource_index via

.. code-block:: cmake

    pluginlib_export_plugin_description_file(rviz_common plugins_description.xml)

When running ``colcon build``, this installs a file ``my_rviz_displays`` into a subfolder ``rviz_common__pluginlib__plugin`` into the resource_index.
Pluginlib factories within rviz_common will know to gather information from all folders named ``rviz_common__pluginlib__plugin`` for packages that export plugins.
The marker file for pluginlib factories contains an install-folder relative path to the ``plugins_description.xml`` file (and the name of the library as marker file name).
With this information, the pluginlib can load the library and know which plugins to load from the ``plugin_description.xml`` file.

As a second example, consider the possibility to let your own RViz plugins use your own custom meshes.
Meshes get loaded at startup time so that the plugin owner does not have to deal with it, but this implies RViz has to know about the meshes.
To achieve this, RViz provides a function:

.. code-block:: cmake

    register_rviz_ogre_media_exports(DIRECTORIES <my_dirs>)

This registers the directories as an ogre_media resource in the ament index.
In short, it installs a file named after the project which calls the function into a subfolder called ``rviz_ogre_media_exports``.
The file contains the install folder relative paths to the directories listed in the macros.
On startup time, RViz can now search for all folders called ``rviz_ogre_media_exports`` and load resources in all folders provided.
These searches are done using ``ament_index_cpp`` (or ``ament_index_py`` for Python packages).

In the following sections we will explore how to add your own resources to the ament index and provide best practices for doing so.

Querying the ament index
^^^^^^^^^^^^^^^^^^^^^^^^

If necessary, it is possible to query the ament index for resources via CMake.
To do so, there are three functions:

``ament_index_has_resource``: Obtain a prefix path to the resource if it exists with the following parameters:

- ``var``: the output parameter: fill this variable with FALSE if the resource does not exist or the prefix path to the resource otherwise

- ``resource_type``: The type of the resource (e.g. ``rviz_common__pluginlib__plugin``)

- ``resource_name``: The name of the resource which usually amounts to the name of the package having added the resource of type resource_type (e.g. ``rviz_default_plugins``)

``ament_index_get_resource``: Obtain the content of a specific resource, i.e. the contents of the marker file in the ament index.

- ``var``: the output parameter: filled with the content of the resource marker file if it exists.

- ``resource_type``: The type of the resource (e.g. ``rviz_common__pluginlib__plugin``)

- ``resource_name``: The name of the resource which usually amounts to the name of the package having added the resource of type resource_type (e.g. ``rviz_default_plugins``)

- ``PREFIX_PATH``: The prefix path to search for (usually, the default ``ament_index_get_prefix_path()`` will be enough).

Note that ``ament_index_get_resource`` will throw an error if the resource does not exist, so it might be necessary to check using ``ament_index_has_resource``.

``ament_index_get_resources``: Get all packages which registered resources of a specific type from the index

- ``var``: Output parameter: filled with a list of names of all packages which registered a resource of resource_type

- ``resource_type``: The type of the resource (e.g. ``rviz_common__pluginlib__plugin``)

- ``PREFIX_PATH``: The prefix path to search for (usually, the default ``ament_index_get_prefix_path()`` will be enough).

Adding to the ament index
^^^^^^^^^^^^^^^^^^^^^^^^^

Defining a resource requires two bits of information:

- a name for the resource which must be unique,

- a layout of the marker file, which can be anything and could also be empty (this is true for instance for the ""package"" resource marking a ROS 2 package)

For the RViz mesh resource, the corresponding choices were:

- ``rviz_ogre_media_exports`` as name of the resource,

- install path relative paths to all folders containing resources. This will already enable you to write the logic for using the corresponding resource in your package.

To allow users to easily register resources for your package, you should furthermore provide macros or functions such as the pluginlib function or ``rviz_ogre_media_exports`` function.

To register a resource, use the ament function ``ament_index_register_resource``.
This will create and install the marker files in the resource_index.
As an example, the corresponding call for ``rviz_ogre_media_exports`` is the following:

.. code-block:: cmake

    ament_index_register_resource(rviz_ogre_media_exports CONTENT ${OGRE_MEDIA_RESOURCE_FILE})

This installs a file named like ``${PROJECT_NAME}`` into a folder ``rviz_ogre_media_exports`` into the resource_index with content given by variable ``${OGRE_MEDIA_RESOURCE_FILE}``.
The macro has a number of parameters that can be useful:

- the first (unnamed) parameter is the name of the resource, which amounts to the name of the folder in the resource_index

- ``CONTENT``: The content of the marker file as string. This could be a list of relative paths, etc. ``CONTENT`` cannot be used together with ``CONTENT_FILE``.

- ``CONTENT_FILE``: The path to a file which will be use to create the marker file. The file can be a plain file or a template file expanded with ``configure_file()``.
  ``CONTENT_FILE`` cannot be used together with ``CONTENT``.

- ``PACKAGE_NAME``: The name of the package/library exporting the resource, which amounts to the name of the marker file. Defaults to ``${PROJECT_NAME}``.

- ``AMENT_INDEX_BINARY_DIR``: The base path of the generated ament index. Unless really necessary, always use the default ``${CMAKE_BINARY_DIR}/ament_cmake_index``.

- ``SKIP_INSTALL``: Skip installing the marker file.

Since only one marker file exists per package, it is usually a problem if the CMake function/macro gets called twice by the same project.
However, for large projects it might be best to split up calls registering resources.

Therefore, it is best practice to let a macro registering a resource such as ``register_rviz_ogre_media_exports.cmake`` only fill some variables.
The real call to ``ament_index_register_resource`` can then be added within an ament extension to ``ament_package``.
Since there must only ever be one call to ``ament_package`` per project, there will always only be one place where the resource gets registered.
In the case of ``rviz_ogre_media_exports`` this amounts to the following strategy:

- The macro ``register_rviz_ogre_media_exports`` takes a list of folders and appends them to a variable called ``OGRE_MEDIA_RESOURCE_FILE``.

- Another macro called ``register_rviz_ogre_media_exports_hook`` calls ``ament_index_register_resource`` if ``${OGRE_MEDIA_RESOURCE_FILE}`` is non-empty.

- The ``register_rviz_ogre_media_exports_hook.cmake`` file is registered as an ament extension in a third file ``register_rviz_ogre_media_exports_hook-extras.cmake`` via calling

.. code-block:: cmake

    ament_register_extension(""ament_package"" ""rviz_rendering""
      ""register_rviz_ogre_media_exports_hook.cmake"")

- The files ``register_rviz_ogre_media_exports.cmake`` and ``register_rviz_ogre_media_exports_hook-extra.cmake`` are registered as ``CONFIG_EXTRA`` with ``ament_package()``.
",What is the purpose of the ament index in the context of package development in ROS 2?
".. redirect-from::

    Working-with-multiple-RMW-implementations
    Guides/Working-with-multiple-RMW-implementations
    Tutorials/Working-with-multiple-RMW-implementations

Working with multiple ROS 2 middleware implementations
======================================================

.. contents:: Table of Contents
   :depth: 2
   :local:

This page explains the default RMW implementation and how to specify an alternative.

Prerequisites
--------------

You should have already read the :doc:`DDS and ROS middleware implementations page <../Concepts/Intermediate/About-Different-Middleware-Vendors>`.

Specifying RMW implementations
------------------------------

To have multiple RMW implementations available for use you must have installed the ROS 2 binaries and any additional dependencies for specific RMW implementations, or built ROS 2 from source with multiple RMW implementations in the workspace (the RMW implementations are included in the build by default if their compile-time dependencies are met). See :doc:`Install DDS implementations <../Installation/DDS-Implementations>`.

----

Both C++ and Python nodes support an environment variable ``RMW_IMPLEMENTATION`` that allows the user to select the RMW implementation to use when running ROS 2 applications.

The user may set this variable to a specific implementation identifier, such as ``rmw_cyclonedds_cpp``, ``rmw_fastrtps_cpp``, ``rmw_connextdds``, or ``rmw_gurumdds_cpp``.

For example, to run the talker demo using the C++ talker and Python listener with the Connext RMW implementation:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

       RMW_IMPLEMENTATION=rmw_connextdds ros2 run demo_nodes_cpp talker

       # Run in another terminal
       RMW_IMPLEMENTATION=rmw_connextdds ros2 run demo_nodes_py listener

  .. group-tab:: macOS

    .. code-block:: bash

       RMW_IMPLEMENTATION=rmw_connextdds ros2 run demo_nodes_cpp talker

       # Run in another terminal
       RMW_IMPLEMENTATION=rmw_connextdds ros2 run demo_nodes_py listener

  .. group-tab:: Windows

    .. code-block:: bat

       set RMW_IMPLEMENTATION=rmw_connextdds
       ros2 run demo_nodes_cpp talker

       REM run in another terminal
       set RMW_IMPLEMENTATION=rmw_connextdds
       ros2 run demo_nodes_py listener

Adding RMW implementations to your workspace
--------------------------------------------

Suppose that you have built your ROS 2 workspace with only Fast DDS installed and therefore only the Fast DDS RMW implementation built.
The last time your workspace was built, any other RMW implementation packages, ``rmw_connextdds`` for example, were probably unable to find installations of the relevant DDS implementations.
If you then install an additional DDS implementation, Connext for example, you will need to re-trigger the check for a Connext installation that occurs when the Connext RMW implementation is being built.
You can do this by specifying the ``--cmake-clean-cache`` flag on your next workspace build, and you should see that the RMW implementation package then gets built for the newly installed DDS implementation.

It is possible to run into a problem when ""rebuilding"" the workspace with an additional RMW implementation using the ``--cmake-clean-cache`` option where the build complains about the default RMW implementation changing.
To resolve this, you can either set the default implementation to what is was before with the ``RMW_IMPLEMENTATION`` CMake argument or you can delete the build folder for packages that complain and continue the build with ``--packages-start <package name>``.

Troubleshooting
---------------

Checking the Current RMW
^^^^^^^^^^^^^^^^^^^^^^^^

To check the RMW that is currently in use you simply check the ``RMW_IMPLEMENTATION`` environment variable. On Linux systems ``printenv`` prints the full list of environment variables.
Other operating systems will have other procedures for viewing environment variables.
If ``RMW_IMPLEMENTATION`` is not in the environment it is safe to assume you are using the default for your ROS distro, otherwise the current RMW is the value listed.
The default RMW for each ROS Distro can be found in `REP-2000 <https://www.ros.org/reps/rep-2000.html#platforms-by-distribution>`_.

Ensuring use of a particular RMW implementation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the ``RMW_IMPLEMENTATION`` environment variable is set to an RMW implementation for which support is not installed, you will see an error message similar to the following if you have only one implementation installed:

.. code-block:: bash

   Expected RMW implementation identifier of 'rmw_connextdds' but instead found 'rmw_fastrtps_cpp', exiting with 102.

If you have support for multiple RMW implementations installed and you request use of one that is not installed, you will see something similar to:

.. code-block:: bash

   Error getting RMW implementation identifier / RMW implementation not installed (expected identifier of 'rmw_connextdds'), exiting with 1.

If this occurs, double check that your ROS 2 installation includes support for the RMW implementation that you have specified in the ``RMW_IMPLEMENTATION`` environment variable.

If you want to switch between RMW implementations, verify that the ROS 2 daemon process is not running with the previous RMW implementation to avoid any issues between nodes and command line tools such as ``ros2 node``.
For example, if you run:

.. code-block:: bash

   RMW_IMPLEMENTATION=rmw_connextdds ros2 run demo_nodes_cpp talker

and

.. code-block:: bash

   ros2 node list

it will generate a daemon with a Fast DDS implementation:

.. code-block:: bash

   21318 22.0  0.6 535896 55044 pts/8    Sl   16:14   0:00 /usr/bin/python3 /opt/ros/{DISTRO}/bin/_ros2_daemon --rmw-implementation rmw_fastrtps_cpp --ros-domain-id 0

Even if you run the command line tool again with the correct RMW implementation, the daemon's RMW implementation will not change and the ROS 2 command line tools will fail.

To solve this, simply stop the daemon process:

.. code-block:: bash

   ros2 daemon stop

and rerun the ROS 2 command line tool with the correct RMW implementation.

RTI Connext on OSX: Failure due to insufficient shared memory kernel settings
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you receive an error message similar to below when running RTI Connext on OSX:

.. code-block:: console

   [D0062|ENABLE]DDS_DomainParticipantPresentation_reserve_participant_index_entryports:!enable reserve participant index
   [D0062|ENABLE]DDS_DomainParticipant_reserve_participant_index_entryports:Unusable shared memory transport. For a more in-   depth explanation of the possible problem and solution, please visit https://community.rti.com/kb/osx510.

This error is caused by an insufficient number or size of shared memory segments allowed by the operating system. As a result, the ``DomainParticipant`` is unable to allocate enough resources and calculate its participant index which causes the error.

You can increase the shared memory resources of your machine either temporarily or permanently.

To increase the settings temporarily, you can run the following commands as user root:

.. code-block:: console

   /usr/sbin/sysctl -w kern.sysv.shmmax=419430400
   /usr/sbin/sysctl -w kern.sysv.shmmin=1
   /usr/sbin/sysctl -w kern.sysv.shmmni=128
   /usr/sbin/sysctl -w kern.sysv.shmseg=1024
   /usr/sbin/sysctl -w kern.sysv.shmall=262144

To increase the settings permanently, you will need to edit or create the file ``/etc/sysctl.conf``. Creating or editing this file will require root permissions. Either add to your existing ``etc/sysctl.conf`` file or create ``/etc/sysctl.conf`` with the following lines:

.. code-block:: console

   kern.sysv.shmmax=419430400
   kern.sysv.shmmin=1
   kern.sysv.shmmni=128
   kern.sysv.shmseg=1024
   kern.sysv.shmall=262144

You will need to reboot the machine after modifying this file to have the changes take effect.

This solution is edited from the RTI Connext community forum.
See the `original post <https://community.rti.com/kb/osx510>`__ for more detailed explanation.
",What are the steps to specify an alternative RMW implementation when working with multiple ROS 2 middleware implementations?
".. redirect-from::

    Node-arguments
    Guides/Node-arguments
    Tutorials/Node-arguments

Passing ROS arguments to nodes via the command-line
===================================================

.. contents:: Table of Contents
   :depth: 1
   :local:


All ROS nodes take a set of arguments that allow various properties to be reconfigured.
Examples include configuring the name/namespace of the node, topic/service names used, and parameters on the node.
All ROS-specific arguments have to be specified after a ``--ros-args`` flag:


.. code-block:: bash

   ros2 run my_package node_executable --ros-args ...


For more details, see `this design doc <https://design.ros2.org/articles/ros_command_line_arguments.html>`__.

Name remapping
--------------

Names within a node (e.g. topics/services) can be remapped using the syntax ``-r <old name>:=<new name>``.
The name/namespace of the node itself can be remapped using ``-r __node:=<new node name>`` and ``-r __ns:=<new node namespace>``.


Note that these remappings are ""static"" remappings, in that they apply for the lifetime of the node.
""Dynamic"" remapping of names after nodes have been started is not yet supported.

See `this design doc <https://design.ros2.org/articles/static_remapping.html>`__ for more details on remapping arguments (not all functionality is available yet).

Example
^^^^^^^

The following invocation will cause the ``talker`` node to be started under the node name ``my_talker``, publishing on the topic named ``my_topic`` instead of the default of ``chatter``.
The namespace, which must start with a forward slash, is set to ``/demo``, which means that topics are created in that namespace (``/demo/my_topic``), as opposed to globally (``/my_topic``).

.. code-block:: bash

  ros2 run demo_nodes_cpp talker --ros-args -r __ns:=/demo -r __node:=my_talker -r chatter:=my_topic

Passing remapping arguments to specific nodes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If multiple nodes are being run within a single process (e.g. using :doc:`Composition <../Concepts/Intermediate/About-Composition>`), remapping arguments can be passed to a specific node using its name as a prefix.
For example, the following will pass the remapping arguments to the specified nodes:

.. code-block:: bash

  ros2 run composition manual_composition --ros-args -r talker:__node:=my_talker -r listener:__node:=my_listener


The following example will both change the node name and remap a topic (node and namespace changes are always applied *before* topic remapping):

.. code-block:: bash

  ros2 run composition manual_composition --ros-args -r talker:__node:=my_talker -r my_talker:chatter:=my_topic -r listener:__node:=my_listener -r my_listener:chatter:=my_topic


Logger configuration
--------------------

The per-node logging level can be specified using the ``--log-level`` command line argument.
The executable log file name prefix, which includes all nodes in the executable, can be specified using ``--log-file-name`` command line argument.
For more information please see :doc:`the logging page <../Tutorials/Demos/Logging-and-logger-configuration>`.

Parameters
----------

.. _NodeArgsParameters:

Setting parameters directly from the command line
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can set parameters directly from the command line using the following syntax:

.. code-block:: bash

  ros2 run package_name executable_name --ros-args -p param_name:=param_value

As an example, you can run:

.. code-block:: bash

  ros2 run demo_nodes_cpp parameter_blackboard --ros-args -p some_int:=42 -p ""a_string:=Hello world"" -p ""some_lists.some_integers:=[1, 2, 3, 4]"" -p ""some_lists.some_doubles:=[3.14, 2.718]""

Other nodes will be able to retrieve the parameter values, e.g.:

.. code-block:: bash

  $ ros2 param list parameter_blackboard
  a_string
  qos_overrides./parameter_events.publisher.depth
  qos_overrides./parameter_events.publisher.durability
  qos_overrides./parameter_events.publisher.history
  qos_overrides./parameter_events.publisher.reliability
  some_int
  some_lists.some_doubles
  some_lists.some_integers
  use_sim_time

Setting parameters from YAML files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Parameters can be set from the command-line in the form of yaml files.

`See here <https://github.com/ros2/rcl/tree/{REPOS_FILE_BRANCH}/rcl_yaml_param_parser>`__ for examples of the yaml file syntax.

As an example, save the following as ``demo_params.yaml``:

.. code-block:: yaml

  parameter_blackboard:
      ros__parameters:
          some_int: 42
          a_string: ""Hello world""
          some_lists:
              some_integers: [1, 2, 3, 4]
              some_doubles : [3.14, 2.718]

Then either declare the parameters within your node with `declare_parameter <http://docs.ros.org/en/{DISTRO}/p/rclcpp/generated/classrclcpp_1_1Node.html#_CPPv4N6rclcpp4Node17declare_parameterERKNSt6stringERKN6rclcpp14ParameterValueERKN14rcl_interfaces3msg19ParameterDescriptorEb>`__  or `declare_parameters <http://docs.ros.org/en/{DISTRO}/p/rclcpp/generated/classrclcpp_1_1Node.html#_CPPv4I0EN6rclcpp4Node18declare_parametersENSt6vectorI10ParameterTEERKNSt6stringERKNSt3mapINSt6stringENSt4pairI10ParameterTN14rcl_interfaces3msg19ParameterDescriptorEEEEEb>`__, or `set the node to automatically declare parameters <http://docs.ros.org/en/{DISTRO}/p/rclcpp/generated/classrclcpp_1_1NodeOptions.html#_CPPv4NK6rclcpp11NodeOptions47automatically_declare_parameters_from_overridesEv>`__ if they were passed in via a command line override.

Then run the following:

.. code-block:: bash

  ros2 run demo_nodes_cpp parameter_blackboard --ros-args --params-file demo_params.yaml


Other nodes will be able to retrieve the parameter values, e.g.:

.. code-block:: bash

  $ ros2 param list parameter_blackboard
  a_string
  qos_overrides./parameter_events.publisher.depth
  qos_overrides./parameter_events.publisher.durability
  qos_overrides./parameter_events.publisher.history
  qos_overrides./parameter_events.publisher.reliability
  some_int
  some_lists.some_doubles
  some_lists.some_integers
  use_sim_time
",What flag needs to be specified in ROS to pass ROS-specific arguments to nodes via the command-line?
".. _TopicsServicesActions:

Topics vs Services vs Actions
=============================

.. contents:: Contents
   :depth: 1
   :local:

When designing a system there are three primary styles of interfaces.
The specifications for the content is in the :doc:`Interfaces Overview <../Concepts/Basic/About-Interfaces>`.
This is written to provide the reader with guidelines about when to use each type of interface.

Topics
------

* Should be used for continuous data streams (sensor data, robot state, ...).
* Are for continuous data flow. Data might be published and subscribed at any time independent of any senders/receivers. Many to many connection. Callbacks receive data once it is available. The publisher decides when data is sent.

Services
--------

* Should be used for remote procedure calls that terminate quickly, e.g. for querying the state of a node or doing a quick calculation such as IK. They should never be used for longer running processes, in particular processes that might be required to preempt if exceptional situations occur and they should never change or depend on state to avoid unwanted side effects for other nodes.
* Simple blocking call. Mostly used for comparably fast tasks as requesting specific data. Semantically for processing requests.

Actions
-------

* Should be used for any discrete behavior that moves a robot or that runs for a longer time but provides feedback during execution.
* The most important property of actions is that they can be preempted and preemption should always be implemented cleanly by action servers.
* Actions can keep state for the lifetime of a goal, i.e. if executing two action goals in parallel on the same server, for each client a separate state instance can be kept since the goal is uniquely identified by its id.
* Slow perception routines which take several seconds to terminate or initiating a lower-level control mode are good use cases for actions.
* More complex non-blocking background processing. Used for longer tasks like execution of robot actions. Semantically for real-world actions.
",Which style of interface should be used for remote procedure calls that terminate quickly and should never be used for longer running processes?
"Migrating from ROS 1 to ROS 2
=============================

These guides show how to convert existing ROS 1 packages to ROS 2.
If you are new to porting between ROS 1 and ROS 2, it is recommended to read through the guides in order.

.. toctree::
   :maxdepth: 1

   Migrating-from-ROS1/Migrating-Packages
   Migrating-from-ROS1/Migrating-Package-XML
   Migrating-from-ROS1/Migrating-Interfaces
   Migrating-from-ROS1/Migrating-CPP-Package-Example
   Migrating-from-ROS1/Migrating-CPP-Packages
   Migrating-from-ROS1/Migrating-Python-Package-Example
   Migrating-from-ROS1/Migrating-Python-Packages
   Migrating-from-ROS1/Migrating-Launch-Files
   Migrating-from-ROS1/Migrating-Parameters
   Migrating-from-ROS1/Migrating-Scripts

Automatic tools
---------------

There are also some automatic conversion tools that exist, though they are not exhaustive:

* `Magical ROS 2 Conversion Tool <https://github.com/DLu/roscompile/tree/main/magical_ros2_conversion_tool>`_
* Launch File migrator that converts a ROS 1 XML launch file to a ROS 2 Python launch file: https://github.com/aws-robotics/ros2-launch-file-migrator
* Amazon has made their tools for porting from ROS 1 to ROS 2 available at: https://github.com/awslabs/ros2-migration-tools/tree/master/porting\_tools
* `rospy2 <https://github.com/dheera/rospy2>`_ Python project to automatically convert rospy calls to rclpy calls
",What are some automatic conversion tools available for migrating from ROS 1 to ROS 2?
".. redirect-from::

  Guides/Building-a-Custom-Debian-Package
  How-To-Guides/Building-a-Custom-Debian-Package

Building a custom deb package
=============================

Many Ubuntu users install ROS 2 on their system by installing :doc:`deb packages <../Installation/Ubuntu-Install-Debs>`.
This guide gives a short set of instructions to build local, custom deb packages.

.. contents:: Table of Contents
   :local:

Prerequisites
-------------

To successfully build a custom package, all of the dependencies of the package to be built must be available locally or in rosdep.
Additionally, all of the dependencies of the package should be properly declared in the ``package.xml`` file of the package.

Install dependencies
--------------------

Run the following command to install utilities needed for the build:

.. code:: bash

  $ sudo apt install python3-bloom python3-rosdep fakeroot debhelper dh-python

Initialize rosdep
-----------------

Initialize the rosdep database by calling:

.. code:: bash

  $ sudo rosdep init
  $ rosdep update

Note that the ``rosdep init`` command may fail if it has already been initialized in the past; this can safely be ignored.

Build the deb from the package
------------------------------

Run the following commands to build the deb:

.. code:: bash

  $ cd /path/to/pkg_source  # this should be the directory that contains the package.xml
  $ bloom-generate rosdebian
  $ fakeroot debian/rules binary

Assuming that all required dependencies are available and that compilation succeeds, the new package will be available in the parent directory of this directory.
",What are the key prerequisites for successfully building a custom deb package according to the text?
".. redirect-from::

  Guides/Sync-Vs-Async
  Tutorials/Sync-Vs-Async

.. _SyncAsync:

Synchronous vs. asynchronous service clients
============================================

**Level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:


Introduction
------------

This guide is intended to warn users of the risks associated with the Python synchronous service client ``call()`` API.
It is very easy to mistakenly cause deadlock when calling services synchronously, so we do not recommend using ``call()``.

We provide an example on how to use ``call()`` correctly for experienced users who wish to use synchronous calls and are aware of the pitfalls.
We also highlight possible scenarios for deadlock that accompany it.

Because we recommend avoiding sync calls, this guide will also address the features and usage of the recommended alternative, async calls (``call_async()``).

The C++ service call API is only available in async, so the comparisons and examples in this guide pertain to Python services and clients.
The definition of async given here generally applies to C++, with some exceptions.

1 Synchronous calls
-------------------

A synchronous client will block the calling thread when sending a request to a service until a response has been received; nothing else can happen on that thread during the call.
The call can take arbitrary amounts of time to complete.
Once complete, the response returns directly to the client.

The following is an example of how to correctly execute a synchronous service call from a client node, similar to the async node in the :doc:`Simple Service and Client <../Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client>` tutorial.

.. code-block:: python

  from threading import Thread

  from example_interfaces.srv import AddTwoInts
  import rclpy
  from rclpy.executors import ExternalShutdownException
  from rclpy.node import Node

  class MinimalClientSync(Node):

      def __init__(self):
          super().__init__('minimal_client_sync')
          self.cli = self.create_client(AddTwoInts, 'add_two_ints')
          while not self.cli.wait_for_service(timeout_sec=1.0):
              self.get_logger().info('service not available, waiting again...')
          self.req = AddTwoInts.Request()

      def send_request(self):
          self.req.a = 41
          self.req.b = 1
          return self.cli.call(self.req)
          # This only works because rclpy.spin() is called in a separate thread below.
          # Another configuration, like spinning later in main() or calling this method from a timer callback, would result in a deadlock.

  def main():
      try:
          with rclpy.init():
              minimal_client = MinimalClientSync()

              spin_thread = Thread(target=rclpy.spin, args=(minimal_client,))
              spin_thread.start()

              response = minimal_client.send_request()
              minimal_client.get_logger().info(
                  'Result of add_two_ints: for %d + %d = %d' %
                  (minimal_client.req.a, minimal_client.req.b, response.sum))
      except (KeyboardInterrupt, ExternalShutdownException):
          pass


  if __name__ == '__main__':
      main()

Note inside ``main()`` that the client calls ``rclpy.spin`` in a separate thread.
Both ``send_request`` and ``rclpy.spin`` are blocking, so they need to be on separate threads.

1.1 Sync deadlock
-----------------

There are several ways that the synchronous ``call()`` API can cause deadlock.

As mentioned in the comments of the example above, failing to create a separate thread to spin ``rclpy`` is one cause of deadlock.
When a client is blocking a thread waiting for a response, but the response can only be returned on that same thread, the client will never stop waiting, and nothing else can happen.

Another cause of deadlock is blocking ``rclpy.spin`` by calling a service synchronously in a subscription, timer callback or service callback.
For example, if the synchronous client's ``send_request`` is placed in a callback:

.. code-block:: python

  def trigger_request(msg):
      response = minimal_client.send_request()  # This will cause deadlock
      minimal_client.get_logger().info(
          'Result of add_two_ints: for %d + %d = %d' %
          (minimal_client.req.a, minimal_client.req.b, response.sum))
  subscription = minimal_client.create_subscription(String, 'trigger', trigger_request, 10)

  rclpy.spin(minimal_client)

Deadlock occurs because ``rclpy.spin`` will not preempt the callback with the ``send_request`` call.
In general, callbacks should only perform light and fast operations.

.. warning::

  When deadlock occurs, you will not receive any indication that the service is blocked.
  There will be no warning or exception thrown, no indication in the stack trace, and the call will not fail.

2 Asynchronous calls
--------------------

Async calls in ``rclpy`` are entirely safe and the recommended method of calling services.
They can be made from anywhere without running the risk of blocking other ROS and non-ROS processes, unlike sync calls.

An asynchronous client will immediately return ``future``, a value that indicates whether the call and response is finished (not the value of the response itself), after sending a request to a service.
The returned ``future`` may be queried for a response at any time.

Since sending a request doesn’t block anything, a loop can be used to both spin ``rclpy`` and check ``future`` in the same thread, for example:

.. code-block:: python

    while rclpy.ok():
        rclpy.spin_once(node)
        if future.done():
            #Get response

The :doc:`Simple Service and Client <../Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client>` tutorial for Python illustrates how to perform an async service call and retrieve the ``future`` using a loop.

The ``future`` can also be retrieved using a timer or callback, like in `this example <https://github.com/ros2/examples/blob/{REPOS_FILE_BRANCH}/rclpy/services/minimal_client/examples_rclpy_minimal_client/client_async_callback.py>`_, a dedicated thread, or by another method.
It is up to you, as the caller, to decide how to store ``future``, check on its status, and retrieve your response.

Summary
-------

It is not recommended to implement a synchronous service client.
They are susceptible to deadlock, but will not provide any indication of issue when deadlock occurs.
If you must use synchronous calls, the example in section `1 Synchronous calls`_ is a safe method of doing so.
You should also be aware of the conditions that cause deadlock outlined in section `1.1 Sync deadlock`_.
We recommend using async service clients instead.
",What are some of the risks associated with using a synchronous service client in Python according to the provided text?
"Getting Backtraces in ROS 2
###########################

.. contents:: Table of Contents
   :local:

**Goal:** Show various methods for getting backtraces in ROS 2

**Tutorial level:** Intermediate

**Time:** 15 minutes

The following steps show ROS 2 users how to get backtraces when they encounter a problem.

Overview
--------

**What is a Backtrace ?**

- Imagine your program is like a stack of pancakes where each pancake represents a function it's currently executing.
  A backtrace is like a photo of the collapsed pancake stack, showing you the order they were in, revealing how the program ended up with the failure.
- It lists out the sequence of functions that were called, one on top of the other, leading up to the point of failure.

**Why is it Useful?**

- **Pinpoints the Problem:** Instead of guessing where in your code an error occurred, the backtrace shows you the exact line number responsible for the crash.
- **Reveals Context:** You can see the chain of events (functions calling other functions) that ultimately triggered the failure.
  This helps you understand not just where things went wrong, but also why.

**Visual Analogy**:  Stack of Pancakes

1. Each Pancake is a Function: Imagine each pancake in a stack represents a function that your program is currently executing.
   The pancake at the bottom is your main() function, where it all begins.

2. Adding Pancakes: Every time a function calls another function, a new pancake is placed on top of the stack.

3. The Crash: A crash is like the plate slipping out from the bottom of the stack – something went disastrously wrong in the function currently executing.

4. The Backtrace: The backtrace is like a photo of that fallen pancake stack.
   It shows the order of pancakes (functions) from top to bottom, revealing how you ended up at the crash site.


**Code Example:**

.. code-block:: cpp

  void functionC() {
    // Something bad happens here, causing a crash
  }

  void functionB() {
      functionC();
  }

  void functionA() {
      functionB();
  }

  int main() {
      functionA();
      return 0;
  }

**Backtrace from the Crash:**

.. code-block:: bash

  #0  functionC() at file.cpp:3 // Crash occurred here
  #1  functionB() at file.cpp:8
  #2  functionA() at file.cpp:13
  #3  main() at file.cpp:18

**How the Backtrace Helps:**

- **Crash Origin:** Shows you the exact line in ``functionC()`` that triggered the crash.
- **Call Sequence:** Reveals that ``main()`` called ``functionA()``, which called ``functionB()``, which ultimately led to the error in ``functionC()``.

The above example gave us a clear picture of what is a backtrace and how it can be useful.
Now, the following steps show ROS 2 users how to get traces from specific nodes when they encounter a problem.
This tutorial applies to both simulated and physical robots.

This will cover how to get a backtrace from a specific node using ``ros2 run``, from a launch file representing a single node using ``ros2 launch``, and from a more complex orchestration of nodes.
By the end of this tutorial, you should be able to get a backtrace when you notice a node crashing in ROS 2.

Preliminaries
-------------

GDB is the most popular debugger for C/C++ on Unix systems.
It can be used to determine the reason for a crash and track threads.
It may also be used to add breakpoints in your code to check values in memory at particular points in your software.

Using GDB is a critical skill for all software developers working on C/C++.
While many IDEs have some kind of debugger or profiler built in, it is important to understand how to use these raw tools you have available rather than relying on an IDE to provide them.
Understanding these tools is a fundamental skill of C/C++ development and leaving it up to your IDE can be problematic if you change roles and no longer have access to it or are doing development on the fly through an ssh session to a remote asset.

Using GDB luckily is fairly simple after you have the basics under your belt.
Here's how to ensure your ROS2 code is ready for debugging:

- By using ``--cmake-args``: The easiest way to include debug symbols is by adding ``--cmake-args -DCMAKE_BUILD_TYPE=Debug`` to your ``colcon build`` command:

.. code-block:: bash

  colcon build --packages-up-to <package_name> --cmake-args -DCMAKE_BUILD_TYPE=Debug

- By editing ``CMakeLists.txt`` : Another way is to add ``-g`` to your compiler flags for the ROS package you want to profile / debug.
  This flag builds debug symbols that GDB can read to tell you specific lines of code in your project are failing and why.
  If you do not set this flag, you can still get backtraces but it will not provide line numbers for failures.

Now you're ready to debug your code!
If this was a non-ROS project, at this point you might do something like below.
Here we're launching a GDB session and telling our program to immediately run.
Once your program crashes, it will return a gdb session prompt denoted by ``(gdb)``.
At this prompt you can access the information you're interested in.
However, since this is a ROS project with lots of node configurations and other things going on, this isn't a great option for beginners or those that don't like tons of commandline work and understanding the filesystem.

.. code-block:: bash

  gdb ex run --args /path/to/exe/program

Below are sections to describe the three major situations you could run into with ROS 2-based systems.
Read the section that best describes the problem you're attempting to solve.

Debugging a specific node with GDB
----------------------------------

To easily set up a GDB session before launching a ROS 2 node, leverage the ``--prefix`` option to easily set up a GDB session before launching a ROS 2 node.
For GDB debugging, use it as follows:

.. note::

  Keep in mind that a ROS 2 executable might contain multiple nodes.
  The ``--prefix`` approach ensures you're debugging the correct node within the process.

**Why Direct GDB Usage Can Be Tricky**

``--prefix`` will execute some bits of code before our ROS 2 command allowing us to insert some information.
If you attempted to do ``gdb ex run --args ros2 run <pkg> <node>`` as analog to our example in the preliminaries, you’d find that it couldn’t find the ``ros2`` command.
Additionally, trying to source your workspace within GDB would fail for similar reasons.
This is because GDB, when launched this way, lacks the environment setup that normally makes the ``ros2`` command available.

**Simplifying the Process with --prefix**

Rather than having to revert to finding the install path of the executable and typing it all out, we can instead use ``--prefix``.
This allows us to use the same ``ros2 run`` syntax you’re used to without having to worry about some of the GDB details.

.. code-block:: bash

  ros2 run --prefix 'gdb -ex run --args' <pkg> <node> --all-other-launch arguments

**The GDB Experience**

Just as before, this prefix will launch a GDB session and run the node you requested with all the additional command-line arguments.
You should now have your node running and should be chugging along with some debug printing.

Reading the Stack Trace
-----------------------

After you obtain a backtrace using GDB, here's how to interpret it:

- Start at the Bottom: Backtraces list function calls in reverse chronological order.
  The function at the bottom is where the crash originates.

- Follow the Stack Upwards: Each line above represents the function that called the function below it.
  Trace upwards until you reach a line of code within your own project.
  This often reveals where the problem initiated.

- Debugging Clues: Function names and their arguments can provide valuable clues about what went wrong.

**How to Debug once your Node Crashes**

Once your node crashes, you’ll see a prompt like below.
At this point you can get a backtrace.

.. code-block:: bash

  (gdb)

In this session, type ``backtrace`` and it will provide you with a backtrace.
Copy this for your needs.


**Example backtrace**

.. code-block:: bash

  (gdb) backtrace
  #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
  #1  0x00007ffff79cc859 in __GI_abort () at abort.c:79
  #2  0x00007ffff7c52951 in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
  #3  0x00007ffff7c5e47c in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
  #4  0x00007ffff7c5e4e7 in std::terminate() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
  #5  0x00007ffff7c5e799 in __cxa_throw () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
  #6  0x00007ffff7c553eb in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
  #7  0x000055555555936c in std::vector<int, std::allocator<int> >::_M_range_check (
      this=0x5555555cfdb0, __n=100) at /usr/include/c++/9/bits/stl_vector.h:1070
  #8  0x0000555555558e1d in std::vector<int, std::allocator<int> >::at (this=0x5555555cfdb0,
      __n=100) at /usr/include/c++/9/bits/stl_vector.h:1091
  #9  0x000055555555828b in GDBTester::VectorCrash (this=0x5555555cfb40)
      at /home/steve/Documents/nav2_ws/src/gdb_test_pkg/src/gdb_test_node.cpp:44
  #10 0x0000555555559cfc in main (argc=1, argv=0x7fffffffc108)
      at /home/steve/Documents/nav2_ws/src/gdb_test_pkg/src/main.cpp:25

In this example you should read this in the following way, starting at the bottom:

- In the main function, on line 25 we call a function VectorCrash.

- In VectorCrash, on line 44, we crashed in the Vector's ``at()`` method with input ``100``.

- It crashed in ``at()`` on STL vector line 1091 after throwing an exception from a range check failure.

These traces take some time to get used to reading, but in general, start at the bottom and follow it up the stack until you see the line it crashed on.
Then you can deduce why it crashed.
When you are done with GDB, type ``quit`` and it will exit the session and kill any processes still up.
It may ask you if you want to kill some threads at the end, say yes.

From a Launch File
------------------

Just as in our non-ROS example, we need to setup a GDB session before launching our ROS 2 launch file.
While we could set this up through the commandline, we can instead make use of the same mechanics that we did in the ``ros2 run`` node example, now using a launch file.

In your launch file, find the node that you’re interested in debugging.
For this section, we assume that your launch file contains only a single node (and potentially other information as well).
The ``Node`` function used in the ``launch_ros`` package will take in a field prefix taking a list of prefix arguments.
We will insert the GDB snippet here.

**Consider the following approaches, depending on your setup:**

- **Local Debugging with GUI :**  If you are debugging locally and have a GUI system available, use:

.. code-block:: python

  prefix=['xterm -e gdb -ex run --args']

This will provide a more interactive debbuging experience.
Example usecase for debugging building upon ``'start_sync_slam_toolbox_node'`` -

.. code-block:: python

  start_sync_slam_toolbox_node = Node(
    parameters=[
        get_package_share_directory(""slam_toolbox"") + '/config/mapper_params_online_sync.yaml',
        {'use_sim_time': use_sim_time}
    ],
    package='slam_toolbox',
    executable='sync_slam_toolbox_node',
    name='slam_toolbox',
    prefix=['xterm -e gdb -ex run --args'],  # For interactive GDB in a separate window/GUI
    output='screen')

- **Remote Debugging (without GUI):** If debugging without GUI, omit ``xterm -e`` :

.. code-block:: bash

  prefix=['gdb -ex run --args']

GDB's output and interaction will happen within the terminal session where you launched the ROS 2 application.
Here's an similar example for the ``'start_sync_slam_toolbox_node'`` -

.. code-block:: python

  start_sync_slam_toolbox_node = Node(
    parameters=[
        get_package_share_directory(""slam_toolbox"") + '/config/mapper_params_online_sync.yaml',
        {'use_sim_time': use_sim_time}
    ],
    package='slam_toolbox',
    executable='sync_slam_toolbox_node',
    name='slam_toolbox',
    prefix=['gdb -ex run --args'],  # For GDB within the launch terminal
    output='screen')

Just as before, this prefix will launch a GDB session, now in ``xterm`` and run the launch file you requested with all the additional launch arguments defined.

Once your node crashes, you'll see a prompt like below, now in the ``xterm`` session.
At this point you can now get a backtrace, and read it using the instructions in `Reading the Stack Trace`_.

From a Large Project
--------------------
Working with launch files with multiple nodes is a little different so you can interact with your GDB session without being bogged down by other logging in the same terminal.
For this reason, when working with larger launch files, it is a good idea to pull out the specific node you're interested in and launch it separately.

If your node of interest is being launched from a nested launch file (e.g. an included launch file) you may want to do the following:

- Comment out the launch file inclusion from the parent launch file

- Recompile the package of interest with ``-g`` flag for debug symbols

- Launch the parent launch file in a terminal

- Launch the node's launch file in another terminal following the instructions in `From a Launch File`_.

Alternatively, if your node of interest is being launched in these files directly (e.g. you see a ``Node``, ``LifecycleNode``, or inside a ``ComponentContainer``), you will need to separate this from the others:

- Comment out the node's inclusion from the parent launch file

- Recompile the package of interest with ``-g`` flag for debug symbols

- Launch the parent launch file in a terminal

- Launch the node in another terminal following the instructions in `Debugging a specific node with GDB`_.

.. note::

  In this case you may need to remap or provide parameter files to this node if it was previously provided by the launch file.
  Using ``--ros-args`` you can give it the path to the new parameters file, remaps, or names.
  See :doc:`this tutorial <../../How-To-Guides/Node-arguments>` for the commandline arguments required.

  We understand this can be a pain, so it might encourage you to rather have each node possible as a separately included launch file to make debugging easier.
  An example set of arguments might be ``--ros-args -r __node:=<node_name> --params-file /absolute/path/to/params.yaml`` (as a template).

Once your node crashes, you'll see a prompt like below in the terminal of the specific node.
At this point you can now get a backtrace, and read it using the instructions in `Reading the Stack Trace`_.

Debugging tests with GDB
------------------------

If a C++ test is failing, GDB can be used directly on the test executable in the build directory.
Ensure to build the code in debug mode.
Since the previous build type may be cached by CMake, clean the cache and rebuild.

.. code-block:: console

  colcon build --cmake-clean-cache --mixin debug

In order for GDB to load debug symbols for any shared libraries called, make sure to source your environment.
This configures the value of ``LD_LIBRARY_PATH``.

.. code-block:: console

  source install/setup.bash

Finally, run the test directly through GDB.
For example:

.. code-block:: console

  gdb -ex run ./build/rcl/test/test_logging

If the code is throwing an unhandled exception, you can catch it in GDB before gtest handles it.

.. code-block:: console

  gdb ./build/rcl/test/test_logging
  catch throw
  run

Automatic backtrace on crash
----------------------------

The `backward-cpp <https://github.com/pal-robotics/backward_ros>`_ library provides beautiful stack traces, and the `backward_ros <https://github.com/pal-robotics/backward_ros>`_ wrapper simplifies its integration.

Just add it as a dependency and ``find_package`` it in your CMakeLists and the backward libraries will be injected in all your executables and libraries.
",How can you set up a GDB session before launching a ROS 2 node for debugging purposes?
"Using the ``ros2 param`` command-line tool
==========================================

.. contents:: Table of Contents
   :depth: 1
   :local:

Parameters in ROS 2 can be get, set, listed, and described through a set of services as described in :doc:`the concept document <../Concepts/Basic/About-Parameters>`.
The ``ros2 param`` command-line tool is a wrapper around these service calls that makes it easy to manipulate parameters from the command-line.

``ros2 param list``
-------------------

This command will list all of the available parameters on a given node, or on all discoverable nodes if no node is given.

To get all of the parameters on a given node:

.. code-block:: console

  ros2 param list /my_node

To get all of the parameters on all nodes in the system (this can take a long time on a complicated network):

.. code-block:: console

  ros2 param list

``ros2 param get``
------------------

This command will get the value of a particular parameter on a particular node.

To get the value of a parameter on a node:

.. code-block:: console

  ros2 param get /my_node use_sim_time

``ros2 param set``
------------------

This command will set the value of a particular parameter on a particular node.
For most parameters, the type of the new value must be the same as the existing type.

To set the value of a parameter on a node:

.. code-block:: console

  ros2 param set /my_node use_sim_time false

The value that is passed on the command-line is in YAML, which allows arbitrary YAML expressions to be used.
However, it also means that certain expressions will be interpreted differently than might be expected.
For instance, if the parameter ``my_string`` on node ``my_node`` is of type string, the following will not work:

.. code-block:: console

  ros2 param set /my_node my_string off

That's because YAML is interpreting ""off"" as a boolean, and ``my_string`` is a string type.
This can be worked around by using the YAML syntax for explicitly setting strings, e.g.:

.. code-block:: console

  ros param set /my_node my_string '!!str off'

Additionally, YAML supports heterogeneous lists, containing (say) a string, a boolean, and an integer.
However, ROS 2 parameters do not support heterogenous lists, so any YAML list that has multiple types will be interpreted as a string.
Assuming that the parameter ``my_int_array`` on node ``my_node`` is of type integer array, the following will not work:

.. code-block:: console

  ros param set /my_node my_int_array '[foo,off,1]'

The following string typed parameter would work:

.. code-block:: console

  ros param set /my_node my_string '[foo,off,1]'

``ros2 param delete``
---------------------

This command will remove a parameter from a particular node.
However, note that this can only remove dynamic parameters (not declared parameters).
See :doc:`the concept document <../Concepts/Basic/About-Parameters>` for more information.

.. code-block:: console

  ros2 param delete /my_node my_string

``ros2 param describe``
-----------------------

This command will provide a textual description of a particular parameter on a particular node:

.. code-block:: console

  ros2 param describe /my_node use_sim_time

``ros2 param dump``
-------------------

This command will print out all of the parameters on a particular node in a YAML file format.
The output of this command can then be used to re-run the node with the same parameters later:

.. code-block:: console

  ros2 param dump /my_node

``ros2 param load``
-------------------

This command will load the values of the parameters from a YAML file into a particular node.
That is, this command can reload values at runtime that were dumped out by ``ros2 param dump``:

.. code-block:: console

  ros2 param load /my_node my_node.yaml
",What is the purpose of the `ros2 param load` command in ROS 2 and how is it used?
".. redirect-from::

    How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation

Building ROS 2 with tracing
===========================

.. contents:: Table of Contents
   :depth: 2
   :local:

Tracing instrumentation is included in the ROS 2 source code, and Linux installations of ROS 2 include the LTTng tracer as a dependency.
Therefore, ROS 2 can be traced out-of-the-box on Linux.

However, ROS 2 can be built from source to remove the tracepoints or completely remove the instrumentation.
This guide shows how to do that.
For more information, see `the repository <https://github.com/ros2/ros2_tracing>`__.

.. note::

   This guide only applies to Linux systems.

Prerequisites
-------------

Set up your system to build ROS 2 from source.
See :doc:`the source installation page <../Installation/Alternatives/Ubuntu-Development-Setup>` for more information.

Build configurations
--------------------

The ROS 2 tracing instrumentation is split into two components: function instrumentation and tracepoints.
First, a ROS 2 core package (e.g., ``rclcpp``) calls a function provided by the ``tracetools`` package.
Then, that function triggers a tracepoint, which records data if the tracepoint is enabled at runtime.

By default, if the tracer is not `configured to trace or if the tracepoints are not enabled <https://github.com/ros2/ros2_tracing#tracing>`__, they will have virtually no impact on the execution.
However, the tracepoints can still be removed through a CMake option.
Furthermore, the functions can be completely removed through a CMake option, which implies that tracepoints are also removed.

Building without tracepoints
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This step depends on whether you are :doc:`building ROS 2 from source <../Installation/Alternatives/Ubuntu-Development-Setup>` or using ROS 2 binaries (:doc:`deb packages <../Installation/Ubuntu-Install-Debs>` or :doc:`binary archive <../Installation/Alternatives/Ubuntu-Install-Binary>`).
To remove the tracepoints, (re)build ``tracetools`` and set the ``TRACETOOLS_TRACEPOINTS_EXCLUDED`` CMake option to ``ON``:

.. tabs::

  .. group-tab:: Source installation

    .. code-block:: bash

       cd ~/ros2_{DISTRO}
       colcon build --packages-select tracetools --cmake-clean-cache --cmake-args -DTRACETOOLS_TRACEPOINTS_EXCLUDED=ON

  .. group-tab:: Binary installation

    Clone the ``ros2_tracing`` repository into your workspace and build:

    .. code-block:: bash

       cd ~/ws
       git clone https://github.com/ros2/ros2_tracing.git -b {DISTRO} src/ros2_tracing
       colcon build --packages-select tracetools --cmake-args -DTRACETOOLS_TRACEPOINTS_EXCLUDED=ON

Building without instrumentation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To completely remove both tracepoints and function calls, :doc:`build ROS 2 from source <../Installation/Alternatives/Ubuntu-Development-Setup>` and set the ``TRACETOOLS_DISABLED`` CMake option to ``ON``:

.. code-block:: bash

   cd ~/ros2_{DISTRO}
   colcon build --cmake-args -DTRACETOOLS_DISABLED=ON --no-warn-unused-cli

Validating
----------

Validate that tracing is disabled:

.. code-block:: bash

   cd ~/ws
   source install/setup.bash
   ros2 run tracetools status

It should print out:

.. tabs::

  .. group-tab:: Without tracepoints

    .. code-block:: bash

       Tracing disabled

  .. group-tab:: Without instrumentation

    .. code-block:: bash

       Tracing disabled through configuration

If something else is printed, then something went wrong.
",How can tracepoints be removed when building ROS 2 from source?
".. redirect-from::

    Developing-a-ROS-2-Package
    Guides/Developing-a-ROS-2-Package
    Tutorials/Developing-a-ROS-2-Package

Developing a ROS 2 package
##########################

.. contents:: Table of Contents
   :depth: 2
   :local:

This tutorial will teach you how to create your first ROS 2 application.
It is intended for developers who want to learn how to create custom packages in ROS 2, not for people who want to use ROS 2 with its existing packages.

Prerequisites
-------------

- :doc:`Install ROS <../../Installation>`

- `Install colcon <https://colcon.readthedocs.io/en/released/user/installation.html>`__

- Setup your workspace by sourcing your ROS 2 installation.

Creating a package
------------------

All ROS 2 packages begin by running the command

.. code-block:: bash

   ros2 pkg create --license Apache-2.0 <pkg-name> --dependencies [deps]

in your workspace (usually ``~/ros2_ws/src``).

To create a package for a specific client library:

.. tabs::

  .. group-tab:: C++

    .. code-block:: bash

       ros2 pkg create  --build-type ament_cmake --license Apache-2.0 <pkg-name> --dependencies [deps]

  .. group-tab:: Python

    .. code-block:: bash

       ros2 pkg create  --build-type ament_python --license Apache-2.0 <pkg-name> --dependencies [deps]

You can then update the ``package.xml`` with your package info such as dependencies, descriptions, and authorship.

C++ Packages
^^^^^^^^^^^^

You will mostly use the ``add_executable()`` CMake macro along with

.. code-block:: cmake

   ament_target_dependencies(<executable-name> [dependencies])

to create executable nodes and link dependencies.

To install your launch files and nodes, you can use the ``install()`` macro placed towards the end of the file but before the ``ament_package()`` macro.

An example for launch files and nodes:

.. code-block:: cmake

   # Install launch files
   install(
     DIRECTORY launch
     DESTINATION share/${PROJECT_NAME}
   )

   # Install nodes
   install(
     TARGETS [node-names]
     DESTINATION lib/${PROJECT_NAME}
   )

Python Packages
^^^^^^^^^^^^^^^

ROS 2 follows Python's standard module distribution process that uses ``setuptools``.
For Python packages, the ``setup.py`` file complements a C++ package's ``CMakeLists.txt``.
More details on distribution can be found in the `official documentation <https://docs.python.org/3/distributing/index.html#distributing-index>`_.

In your ROS 2 package, you should have a ``setup.cfg`` file which looks like:

.. code-block:: bash

   [develop]
   script_dir=$base/lib/<package-name>
   [install]
   install_scripts=$base/lib/<package-name>

and a ``setup.py`` file that looks like:

.. code-block:: python

   import os
   from glob import glob
   from setuptools import find_packages, setup

   package_name = 'my_package'

   setup(
       name=package_name,
       version='0.0.0',
       # Packages to export
       packages=find_packages(exclude=['test']),
       # Files we want to install, specifically launch files
       data_files=[
           # Install marker file in the package index
           ('share/ament_index/resource_index/packages', ['resource/' + package_name]),
           # Include our package.xml file
           (os.path.join('share', package_name), ['package.xml']),
           # Include all launch files.
           (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*launch.[pxy][yma]*'))),
       ],
       # This is important as well
       install_requires=['setuptools'],
       zip_safe=True,
       author='ROS 2 Developer',
       author_email='ros2@ros.com',
       maintainer='ROS 2 Developer',
       maintainer_email='ros2@ros.com',
       keywords=['foo', 'bar'],
       classifiers=[
           'Intended Audience :: Developers',
           'License :: TODO',
           'Programming Language :: Python',
           'Topic :: Software Development',
       ],
       description='My awesome package.',
       license='TODO',
       # Like the CMakeLists add_executable macro, you can add your python
       # scripts here.
       entry_points={
           'console_scripts': [
               'my_script = my_package.my_script:main'
           ],
       },
   )


Combined C++ and Python Packages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When writing a package with both C++ and Python code, the ``setup.py`` file and ``setup.cfg`` file are not used.
Instead, use :doc:`ament_cmake_python <./Ament-CMake-Python-Documentation>`.
",What command is used to create a ROS 2 package for a specific client library in C++?
"Documenting a ROS 2 package
###########################

.. contents:: Table of Contents
   :depth: 2
   :local:


This guide introduces the standard way to create documentation for ROS 2 packages.
For packages with binary releases this also results in the docs being hosted at ``docs.ros.org/en/<distro>/p/<package>/``.
For information on how to contribute to this documentation on docs.ros.org, see :doc:`Contributing to ROS 2 Documentation <../The-ROS2-Project/Contributing/Contributing-To-ROS-2-Documentation>`.

Prerequisites
-------------

- :doc:`Install ROS <../../Installation>`

- `Install rosdoc2 <https://github.com/ros-infrastructure/rosdoc2#installation>`__

Package Documentation Overview
------------------------------

The type of documentation discussed in this guide is referred to as ""package docs"" or ""API docs"".
For ROS packages that have been released on ROS Index, their documentation will be built on the ROS buildfarm, included on docs.ros.org, and visible via the ``API Docs`` button on index.ros.org.

The tool responsible for generating ROS 2 package docs is `rosdoc2 <https://github.com/ros-infrastructure/rosdoc2>`__.

``rosdoc2`` is a convenient wrapper around the commonly used `Sphinx <https://www.sphinx-doc.org/>`__ documentation framework.
Sphinx allows freeform written documentation as well as API documentation for python code generated from comments in the code.
The `breathe <https://breathe.readthedocs.io/en/latest/>`__ + `exhale <https://exhale.readthedocs.io/en/latest/>`__ packages allow integration with Doxygen, to include autogenerated C++ API documentation as well.

``rosdoc2`` creates a default configuration for packages with no documentation or configuration at all, and applies options for a uniform theme and integration with other packages.

Building Package Docs
---------------------

To generate the documentation for a package in HTML format with ``rosdoc2``, run:

.. code-block:: console

   rosdoc2 build --package-path <package-path>

The documentation is written to ``docs_output/<package-name>/index.html`` and can be viewed in a browser.

Configuration
-------------

There are three configuration locations for ROS package docs: ``rosdoc2.yaml`` for general settings,
``conf.py`` for sphinx settings and the ``Doxyfile`` for doxygen settings.
For all of those, a default is assumed or generated if not present, so none of them is strictly required.
However, it might be necessary to create and modify those once you want to use features such as custom textual documentation pages.

rosdoc2.yaml
^^^^^^^^^^^^

This is the main entrypoint for rosdoc2.
It specifies generic settings, and can be used to control the execution of specific builders (Doxygen and Sphinx) and decides which builders to run.

``rosdoc2`` provides a multitude of configuration options, which can be adjusted in a config file ``rosdoc2.yaml``.
To generate a default ``rosdoc2.yaml`` which you can then further customize, run:

.. code-block:: console

   rosdoc2 default_config --package-path <package-path>

And add ``<rosdoc2>rosdoc2.yaml</rosdoc2>`` to the export section in your ``package.xml``:

.. code-block:: xml

    <package>
        <!-- [...] -->
        <export>
            <!-- [...] -->
            <rosdoc2>rosdoc2.yaml</rosdoc2>
        </export>
    </package>

However, for most packages,  the default settings in ``rosdoc2`` will suffice, and no custom config is necessary.
More information about ``rosdoc2.yaml`` can be found in the `rosdoc2 readme <https://github.com/ros-infrastructure/rosdoc2#using-a-rosdoc2yaml-file-to-control-how-your-package-is-documented>`__.

conf.py, rosdoc2_settings
^^^^^^^^^^^^^^^^^^^^^^^^^

The final output of the package docs is (almost) always built by Sphinx.
Each Sphinx project is configured by a ``conf.py`` file in the ``doc`` directory.
If no configuration is present, a default Sphinx project is created and used when building the documentation.
If however a ``conf.py`` Sphinx config is found in the ``doc`` subdirectory of the package, this is used instead.
A custom Sphinx project is required if you want to include a standalone reStructuredText documentation page.
A standalone documentation page can be used to list multiple tutorials and guides; if that's something you want for your package you'll need to create a custom Sphinx project.

``rosdoc2`` provides additional settings to ``conf.py`` and overrides some.
Information about changes done to the Sphinx settings are logged to the console with a ``[rosdoc2]`` prefix.

Doxyfile
^^^^^^^^

Doxygen is a tool for automatically generating C++ API docs from code comments.
While Doxygen can also generate HTML output directly, in the usual workflow for ROS packages, Doxygen produces machine readable output in XML format which is then consumed by Sphinx and integrated with the rest of the documentation.
Doxygen-only docs are possible by only enabling the Doxygen builder in ``rosdoc2.yaml``, but this is uncommon.

Customizing Sphinx Documentation
--------------------------------

Creating a Sphinx Project
^^^^^^^^^^^^^^^^^^^^^^^^^

In order to add standalone documentation pages in addition to the automatically generated API docs, a custom Sphinx project is necessary.
This should be created in a subdirectory called ``doc`` in the package directory.
A new Sphinx project can be created by running ``sphinx-quickstart`` in the ``doc`` directory, answering ``no`` to ""Separate source and build directories"".
The wizard requires entering the project name, author and version, but this can later be removed and will be provided to Sphinx by ``rosdoc2`` from your packages ``package.xml``.
More information about creating a sphinx project can be found on the `Sphinx quickstart page <https://www.sphinx-doc.org/en/master/usage/quickstart.html>`__,

Customizing ``index.rst``
^^^^^^^^^^^^^^^^^^^^^^^^^

The ``sphinx-quickstart`` wizard creates an ``index.rst`` file, which is the custom landing page for your package, similar to a Github ``README`` file.

Adding Python API-Docs
^^^^^^^^^^^^^^^^^^^^^^

By default ``rosdoc2``  uses the `sphinx-apidoc tool <https://www.sphinx-doc.org/en/master/man/sphinx-apidoc.html>`__ and the `autodoc Sphinx extension <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`__ to automatically generate documentation for python code.
In order for autodoc to find the Python modules in your package, it must be added to the python search path in ``conf.py``:

.. code-block:: python

    sys.path.insert(0, os.path.abspath('.'))

This is because ``rosdoc2`` wraps the custom ``conf.py`` with more configuration from a script which will be placed in the package.
In this case the ``.``  path in ``os.path.abspath`` refers to the package's directory root, not the package's ``doc`` directory due to the interaction between rosdoc2 and ``conf.py``.

By default, package API docs are already reachable through the ""Module Index"" link that is present on the landing page.
For the API docs to also appear in the table of contents, simply add a link to the ``modules`` page to your ``index.rst``:

.. code-block:: rst

    .. toctree::
       :maxdepth: 2
       :caption: Contents:

       Python Modules <modules>

Adding C++ API-Docs
^^^^^^^^^^^^^^^^^^^

If you would like to add your automatically generated API docs back to your custom landing page, add the line ``generated/index``  to your documentation page where you would like the API docs to appear:

.. code-block:: rst

   .. toctree::
      :maxdepth: 2

      C++ API Docs <generated/index>

This adds the elements ""Class Hierarchy"", ""File Hierarchy"" and ""Reference"" to the table of contents in the sidebar.
To make those appear under one ""C++ API Docs"" heading for a less cluttered sidebar, a separate file such as ``cpp_api_docs.rst`` can be added, which links to the generated docs:

.. code-block:: rst
    :caption: cpp_api_docs.rst

    C++ API Docs
    ============

    These are the autogenerated docs for the internal implementation.

    .. toctree::
       :maxdepth: 3
       :caption: Contents:

       generated/index

Which then also needs to be added in  ``index.rst`` to appear in the sidebar:

.. code-block:: rst
    :caption: index.rst

    .. toctree::
       :maxdepth: 2
       :caption: Contents:

       cpp_api_docs


Including an existing README.md
-------------------------------

If your git repository already has an existing ``README.md``, it is possible to reuse this as the landing page for the documentation, without duplicating the contents.
To correctly include a Markdown file in Sphinx while preserving relative links and images, some additional effort is required.

First, create a proxy-file ``readme_include.md`` next to ``index.rst``.
This is a markdown file which just includes the original README.md, but preserves the relative image paths, which would otherwise break in the next step:

.. code-block:: markdown
    :caption: readme_include.md

    ```{include} ../README.md
    :relative-images:
    ```


Then, include the contents of this file from ``index.rst`` using ``myst`` to include markdown from rst:

.. code-block:: rst
    :caption: index.rst

    .. include:: readme_include.md
       :parser: myst_parser.sphinx_


This also requires adding ``myst_parser`` to the extensions in ``conf.py``:

.. code-block:: python
    :caption: conf.py

    extensions = [""myst_parser""]


CI, docs.ros.org
----------------

The ROS build farm uses ``rosdoc2`` to build the package documentation hosted at ``docs.ros.org/en/<distro>/p/<package>/``.
To enable this, the repository containing the documentation must be configured in `rosdistro/{DISTRO}/distribution.yaml <https://github.com/ros/rosdistro/blob/master/{DISTRO}/distribution.yaml>`__.
This would usually be the package source repository:

.. code-block:: yaml

      <package_name>:
        doc:
          type: git
          url: https://github.com/<github_username>/<package_name>.git
          version: main
        release:
        [...]

The buildfarm hosts the documentation for every distribution separately, and periodically rebuilds it from the latest commit on the specified branch.
It is not required to tag a new release to update the hosted documentation.
To view the status of your package's documentation build, search for ``doc__<package_name>`` on `<https://build.ros2.org>`__.
One job is created for every distribution for which the package is released.
On each job page, you can see when a build was last triggered, as well as the status and logs of each build.

Further Reading
---------------

* ``rosdoc2`` readme: https://github.com/ros-infrastructure/rosdoc2/blob/main/README.md
* ROS 2 design document on package documentation: https://design.ros2.org/articles/per_package_documentation.html
* The ROS 2 cookbook: https://github.com/mikeferguson/ros2_cookbook/blob/main/pages/rosdoc2.md
",What tool is responsible for generating ROS 2 package docs and what is it a wrapper around?
"Using Custom Rosdistro Version
==============================


.. contents:: Contents
    :depth: 2
    :local:


Overview
--------

`rosdistro <https://github.com/ros/rosdistro>`_ contains the central index of ROS packages for all distributions and ``rosdep`` keys for packaged binary dependencies for installation.
When you invoke ``rosdep install ...``, it is checking a local cached index from rosdistro (populated during ``rosdep update``) to correlate keys in a ``package.xml`` to the ROS package, python module, or binary to install.
Thus, this index is an important element of the ROS ecosystem.

However, there are occasions where a user would like the assert further control over this index to add in their own proprietary keys or use a previous state of rosdistro.
This guide walks through how to set a version of rosdistro to use on your system.

The motivating example that this guide will use is a desire to use a previous version of Rolling due to a breakage on your development computer or Continuous Integration.
It is possible that during transition periods from one operating system to another, Rolling on the older operating system may become unusable due to support shifting to a new OS (i.e. moving from Ubuntu 22.04 to 24.04).
Thus, we wish to set a prior version of rosdistro that aligns with a working Rolling distribution on a given operating system to keep our systems functioning before upgrading to the new operating system.

Important Preliminaries
-----------------------

Rosdep populates its cache from the locations set in its ``/etc/ros/rosdep/sources.list.d/20-default.list`` by default.
When setting up rosdep with ``rosdep init``, it populates ``20-default.list`` with the main rosdistro URLs (`from this file <https://github.com/ros/rosdistro/blob/master/rosdep/sources.list.d/20-default.list>`_).
The cache generated by ``rosdep update`` is located in ``~/.ros/rosdep/sources.cache`` and should not be modified by hand.

When no ``ROSDISTRO_INDEX_URL`` environment variable value is set during a rosdep update, it uses the main public rosdistro index.
However, when this value is set, you may use a custom rosdisto index which could be a snapshot from the public index or a completely separate index populated with your proprietary packages.

If you'd like to learn more about this, checkout the `documentation in ros_buildfarm package <https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/custom_rosdistro.rst>`_.

How to Use a Custom Rosdistro Version
-------------------------------------

To use a custom version in your CI, docker build, local environment, robot, or other application, we need to first identify the rosdistro version of interest.

For our motivating example, we wish to use the last index state before the first sync of ``rolling`` on the new operating system.
In this case, that last sync for our operating system was performed on February 28, 2024.
Conveniently, the syncs are tagged so we can obtain that information on the ``rolling/2024-02-28`` tagged branch.

Thus, we need to update the ``20-default.list`` with our tagged branch values rather than using the main repository's current state.
This can be accomplished using the script as follows.
If running on a local host, you may need to include ``sudo``.
This will update list to use our tagged branch rather than the master branch.

.. code-block:: bash

    sed -i ""s|ros\/rosdistro\/master|ros\/rosdistro\/rolling\/2024-02-28|"" /etc/ros/rosdep/sources.list.d/20-default.list

After, we must now update the environment variable ``ROSDISTRO_INDEX_URL`` to point to our new rosdistro index.

.. code-block:: bash

    export ROSDISTRO_INDEX_URL=https://raw.githubusercontent.com/ros/rosdistro/rolling/2024-02-28/index-v4.yaml

If you plan to use this on a local host for a long time, it may be wise to include this in your ``~/.bashrc`` so that all new terminals do this automatically.
The ``v4`` in our index points to a new version of the index format.
A previous index also exists without the ``v4`` which is still present for historical reasons and legacy systems, but you should not use it.

Afterward, you can ``rosdep update``, which will now use the changes to update the index in accordance to the Rolling distribution's state on February 28, 2024 before the breakages began.
You can see this in action in `Nav2's CircleCI <https://github.com/ros-planning/navigation2/commit/80bb5bff1488c0677efcc4254b7a89908c853ba0>`_ and `ros_gz's GitHub Actions <https://github.com/gazebosim/ros_gz/pull/522/files>`_ in order to bypass a temporary Rolling outage in their CI systems.

.. Note:: If you are using a custom rosdistro version, you can substitute the final URLs in the default list and index URL with your fork or index location.
",What is the purpose of setting a custom rosdistro version in the ROS ecosystem according to the provided text document?
".. redirect-from::

  Guides/DDS-tuning
  Troubleshooting/DDS-tuning

DDS tuning information
======================

This page provides some guidance on parameter tunings that were found to address issues faced while using various DDS implementations on Linux in real-world situations.
It is possible that the issues we identified on Linux or while using one vendor may occur for other platforms and vendors not documented here.

The recommendations below are starting points for tuning; they worked for specific systems and environments, but the tuning may vary depending on a number of factors.
You may need to increase or decrease values while debugging relative to factors like message size, network topology, etc.

It is important to recognize that tuning parameters can come at a cost to resources, and may affect parts of your system beyond the scope of the desired improvements.
The benefits of improving reliability should be weighed against any detriments for each individual case.

.. _cross-vendor-tuning:

Cross-vendor tuning
-------------------

**Issue:** Sending data over lossy (usually WiFi) connections becomes problematic when some IP fragments are dropped, possibly causing the kernel buffer on the receiving side to become full.

When a UDP packet is missing at least one IP fragment, the rest of the received fragments fill up the kernel buffer.
By default, the Linux kernel will time out after 30s of trying to recombine packet fragments.
Since the kernel buffer is full at this point (default size is 256KB), no new fragments can come in, and so the connection will seemingly ""hang"" for long periods of time.

This issue is generic across all DDS vendors, so the solutions involve adjusting kernel parameters.

**Solution:** Use best-effort QoS settings instead of reliable.

Best-effort settings reduce the amount of network traffic since the DDS implementation does not have to incur the overhead of reliable communications, where publishers require acknowledgements for messages sent to subscribers and must resend samples that have not been properly received.

If the kernel buffer for IP fragments gets full, though, the symptom is still the same (blocking for 30s).
This solution should improve the issue somewhat without having to adjust parameters.

**Solution:** Reduce the value of the ``ipfrag_time`` parameter.

``net.ipv4.ipfrag_time / /proc/sys/net/ipv4/ipfrag_time`` (default 30s) :
Time in seconds to keep an IP fragment in memory.

Reduce the value, for example, to 3s, by running:

.. code-block:: console

    sudo sysctl net.ipv4.ipfrag_time=3

Reducing this parameter’s value also reduces the window of time where no fragments are received.
The parameter is global for all incoming fragments, so the feasibility of reducing its value needs to be considered for every environment.

**Solution:** Increase the value of the ``ipfrag_high_thresh`` parameter.

``net.ipv4.ipfrag_high_thresh / /proc/sys/net/ipv4/ipfrag_high_thresh`` (default: 262144 bytes):
Maximum memory used to reassemble IP fragments.

Increase the value, for example, to 128MB, by running:

.. code-block:: console

    sudo sysctl net.ipv4.ipfrag_high_thresh=134217728     # (128 MB)

Significantly increasing this parameter’s value is an attempt to ensure that the buffer never becomes completely full.
However, the value would likely have to be significantly high to hold all data received during the time window of ``ipfrag_time``, assuming every UDP packet lacks one fragment.

**Issue:** Sending custom messages with large variable-sized arrays of non-primitive types causes high serialization/deserialization overhead and CPU load.
This can lead to stalling of the publisher due to excessive time spent in ``publish()`` and tools like ``ros2 topic hz`` under reporting the actual frequency of messages being received.
Note that for example ``builtin_interfaces/Time`` is also considered a non-primitive type and will incur higher serialization overhead.
Because of the increased serialization overhead, severe performance degradation can be observed when naively transitioning custom message types from ROS 1 to ROS 2.

**Workaround:** Use multiple arrays of primitives instead of a single array of custom types, or pack into byte array as done e.g. in ``PointCloud2`` messages.
For example, instead of defining a ``FooArray`` message as:

.. code-block:: console

    Foo[] my_large_array

with ``Foo`` is defined as:

.. code-block:: console

    uint64 foo_1
    uint32 foo_2

Instead, define ``FooArray`` as:

.. code-block:: console

    uint64[] foo_1_array
    uint32[] foo_2_array

Fast RTPS tuning
----------------

**Issue:** Fast RTPS floods the network with large pieces of data or fast-published data when operating over WiFi.

See the solutions under :ref:`Cross-vendor tuning <cross-vendor-tuning>`.

Cyclone DDS tuning
------------------

**Issue:** Cyclone DDS is not delivering large messages reliably, despite using reliable settings and transferring over a wired network.

This issue should be `addressed soon <https://github.com/eclipse-cyclonedds/cyclonedds/issues/484>`_.
Until then, we’ve come up with the following solution (debugged using `this test program <https://github.com/jacobperron/pc_pipe>`_):

**Solution:** Increase the maximum Linux kernel receive buffer size and the minimum socket receive buffer size that Cyclone uses.

*Adjustments to solve for a 9MB message:*

Set the maximum receive buffer size, ``rmem_max``, by running:

 .. code-block:: console

    sudo sysctl -w net.core.rmem_max=2147483647

Or permanently set it by editing the ``/etc/sysctl.d/10-cyclone-max.conf`` file to contain:

 .. code-block:: console

    net.core.rmem_max=2147483647

Next, to set the minimum socket receive buffer size that Cyclone requests, write out a configuration file for Cyclone to use while starting, like so:

.. code-block:: xml

  <?xml version=""1.0"" encoding=""UTF-8"" ?>
  <CycloneDDS xmlns=""https://cdds.io/config"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""https://cdds.io/config
  https://raw.githubusercontent.com/eclipse-cyclonedds/cyclonedds/master/etc/cyclonedds.xsd"">
      <Domain id=""any"">
          <Internal>
              <SocketReceiveBufferSize min=""10MB""/>
          </Internal>
      </Domain>
  </CycloneDDS>

Then, whenever you are going to run a node, set the following environment variable:

.. code-block:: console

    CYCLONEDDS_URI=file:///absolute/path/to/config_file.xml

RTI Connext tuning
------------------

**Issue:** Connext is not delivering large messages reliably, despite using reliable settings and transferring over a wired network.

**Solution:** This `Connext QoS profile <https://github.com/jacobperron/pc_pipe/blob/master/etc/ROS2TEST_QOS_PROFILES.xml>`_, along with increasing the ``rmem_max`` parameter.

Set the maximum receive buffer size, ``rmem_max``, by running:

 .. code-block:: console

    sudo sysctl -w net.core.rmem_max=4194304

By tuning ``net.core.rmem_max`` to 4MB in the Linux kernel, the QoS profile can produce truly reliable behavior.

This configuration has been proven to reliably deliver messages via SHMEM|UDPv4, and with just UDPv4 on a single machine.
A multi-machine configuration was also tested with ``rmem_max`` at 4MB and at 20MB (two machines connected with 1Gbps ethernet), with no dropped messages and average message delivery times of 700ms and 371ms, respectively.

Without configuring the kernel’s ``rmem_max``, the same Connext QoS profile took up to 12 seconds for the data to be delivered.
However, it always at least managed to complete the delivery.

**Solution:** Use the `Connext QoS profile <https://github.com/jacobperron/pc_pipe/blob/master/etc/ROS2TEST_QOS_PROFILES.xml>`_ *without* adjusting ``rmem_max``.

The ROS2TEST_QOS_PROFILES.xml file was configured using RTI’s documentation on `configuring flow controllers <https://community.rti.com/forum-topic/transfering-large-data-over-dds>`_. It has slow, medium and fast flow controllers (seen in the Connext QoS profile link).

The medium flow controller produced the best results for our case.
However, the controllers will still need to be tuned for the particular machine/network/environment they are operating in.
The Connext flow controllers can be used to tune bandwidth and its aggressiveness for sending out data, though once the bandwidth of a particular setup is passed, performance will start to drop.
",What adjustments can be made for solving the issue related to sending data over lossy connections with UDP packets in DDS implementations on Linux?
".. redirect-from::

  Guides/Package-maintainer-guide
  How-To-Guides/Package-maintainer-guide

ROS 2 Core Maintainer Guide
===========================

Each package in the ROS 2 core has one or more maintainers that are responsibile for the general health of the package.
This guide gives some information about the responsibilities of a ROS 2 core package maintainer.

.. contents:: Table of Contents
   :local:

Reviews
-------

All incoming code to ROS 2 core repositories must be reviewed.
The review is looking for:

* Suitability in the package
* Correct code
* Conforms to developer guidelines:

    * :doc:`Developer Guide <../The-ROS2-Project/Contributing/Developer-Guide>`
    * :doc:`Code Style Guide <../The-ROS2-Project/Contributing/Code-Style-Language-Versions>`

* Adds tests for the bug/feature
* Adds documentation for new features
* Clean Continuous Integration run
* Targets default branch (usually ""rolling"")
* Has at least one approval from a maintainer that is not the author

Continuous Integration
----------------------

All incoming code to ROS 2 core repositories must be run through Continuous Integration.
ROS 2 currently has two separate CI systems, and it is required that PRs pass both of them before merging.

PR builds (https://build.ros2.org/view/Rpr)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ROS 2 PR (Pull Request) builds run automatically every time a pull request is opened.
These builds run a build and test of this repository, and this repository only.
This means that it does not build any dependencies, and it also does not build any repositories that depend upon packages in this repository.
These builds are good for quick feedback to see if the change passes linters, unit tests, etc.
There are two major problems with them:

* These builds do not work across multiple repositories (so won't work for adding or changing an API, etc)
* These tests only run on Linux (they won't run on macOS or Windows)

To address these two problems, there is also the CI builds.

CI builds (https://ci.ros2.org)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CI builds do not run automatically when a pull request is opened.
One of the maintainers of the repository must manually request that a CI build is done by going to https://ci.ros2.org/job/ci_launcher/ .

By default, running a job in this way will build and run tests for all packages (> 300 currently) on all platforms (Linux, macOS, and Windows).
As a full run can take many hours and tie up the CI machines, it is recommended that all runs here restrict the number of packages that are built and tested.
This can be accomplished by using the colcon arguments ``--packages-up-to``, ``--packages-select``, ``--packages-above-and-dependencies``, ``--packages-above``, amongst others.
See the `colcon documentation <https://colcon.readthedocs.io/en/released/user/how-to.html#build-only-a-single-package-or-selected-packages>`__ for more examples on the flags that can be used.
Further documentation on how to use the CI machinery is available at https://github.com/ros2/ci/blob/master/CI_BUILDERS.md.

Merging Pull Requests
---------------------

A pull request can be merged if all of the following are true:

* The DCO bot reports a passing result
* The PR build reports a passing result
* The CI build reports a passing result on all platforms
* The code has been reviewed and approved by at least one maintainer

After a PR is merged, it will automatically get built with the next `nightlies <https://ci.ros2.org/view/nightly>`__.
It is highly recommended to check the nightlies after merging pull requests to ensure no regressions have occurred.

Keeping CI green
----------------

The nightly jobs that run tests are typically much more comprehensive than what is done for individual pull requests.
For this reason, there can be regressions that occur in the nightlies that were not seen in the CI jobs.
It is a maintainer's responsibility to check for regressions in their packages at the following locations:

* https://ci.ros2.org/view/nightly
* https://ci.ros2.org/view/packaging
* https://build.ros2.org/view/Rci
* https://build.ros2.org/view/Rdev

For any problems that are found, new issues and/or pull requests on the relevant repositories should be opened.

Making releases
---------------

In order to get new features and bugfixes out to end users, the maintainers must periodically do a release of the repository (a release may also be requested on-demand from other maintainers).

As outlined in the :ref:`developer guide <semver>`, ROS 2 packages follow semver for version numbers.

A release, in ROS terms, consists of two distinct steps: making a source release, and then making a binary release.

Source release
^^^^^^^^^^^^^^

A source release creates a changelog and a tag in the relevant repository.

The process starts by generating or updating CHANGELOG.rst files with the following command:

.. code-block:: bash

  $ catkin_generate_changelog

If one or more packages in the repository don't have contain CHANGELOG.rst, add the ``--all`` option to populate all of the previous commits for each package.
The ``catkin_generate_changelog`` command will simply populate the files with the commit logs from the repository.
Since those commit logs aren't always appropriate for a changelog, it is recommended to edit CHANGELOG.rst and edit it to make it more readable.
Once editing is done, it is important to commit the updated CHANGELOG.rst file to the repository.

The next step is to bump the version in the package.xml and the changelog files with the following command:

.. code-block:: bash

  $ catkin_prepare_release

This command will find all of the packages in the repository, check that the changelogs exist, check that there are no uncommitted local changes, increment the version in the package.xml files, and commit/tag the changes with a bloom-compatible tag.
Using this command is the best way to ensure the release versions are consistent and compatible with bloom.
By default, ``catkin_prepare_release`` will bump the patch version of the packages, e.g. 0.1.1 -> 0.1.2 .
However, it can also bump the minor or major number, or even have an exact version set.
See the help output from ``catkin_prepare_release`` for more information.

Assuming the above was successful, a source release has been made.

Binary release
^^^^^^^^^^^^^^

The next step is to use the ``bloom-release`` command to create a binary release.
For full instructions on how to use bloom, please see http://wiki.ros.org/bloom.
To do a binary release of a repository, run:

.. code-block:: bash

  $ bloom-release --track <rosdistro> --rosdistro <rosdistro> <repository_name>

For instance, to release the ``rclcpp`` repository to the {DISTRO_TITLE} distribution, the command would be:

.. code-block:: bash

  $ bloom-release --track {DISTRO} --rosdistro {DISTRO} rclcpp

This command will fetch the release repository, make the necessary changes to make the release, push the changes to the release repository, and finally open a pull request to https://github.com/ros/rosdistro .

Backporting to released distributions
-------------------------------------

All incoming changes should first land on the development branch.
Once a change has been merged onto the development branch, it can be considered for backporting to released distributions.
However, any backported code must not break `API <https://en.wikipedia.org/wiki/API>`__ or `ABI <https://en.wikipedia.org/wiki/Application_binary_interface>`__ in a released distribution.
If a change can be backported without breaking API or ABI, then a new pull request targeting the appropriate branch should be created.
The new pull request should be added to the appropriate distributions project board at https://github.com/orgs/ros2/projects.
The new pull request should have all of the steps run as before, but making sure to target the distribution in question for CI, etc.

Responding to issues
--------------------

Package maintainers should also look at incoming issues on the repository and triage the problems that users are having.

For issues that look like questions, the issue should be closed and the user redirected to `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__ .

If an issue looks like a problem, but is not relevant to this particular repository, it should be moved to the appropriate repository with the GitHub ""Transfer issue"" button.

If the reporter has not provided enough information to determine the cause of the problem, more information should be requested from the reporter.

If this is a new feature, tag the issue with ""help-wanted"".

Any remaining issues should be reproduced, and determined if they are truly a bug.
If it is a bug, fixes are highly appreciated.

Getting help
------------

While doing maintenance on a package, questions about general procedures or individual issues may come up.

For general questions, please follow the :doc:`contributing guidelines <../The-ROS2-Project/Contributing>`.

For questions on individual issues, please tag the ROS 2 GitHub team (@ros/team), and someone on the team will take a look.
",What are the responsibilities of a ROS 2 core package maintainer according to the text provided?
"Using ``ros1_bridge`` with upstream ROS on Ubuntu 22.04
=======================================================

.. contents:: Table of Contents
   :depth: 1
   :local:

The release of ROS 2 Humble (and Rolling) on Ubuntu 22.04 Jammy Jellyfish marks the first ROS 2 release on a platform with no official ROS 1 release.
While ROS 1 Noetic will continue to be supported through the duration of its `long term support window <https://www.ros.org/reps/rep-0003.html#noetic-ninjemys-may-2020-may-2025>`__, it will only target Ubuntu 20.04.
Alternatively, there are `upstream variants of ROS 1 packages <https://packages.ubuntu.com/jammy/ros-desktop>`__ in Debian and Ubuntu that are not maintained as an official distribution by the ROS maintainers.

This guide outlines the current mechanism for bridging ROS 2 releases with these upstream packages on Ubuntu 22.04 Jammy Jellyfish.
This provides a migration path for users who still depend on ROS 1, but desire moving to newer ROS 2 and Ubuntu releases.

ROS 2 via deb packages
----------------------

Installing :doc:`ROS 2 from deb packages <../Installation/Ubuntu-Install-Debs>` currently does not work for ROS 2 on Ubuntu Jammy.
The version of ``catkin-pkg-modules`` available in the Ubuntu repository conflicts with that in the ROS 2 package repository.

If the ROS 2 apt repository is in the available apt repositories (``/etc/apt/sources.list.d``), no ROS 1 packages will be installable.
The error will be:

.. code-block:: bash

  $ apt install ros-core-dev
  Reading package lists... Done
  Building dependency tree... Done
  Reading state information... Done
  Some packages could not be installed. This may mean that you have
  requested an impossible situation or if you are using the unstable
  distribution that some required packages have not yet been created
  or been moved out of Incoming.
  The following information may help to resolve the situation:

  The following packages have unmet dependencies:
   ros-core-dev : Depends: catkin but it is not installable
  E: Unable to correct problems, you have held broken packages.

To correct this, remove packages.ros.org from your ``sources.list``.
If you were following the ROS 2 installation guide, simply remove ``/etc/apt/sources.list.d/ros2.list``

For now, to support ``ros1_bridge``, follow the instructions below for building ROS 2 from source.

ROS 2 from source
-----------------

Installing :doc:`ROS 2 from Source <../Installation/Alternatives/Ubuntu-Development-Setup>` is the only configuration that works for ROS 2 on Ubuntu Jammy.

Below is a summary of the necessary instructions from the source build instructions.
The substantial deviation is that we skip using the ROS 2 apt repositories because of conflicting packages.

Install development tools and ROS tools
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since we aren't using the ROS 2 apt repositories, ``colcon`` must be installed via ``pip``.

.. code-block:: bash

   sudo apt update && sudo apt install -y \
     build-essential \
     cmake \
     git \
     python3-flake8 \
     python3-flake8-blind-except \
     python3-flake8-builtins \
     python3-flake8-class-newline \
     python3-flake8-comprehensions \
     python3-flake8-deprecated \
     python3-flake8-docstrings \
     python3-flake8-import-order \
     python3-flake8-quotes \
     python3-pip \
     python3-pytest \
     python3-pytest-cov \
     python3-pytest-repeat \
     python3-pytest-rerunfailures \
     python3-rosdep \
     python3-setuptools \
     wget

   # Install colcon from PyPI, rather than apt packages
   python3 -m pip install -U colcon-common-extensions vcstool

From here, continue with the :doc:`source install guide <../Installation/Alternatives/Ubuntu-Development-Setup>` to build ROS 2.

Install ROS 1 from Ubuntu packages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: bash

   sudo apt update && sudo apt install -y ros-core-dev


Build ``ros1_bridge``
^^^^^^^^^^^^^^^^^^^^^

.. code-block:: bash

    # Create a workspace for the ros1_bridge
    mkdir -p ~/ros1_bridge/src
    cd ~/ros1_bridge/src
    git clone https://github.com/ros2/ros1_bridge
    cd ~/ros1_bridge

    # Source the ROS 2 workspace
    . ~/ros2_humble/install/local_setup.bash

    # Build
    colcon build

After building all of ``ros1_bridge``, the remainder of the `ros1_bridge examples <https://github.com/ros2/ros1_bridge#example-1-run-the-bridge-and-the-example-talker-and-listener>`__ should work with your new installation

",What method is recommended for bridging ROS 2 releases with upstream ROS 1 packages on Ubuntu 22.04 Jammy Jellyfish?
".. redirect-from::

  Guides/Launch-file-different-formats

Using Python, XML, and YAML for ROS 2 Launch Files
==================================================

.. contents:: Table of Contents
   :depth: 1
   :local:

ROS 2 launch files can be written in Python, XML, and YAML.
This guide shows how to use these different formats to accomplish the same task, as well as has some discussion on when to use each format.

Launch file examples
--------------------

Below is a launch file implemented in Python, XML, and YAML.
Each launch file performs the following actions:

* Setup command line arguments with defaults
* Include another launch file
* Include another launch file in another namespace
* Start a node and setting its namespace
* Start a node, setting its namespace, and setting parameters in that node (using the args)
* Create a node to remap messages from one topic to another

.. tabs::

   .. group-tab:: Python

      .. code-block:: python

        # example_launch.py

        import os

        from ament_index_python import get_package_share_directory

        from launch import LaunchDescription
        from launch.actions import DeclareLaunchArgument
        from launch.actions import GroupAction
        from launch.actions import IncludeLaunchDescription
        from launch.launch_description_sources import PythonLaunchDescriptionSource
        from launch.substitutions import LaunchConfiguration
        from launch.substitutions import TextSubstitution
        from launch_ros.actions import Node
        from launch_ros.actions import PushROSNamespace
        from launch_xml.launch_description_sources import XMLLaunchDescriptionSource
        from launch_yaml.launch_description_sources import YAMLLaunchDescriptionSource


        def generate_launch_description():

            # args that can be set from the command line or a default will be used
            background_r_launch_arg = DeclareLaunchArgument(
                ""background_r"", default_value=TextSubstitution(text=""0"")
            )
            background_g_launch_arg = DeclareLaunchArgument(
                ""background_g"", default_value=TextSubstitution(text=""255"")
            )
            background_b_launch_arg = DeclareLaunchArgument(
                ""background_b"", default_value=TextSubstitution(text=""0"")
            )
            chatter_py_ns_launch_arg = DeclareLaunchArgument(
                ""chatter_py_ns"", default_value=TextSubstitution(text=""chatter/py/ns"")
            )
            chatter_xml_ns_launch_arg = DeclareLaunchArgument(
                ""chatter_xml_ns"", default_value=TextSubstitution(text=""chatter/xml/ns"")
            )
            chatter_yaml_ns_launch_arg = DeclareLaunchArgument(
                ""chatter_yaml_ns"", default_value=TextSubstitution(text=""chatter/yaml/ns"")
            )

            # include another launch file
            launch_include = IncludeLaunchDescription(
                PythonLaunchDescriptionSource(
                    os.path.join(
                        get_package_share_directory('demo_nodes_cpp'),
                        'launch/topics/talker_listener_launch.py'))
            )
            # include a Python launch file in the chatter_py_ns namespace
            launch_py_include_with_namespace = GroupAction(
                actions=[
                    # push_ros_namespace first to set namespace of included nodes for following actions
                    PushROSNamespace('chatter_py_ns'),
                    IncludeLaunchDescription(
                        PythonLaunchDescriptionSource(
                            os.path.join(
                                get_package_share_directory('demo_nodes_cpp'),
                                'launch/topics/talker_listener_launch.py'))
                    ),
                ]
            )

            # include a xml launch file in the chatter_xml_ns namespace
            launch_xml_include_with_namespace = GroupAction(
                actions=[
                    # push_ros_namespace first to set namespace of included nodes for following actions
                    PushROSNamespace('chatter_xml_ns'),
                    IncludeLaunchDescription(
                        XMLLaunchDescriptionSource(
                            os.path.join(
                                get_package_share_directory('demo_nodes_cpp'),
                                'launch/topics/talker_listener_launch.xml'))
                    ),
                ]
            )

            # include a yaml launch file in the chatter_yaml_ns namespace
            launch_yaml_include_with_namespace = GroupAction(
                actions=[
                    # push_ros_namespace first to set namespace of included nodes for following actions
                    PushROSNamespace('chatter_yaml_ns'),
                    IncludeLaunchDescription(
                        YAMLLaunchDescriptionSource(
                            os.path.join(
                                get_package_share_directory('demo_nodes_cpp'),
                                'launch/topics/talker_listener_launch.yaml'))
                    ),
                ]
            )

            # start a turtlesim_node in the turtlesim1 namespace
            turtlesim_node = Node(
                package='turtlesim',
                namespace='turtlesim1',
                executable='turtlesim_node',
                name='sim'
            )

            # start another turtlesim_node in the turtlesim2 namespace
            # and use args to set parameters
            turtlesim_node_with_parameters = Node(
                package='turtlesim',
                namespace='turtlesim2',
                executable='turtlesim_node',
                name='sim',
                parameters=[{
                    ""background_r"": LaunchConfiguration('background_r'),
                    ""background_g"": LaunchConfiguration('background_g'),
                    ""background_b"": LaunchConfiguration('background_b'),
                }]
            )

            # perform remap so both turtles listen to the same command topic
            forward_turtlesim_commands_to_second_turtlesim_node = Node(
                package='turtlesim',
                executable='mimic',
                name='mimic',
                remappings=[
                    ('/input/pose', '/turtlesim1/turtle1/pose'),
                    ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'),
                ]
            )

            return LaunchDescription([
                background_r_launch_arg,
                background_g_launch_arg,
                background_b_launch_arg,
                chatter_py_ns_launch_arg,
                chatter_xml_ns_launch_arg,
                chatter_yaml_ns_launch_arg,
                launch_include,
                launch_py_include_with_namespace,
                launch_xml_include_with_namespace,
                launch_yaml_include_with_namespace,
                turtlesim_node,
                turtlesim_node_with_parameters,
                forward_turtlesim_commands_to_second_turtlesim_node,
            ])


   .. group-tab:: XML

      .. code-block:: xml

        <!-- example_launch.xml -->

        <launch>

            <!-- args that can be set from the command line or a default will be used -->
            <arg name=""background_r"" default=""0"" />
            <arg name=""background_g"" default=""255"" />
            <arg name=""background_b"" default=""0"" />
            <arg name=""chatter_py_ns"" default=""chatter/py/ns"" />
            <arg name=""chatter_xml_ns"" default=""chatter/xml/ns"" />
            <arg name=""chatter_yaml_ns"" default=""chatter/yaml/ns"" />

            <!-- include another launch file -->
            <include file=""$(find-pkg-share demo_nodes_cpp)/launch/topics/talker_listener_launch.py"" />
            <!-- include a Python launch file in the chatter_py_ns namespace-->
            <group>
                <!-- push_ros_namespace to set namespace of included nodes -->
                <push_ros_namespace namespace=""$(var chatter_py_ns)"" />
                <include file=""$(find-pkg-share demo_nodes_cpp)/launch/topics/talker_listener_launch.py"" />
            </group>
            <!-- include a xml launch file in the chatter_xml_ns namespace-->
            <group>
                <!-- push_ros_namespace to set namespace of included nodes -->
                <push_ros_namespace namespace=""$(var chatter_xml_ns)"" />
                <include file=""$(find-pkg-share demo_nodes_cpp)/launch/topics/talker_listener_launch.xml"" />
            </group>
            <!-- include a yaml launch file in the chatter_yaml_ns namespace-->
            <group>
                <!-- push_ros_namespace to set namespace of included nodes -->
                <push_ros_namespace namespace=""$(var chatter_yaml_ns)"" />
                <include file=""$(find-pkg-share demo_nodes_cpp)/launch/topics/talker_listener_launch.yaml"" />
            </group>

            <!-- start a turtlesim_node in the turtlesim1 namespace -->
            <node pkg=""turtlesim"" exec=""turtlesim_node"" name=""sim"" namespace=""turtlesim1"" />
            <!-- start another turtlesim_node in the turtlesim2 namespace
                and use args to set parameters -->
            <node pkg=""turtlesim"" exec=""turtlesim_node"" name=""sim"" namespace=""turtlesim2"">
                <param name=""background_r"" value=""$(var background_r)"" />
                <param name=""background_g"" value=""$(var background_g)"" />
                <param name=""background_b"" value=""$(var background_b)"" />
            </node>
            <!-- perform remap so both turtles listen to the same command topic -->
            <node pkg=""turtlesim"" exec=""mimic"" name=""mimic"">
                <remap from=""/input/pose"" to=""/turtlesim1/turtle1/pose"" />
                <remap from=""/output/cmd_vel"" to=""/turtlesim2/turtle1/cmd_vel"" />
            </node>
        </launch>

   .. group-tab:: YAML

      .. code-block:: yaml

        # example_launch.yaml

        launch:

        # args that can be set from the command line or a default will be used
        - arg:
            name: ""background_r""
            default: ""0""
        - arg:
            name: ""background_g""
            default: ""255""
        - arg:
            name: ""background_b""
            default: ""0""
        - arg:
            name: ""chatter_py_ns""
            default: ""chatter/py/ns""
        - arg:
            name: ""chatter_xml_ns""
            default: ""chatter/xml/ns""
        - arg:
            name: ""chatter_yaml_ns""
            default: ""chatter/yaml/ns""


        # include another launch file
        - include:
            file: ""$(find-pkg-share demo_nodes_cpp)/launch/topics/talker_listener_launch.py""

        # include a Python launch file in the chatter_py_ns namespace
        - group:
            - push_ros_namespace:
                namespace: ""$(var chatter_py_ns)""
            - include:
                file: ""$(find-pkg-share demo_nodes_cpp)/launch/topics/talker_listener_launch.py""

        # include a xml launch file in the chatter_xml_ns namespace
        - group:
            - push_ros_namespace:
                namespace: ""$(var chatter_xml_ns)""
            - include:
                file: ""$(find-pkg-share demo_nodes_cpp)/launch/topics/talker_listener_launch.xml""

        # include a yaml launch file in the chatter_yaml_ns namespace
        - group:
            - push_ros_namespace:
                namespace: ""$(var chatter_yaml_ns)""
            - include:
                file: ""$(find-pkg-share demo_nodes_cpp)/launch/topics/talker_listener_launch.yaml""

        # start a turtlesim_node in the turtlesim1 namespace
        - node:
            pkg: ""turtlesim""
            exec: ""turtlesim_node""
            name: ""sim""
            namespace: ""turtlesim1""

        # start another turtlesim_node in the turtlesim2 namespace and use args to set parameters
        - node:
            pkg: ""turtlesim""
            exec: ""turtlesim_node""
            name: ""sim""
            namespace: ""turtlesim2""
            param:
            -
              name: ""background_r""
              value: ""$(var background_r)""
            -
              name: ""background_g""
              value: ""$(var background_g)""
            -
              name: ""background_b""
              value: ""$(var background_b)""

        # perform remap so both turtles listen to the same command topic
        - node:
            pkg: ""turtlesim""
            exec: ""mimic""
            name: ""mimic""
            remap:
            -
                from: ""/input/pose""
                to: ""/turtlesim1/turtle1/pose""
            -
                from: ""/output/cmd_vel""
                to: ""/turtlesim2/turtle1/cmd_vel""

Using the Launch files from the command line
--------------------------------------------

Launching
^^^^^^^^^

Any of the launch files above can be run with ``ros2 launch``.
To try them locally, you can either create a new package and use

.. code-block:: console

  ros2 launch <package_name> <launch_file_name>

or run the file directly by specifying the path to the launch file

.. code-block:: console

  ros2 launch <path_to_launch_file>

Setting arguments
^^^^^^^^^^^^^^^^^

To set the arguments that are passed to the launch file, you should use ``key:=value`` syntax.
For example, you can set the value of ``background_r`` in the following way:

.. code-block:: console

  ros2 launch <package_name> <launch_file_name> background_r:=255

or

.. code-block:: console

  ros2 launch <path_to_launch_file> background_r:=255

Controlling the turtles
^^^^^^^^^^^^^^^^^^^^^^^

To test that the remapping is working, you can control the turtles by running the following command in another terminal:

.. code-block:: console

  ros2 run turtlesim turtle_teleop_key --ros-args --remap __ns:=/turtlesim1


Python, XML, or YAML: Which should I use?
-----------------------------------------

.. note::

  Launch files in ROS 1 were written in XML, so XML may be the most familiar to people coming from ROS 1.
  To see what's changed, you can visit :doc:`Migrating-from-ROS1/Migrating-Launch-Files`.

For most applications the choice of which ROS 2 launch format comes down to developer preference.
However, if your launch file requires flexibility that you cannot achieve with XML or YAML, you can use Python to write your launch file.
Using Python for ROS 2 launch is more flexible because of following two reasons:

* Python is a scripting language, and thus you can leverage the language and its libraries in your launch files.
* `ros2/launch <https://github.com/ros2/launch>`_ (general launch features) and `ros2/launch_ros <https://github.com/ros2/launch_ros>`_ (ROS 2 specific launch features) are written in Python and thus you have lower level access to launch features that may not be exposed by XML and YAML.

That being said, a launch file written in Python may be more complex and verbose than one in XML or YAML.
",Which formats can ROS 2 launch files be written in according to the given text?
"IDEs and Debugging [community-contributed]
==========================================

ROS 2 is not made around a specific development environment and the main focus is on building / running from the command line.
Nonetheless Integrated Development Environments (IDEs) can be used to develop, run and/or debug ROS 2 nodes.

Below are listed some IDEs and instructions on how to use them with ROS 2.


.. contents:: Contents
    :depth: 2
    :local:


General
-------


.. _InstalledPythonCode:

Installed Python Code
^^^^^^^^^^^^^^^^^^^^^

By default, when building workspaces with:

.. code-block:: bash

   colcon build

The Python code will be coped over into the ``build``/``install`` directories.
So when attaching a debugger to a ``ros2 run`` command from within an IDE, the code being run (from the ``build``/``install``) is not the same as the files opened in the IDE project.

There are 2 options to deal with this:

* Open the source files from ``build``/``install`` directory and place breakpoints there.
* Build the workspace with the `--symlink-install <https://colcon.readthedocs.io/en/released/reference/verb/build.html#command-line-arguments>`__ flag to colcon, which will symlink the source files to the ``build``/``install`` directory instead.


Visual Studio Code
------------------

`VSCode <https://code.visualstudio.com/>`_ is a versatile and free development environment.

VSCode is relatively easy to use with ROS 2.
Simply activate your environment in a command line and start the VSCode application from the same terminal and use as normal.
So:

#. Create your ROS workspace as you would normally.
#. In a terminal, source both ROS 2 and your install (if it was built already).
#. Start VSCode from the same command line. The terminal will be blocked until the application is closed again.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: bash

        source /opt/ros/{DISTRO}/setup.bash
        cd ~/dev_ws
        source ./install/setup.bash
        /usr/bin/code ./src/my_node/

   .. group-tab:: macOS

      .. code-block:: console

        . ~/ros2_install/ros2-osx/setup.bash
        cd ~/dev_ws
        . ./install/setup.bash
        /Applications/Visual Studio Code.app/Contents/Resources/app/bin/code ./src/my_node/

   .. group-tab:: Windows

      .. code-block:: console

        # For CMD:
        call C:\dev\ros2\local_setup.bat
        cd C:\dev_ws
        call .\install\local_setup.bat
        ""C:\Program Files\Microsoft VS Code\Code.exe"" .\src\my_node\

        # For PowerShell:
        C:\dev\ros2\local_setup.ps1
        cd C:\dev_ws
        .\install\local_setup.ps1
        & ""C:\Program Files\Microsoft VS Code\Code.exe"" .\src\my_node\


VSCode and any terminal created inside VSCode will correctly inherit from the parent environment and should have ROS and installed package available.

.. note::

   After adding packages or making major changes you might need to source your install again.
   The simplest way to do this is to close VSCode and restart it as above.


Python
^^^^^^

In your workspace, verify the correct interpreter is used.
Through sourcing the basic command ``python`` should be correct, but VSCode likes to resort to an absolute path for Python.
In the bottom right corner click on ""Selected Python Interpreter"" to change it.

If your ROS 2 Python version is from a virtual environment, VSCode will try to source it at each run command.
But we already started VSCode from a sourced environment, so this extra step is not necessary.
You can disable this for the current workspace by finding ""Settings"" > ""Extensions"" > ""Python"" > ""Activate Environment"" and disabling the check.

Now simply run a file or create a configuration in ``launch.json``.
Debugging a node is easiest by creating a configuration like a ``python ...`` command, instead of ``ros2 run/launch ...``.
An example of ``launch.json`` could be:

.. code-block::

   {
       ""version"": ""0.2.0"",
       ""configurations"": [
           {
               ""name"": ""Python: File"",
               ""type"": ""python"",
               ""request"": ""launch"",
               ""program"": ""my_node.py""
           },
       ]
   }


Instead you could also create a configuration for attaching to a running process, under ""Attach using Process Id"".


See :doc:`Setup ROS 2 with VSCode and Docker<Setup-ROS-2-with-VSCode-and-Docker-Container>` for full instructions on how to use VSCode, in combination with Docker.


PyCharm
-------

`PyCharm <https://www.jetbrains.com/pycharm/>`_ is an IDE specifically for Python.

Of course it can only be meaningfully used for nodes made in Python.

With PyCharm you can either attach to an existing process (probably started by you via ``ros2 run ...`` or ``ros2 launch ...``) or run the node directly from Python (equivalent to ``python [file.py]``.


Integrate for code inspection
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can setup your PyCharm project such that it is fully aware of ROS 2 code, allowing code completion and suggestion.


Linux
""""""""""

Open a terminal, source ROS and start PyCharm:

.. code-block:: bash

   source /opt/ros/humble/setup.bash
   cd path/to/dev_ws
   /opt/pycharm/bin/pycharm.sh

After selecting the correct interpreter, everything should work.

.. note::

    This is untested.


Windows
""""""""""""""

First sourcing ROS and then starting PyCharm from the command line seems to have no effect on Windows.
Instead, some settings need to be tweaked.

#. Create your ROS workspace as you would normally.
#. Start PyCharm normally.
#. Open a project. This should be the root directory of the ROS node you're developing, e.g. ``C:\dev_ws\src\my_node``.
#. Click ""Add new interpreter"" > ""Add local interpreter..."".
   Select a system interpreter (or virtual environment if you're using one) and select the executable of your ROS Python version (typically ``C:\Python38\python.exe``).

      * If you now open one of your code files, you will see warnings about missing imports.
        Trying to run the file will confirm these issues.

#. Under the ""Python Interpreters"" window, find and select your ROS interpreter.
   Edit the name to something recognizable.
   More importantly, now click the ""Show Interpreter Paths"" button.
#. In the new window, you will see the paths already associated with this interpreter.
   Click the ""+"" button and add two more paths (according to your ROS install):

      * ``C:\dev\ros2_humble\bin``
      * ``C:\dev\ros2_humble\Lib\site-packages``

PyCharm will re-index and when finished it should correctly interpret your project, recognising the ROS 2 system packages.
You can navigate through code, get completion and read doc blurbs as expected.


If there are dependencies built alongside with your package, they are probably not yet recognized and result in invalid IDE warnings and runtime errors.

Resolve this by:

* Making sure the ``PATH`` override in the run/debug configuration includes both the ROS 2 install and your workspace, e.g.:

  .. code-block:: bash

     C:\dev\ros2_humble\local_setup.ps1
     C:\dev_ws\install\local_setup.ps1
     echo $ENV:Path

* Adding the relevant folders from the ``install/`` directory to your project sources.

  Go to ""Settings..."" and under ""Project: "" > ""Project Structure"" click ""Add content root"".
  Add all the relevant ``site-packages`` folders under ``install/Lib/*``.

  Finally, make sure your run/debug configuration has the option ""include content roots in PYTHONPATH"" enabled.

.. tip::

   Using the `--merge-install <https://colcon.readthedocs.io/en/released/user/isolated-vs-merged-workspaces.html>`__ option with your colcon build will limit the number of depending directories, making it easier to configure PyCharm.


Attach to Process
^^^^^^^^^^^^^^^^^

Even without any configuration to PyCharm, you can always just attach to a running Python node.
Open your project source and simply run your node as usual:

.. code-block:: bash

   ros2 run my_node main

Then in PyCharm select ""Run"" > ""Attach to Process..."".
It might take a second, but a small window should show listing the currently running Python instances, including your node.
There can be multiple Python processes, so there may be some trial-and-error to find the right one.

After selecting an instance, the usual debugging tools are available.
You can pause it or create breakpoints in the code and step through it.

.. note::

   The code in your project might not be the files being executed, see :ref:`this<InstalledPythonCode>`.


Run/Debug
^^^^^^^^^

Follow the steps for integration first.

Running your Python file from PyCharm will likely result in import errors.
This is because PyCharm extends the ``PYTHONPATH`` environment variable, but it leaves ``PATH`` untouched.
Necessary library files in ``ros/bin`` are not found.

Edit the run/debug configuration for your file and under ""Environment Variables:"" add a new variable.
It is currently not supported to extend the existing ``PATH``, so we need to override it.
From a sourced ROS terminal, export the content of ``PATH`` with: ``echo $Env:PATH``.
Copy the result.

Back in PyCharm, paste it as ``PATH``, apply changes and run or debug your node.
It should work like any Python project now, allowing easy additions of breakpoints and other debug methods.

.. note::

   On Windows it seems the capitalization of the ``PATH`` variable under ""Environment Variables:"" must be ""path"" (all lowercase) in order to work.
","What are the two options provided in the text for dealing with the discrepancy between the code being run from the ""build""/""install"" directories and the files opened in an IDE project for debugging a ROS 2 node?"
".. redirect-from::

  Guides/Overriding-QoS-Policies-For-Recording-And-Playback
  Tutorials/Ros2bag/Overriding-QoS-Policies-For-Recording-And-Playback

.. _ROS2Bag-QoS-Override:

rosbag2: Overriding QoS Policies
================================

**Goal:** Override Ros2Bag QoS profile settings for recording and playback.

.. contents:: Contents
   :depth: 2
   :local:


Background
----------

With the introduction of DDS in ROS 2, Quality of Service (QoS) compatibility for publisher/subscriber nodes needs to be considered when recording and playing back data.
More detail on how QoS works can be found :doc:`here <../Concepts/Intermediate/About-Quality-of-Service-Settings>`.
For the purposes of this guide, it is sufficient to know that only the reliability and durability policies affect whether publishers/subscribers are compatible and can receive data from one other.

Ros2Bag adapts its requested/offered QoS profile when recording/playing data from a topic to prevent dropped messages.
During playback, Ros2bag also attempts to preserve the policy originally offered by the topic.
Certain situations may require specifying explicit QoS profile settings so Ros2Bag can record/playback topics.
These QoS profile overrides can be specified via the CLI using the ``--qos-profile-overrides-path`` flag.

Using QoS Overrides
-------------------

The YAML schema for the profile overrides is a dictionary of topic names with key/value pairs for each QoS policy:

.. code-block:: yaml

    topic_name: str
      qos_policy_name: str
      ...
      qos_duration: object
        sec: int
        nsec: int

If a policy value is not specified, the value will fallback to the default used by Ros2Bag.
If you specify a Duration based policy such as ``deadline`` or ``lifespan``, you will need to specify both seconds and nanoseconds.
Policy values are determined by the policy’s short keys which can be found using ``ros2topic`` verbs such as ``ros2 topic pub --help``.
All values are replicated below for reference.

.. code-block:: yaml

    history: [keep_all, keep_last]
    depth: int
    reliability: [system_default, reliable, best_effort, unknown]
    durability: [system_default, transient_local, volatile, unknown]
    deadline:
      sec: int
      nsec: int
    lifespan:
      sec: int
      nsec: int
    liveliness: [system_default, automatic, manual_by_topic, unknown]
    liveliness_lease_duration:
      sec: int
      nsec: int
    avoid_ros_namespace_conventions: [true, false]

Example
-------

Consider a topic ``/talker`` offering a ``transient_local`` Durability policy.
ROS 2 publishers by default request ``volatile`` Durability.

.. code-block:: console

    ros2 topic pub -r 0.1 --qos-durability transient_local /talker std_msgs/String ""data: Hello World""

In order for Ros2Bag to record the data, we would want to override the recording policy for that specific topic like so:

.. code-block:: yaml

    # durability_override.yaml
    /talker:
      durability: transient_local
      history: keep_all

And call it from the CLI:

.. code-block:: console

    ros2 bag record -a -o my_bag --qos-profile-overrides-path durability_override.yaml

If we want to playback the bag file but with a different Reliability policy, we can specify one as such;

.. code-block:: yaml

    # reliability_override.yaml
    /talker:
      reliability: best_effort
      history: keep_all

And call it from the CLI:

.. code-block:: console

    ros2 bag play --qos-profile-overrides-path reliability_override.yaml my_bag

We can see the results with ``ros2 topic``

.. code-block:: console

    ros2 topic echo --qos-reliability best_effort /talker std_msgs/String
",What is the purpose of using QoS profile overrides in Ros2Bag for recording and playback?
"Using ROS 2 launch to launch composable nodes
=============================================

.. contents:: Table of Contents
   :depth: 1
   :local:

In the :doc:`Composition tutorial <../Tutorials/Intermediate/Composition>`, you learned about composable nodes and how to use them from the command-line.
In the :doc:`Launch tutorials <../Tutorials/Intermediate/Launch/Launch-Main>`, you learned about launch files and how to use them to manage multiple nodes.

This guide will combine the above two topics and teach you how to write launch files for composable nodes.

Setup
-----

See the :doc:`installation instructions <../Installation>` for details on installing ROS 2.

If you've installed ROS 2 from packages, ensure that you have ``ros-{DISTRO}-image-tools`` installed.
If you downloaded the archive or built ROS 2 from source, it will already be part of the installation.

Launch file examples
--------------------

Below is a launch file that launches composable nodes in Python, XML, and YAML.
The launch files all do the following:

* Instantiate a cam2image composable node with remappings, custom parameters, and extra arguments
* Instantiate a showimage composable node with remappings, custom parameters, and extra arguments

.. tabs::

  .. group-tab:: Python

    .. code-block:: python

      import launch
      from launch_ros.actions import ComposableNodeContainer
      from launch_ros.descriptions import ComposableNode


      def generate_launch_description():
          """"""Generate launch description with multiple components.""""""
          container = ComposableNodeContainer(
                  name='image_container',
                  namespace='',
                  package='rclcpp_components',
                  executable='component_container',
                  composable_node_descriptions=[
                      ComposableNode(
                          package='image_tools',
                          plugin='image_tools::Cam2Image',
                          name='cam2image',
                          remappings=[('/image', '/burgerimage')],
                          parameters=[{'width': 320, 'height': 240, 'burger_mode': True, 'history': 'keep_last'}],
                          extra_arguments=[{'use_intra_process_comms': True}]),
                      ComposableNode(
                          package='image_tools',
                          plugin='image_tools::ShowImage',
                          name='showimage',
                          remappings=[('/image', '/burgerimage')],
                          parameters=[{'history': 'keep_last'}],
                          extra_arguments=[{'use_intra_process_comms': True}])
                  ],
                  output='both',
          )

          return launch.LaunchDescription([container])

  .. group-tab:: XML

    .. code-block:: xml

      <launch>
          <node_container pkg=""rclcpp_components"" exec=""component_container"" name=""image_container"" namespace="""">
              <composable_node pkg=""image_tools"" plugin=""image_tools::Cam2Image"" name=""cam2image"" namespace="""">
                  <remap from=""/image"" to=""/burgerimage"" />
                  <param name=""width"" value=""320"" />
                  <param name=""height"" value=""240"" />
                  <param name=""burger_mode"" value=""true"" />
                  <param name=""history"" value=""keep_last"" />
                  <extra_arg name=""use_intra_process_comms"" value=""true"" />
              </composable_node>
              <composable_node pkg=""image_tools"" plugin=""image_tools::ShowImage"" name=""showimage"" namespace="""">
                  <remap from=""/image"" to=""/burgerimage"" />
                  <param name=""history"" value=""keep_last"" />
                  <extra_arg name=""use_intra_process_comms"" value=""true"" />
              </composable_node>
          </node_container>
      </launch>

  .. group-tab:: YAML

    .. code-block:: yaml

      launch:

          - node_container:
              pkg: rclcpp_components
              exec: component_container
              name: image_container
              namespace: ''
              composable_node:
                  -   pkg: image_tools
                      plugin: image_tools::Cam2Image
                      name: cam2image
                      namespace: ''
                      remap:
                          - from: /image
                            to: /burgerimage
                      param:
                          - name: width
                            value: 320
                          - name: height
                            value: 240
                          - name: burger_mode
                            value: true
                          - name: history
                            value: keep_last
                      extra_arg:
                          - name: use_intra_process_comms
                            value: 'true'

                  -   pkg: image_tools
                      plugin: image_tools::ShowImage
                      name: showimage
                      namespace: ''
                      remap:
                          - from: /image
                            to: /burgerimage
                      param:
                          - name: history
                            value: keep_last
                      extra_arg:
                          - name: use_intra_process_comms
                            value: 'true'


Loading composable nodes into an existing container
---------------------------------------------------

Containers can sometimes be launched by other launch files or from a commandline.
In that case, you need to add your components to an existing container.
For this, you may use ``LoadComposableNodes`` to load components into a given container.
The below example launches the same nodes as above.

.. tabs::

  .. group-tab:: Python

    .. code-block:: python

      from launch import LaunchDescription
      from launch_ros.actions import LoadComposableNodes, Node
      from launch_ros.descriptions import ComposableNode

      def generate_launch_description():
          container = Node(
              name='image_container',
              package='rclcpp_components',
              executable='component_container',
              output='both',
          )

          load_composable_nodes = LoadComposableNodes(
              target_container='image_container',
              composable_node_descriptions=[
                  ComposableNode(
                       package='image_tools',
                      plugin='image_tools::Cam2Image',
                      name='cam2image',
                      remappings=[('/image', '/burgerimage')],
                      parameters=[{'width': 320, 'height': 240, 'burger_mode': True, 'history': 'keep_last'}],
                      extra_arguments=[{'use_intra_process_comms': True}],
                  ),
                  ComposableNode(
                      package='image_tools',
                      plugin='image_tools::ShowImage',
                      name='showimage',
                      remappings=[('/image', '/burgerimage')],
                      parameters=[{'history': 'keep_last'}],
                      extra_arguments=[{'use_intra_process_comms': True}]
                  ),
              ],
          )

          return LaunchDescription([container, load_composable_nodes])

  .. group-tab:: XML

    .. code-block:: xml

      <launch>
          <node pkg=""rclcpp_components"" exec=""component_container"" name=""image_container"">
          </node>
          <load_composable_node target=""image_container"">
              <composable_node pkg=""image_tools"" plugin=""image_tools::Cam2Image"" name=""cam2image"">
                  <remap from=""/image"" to=""/burgerimage"" />
                  <param name=""width"" value=""320"" />
                  <param name=""height"" value=""240"" />
                  <param name=""burger_mode"" value=""true"" />
                  <param name=""history"" value=""keep_last"" />
                  <extra_arg name=""use_intra_process_comms"" value=""true"" />
              </composable_node>
              <composable_node pkg=""image_tools"" plugin=""image_tools::ShowImage"" name=""showimage"" namespace="""">
                  <remap from=""/image"" to=""/burgerimage"" />
                  <param name=""history"" value=""keep_last"" />
                  <extra_arg name=""use_intra_process_comms"" value=""true"" />
              </composable_node>
          </load_composable_node>
      </launch>

  .. group-tab:: YAML

    .. code-block:: yaml

      launch:
          - node_container:
              pkg: rclcpp_components
              exec: component_container
              name: image_container
              namespace: ''
              composable_node:
                  -   pkg: image_tools
                      plugin: image_tools::Cam2Image
                      name: cam2image
                      namespace: ''
                      remap:
                          - from: /image
                            to: /burgerimage
                      param:
                          - name: width
                            value: 320
                          - name: height
                            value: 240
                          - name: burger_mode
                            value: true
                          - name: history
                            value: keep_last
                      extra_arg:
                          - name: use_intra_process_comms
                            value: 'true'

                  -   pkg: image_tools
                      plugin: image_tools::ShowImage
                      name: showimage
                      namespace: ''
                      remap:
                          - from: /image
                            to: /burgerimage
                      param:
                          - name: history
                            value: keep_last
                      extra_arg:
                          - name: use_intra_process_comms
                            value: 'true'


Using the Launch files from the command-line
--------------------------------------------

Any of the launch files above can be run with ``ros2 launch``.
Copy the data into a local file, and then run:

.. code-block:: console

  ros2 launch <path_to_launch_file>

Intra-process communications
----------------------------

All of the above examples use an extra argument to setup intra-process communication between the nodes.
For more information on what intra-process communications are, see the :doc:`intra-process comms tutorial <../Tutorials/Demos/Intra-Process-Communication>`.

Python, XML, or YAML: Which should I use?
-----------------------------------------

See the discussion in :doc:`Launch-file-different-formats` for more information.
",Which three formats are provided for writing launch files for composable nodes in ROS 2?
".. redirect-from::

  How-To-Guides/Disabling-ZeroCopy-loaned-messages

Configure Zero Copy Loaned Messages
===================================

.. contents:: Contents
   :depth: 1
   :local:

See the `Loaned Messages <https://design.ros2.org/articles/zero_copy.html>`__ article for details on how loaned messages work.

How to disable Loaned Messages
------------------------------

Publishers
~~~~~~~~~~

By default, *Loaned Messages* will try to borrow the memory from underlying middleware if it supports *Loaned Messages*.
The ``ROS_DISABLE_LOANED_MESSAGES`` environment variable can be used to disable *Loaned Messages*, and fallback to normal publisher behavior, without any code changes or middleware configuration.
You can set the environment variable with the following command:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        export ROS_DISABLE_LOANED_MESSAGES=1

      To maintain this setting between shell sessions, you can add the command to your shell startup script:

      .. code-block:: console

        echo ""export ROS_DISABLE_LOANED_MESSAGES=1"" >> ~/.bashrc

   .. group-tab:: macOS

      .. code-block:: console

        export ROS_DISABLE_LOANED_MESSAGES=1

      To maintain this setting between shell sessions, you can add the command to your shell startup script:

      .. code-block:: console

        echo ""export ROS_DISABLE_LOANED_MESSAGES=1"" >> ~/.bash_profile

   .. group-tab:: Windows

      .. code-block:: console

        set ROS_DISABLE_LOANED_MESSAGES=1

      If you want to make this permanent between shell sessions, also run:

      .. code-block:: console

        setx ROS_DISABLE_LOANED_MESSAGES 1


Subscriptions
~~~~~~~~~~~~~

Currently using *Loaned Messages* is not safe on subscription, see more details in `this issue <https://github.com/ros2/rmw_cyclonedds/issues/469>`_.
Because of this, by default *Loaned Messages* is ``disabled`` on subscription with `Set disable loan to on by default <https://github.com/ros2/rcl/pull/1110>`_ even though underlying middleware supports that.
To enable *Loaned Messages* on subscription, you need to set the environment variable ``ROS_DISABLE_LOANED_MESSAGES`` to ``0`` explicitly.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        export ROS_DISABLE_LOANED_MESSAGES=0

      To maintain this setting between shell sessions, you can add the command to your shell startup script:

      .. code-block:: console

        echo ""export ROS_DISABLE_LOANED_MESSAGES=0"" >> ~/.bashrc

   .. group-tab:: macOS

      .. code-block:: console

        export ROS_DISABLE_LOANED_MESSAGES=0

      To maintain this setting between shell sessions, you can add the command to your shell startup script:

      .. code-block:: console

        echo ""export ROS_DISABLE_LOANED_MESSAGES=0"" >> ~/.bash_profile

   .. group-tab:: Windows

      .. code-block:: console

        set ROS_DISABLE_LOANED_MESSAGES=0

      If you want to make this permanent between shell sessions, also run:

      .. code-block:: console

        setx ROS_DISABLE_LOANED_MESSAGES 0
",How can Loaned Messages be disabled for Publishers and Subscriptions in ROS2?
".. redirect-from::

    Tutorials/Run-2-nodes-in-a-single-docker-container
    Tutorials/Run-2-nodes-in-two-separate-docker-containers
    Guides/Run-2-nodes-in-two-separate-docker-containers

Running ROS 2 nodes in Docker [community-contributed]
=====================================================

Run two nodes in a single docker container
------------------------------------------

Pull the ROS docker image with tag ""{DISTRO}-desktop"".

.. code-block:: bash

   docker pull osrf/ros:{DISTRO}-desktop


Run the image in a container in interactive mode.

.. code-block:: bash

   $ docker run -it osrf/ros:{DISTRO}-desktop
   root@<container-id>:/#


Your best friend is the ``ros2`` command line help now.

.. code-block:: bash

   root@<container-id>:/# ros2 --help


E.g. list all installed packages.

.. code-block:: bash

   root@<container-id>:/# ros2 pkg list
   (you will see a list of packages)


E.g. list all executables:

.. code-block:: bash

   root@<container-id>:/# ros2 pkg executables
   (you will see a list of <package> <executable>)


Run a minimal example of 2 C++ nodes (1 topic subscriber ``listener``, 1 topic publisher ``talker``) from the package ``demo_nodes_cpp`` in this container:

.. code-block:: bash

   ros2 run demo_nodes_cpp listener &
   ros2 run demo_nodes_cpp talker

Run two nodes in two separate docker containers
-----------------------------------------------

Open a terminal. Run the image in a container in interactive mode and launch a topic publisher (executable ``talker`` from the package ``demo_nodes_cpp``) with ``ros2 run``:

.. code-block:: bash

   docker run -it --rm osrf/ros:{DISTRO}-desktop ros2 run demo_nodes_cpp talker

Open a second terminal. Run the image in a container in interactive mode and launch a topic subscriber (executable ``listener`` from the package ``demo_nodes_cpp``)  with ``ros2 run``:

.. code-block:: bash

   docker run -it --rm osrf/ros:{DISTRO}-desktop ros2 run demo_nodes_cpp listener

As an alternative to the command line invocation, you can create a ``docker-compose.yml`` file (here version 2) with the following (minimal) content:

.. code-block:: yaml

   version: '2'

   services:
     talker:
       image: osrf/ros:{DISTRO}-desktop
       command: ros2 run demo_nodes_cpp talker
     listener:
       image: osrf/ros:{DISTRO}-desktop
       command: ros2 run demo_nodes_cpp listener
       depends_on:
         - talker

To run the containers call ``docker compose up`` in the same directory. You can close the containers with ``Ctrl+C``.
",Question: How can you run two ROS 2 nodes in two separate docker containers using the provided Docker image?
".. redirect-from::

  Guides/Cross-compilation
  Tutorials/Cross-compilation

Cross-compilation
=================

The `cross_compile <https://github.com/ros-tooling/cross_compile>`__ tool is not supported anymore.

An alternative to cross-compilation is to `build multi-platform Docker images <https://github.com/docker/buildx#building-multi-platform-images>`__ using ``docker buildx``.
",What is the alternative to cross-compilation mentioned in the text provided?
"Using variants
==============

Metapackages do not provide software directly but depend on a group of other related packages to provide a convienent installation mechanism for the complete group of packages. [#]_ [#]_
Variants are a list of official metapackages for commonly useful groups of ROS packages.

.. [#] https://wiki.debian.org/metapackage
.. [#] https://help.ubuntu.com/community/MetaPackages

The different variants in ROS 2 are specified in `REP-2001 <https://ros.org/reps/rep-2001.html>`_.

In addition to the official variants, there may be metapackages for specific institutions or robots as described in `REP-108 <https://www.ros.org/reps/rep-0108.html#institution-specific>`_.

Adding variants
---------------

Additional variants that are of general use to the ROS community can be proposed by contributing an update to `REP-2001 via pull request <https://github.com/ros-infrastructure/rep/blob/master/rep-2001.rst>`_ describing the packages included in the new variant.
Institution and robot specific variants can be published directly by their respective maintainers and no update to REP-2001 is required.

Creating project-specific variants
----------------------------------

If you are creating ROS packages to use privately in your own projects, you can create variants specific to your projects using the official variants as examples.
To do so you need only create two files:

#. A minimal variant package is created as a package with the ``ament_cmake`` build type, a ``buildtool_depend`` on ``ament_cmake`` and ``exec_depend`` entries for each package you want to include in the variant.

   .. code-block:: xml

    <?xml version=""1.0""?>
    <?xml-model href=""http://download.ros.org/schema/package_format2.xsd"" schematypens=""http://www.w3.org/2001/XMLSchema""?>
    <package format=""2"">
      <name>my_project_variant</name>
      <version>1.0.0</version>
      <description>A package to aggregate all packages in my_project.</description>
      <maintainer email=""maintainer-email"">Maintainer Name</maintainer>
      <license>Apache-2.0</license>
      <!-- packages in my_project -->
      <exec_depend>my_project_msgs</exec_depend>
      <exec_depend>my_project_services</exec_depend>
      <exec_depend>my_project_examples</exec_depend>

      <export>
        <build_type>ament_cmake</build_type>
      </export>
    </package>

#. A minimal ament_cmake package includes a ``CMakeLists.txt`` which registers the package.xml as an ament package for use in ROS 2.

   .. code-block:: cmake

    cmake_minimum_required(VERSION 3.5)

    project(my_project_variant NONE)
    find_package(ament_cmake REQUIRED)
    ament_package()

You can then build and install your variant package alongside your other private packages.

Creating custom variants with platform-specific tools
*****************************************************

Some platforms have tools for creating basic packages that do not require a full ROS build farm environment or equivalent infrastructure.
It is possible to use these tools to create platform-dependent variants.
This approach does not include support for ROS packaging tools and is platform dependent but requires much less infrastructure to produce if you are creating collections of existing packages rather than a mix of public and private ROS packages.
For example, on Debian or Ubuntu systems you can use the ``equivs`` utilities.
The Debian Administrator's handbook has a `Section on meta-packages <https://www.debian.org/doc/manuals/debian-handbook/sect.building-first-package.en.html#id-1.18.5.2>`_.
",What is the process for proposing additional variants for the ROS community according to `REP-2001`?
".. redirect-from::

  Guides/Using-Python-Packages
  Tutorials/Using-Python-Packages

.. _PythonPackages:

Using Python Packages with ROS 2
================================

**Goal:** Explain how to interoperate with other Python packages from the ROS 2 ecosystem.

.. contents:: Contents
    :depth: 2
    :local:

.. note::

    A cautionary note, if you intended to use pre-packaged binaries (either ``deb`` files, or the binary archive distributions), the Python interpreter must match what was used to build the original binaries.
    If you intend to use something like ``virtualenv`` or ``pipenv``\, make sure to use the system interpreter.
    If you use something like ``conda``, it is very likely that the interpreter will not match the system interpreter and will be incompatible with ROS 2 binaries.

Installing via ``rosdep``
-------------------------

The fastest way to include third-party python packages is to use their corresponding rosdep keys, if available.  ``rosdep`` keys can be checked via:

* https://github.com/ros/rosdistro/blob/master/rosdep/base.yaml
* https://github.com/ros/rosdistro/blob/master/rosdep/python.yaml

These ``rosdep`` keys can be added to your ``package.xml`` file, which indicates to the build system that your package (and dependent packages) depend on those keys.
In a new workspace, you can also quickly install all rosdep keys with:

.. code-block:: console

    rosdep install -yr ./path/to/your/workspace

If there aren’t currently ``rosdep`` keys for the package that you are interested in, it is possible to add them by following the `rosdep key contribution guide`_.

To learn more about the ``rosdep`` tool and how it works, consult the `rosdep documentation`_.

Installing via a package manager
--------------------------------

If you don’t want to make a rosdep key, but the package is available in your system package manager (eg ``apt``), you can install and use the package that way:

.. code-block:: console

    sudo apt install python3-serial

If the package is available on `The Python Package Index (PyPI) <https://pypi.org/>`_ and you want to install globally on your system:

.. code-block::

    python3 -m pip install -U pyserial

If the package is available on PyPI and you want to install locally to your user:

.. code-block:: console

    python3 -m pip install -U --user pyserial

Installing via a virtual environment
------------------------------------

First, create a Colcon workspace:

.. code-block:: console

    mkdir -p ~/colcon_venv/src
    cd ~/colcon_venv/

Then setup your virtual environment:

.. code-block:: console

    # Make a virtual env and activate it
    virtualenv -p python3 ./venv
    source ./venv/bin/activate
    # Make sure that colcon doesn’t try to build the venv
    touch ./venv/COLCON_IGNORE

Next, install the Python packages that you want in your virtual environment:

.. code-block:: console

    python3 -m pip install gtsam pyserial… etc

Now you can build your workspace and run your python node that depends on packages installed in your virtual environment.

.. code-block:: console

    # Source {DISTRO_TITLE} and build
    source /opt/ros/{DISTRO}/setup.bash
    colcon build

.. note::

    If you want to release your package using Bloom, you should add the packages you require to ``rosdep``, see the `rosdep key contribution guide`_.

.. _rosdep key contribution guide: http://docs.ros.org/en/independent/api/rosdep/html/contributing_rules.html

.. _rosdep documentation: http://docs.ros.org/en/independent/api/rosdep/html/
",How can third-party Python packages be included using rosdep keys and package managers in ROS 2?
"Setup ROS 2 with VSCode and Docker [community-contributed]
==========================================================


.. contents:: Contents
    :depth: 2
    :local:


Install VS Code and Docker
--------------------------


Using Visual Studio Code and Docker Containers will enable you to run your favorite ROS 2 Distribution without the necessity to change your operating system or use a virtual machine.
With this tutorial you can set up a docker container, which can be used for your future ROS 2 projects.


Install Docker
^^^^^^^^^^^^^^


To install docker and set the correct user rights please use the following commands.

.. code-block:: console

    sudo apt install docker.io git python3-pip
    pip3 install vcstool
    echo export PATH=$HOME/.local/bin:$PATH >> ~/.bashrc
    source ~/.bashrc
    sudo groupadd docker
    sudo usermod -aG docker $USER
    newgrp docker

Now you can check if the installation was successful by running the following command:

.. code-block:: console

    docker run hello-world

You might need to start the Docker Daemon first, if you cannot run hello-world out of the box:

.. code-block:: console

    sudo systemctl start docker

Install VS Code
^^^^^^^^^^^^^^^

To install VS Code please use the following commands:

.. code-block:: console

    sudo apt update
    sudo apt install software-properties-common apt-transport-https wget -y
    wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add -
    sudo add-apt-repository ""deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main""
    sudo apt install code


You can run VS Code by typing ``code`` in a terminal.


Install Remote Development Extension
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Within VS Code search in Extensions (CTRL+SHIFT+X) for the ""Remote Development"" Extension and install it.


Configure workspace in Docker and VS Code
-----------------------------------------

Add your ROS 2 workspace
^^^^^^^^^^^^^^^^^^^^^^^^


Add a workspace in order to build and open them in a container, e.g.:

.. code-block:: console

    cd ~/
    mkdir ws
    cd ws
    mkdir src

Now create a ``.devcontainer`` folder in the root of your workspace and add a ``devcontainer.json`` and ``Dockerfile`` to this ``.devcontainer`` folder.
The workspace structure should look like this:

::

    ws
    ├── .devcontainer
    │   ├── devcontainer.json
    │   └── Dockerfile
    ├── src
        ├── package1
        └── package2


With ``File->Open Folder...`` or ``Ctrl+K Ctrl+O``, open the ``ws`` folder of your workspace in VS Code.

Edit ``devcontainer.json`` for your environment
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For the Dev Container to function properly, we have to build it with the correct user.
Therefore add the following to ``.devcontainer/devcontainer.json``:

.. code-block:: json

    {
        ""name"": ""ROS 2 Development Container"",
        ""privileged"": true,
        ""remoteUser"": ""YOUR_USERNAME"",
        ""build"": {
            ""dockerfile"": ""Dockerfile"",
            ""args"": {
                ""USERNAME"": ""YOUR_USERNAME""
            }
        },
        ""workspaceFolder"": ""/home/ws"",
        ""workspaceMount"": ""source=${localWorkspaceFolder},target=/home/ws,type=bind"",
        ""customizations"": {
            ""vscode"": {
                ""extensions"":[
                    ""ms-vscode.cpptools"",
                    ""ms-vscode.cpptools-themes"",
                    ""twxs.cmake"",
                    ""donjayamanne.python-extension-pack"",
                    ""eamodio.gitlens"",
                    ""ms-iot.vscode-ros""
                ]
            }
        },
        ""containerEnv"": {
            ""DISPLAY"": ""unix:0"",
            ""ROS_AUTOMATIC_DISCOVERY_RANGE"": ""LOCALHOST"",
            ""ROS_DOMAIN_ID"": ""42""
        },
        ""runArgs"": [
            ""--net=host"",
            ""--pid=host"",
            ""--ipc=host"",
            ""-e"", ""DISPLAY=${env:DISPLAY}""
        ],
        ""mounts"": [
           ""source=/tmp/.X11-unix,target=/tmp/.X11-unix,type=bind,consistency=cached"",
           ""source=/dev/dri,target=/dev/dri,type=bind,consistency=cached""
        ],
        ""postCreateCommand"": ""sudo rosdep update && sudo rosdep install --from-paths src --ignore-src -y && sudo chown -R $(whoami) /home/ws/""
    }



Use ``Ctrl+F`` to open the search and replace menu.
Search for ``YOUR_USERNAME`` and replace it with your ``Linux username``.
If you do not know your username, you can find it by running ``echo $USERNAME`` in the terminal.


Edit ``Dockerfile``
^^^^^^^^^^^^^^^^^^^

Open the Dockerfile and add the following contents:


.. code-block:: bash

    FROM ros:ROS_DISTRO
    ARG USERNAME=USERNAME
    ARG USER_UID=1000
    ARG USER_GID=$USER_UID

    # Delete user if it exists in container (e.g Ubuntu Noble: ubuntu)
    RUN if id -u $USER_UID ; then userdel `id -un $USER_UID` ; fi

    # Create the user
    RUN groupadd --gid $USER_GID $USERNAME \
        && useradd --uid $USER_UID --gid $USER_GID -m $USERNAME \
        #
        # [Optional] Add sudo support. Omit if you don't need to install software after connecting.
        && apt-get update \
        && apt-get install -y sudo \
        && echo $USERNAME ALL=\(root\) NOPASSWD:ALL > /etc/sudoers.d/$USERNAME \
        && chmod 0440 /etc/sudoers.d/$USERNAME
    RUN apt-get update && apt-get upgrade -y
    RUN apt-get install -y python3-pip
    ENV SHELL /bin/bash

    # ********************************************************
    # * Anything else you want to do like clean up goes here *
    # ********************************************************

    # [Optional] Set the default user. Omit if you want to keep the default as root.
    USER $USERNAME
    CMD [""/bin/bash""]

Replace ``ROS_DISTRO`` with the ROS 2 distribution you wish to use as base image above, for example ``rolling``.


Open and Build Development Container
------------------------------------

Use ``View->Command Palette...`` or ``Ctrl+Shift+P`` to open the command palette.
Search for the command ``Dev Containers: Reopen in Container`` and execute it.
This will build your development docker container for your. It will take a while - sit back or go for a coffee.


Test Container
^^^^^^^^^^^^^^

To test if everything worked correctly, open a terminal in the container using ``View->Terminal`` or ``Ctrl+Shift+``` and ``New Terminal`` in VS Code.
Inside the terminal do the following:

.. code-block:: console

    sudo apt install ros-$ROS_DISTRO-rviz2 -y
    source /opt/ros/$ROS_DISTRO/setup.bash
    rviz2

.. Note:: There might be a problem with displaying RVIZ. Please make sure to allow the user to access X window system with ``xhost +local:<USERNAME>``. If no window still pops up, then check the value of ``echo $DISPLAY`` - if the output is 1, you can fix this problem with ``echo ""export DISPLAY=unix:1"" >> /etc/bash.bashrc`` and then test it again. You can also change the DISPLAY value in the devcontainer.json and rebuild it.
",What are the steps to configure a ROS 2 workspace using Docker and Visual Studio Code as described in the text document?
".. redirect-from::

   Migration-Guide-Python
   The-ROS2-Project/Contributing/Migration-Guide-Python

Migrating Python Packages Reference
===================================

This page is a reference on how to migrate Python packages from ROS 1 to ROS 2.
If this is your first time migrating a Python package, then follow :doc:`this guide to migrate an example Python package <./Migrating-Python-Package-Example>` first.

.. contents:: Table of Contents
   :depth: 2
   :local:

Build tool
----------

Instead of using ``catkin_make``, ``catkin_make_isolated`` or ``catkin build`` ROS 2 uses the command line tool `colcon <https://design.ros2.org/articles/build_tool.html>`__ to build and install a set of packages.
See the :doc:`beginner tutorial <../../Tutorials/Beginner-Client-Libraries/Colcon-Tutorial>` to get started with ``colcon``.

Build system
------------

For pure Python packages, ROS 2 uses the standard ``setup.py`` installation mechanism familiar to Python developers.

Update the files to use *setup.py*
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the ROS 1 package uses CMake only to invoke the ``setup.py`` file and does not contain anything beside Python code (e.g. no messages, services, etc.) it should be converted into a pure Python package in ROS 2:

*
  Update or add the build type in the ``package.xml`` file:

  .. code-block:: xml

     <export>
       <build_type>ament_python</build_type>
     </export>

*
  Remove the ``CMakeLists.txt`` file

*
  Update the ``setup.py`` file to be a standard Python setup script

ROS 2 supports Python 3 only.
While each package can choose to also support Python 2 it must invoke executables with Python 3 if it uses any API provided by other ROS 2 packages.

Update source code
------------------

Node Initialization
^^^^^^^^^^^^^^^^^^^

In ROS 1:

.. code-block:: python

   rospy.init_node('asdf')

   rospy.loginfo('Created node')

In ROS 2:

.. code-block:: python

   with rclpy.init(args=sys.argv):
       node = rclpy.create_node('asdf')

       node.get_logger().info('Created node')

ROS Parameters
^^^^^^^^^^^^^^

In ROS 1:

.. code-block:: python

   port = rospy.get_param('port', '/dev/ttyUSB0')
   assert isinstance(port, str), 'port parameter must be a str'

   baudrate = rospy.get_param('baudrate', 115200)
   assert isinstance(baudrate, int), 'baudrate parameter must be an integer'

  rospy.logwarn('port: ' + port)

In ROS 2:

.. code-block:: python

   port = node.declare_parameter('port', '/dev/ttyUSB0').value
   assert isinstance(port, str), 'port parameter must be a str'

   baudrate = node.declare_parameter('baudrate', 115200).value
   assert isinstance(baudrate, int), 'baudrate parameter must be an integer'

   node.get_logger().warn('port: ' + port)

Creating a Publisher
^^^^^^^^^^^^^^^^^^^^

In ROS 1:

.. code-block:: python

   pub = rospy.Publisher('chatter', String)
   # or
   pub = rospy.Publisher('chatter', String, queue_size=10)

In ROS 2:

.. code-block:: python

   pub = node.create_publisher(String, 'chatter', rclpy.qos.QoSProfile())
   # or
   pub = node.create_publisher(String, 'chatter', 10)

Creating a Subscriber
^^^^^^^^^^^^^^^^^^^^^

In ROS 1:

.. code-block:: python

   sub = rospy.Subscriber('chatter', String, callback)
   # or
   sub = rospy.Subscriber('chatter', String, callback, queue_size=10)

In ROS 2:

.. code-block:: python

   sub = node.create_subscription(String, 'chatter', callback, rclpy.qos.QoSProfile())
   # or
   sub = node.create_subscription(String, 'chatter', callback, 10)

Creating a Service
^^^^^^^^^^^^^^^^^^

In ROS 1:

.. code-block:: python

   srv = rospy.Service('add_two_ints', AddTwoInts, add_two_ints_callback)

In ROS 2:

.. code-block:: python

   srv = node.create_service(AddTwoInts, 'add_two_ints', add_two_ints_callback)

Creating a Service Client
^^^^^^^^^^^^^^^^^^^^^^^^^

In ROS 1:

.. code-block:: python

   rospy.wait_for_service('add_two_ints')
   add_two_ints = rospy.ServiceProxy('add_two_ints', AddTwoInts)
   resp = add_two_ints(req)

In ROS 2:

.. code-block:: python

   add_two_ints = node.create_client(AddTwoInts, 'add_two_ints')
   while not add_two_ints.wait_for_service(timeout_sec=1.0):
       node.get_logger().info('service not available, waiting again...')
   resp = add_two_ints.call_async(req)
   rclpy.spin_until_future_complete(node, resp)

.. warning::

   Do not use ``rclpy.spin_until_future_complete`` in a ROS 2 callback.
   For more details see the :doc:`sync deadlock article <../Sync-Vs-Async>`.
",What command line tool does ROS 2 use for building and installing packages?
".. redirect-from::

   Guides/Parameters-YAML-files-migration-guide
   Tutorials/Parameters-YAML-files-migration-guide
   How-To-Guides/Parameters-YAML-files-migration-guide

Migrating Parameters
====================

.. contents:: Table of Contents
   :depth: 2
   :local:

In ROS 1, parameters are associated with a central server that allowed retrieving parameters at runtime through the use of the network APIs.
In ROS 2, parameters are associated per node and are configurable at runtime with ROS services.

* See `ROS 2 Parameter design document <https://design.ros2.org/articles/ros_parameters.html>`_ for more details about the system model.

* See :doc:`ROS 2 CLI usage <../../Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters>` for a better understanding of how the CLI tools work and its differences with ROS 1 tooling.

Migrating YAML Parameter Files
------------------------------

This guide describes how to adapt ROS 1 parameters files for ROS 2.

YAML file example
^^^^^^^^^^^^^^^^^

YAML is used to write parameters files in both ROS 1 and ROS 2.
The main difference in ROS 2 is that node names must be used to address parameters.
In addition to the fully qualified node name, we use the key ""ros__parameters"" to signal the start of parameters for the node.


For example, here is a parameters file in ROS 1:

.. code-block:: yaml

   lidar_name: foo
   lidar_id: 10
   ports: [11312, 11311, 21311]
   debug: true

Let's assume that the first two parameters are for a node named ``/lidar_ns/lidar_node_name``, the next parameter is for a node named ``/imu``, and the last parameter we want to set on both nodes.

We would construct our ROS 2 parameters file as follows:

.. code-block:: yaml

   /lidar_ns:
     lidar_node_name:
       ros__parameters:
         lidar_name: foo
         id: 10
   imu:
     ros__parameters:
       ports: [2438, 2439, 2440]
   /**:
     ros__parameters:
       debug: true

Note the use of wildcards (``/**``) to indicate that the parameter ``debug`` should be set on any node in any namespace.

Feature parity
^^^^^^^^^^^^^^

Some features of ROS 1 parameters files do not exist in ROS 2:

- Mixed types in a list is not supported yet (`related issue <https://github.com/ros2/rcl/issues/463>`_)
- ``deg`` and ``rad`` substitutions are not supported
",How do parameters differ in ROS 1 and ROS 2 according to the text?
"Migrating Scripts
=================

ROS CLI
-------

In ROS 1 there were individual commands for performing various actions, like ``rosrun``, ``rosparam``, etc.

In ROS 2, there is a single top-level commands called ``ros2``, and all of the actions are sub-commands of that, like ``ros2 run``, ``ros2 param``, etc.

ROS CLI arguments
-----------------

In ROS 1, arguments to nodes were provided directly on the command-line.

ROS 2 arguments should be scoped with ``--ros-args`` and a trailing ``--`` (the trailing double dash may be elided if no arguments follow it).

Remapping names is similar to ROS 1, taking on the form ``from:=to``, except that it must be preceded by a ``--remap`` (or ``-r``) flag.
For example:

.. code-block:: bash

   ros2 run some_package some_ros_executable --ros-args -r foo:=bar

We use a similar syntax for parameters, using the ``--param`` (or ``-p``) flag:

.. code-block:: bash

   ros2 run some_package some_ros_executable --ros-args -p my_param:=value

Note, this is different than using a leading underscore in ROS 1.

To change a node name use ``__node`` (the ROS 1 equivalent is ``__name``):

.. code-block:: bash

   ros2 run some_package some_ros_executable --ros-args -r __node:=new_node_name

Note the use of the ``-r`` flag.
The same remap flag is needed for changing the namespace ``__ns``:

.. code-block:: bash

   ros2 run some_package some_ros_executable --ros-args -r __ns:=/new/namespace

There is no equivalent in ROS 2 for the following ROS 1 keys:

- ``__log`` (but ``--log-config-file`` can be used to provide a logger configuration file)
- ``__ip``
- ``__hostname``
- ``__master``

For more information, see the `design document <https://design.ros2.org/articles/ros_command_line_arguments.html>`_.

Quick reference
~~~~~~~~~~~~~~~

+------------+-------------+----------------+
| Feature    | ROS 1       | ROS 2          |
+============+=============+================+
| remapping  | foo:=bar    | -r foo:=bar    |
+------------+-------------+----------------+
| parameters | _foo:=bar   | -p foo:=bar    |
+------------+-------------+----------------+
| node name  | __name:=foo | -r __node:=foo |
+------------+-------------+----------------+
| namespace  | __ns:=foo   | -r __ns:=foo   |
+------------+-------------+----------------+
",What are the differences in specifying arguments for nodes between ROS 1 and ROS 2 CLI?
"Migrating a Python Package Example
==================================

This guide shows how to migrate an example Python package from ROS 1 to ROS 2.

.. contents:: Table of Contents
   :depth: 2
   :local:

Prerequisites
-------------

You need a working ROS 2 installation, such as :doc:`ROS {DISTRO} <../../Installation>`.

The ROS 1 code
--------------

You won't be using `catkin <https://index.ros.org/p/catkin/>`__ in this guide, so you don't need a working ROS 1 installation.
You are going to use ROS 2's build tool `Colcon <https://colcon.readthedocs.io/>`__ instead.

This section gives you the code for a ROS 1 Python package.
The package is called ``talker_py``, and it has one node called ``talker_py_node``.
To make it easier to run Colcon later, these instructions make you create the package inside a `Colcon workspace <https://colcon.readthedocs.io/en/released/user/what-is-a-workspace.html>`__,

First, create a folder at ``~/ros2_talker_py`` to be the root of the Colcon workspace.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

        mkdir -p ~/ros2_talker_py/src

  .. group-tab:: macOS

    .. code-block:: bash

        mkdir -p ~/ros2_talker_py/src

  .. group-tab:: Windows

    .. code-block:: bash

        md \ros2_talker_py\src

Next, create the files for the ROS 1 package.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

        cd ~/ros2_talker_py
        mkdir -p src/talker_py/src/talker_py
        mkdir -p src/talker_py/scripts
        touch src/talker_py/package.xml
        touch src/talker_py/CMakeLists.txt
        touch src/talker_py/src/talker_py/__init__.py
        touch src/talker_py/scripts/talker_py_node
        touch src/talker_py/setup.py

  .. group-tab:: macOS

    .. code-block:: bash

        cd ~/ros2_talker_py
        mkdir -p src/talker_py/src/talker_py
        mkdir -p src/talker_py/scripts
        touch src/talker_py/package.xml
        touch src/talker_py/CMakeLists.txt
        touch src/talker_py/src/talker_py/__init__.py
        touch src/talker_py/scripts/talker_py_node
        touch src/talker_py/setup.py

  .. group-tab:: Windows

    .. code-block:: bash

        cd \ros2_talker_py
        md src\talker_py\src\talker_py
        md src\talker_py\scripts
        type nul > src\talker_py\package.xml
        type nul > src\talker_py\CMakeLists.txt
        type nul > src\talker_py\src\talker_py\__init__.py
        type nul > src\talker_py\scripts/talker_py_node
        type nul > src\talker_py\setup.py

Put the following content into each file.

``src/talker_py/package.xml``:

.. code-block:: xml

    <?xml version=""1.0""?>
    <?xml-model href=""http://download.ros.org/schema/package_format2.xsd"" schematypens=""http://www.w3.org/2001/XMLSchema""?>
    <package format=""2"">
        <name>talker_py</name>
        <version>1.0.0</version>
        <description>The talker_py package</description>
        <maintainer email=""gerkey@example.com"">Brian Gerkey</maintainer>
        <license>BSD</license>

        <buildtool_depend>catkin</buildtool_depend>

        <depend>rospy</depend>
        <depend>std_msgs</depend>
    </package>

``src/talker_py/CMakeLists.txt``:

.. code-block:: cmake

    cmake_minimum_required(VERSION 3.0.2)
    project(talker_py)

    find_package(catkin REQUIRED)

    catkin_python_setup()

    catkin_package()

    catkin_install_python(PROGRAMS
        scripts/talker_py_node
        DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
    )

``src/talker/src/talker_py/__init__.py``:

.. code-block:: Python

    import rospy
    from std_msgs.msg import String

    def main():
        rospy.init_node('talker')
        pub = rospy.Publisher('chatter', String, queue_size=10)
        rate = rospy.Rate(10)  # 10hz
        while not rospy.is_shutdown():
            hello_str = ""hello world %s"" % rospy.get_time()
            rospy.loginfo(hello_str)
            pub.publish(hello_str)
            rate.sleep()

``src/talker_py/scripts/talker_py_node``:

.. code-block:: Python

    #!/usr/bin/env python

    import talker_py

    if __name__ == '__main__':
        talker_py.main()

``src/talker_py/setup.py``:

.. code-block:: Python

    from setuptools import setup
    from catkin_pkg.python_setup import generate_distutils_setup

    setup_args = generate_distutils_setup(
        packages=['talker_py'],
        package_dir={'': 'src'}
    )

    setup(**setup_args)

This is the complete ROS 1 Python package.

Migrate the ``package.xml``
---------------------------

When migrating packages to ROS 2, migrate the build system files first so that you can check your work by building and running code as you go.
Always start by migrating your ``package.xml``.

First, ROS 2 does not use ``catkin``.
Delete the ``<buildtool_depend>`` on it.

.. code-block::

    <!-- delete this -->
    <buildtool_depend>catkin</buildtool_depend>


Next, ROS 2 uses ``rclpy`` instead of ``rospy``.
Delete the dependency on ``rospy``.

.. code-block::

    <!-- Delete this -->
    <depend>rospy</depend>


Replace it with a new dependency on ``rclpy``.

.. code-block:: xml

    <depend>rclpy</depend>

Add an ``<export>`` section to tell ROS 2's build tool `Colcon <https://colcon.readthedocs.io/>`__ that this is an ``ament_python`` package instead of a ``catkin`` package.

.. code-block:: xml

     <export>
       <build_type>ament_python</build_type>
     </export>


Your ``package.xml`` is fully migrated.
It should now look like this:

.. code-block:: xml

    <?xml version=""1.0""?>
    <?xml-model href=""http://download.ros.org/schema/package_format2.xsd"" schematypens=""http://www.w3.org/2001/XMLSchema""?>
    <package format=""2"">
        <name>talker_py</name>
        <version>1.0.0</version>
        <description>The talker_py package</description>
        <maintainer email=""gerkey@example.com"">Brian Gerkey</maintainer>
        <license>BSD</license>

        <depend>rclpy</depend>
        <depend>std_msgs</depend>

        <export>
            <build_type>ament_python</build_type>
        </export>
    </package>

Delete the ``CMakeLists.txt``
-----------------------------

Python packages in ROS 2 do not use CMake, so delete the ``CMakeLists.txt``.

Migrate the ``setup.py``
------------------------

The arguments to ``setup()`` in the ``setup.py`` can no longer be automatically generated with ``catkin_pkg``.
You must pass these arguments manually, which means there will be some duplication with your ``package.xml``.

Start by deleting the import from ``catkin_pkg``.

.. code-block::

    # Delete this
    from catkin_pkg.python_setup import generate_distutils_setup

Move all arguments given to ``generate_distutils_setup()`` to the call to ``setup()``, and then add the ``install_requires`` and ``zip_safe`` arguments.
Your call to ``setup()`` should  look like this:

.. code-block:: Python

    setup(
        packages=['talker_py'],
        package_dir={'': 'src'},
        install_requires=['setuptools'],
        zip_safe=True,
    )

Delete the call to ``generate_distutils_setup()``.

.. code-block::

    # Delete this
    setup_args = generate_distutils_setup(
        packages=['talker_py'],
        package_dir={'': 'src'}
    )

The call to ``setup()`` needs some `additional metadata <https://docs.python.org/3.11/distutils/setupscript.html#additional-meta-data>`__ copied from the ``package.xml``:

* package name via the ``name`` argument
* package version via the ``version`` argument
* maintainer via the ``maintainer`` and ``maintainer_email`` arguments
* description via the ``description`` argument
* license via the ``license`` argument

The package name will be used multiple times.
Create a variable called ``package_name`` above the call to ``setup()``.

.. code-block:: Python

    package_name = 'talker_py'

Copy all of the remaining information into the arguments of ``setup()`` in ``setup.py``.
Your call to ``setup()`` should look like this:

.. code-block:: Python

    setup(
        name=package_name,
        version='1.0.0',
        install_requires=['setuptools'],
        zip_safe=True,
        packages=['talker_py'],
        package_dir={'': 'src'},
        maintainer='Brian Gerkey',
        maintainer_email='gerkey@example.com',
        description='The talker_py package',
        license='BSD',
    )


ROS 2 packages must install two data files:

* a ``package.xml``
* a package marker file

Your package already has a ``package.xml``.
It describes your package's dependencies.
A package marker file tells tools like ``ros2 run`` where to find your package.

Create a directory next to the ``package.xml`` called ``resource``.
Create an empty file in the ``resource`` directory with the same name as the package.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

        mkdir resource
        touch resource/talker_py

  .. group-tab:: macOS

    .. code-block:: bash

        mkdir resource
        touch resource/talker_py

  .. group-tab:: Windows

    .. code-block:: bash

        md resource
        type nul > resource\talker_py

The ``setup()`` call in ``setup.py`` must tell ``setuptools`` how to install these files.
Add the following ``data_files`` argument to the call to ``setup()``.

.. code-block:: Python

    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
    ],

Your ``setup.py`` is almost complete.

Migrate Python scripts and create ``setup.cfg``
-----------------------------------------------

ROS 2 Python packages uses ``console_scripts`` `entry points <https://python-packaging.readthedocs.io/en/latest/command-line-scripts.html#the-console-scripts-entry-point>`__ to install Python scripts as executables.
The `configuration file <https://setuptools.pypa.io/en/latest/userguide/declarative_config.html>`__ ``setup.cfg`` tells ``setuptools`` to install those executables in a package specific directory so that tools like ``ros2 run`` can find them.
Create a ``setup.cfg`` file next to the ``package.xml``.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

        touch setup.cfg

  .. group-tab:: macOS

    .. code-block:: bash

        touch setup.cfg

  .. group-tab:: Windows

    .. code-block:: bash

        type nul > touch setup.cfg

Put the following content into it:

.. code-block::

    [develop]
    script_dir=$base/lib/talker_py
    [install]
    install_scripts=$base/lib/talker_py

You'll need to use the ``console_scripts`` entry point to define the executables to be installed.
Each entry has the format ``executable_name = some.module:function``.
The first part specifies the name of the executable to create.
The second part specifies the function that should be run when the executable starts.
This package needs to create an executable called ``talker_py_node``, and the executable needs to call the function ``main`` in the ``talker_py`` module.
Add the following entry point specification as another argument to ``setup()`` in your ``setup.py``.

.. code-block:: Python

    entry_points={
        'console_scripts': [
            'talker_py_node = talker_py:main',
        ],
    },

The ``talker_py_node`` file is no longer necessary.
Delete the file ``talker_py_node`` and delete the ``scripts/`` directory.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

        rm scripts/talker_py_node
        rmdir scripts

  .. group-tab:: macOS

    .. code-block:: bash

        rm scripts/talker_py_node
        rmdir scripts

  .. group-tab:: Windows

    .. code-block:: bash

        del scripts/talker_py_node
        rd scripts

The addition of ``console_scripts`` is the last change to your ``setup.py``.
Your final ``setup.py`` should look like this:

.. code-block:: Python

    from setuptools import setup

    package_name = 'talker_py'

    setup(
        name=package_name,
        version='1.0.0',
        packages=['talker_py'],
        package_dir={'': 'src'},
        install_requires=['setuptools'],
        zip_safe=True,
        data_files=[
            ('share/ament_index/resource_index/packages',
                ['resource/' + package_name]),
            ('share/' + package_name, ['package.xml']),
        ],
        maintainer='Brian Gerkey',
        maintainer_email='gerkey@example.com',
        description='The talker_py package',
        license='BSD',
        entry_points={
            'console_scripts': [
                'talker_py_node = talker_py:main',
            ],
        },
    )

Migrate Python code in ``src/talker_py/__init__.py``
----------------------------------------------------

ROS 2 changed a lot of the best practices for Python code.
Start by migrating the code as-is.
It will be easier to refactor code later after you have something working.

Use ``rclpy`` instead of ``rospy``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ROS 2 packages use `rclpy <https://index.ros.org/p/rclpy>`__ instead of ``rospy``.
You must do two things to use ``rclpy``:

    1. Import ``rclpy``
    2. Initialize ``rclpy``

Remove the statement that imports ``rospy``.

.. code-block:: Python

    # Remove this
    import rospy

Rplace it with a statement that imports ``rclpy``.

.. code-block:: Python

    import rclpy

Add a call to ``rclpy.init()`` as the very first statement in the ``main()`` function.

.. code-block:: Python

    def main():
        # Add this line
        rclpy.init()

Execute callbacks in the background
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Both ROS 1 and ROS 2 use `callbacks <https://en.wikipedia.org/wiki/Callback_(computer_programming)>`__.
In ROS 1, callbacks are always executed in background threads, and users are free to block the main thread with calls like ``rate.sleep()``.
In ROS 2, ``rclpy`` uses :doc:`Executors <../../Concepts/Intermediate/About-Executors>` to give users more control over where callbacks are called.
When porting code that uses blocking calls like ``rate.sleep()``, you must make sure that those calls won't interfere with the executor.
One way to do this is to create a dedicated thread for the executor.

First, add these two import statements.

.. code-block:: Python

    import threading

    from rclpy.executors import ExternalShutdownException

Next, add top-level function called ``spin_in_background()``.
This function asks the default executor to execute callbacks until something shuts it down.

.. code-block:: Python

    def spin_in_background():
        executor = rclpy.get_global_executor()
        try:
            executor.spin()
        except ExternalShutdownException:
            pass

Add the following code in the ``main()`` function just after the call to ``rclpy.init()`` to start a thread that calls ``spin_in_background()``.

.. code-block:: Python

        # In rospy callbacks are always called in background threads.
        # Spin the executor in another thread for similar behavior in ROS 2.
        t = threading.Thread(target=spin_in_background)
        t.start()


Finally, join the thread when the program ends by putting this statement at the bottom of the ``main()`` function.

.. code-block:: Python

        t.join()


Create a node
~~~~~~~~~~~~~

In ROS 1, Python scripts can only create a single node per process, and the API ``init_node()`` creates it.
In ROS 2, a single Python script may create multiple nodes, and the API to create a node is named ``create_node``.

Remove the call to ``rospy.init_node()``:

.. code-block::

    rospy.init_node('talker')

Add a new call to ``rclpy.create_node()`` and store the result in a variable named ``node``:

.. code-block:: Python

    node = rclpy.create_node('talker')

We must tell the executor about this node.
Add the following line just below the creation of the node:

.. code-block:: Python

    rclpy.get_global_executor().add_node(node)

Create a publisher
~~~~~~~~~~~~~~~~~~

In ROS 1, users create publishers by instantiating the ``Publisher`` class.
In ROS 2, users create publishers through a node's ``create_publisher()`` API.
The ``create_publisher()`` API has an unfortunate difference with ROS 1: the topic name and topic type arguments are swapped.

Remove the creation of the ``rospy.Publisher`` instance.

.. code-block::

    pub = rospy.Publisher('chatter', String, queue_size=10)

Replace it with a call to ``node.create_publisher()``.

.. code-block:: Python

    pub = node.create_publisher(String, 'chatter', 10)


Create a rate
~~~~~~~~~~~~~

In ROS 1, users create ``Rate`` instances directly, while in ROS 2 users create them through a node's ``create_rate()`` API.

Remove the creation of the ``rospy.Rate`` instance.

.. code-block::

    rate = rospy.Rate(10)  # 10hz

Replace it with a call to ``node.create_rate()``.

.. code-block:: Python

    rate = node.create_rate(10)  # 10hz

Loop on ``rclpy.ok()``
~~~~~~~~~~~~~~~~~~~~~~

In ROS 1, the ``rospy.is_shutdown()`` API indicates if the process has been asked to shutdown.
In ROS 2, the ``rclpy.ok()`` API does this.

Remove the statement ``not rospy.is_shutdown()``

.. code-block::

    while not rospy.is_shutdown():

Replace it with a call to ``rclpy.ok()``.

.. code-block:: Python

    while rclpy.ok():


Create a ``String`` message with the current time
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You must make a few changes to this line

.. code-block::

    hello_str = ""hello world %s"" % rospy.get_time()

In ROS 2 you:

* Must get the time from a ``Clock`` instance
* Should format the ``str`` data using `f-strings <https://docs.python.org/3/reference/lexical_analysis.html#f-strings>`__ since  `% is discouraged in active Python versions <https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting>`__
* Must instantiate a ``std_msgs.msg.String`` instance

Start with getting the time.
ROS 2 nodes have a ``Clock`` instance.
Replace the call to ``rospy.get_time()`` with ``node.get_clock().now()`` to get the current time from the node's clock.

Next, replace the use of ``%`` with an f-string: ``f'hello world {node.get_clock().now()}'``.

Finally, instantiate a ``std_msgs.msg.String()`` instance and assign the above to the ``data`` attribute of that instance.
Your final code should look like this:

.. code-block:: Python

    hello_str = String()
    hello_str.data = f'hello world {node.get_clock().now()}'

Log an informational message
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In ROS 2, you must send log messages through a ``Logger`` instance, and the node has one.

Remove the call to ``rospy.loginfo()``.

.. code-block::

    rospy.loginfo(hello_str)

Replace it with a call to ``info()`` on the node's ``Logger`` instance.

.. code-block:: Python

    node.get_logger().info(hello_str.data)

This is the last change to ``src/talker_py/__init__.py``.
Your file should look like the following:

.. code-block:: Python

    import threading

    import rclpy
    from rclpy.executors import ExternalShutdownException
    from std_msgs.msg import String


    def spin_in_background():
        executor = rclpy.get_global_executor()
        try:
            executor.spin()
        except ExternalShutdownException:
            pass


    def main():
        rclpy.init()
        # In rospy callbacks are always called in background threads.
        # Spin the executor in another thread for similar behavior in ROS 2.
        t = threading.Thread(target=spin_in_background)
        t.start()

        node = rclpy.create_node('talker')
        rclpy.get_global_executor().add_node(node)
        pub = node.create_publisher(String, 'chatter', 10)
        rate = node.create_rate(10)  # 10hz

        while rclpy.ok():
            hello_str = String()
            hello_str.data = f'hello world {node.get_clock().now()}'
            node.get_logger().info(hello_str.data)
            pub.publish(hello_str)
            rate.sleep()

        t.join()


Build and run ``talker_py_node``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Create three terminals:

1. One to build ``talker_py``
2. One to run ``talker_py_node``
3. One to echo the message published by ``talker_py_node``

Build the workspace in the first terminal.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

        cd ~/ros2_talker_py
        . /opt/ros/{DISTRO}/setup.bash
        colcon build

  .. group-tab:: macOS

    .. code-block:: bash

        cd ~/ros2_talker_py
        . /opt/ros/{DISTRO}/setup.bash
        colcon build

  .. group-tab:: Windows

    .. code-block:: bash

        cd \ros2_talker_py
        call C:\dev\ros2\local_setup.bat
        colcon build

Source your workspace in the second terminal, and run the ``talker_py_node``.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

        cd ~/ros2_talker_py
        . install/setup.bash
        ros2 run talker_py talker_py_node

  .. group-tab:: macOS

    .. code-block:: bash

        cd ~/ros2_talker_py
        . install/setup.bash
        ros2 run talker_py talker_py_node

  .. group-tab:: Windows

    .. code-block:: bash

        cd \ros2_talker_py
        call install\setup.bat
        ros2 run talker_py talker_py_node

Echo the message published by the node in the third terminal:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

        . /opt/ros/{DISTRO}/setup.bash
        ros2 topic echo /chatter

  .. group-tab:: macOS

    .. code-block:: bash

        . /opt/ros/{DISTRO}/setup.bash
        ros2 topic echo /chatter

  .. group-tab:: Windows

    .. code-block:: bash

        call C:\dev\ros2\local_setup.bat
        ros2 topic echo /chatter


You should see messages with the current time being published in the second terminal, and those same messages received in the third.

Refactor code to use ROS 2 convensions
--------------------------------------

You have successfully migrated a ROS 1 Python package to ROS 2!
Now that you have something working, consider refactoring it to align better with ROS 2's Python APIs.
Follow these two principles.

* Create a class that inherits from ``Node``.
* Do all work in callbacks, and never block those callbacks.

For example, create a ``Talker`` class that inherits from ``Node``.
As for doing work in callbacks, use a ``Timer`` with a callback instead of ``rate.sleep()``.
Make the timer callback publish the message and return.
Make ``main()`` create a ``Talker`` instance rather than using ``rclpy.create_node()``, and give the executor the main thread to execute in.

Your refactored code might look like this:

.. code-block:: Python

    import rclpy
    from rclpy.node import Node
    from rclpy.executors import ExternalShutdownException
    from std_msgs.msg import String


    class Talker(Node):

        def __init__(self, **kwargs):
            super().__init__('talker', **kwargs)

            self._pub = self.create_publisher(String, 'chatter', 10)
            self._timer = self.create_timer(1 / 10, self.do_publish)

        def do_publish(self):
            hello_str = String()
            hello_str.data = f'hello world {self.get_clock().now()}'
            self.get_logger().info(hello_str.data)
            self._pub.publish(hello_str)


    def main():
        try:
            with rclpy.init():
                rclpy.spin(Talker())
        except (ExternalShutdownException, KeyboardInterrupt):
            pass

Conclusion
----------

You have learned how to migrate an example Python ROS 1 package to ROS 2.
From now on, refer to the :doc:`Migrating Python Packages reference page <./Migrating-Python-Packages>` as you migrate your own Python packages.
",What are the key changes required to migrate a Python ROS 1 package to ROS 2 based on the provided text?
"Migrating Packages
==================

.. contents:: Table of Contents
   :depth: 2
   :local:

There are two different kinds of package migrations:

* Migrating the source code of an existing package from ROS 1 to ROS 2 with the intent that a significant part of the source code will stay the same or at least similar.
  An example for this is `pluginlib <https://github.com/ros/pluginlib>`_ where the source code is maintained in different branches within the same repository and common patches can be ported between those branches when necessary.
* Implementing the same or similar functionality of a ROS 1 package for ROS 2 but with the assumption that the source code will be significantly different.
  An example for this is `roscpp <https://github.com/ros/ros_comm/tree/melodic-devel/clients/roscpp>`_ in ROS 1 and `rclcpp <https://github.com/ros2/rclcpp/tree/rolling/rclcpp>`_ in ROS 2 which are separate repositories and don't share any code.

Prerequisites
-------------

Before being able to migrate a ROS 1 package to ROS 2 all of its dependencies must be available in ROS 2.

Package.xml format version
--------------------------

ROS 2 only supports ``package.xml`` format versions 2 and higher.
If your package's ``package.xml`` uses format 1, then update it using the :doc:`Package.xml format 1 to 2 migration guide <./Migrating-Package-XML>`.

Dependency names
----------------

Dependency names that come from :doc:`rosdep <../../Tutorials/Intermediate/Rosdep>` should not need to change, as those are shared across ROS 1 and ROS 2.

Some packages released into ROS might have different names in ROS 2 so the dependencies might need to be updated accordingly.

Metapackages
------------

ROS 2 doesn't have a special package type for metapackages.
Metapackages can still exist as regular packages that only contain runtime dependencies.
When migrating metapackages from ROS 1, simply remove the ``<metapackage />`` tag in your package manifest.
See :doc:`Using variants <../Using-Variants>` for more information on metapackages/variants.

Licensing
---------

In ROS 1 our recommended license was the `3-Clause BSD License <https://opensource.org/licenses/BSD-3-Clause>`__.
In ROS 2 our recommended license is the `Apache 2.0 License <https://www.apache.org/licenses/LICENSE-2.0>`__.

For any new project we recommend using the Apache 2.0 License, whether ROS 1 or ROS 2.

However, when migrating code from ROS 1 to ROS 2 we cannot simply change the license.
The existing license must be preserved for any preexisting contributions.

To that end if a package is being migrated we recommend keeping the existing license and continuing to contribute to that package under the existing OSI license, which we expect to be the BSD license for core elements.

This will keep things clear and easy to understand.

Changing the License
^^^^^^^^^^^^^^^^^^^^

It is possible to change the license, however you will need to contact all the contributors and get permission.
For most packages this is likely to be a significant effort and not worth considering.
If the package has a small set of contributors then this may be feasible.
",What are the two different kinds of package migrations discussed in the text document?
"Migrating Interfaces
====================

.. contents:: Table of Contents
   :depth: 2
   :local:

Messages, services, and actions are collectively called ``interfaces`` in ROS 2.

Interface definitions
---------------------

Message files must end in ``.msg`` and must be located in the subfolder ``msg``.
Service files must end in ``.srv`` and must be located in the subfolder ``srv``.
Actions files must end in ``.action`` and must be located in the subfolder ``action``.

These files might need to be updated to comply with the `ROS Interface definition <http://design.ros2.org/articles/legacy_interface_definition.html>`__.
Some primitive types have been removed and the types ``duration`` and ``time`` which were builtin types in ROS 1 have been replaced with normal message definitions and must be used from the `builtin_interfaces <https://github.com/ros2/rcl_interfaces/tree/{REPOS_FILE_BRANCH}/builtin_interfaces>`__ package.
Also some naming conventions are stricter than in ROS 1.
There is additional information in the :doc:`conceptual article <../../Concepts/Basic/About-Interfaces>`.

Building interfaces
-------------------

The way in which interfaces are built in ROS 2 differs substantially from ROS 1.
Interfaces can only be built from packages containing a ``CMakeLists.txt``.
If you are developing a pure Python package, then the interfaces should be placed in a different package containing only the interfaces (which is best practice anyway).
See the :doc:`custom interfaces tutorial<../../Tutorials/Beginner-Client-Libraries/Custom-ROS2-Interfaces>` for more information.

Migrating interface package to ROS 2
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In your ``package.xml``:

* Add ``<buildtool_depend>rosidl_default_generators</buildtool_depend>``.
* Add ``<exec_depend>rosidl_default_runtime</exec_depend>``.
* Add ``<member_of_group>rosidl_interface_packages</member_of_group>``
* For each dependent message package, add ``<depend>message_package</depend>``.

In your ``CMakeLists.txt``:

* Enable C++17

.. code-block:: cmake

   set(CMAKE_CXX_STANDARD 17)

* Add ``find_package(rosidl_default_generators REQUIRED)``
* For each dependent message package, add ``find_package(message_package REQUIRED)`` and replace the CMake function call to ``generate_messages`` with ``rosidl_generate_interfaces``.

This will replace ``add_message_files`` and ``add_service_files`` listing of all the message and service files, which can be removed.

","What are the file extensions and subfolder locations for message, service, and action files in ROS 2?"
"Migrating a C++ Package Example
===============================

.. contents:: Table of Contents
   :depth: 2
   :local:

This example shows how to migrate an example C++ package from ROS 1 to ROS 2.

Prerequisites
-------------

You need a working ROS 2 installation, such as :doc:`ROS {DISTRO} <../../Installation>`.

The ROS 1 code
--------------

Say you have a ROS 1 package called ``talker`` that uses ``roscpp`` in one node, called ``talker``.
This package is in a catkin workspace, located at ``~/ros1_talker``.

Your ROS 1 workspace has the following directory layout:

.. code-block:: bash

   $ cd ~/ros1_talker
   $ find .
   .
   ./src
   ./src/talker
   ./src/talker/package.xml
   ./src/talker/CMakeLists.txt
   ./src/talker/talker.cpp

The files have the following content:

``src/talker/package.xml``:

.. code-block:: xml

   <?xml version=""1.0""?>
   <?xml-model href=""http://download.ros.org/schema/package_format2.xsd"" schematypens=""http://www.w3.org/2001/XMLSchema""?>
   <package format=""2"">
     <name>talker</name>
     <version>0.0.0</version>
     <description>talker</description>
     <maintainer email=""gerkey@example.com"">Brian Gerkey</maintainer>
     <license>Apache-2.0</license>
     <buildtool_depend>catkin</buildtool_depend>
     <depend>roscpp</depend>
     <depend>std_msgs</depend>
   </package>

``src/talker/CMakeLists.txt``:

.. code-block:: cmake

   cmake_minimum_required(VERSION 2.8.3)
   project(talker)
   find_package(catkin REQUIRED COMPONENTS roscpp std_msgs)
   catkin_package()
   include_directories(${catkin_INCLUDE_DIRS})
   add_executable(talker talker.cpp)
   target_link_libraries(talker ${catkin_LIBRARIES})
   install(TARGETS talker
     RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})

``src/talker/talker.cpp``:

.. code-block:: cpp

   #include <sstream>
   #include ""ros/ros.h""
   #include ""std_msgs/String.h""
   int main(int argc, char **argv)
   {
     ros::init(argc, argv, ""talker"");
     ros::NodeHandle n;
     ros::Publisher chatter_pub = n.advertise<std_msgs::String>(""chatter"", 1000);
     ros::Rate loop_rate(10);
     int count = 0;
     std_msgs::String msg;
     while (ros::ok())
     {
       std::stringstream ss;
       ss << ""hello world "" << count++;
       msg.data = ss.str();
       ROS_INFO(""%s"", msg.data.c_str());
       chatter_pub.publish(msg);
       ros::spinOnce();
       loop_rate.sleep();
     }
     return 0;
   }

Migrating to ROS 2
------------------

Let's start by creating a new workspace in which to work:

.. code-block:: bash

   mkdir ~/ros2_talker
   cd ~/ros2_talker

We'll copy the source tree from our ROS 1 package into that workspace, where we can modify it:

.. code-block:: bash

   mkdir src
   cp -a ~/ros1_talker/src/talker src

Now we'll modify the C++ code in the node.
The ROS 2 C++ library, called ``rclcpp``, provides a different API from that
provided by ``roscpp``.
The concepts are very similar between the two libraries, which makes the changes
reasonably straightforward to make.

Included headers
~~~~~~~~~~~~~~~~

In place of ``ros/ros.h``, which gave us access to the ``roscpp`` library API, we
need to include ``rclcpp/rclcpp.hpp``, which gives us access to the ``rclcpp``
library API:

.. code-block:: cpp

   //#include ""ros/ros.h""
   #include ""rclcpp/rclcpp.hpp""

To get the ``std_msgs/String`` message definition, in place of
``std_msgs/String.h``, we need to include ``std_msgs/msg/string.hpp``:

.. code-block:: cpp

   //#include ""std_msgs/String.h""
   #include ""std_msgs/msg/string.hpp""

Changing C++ library calls
~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of passing the node's name to the library initialization call, we do
the initialization, then pass the node name to the creation of the node object:

.. code-block:: cpp

   //  ros::init(argc, argv, ""talker"");
   //  ros::NodeHandle n;
       rclcpp::init(argc, argv);
       auto node = rclcpp::Node::make_shared(""talker"");

The creation of the publisher and rate objects looks pretty similar, with some
changes to the names of namespace and methods.

.. code-block:: cpp

   //  ros::Publisher chatter_pub = n.advertise<std_msgs::String>(""chatter"", 1000);
   //  ros::Rate loop_rate(10);
     auto chatter_pub = node->create_publisher<std_msgs::msg::String>(""chatter"",
       1000);
     rclcpp::Rate loop_rate(10);

To further control how message delivery is handled, a quality of service
(``QoS``) profile could be passed in.
The default profile is ``rmw_qos_profile_default``.
For more details, see the
`design document <https://design.ros2.org/articles/qos.html>`__
and :doc:`concept overview <../../Concepts/Intermediate/About-Quality-of-Service-Settings>`.

The creation of the outgoing message is different in the namespace:

.. code-block:: cpp

   //  std_msgs::String msg;
     std_msgs::msg::String msg;

In place of ``ros::ok()``, we call ``rclcpp::ok()``:

.. code-block:: cpp

   //  while (ros::ok())
     while (rclcpp::ok())

Inside the publishing loop, we access the ``data`` field as before:

.. code-block:: cpp

       msg.data = ss.str();

To print a console message, instead of using ``ROS_INFO()``, we use
``RCLCPP_INFO()`` and its various cousins.
The key difference is that ``RCLCPP_INFO()`` takes a Logger object as the first
argument.

.. code-block:: cpp

   //    ROS_INFO(""%s"", msg.data.c_str());
       RCLCPP_INFO(node->get_logger(), ""%s\n"", msg.data.c_str());

Change the publish call to use the ``->`` operator instead of ``.``.

.. code-block:: cpp

   //    chatter_pub.publish(msg);
       chatter_pub->publish(msg);

Spinning (i.e., letting the communications system process any pending
incoming/outgoing messages) is different in that the call now takes the node as
an argument:

.. code-block:: cpp

   //    ros::spinOnce();
       rclcpp::spin_some(node);

Sleeping using the rate object is unchanged.

Putting it all together, the new ``talker.cpp`` looks like this:

.. code-block:: cpp

   #include <sstream>
   // #include ""ros/ros.h""
   #include ""rclcpp/rclcpp.hpp""
   // #include ""std_msgs/String.h""
   #include ""std_msgs/msg/string.hpp""
   int main(int argc, char **argv)
   {
   //  ros::init(argc, argv, ""talker"");
   //  ros::NodeHandle n;
     rclcpp::init(argc, argv);
     auto node = rclcpp::Node::make_shared(""talker"");
   //  ros::Publisher chatter_pub = n.advertise<std_msgs::String>(""chatter"", 1000);
   //  ros::Rate loop_rate(10);
     auto chatter_pub = node->create_publisher<std_msgs::msg::String>(""chatter"", 1000);
     rclcpp::Rate loop_rate(10);
     int count = 0;
   //  std_msgs::String msg;
     std_msgs::msg::String msg;
   //  while (ros::ok())
     while (rclcpp::ok())
     {
       std::stringstream ss;
       ss << ""hello world "" << count++;
       msg.data = ss.str();
   //    ROS_INFO(""%s"", msg.data.c_str());
       RCLCPP_INFO(node->get_logger(), ""%s\n"", msg.data.c_str());
   //    chatter_pub.publish(msg);
       chatter_pub->publish(msg);
   //    ros::spinOnce();
       rclcpp::spin_some(node);
       loop_rate.sleep();
     }
     return 0;
   }

Change the ``package.xml``
~~~~~~~~~~~~~~~~~~~~~~~~~~

ROS 2 packages use CMake functions and macros from ``ament_cmake_ros`` instead of ``catkin``.
Delete the dependency on ``catkin``:

.. code-block::

   <!-- delete this -->
   <buildtool_depend>catkin</buildtool_depend>`

Add a new dependency on ``ament_cmake_ros``:

.. code-block:: xml

     <buildtool_depend>ament_cmake_ros</buildtool_depend>

ROS 2 C++ libraries use `rclcpp <https://index.ros.org/p/roscpp/#noetic>`__ instead of `roscpp <https://index.ros.org/p/roscpp/#noetic>`__.

Delete the dependency on ``roscpp``:

.. code-block::

   <!-- delete this -->
   <depend>roscpp</depend>

Add a dependency on ``rclcpp``:

.. code-block:: xml

     <depend>rclcpp</depend>


Add an ``<export>`` section to tell colcon the package is an ``ament_cmake`` package instead of a ``catkin`` package.

.. code-block:: xml

     <export>
       <build_type>ament_cmake</build_type>
     </export>

Your ``package.xml`` now looks like this:

.. code-block:: xml

   <?xml version=""1.0""?>
   <?xml-model href=""http://download.ros.org/schema/package_format2.xsd"" schematypens=""http://www.w3.org/2001/XMLSchema""?>
   <package format=""2"">
     <name>talker</name>
     <version>0.0.0</version>
     <description>talker</description>
     <maintainer email=""gerkey@example.com"">Brian Gerkey</maintainer>
     <license>Apache-2.0</license>
     <buildtool_depend>ament_cmake</buildtool_depend>
     <depend>rclcpp</depend>
     <depend>std_msgs</depend>
     <export>
       <build_type>ament_cmake</build_type>
     </export>
   </package>


Changing the CMake code
~~~~~~~~~~~~~~~~~~~~~~~

Require a newer version of CMake so that ``ament_cmake`` functions work correctly.

.. code-block::

   cmake_minimum_required(VERSION 3.14.4)

Use a newer C++ standard matching the version used by your target ROS distro in `REP 2000 <https://www.ros.org/reps/rep-2000.html>`__.
If you are using C++17, then set that version with the following snippet after the ``project(talker)`` call.
Add extra compiler checks too because it is a good practice.

.. code-block:: cmake

   if(NOT CMAKE_CXX_STANDARD)
     set(CMAKE_CXX_STANDARD 17)
   endif()
   if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES ""Clang"")
     add_compile_options(-Wall -Wextra -Wpedantic)
   endif()

Replace the ``find_package(catkin ...)`` call with individual calls for each dependency.

.. code-block:: cmake

   find_package(ament_cmake REQUIRED)
   find_package(rclcpp REQUIRED)
   find_package(std_msgs REQUIRED)

Delete the call to ``catkin_package()``.
Add a call to ``ament_package()`` at the bottom of the ``CMakeLists.txt``.

.. code-block:: cmake

   ament_package()

Make the ``target_link_libraries`` call modern CMake targets provided by ``rclcpp`` and ``std_msgs``.

.. code-block:: cmake

   target_link_libraries(talker PUBLIC
     rclcpp::rclcpp
     ${std_msgs_TARGETS})

Delete the call to ``include_directories()``.
Add a call to ``target_include_directories()`` below ``add_executable(talker talker.cpp)``.
Don't pass variables like ``rclcpp_INCLUDE_DIRS`` into ``target_include_directories()``.
The include directories are already handled by calling ``target_link_libraries()`` with modern CMake targets.

.. code-block:: cmake

   target_include_directories(talker PUBLIC
      ""$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>""
      ""$<INSTALL_INTERFACE:include/${PROJECT_NAME}>"")

Change the call to ``install()`` so that the ``talker`` executable is installed into a project specific directory.

.. code-block:: cmake

   install(TARGETS talker
     DESTINATION lib/${PROJECT_NAME})

The new ``CMakeLists.txt`` looks like this:

.. code-block:: cmake

   cmake_minimum_required(VERSION 3.14.4)
   project(talker)
   if(NOT CMAKE_CXX_STANDARD)
     set(CMAKE_CXX_STANDARD 17)
   endif()
   if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES ""Clang"")
     add_compile_options(-Wall -Wextra -Wpedantic)
   endif()
   find_package(ament_cmake REQUIRED)
   find_package(rclcpp REQUIRED)
   find_package(std_msgs REQUIRED)
   add_executable(talker talker.cpp)
   target_include_directories(talker PUBLIC
      ""$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>""
      ""$<INSTALL_INTERFACE:include/${PROJECT_NAME}>"")
   target_link_libraries(talker PUBLIC
     rclcpp::rclcpp
     ${std_msgs_TARGETS})
   install(TARGETS talker
     DESTINATION lib/${PROJECT_NAME})
   ament_package()

Building the ROS 2 code
~~~~~~~~~~~~~~~~~~~~~~~

We source an environment setup file (in this case the one generated by following
the ROS 2 installation tutorial, which builds in ``~/ros2_ws``, then we build our
package using ``colcon build``:

.. code-block:: bash

   . ~/ros2_ws/install/setup.bash
   cd ~/ros2_talker
   colcon build

Running the ROS 2 node
~~~~~~~~~~~~~~~~~~~~~~

Because we installed the ``talker`` executable into the correct directory, after sourcing the
setup file, from our install tree, we can invoke it by running:

.. code-block:: bash

   . ~/ros2_ws/install/setup.bash
   ros2 run talker talker

Conclusion
----------

You have learned how to migrate an example C++ ROS 1 package to ROS 2.
Use the :doc:`Migrating C++ Packages reference page <./Migrating-CPP-Packages>` to help you migrate your own C++ packages from ROS 1 to ROS 2.
",What are the steps involved in migrating a C++ package from ROS 1 to ROS 2 as outlined in the provided text document?
"Migrating your package.xml to format 2
======================================

.. contents:: Table of Contents
   :depth: 2
   :local:

ROS 2 requires ``package.xml`` files to use at least `format 2 <https://ros.org/reps/rep-0140.html>`__.
This guide shows how to migrate a ``package.xml`` from format 1 to format 2.

If the ``<package>`` tag at the start of your ``package.xml`` looks like either of the following, then it is using format 1 and you must migrate it.

.. code-block:: xml

    <package>

.. code-block:: xml

    <package format=""1"">


Prerequisites
-------------

You should have a working ROS 1 installation.
This enables you to check that the converted ``package.xml`` is valid by building and testing the package, since ROS 1 supports all ``package.xml`` format versions.

Migrate from format 1 to 2
--------------------------

Format 1 and format 2 differ in how they specify dependencies.
Read the `compatibility section in REP-0140 <https://www.ros.org/reps/rep-0140.html#compatibility>`__ for a summary of the differences.

Add ``format`` attribute to ``<package>``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Add or set the ``format`` attribute to ``2`` to indicate that the ``package.xml`` uses format 2.

.. code:: xml

  <package format=""2"">

Replace ``<run_depend>``
~~~~~~~~~~~~~~~~~~~~~~~~

The ``<run_depend>`` tag is no longer allowed.
If you have a dependency specified like this:

.. code:: xml

  <run_depend>foo</run_depend>

then replace it with one or both of these tags:

.. code:: xml

  <build_export_depend>foo</build_export_depend>
  <exec_depend>foo</exec_depend>

If the dependency is needed when something in your package is executed, then use the ``<exec_depend>`` tag.
If packages that depend on your package need the dependency when they are built, then use the ``<build_export_depend>`` tag.
Use both tags if you are unsure.

Convert some ``<build_depend>`` to ``<test_depend>``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In format 1 ``<test_depend>`` declares dependencies that are needed when running your package's tests.
It still does that in format 2, but it additionally declares dependencies that are needed when building your package's tests.

Because of the limitations of this tag in format 1, your package may have a test-only dependency specified as a ``<build_depend>`` like this:

.. code:: xml

  <build_depend>testfoo</build_depend>

If so, change it to a ``<test_depend>``.

.. code:: xml

  <test_depend>testfoo</test_depend>

.. note::

    If you are using CMake, then make sure your test dependencies are only referenced within a ``if(BUILD_TESTING)`` block:

    .. code:: cmake

        if (BUILD_TESTING)
            find_package(testfoo REQUIRED)
        endif()

Begin using ``<doc_depend>``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the new ``<doc_depend>`` tag to declare dependencies needed for building your package's documentation.
For example, C++ packages might have this dependency:

.. code:: xml

  <doc_depend>doxygen</doc_depend>

while Python packages might have this one:

.. code:: xml

  <doc_depend>python3-sphinx</doc_depend>

See :doc:`the guide on documenting ROS 2 packages <../Documenting-a-ROS-2-Package>` for more information.

Simplify dependencies with ``<depend>``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``<depend>`` is a new tag that makes ``package.xml`` files more concise.
If your ``package.xml`` has these three tags for the same dependency:

.. code::

  <build_depend>foo</build_depend>
  <build_export_depend>foo</build_export_depend>
  <exec_depend>foo</exec_depend>

then replace them with a single ``<depend>`` like this:

.. code:: xml

  <depend>foo</depend>

Test your new ``package.xml``
-----------------------------

Build and test your package as you normally do using ``catkin_make``, ``cakin_make_isolated``, or the ``catkin`` build tool.
If everything succeeds, then your ``package.xml`` is valid.
",What are the steps for migrating a package.xml file from format 1 to format 2 in ROS 2?
".. redirect-from::

   Guides/Launch-files-migration-guide
   Tutorials/Launch-files-migration-guide
   How-To-Guides/Launch-files-migration-guide

.. _MigratingLaunch:

Migrating Launch Files
======================

.. contents:: Table of Contents
   :depth: 1
   :local:

While launch files in ROS 1 are always specified using `.xml <https://wiki.ros.org/roslaunch/XML>`__ files, ROS 2 supports Python scripts to enable more flexibility (see `launch package <https://github.com/ros2/launch/tree/{REPOS_FILE_BRANCH}/launch>`__) as well as XML and YAML files.

This guide describes how to write ROS 2 XML launch files for an easy migration from ROS 1.

Background
----------

A description of the ROS 2 launch system and its Python API can be found in :doc:`Launch System tutorial <../../../Tutorials/Intermediate/Launch/Launch-system>`.


Migrating tags
--------------

launch
^^^^^^

* `Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/launch>`__.
* ``launch`` is the root element of any ROS 2 launch XML file.

node
^^^^

* `Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/node>`__.
* Launches a new node.
* Differences from ROS 1:

   * ``type`` attribute is now ``exec``.
   * ``ns`` attribute is now ``namespace``.
   * The following attributes aren't available: ``machine``, ``respawn_delay``, ``clear_params``.

Example
~~~~~~~

.. code-block:: xml

   <launch>
      <node pkg=""demo_nodes_cpp"" exec=""talker""/>
      <node pkg=""demo_nodes_cpp"" exec=""listener""/>
   </launch>

param
^^^^^

* `Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/param>`__.
* Used for passing a parameter to a node.
* There's no global parameter concept in ROS 2.
  For that reason, it can only be used nested in a ``node`` tag.
  Some attributes aren't supported in ROS 2: ``type``, ``textfile``, ``binfile``, ``executable``.
* The ``command`` attribute is now ``value=""$(command '...' )""``.

Example
~~~~~~~

.. code-block:: xml

   <launch>
      <node pkg=""demo_nodes_cpp"" exec=""parameter_event"">
         <param name=""foo"" value=""5""/>
      </node>
   </launch>

Type inference rules
~~~~~~~~~~~~~~~~~~~~

Here are some examples of how to write parameters:

.. code-block:: xml

   <node pkg=""my_package"" exec=""my_executable"" name=""my_node"">
      <!--A string parameter with value ""1""-->
      <param name=""a_string"" value=""'1'""/>
      <!--A integer parameter with value 1-->
      <param name=""an_int"" value=""1""/>
      <!--A float parameter with value 1.0-->
      <param name=""a_float"" value=""1.0""/>
      <!--A string parameter with value ""asd""-->
      <param name=""another_string"" value=""asd""/>
      <!--Another string parameter, with value ""asd""-->
      <param name=""string_with_same_value_as_above"" value=""'asd'""/>
      <!--Another string parameter, with value ""'asd'""-->
      <param name=""quoted_string"" value=""\'asd\'""/>
      <!--A list of strings, with value [""asd"", ""bsd"", ""csd""]-->
      <param name=""list_of_strings"" value=""asd, bsd, csd"" value-sep="", ""/>
      <!--A list of ints, with value [1, 2, 3]-->
      <param name=""list_of_ints"" value=""1,2,3"" value-sep="",""/>
      <!--Another list of strings, with value [""1"", ""2"", ""3""]-->
      <param name=""another_list_of_strings"" value=""'1';'2';'3'"" value-sep="";""/>
      <!--A list of strings using an strange separator, with value [""1"", ""2"", ""3""]-->
      <param name=""strange_separator"" value=""'1'//'2'//'3'"" value-sep=""//""/>
   </node>

Parameter grouping
~~~~~~~~~~~~~~~~~~

In ROS 2, ``param`` tags are allowed to be nested.
For example:

.. code-block:: xml

   <node pkg=""my_package"" exec=""my_executable"" name=""my_node"" ns=""/an_absoulute_ns"">
      <param name=""group1"">
         <param name=""group2"">
            <param name=""my_param"" value=""1""/>
         </param>
         <param name=""another_param"" value=""2""/>
      </param>
   </node>

That will create two parameters:

* A ``group1.group2.my_param`` of value ``1``, hosted by node ``/an_absolute_ns/my_node``.
* A ``group1.another_param`` of value ``2`` hosted by node ``/an_absolute_ns/my_node``.

It's also possible to use full parameter names:

.. code-block:: xml

   <node pkg=""my_package"" exec=""my_executable"" name=""my_node"" ns=""/an_absoulute_ns"">
      <param name=""group1.group2.my_param"" value=""1""/>
      <param name=""group1.another_param"" value=""2""/>
   </node>

rosparam
^^^^^^^^

* `Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/rosparam>`__.
* Loads parameters from a yaml file.
* It has been replaced with a ``from`` attribute in ``param`` tags.

Example
~~~~~~~

.. code-block:: xml

   <node pkg=""my_package"" exec=""my_executable"" name=""my_node"" ns=""/an_absoulute_ns"">
      <param from=""/path/to/file""/>
   </node>

remap
^^^^^

* `Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/remap>`__.
* Used to pass remapping rules to a node.
* It can only be used within ``node`` tags.

Example
~~~~~~~

.. code-block:: xml

   <launch>
      <node pkg=""demo_nodes_cpp"" exec=""talker"">
         <remap from=""chatter"" to=""my_topic""/>
      </node>
      <node pkg=""demo_nodes_cpp"" exec=""listener"">
         <remap from=""chatter"" to=""my_topic""/>
      </node>
   </launch>

include
^^^^^^^

* `Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/include>`__.
* Allows including another launch file.
* Differences from ROS 1:

   * Available in ROS 1, included content was scoped.
     In ROS 2, it's not.
     Nest includes in ``group`` tags to scope them.
   * ``ns`` attribute is not supported.
     See example of ``push_ros_namespace`` tag for a workaround.
   * ``arg`` tags nested in an ``include`` tag don't support conditionals (``if``, ``unless``) or the ``description`` attribute.
   * There is no support for nested ``env`` tags.
     ``set_env`` and ``unset_env`` can be used instead.
   * Both ``clear_params`` and ``pass_all_args`` attributes aren't supported.

Examples
~~~~~~~~

See `Replacing an include tag`_.

arg
^^^

* `Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/arg>`__.
* ``arg`` is used for declaring a launch argument, or to pass an argument when using ``include`` tags.
* Differences from ROS 1:

   * ``value`` attribute is not allowed.
     Use ``let`` tag for this.
   * ``doc`` is now ``description``.
   * When nested within an ``include`` tag, ``if``, ``unless``, and ``description`` attributes aren't allowed.

Example
~~~~~~~

.. code-block:: xml

   <launch>
      <arg name=""topic_name"" default=""chatter""/>
      <node pkg=""demo_nodes_cpp"" exec=""talker"">
         <remap from=""chatter"" to=""$(var topic_name)""/>
      </node>
      <node pkg=""demo_nodes_cpp"" exec=""listener"">
         <remap from=""chatter"" to=""$(var topic_name)""/>
      </node>
   </launch>

Passing an argument to the launch file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the XML launch file above, the ``topic_name`` defaults to the name ``chatter``, but can be configured on the command-line.
Assuming the above launch configuration is in a file named ``mylaunch.xml``, a different topic name can be used by launching it with the following:

.. code-block:: bash

   ros2 launch mylaunch.xml topic_name:=custom_topic_name

There is some additional information about passing command-line arguments in :doc:`Using Substitutions <../../../Tutorials/Intermediate/Launch/Using-Substitutions>`.

env
^^^

* `Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/env>`__.
* Sets an environment variable.
* It has been replaced with ``env``, ``set_env`` and ``unset_env``:

   * ``env`` can only be used nested in a ``node`` or ``executable`` tag.
     ``if`` and ``unless`` tags aren't supported.
   * ``set_env`` can be nested within the root tag ``launch`` or in ``group`` tags.
     It accepts the same attributes as ``env``, and also ``if`` and ``unless`` tags.
   * ``unset_env`` unsets an environment variable.
     It accepts a ``name`` attribute and conditionals.

Example
~~~~~~~

.. code-block:: xml

   <launch>
      <set_env name=""MY_ENV_VAR"" value=""MY_VALUE"" if=""CONDITION_A""/>
      <set_env name=""ANOTHER_ENV_VAR"" value=""ANOTHER_VALUE"" unless=""CONDITION_B""/>
      <set_env name=""SOME_ENV_VAR"" value=""SOME_VALUE""/>
      <node pkg=""MY_PACKAGE"" exec=""MY_EXECUTABLE"" name=""MY_NODE"">
         <env name=""NODE_ENV_VAR"" value=""SOME_VALUE""/>
      </node>
      <unset_env name=""MY_ENV_VAR"" if=""CONDITION_A""/>
      <node pkg=""ANOTHER_PACKAGE"" exec=""ANOTHER_EXECUTABLE"" name=""ANOTHER_NODE""/>
      <unset_env name=""ANOTHER_ENV_VAR"" unless=""CONDITION_B""/>
      <unset_env name=""SOME_ENV_VAR""/>
   </launch>


group
^^^^^

* `Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/group>`__.
* Allows limiting the scope of launch configurations.
  Usually used together with ``let``, ``include`` and ``push_ros_namespace`` tags.
* Differences from ROS 1:

   * There is no ``ns`` attribute.
     See the new ``push_ros_namespace`` tag as a workaround.
   * ``clear_params`` attribute isn't available.
   * It doesn't accept ``remap`` nor ``param`` tags as children.

.. _launch-prefix-example:

Example
~~~~~~~

``launch-prefix`` configuration affects both ``executable`` and ``node`` tags' actions.
This example will use ``time`` as a prefix if ``use_time_prefix_in_talker`` argument is ``1``, only for the talker.

.. code-block:: xml

   <launch>
      <arg name=""use_time_prefix_in_talker"" default=""0""/>
      <group>
         <let name=""launch-prefix"" value=""time"" if=""$(var use_time_prefix_in_talker)""/>
         <node pkg=""demo_nodes_cpp"" exec=""talker""/>
      </group>
      <node pkg=""demo_nodes_cpp"" exec=""listener""/>
   </launch>

machine
^^^^^^^

It is not supported at the moment.

test
^^^^

It is not supported at the moment.

New tags in ROS 2
-----------------

set_env and unset_env
^^^^^^^^^^^^^^^^^^^^^

See `env`_ tag decription.

push_ros_namespace
^^^^^^^^^^^^^^^^^^

``include`` and ``group`` tags don't accept an ``ns`` attribute.
This action can be used as a workaround:

.. code-block:: xml

   <!-Other tags-->
   <group>
      <push_ros_namespace namespace=""my_ns""/>
      <!--Nodes here are namespaced with ""my_ns"".-->
      <!--If there is an include action here, its nodes will also be namespaced.-->
      <push_ros_namespace namespace=""another_ns""/>
      <!--Nodes here are namespaced with ""another_ns/my_ns"".-->
      <push_ros_namespace namespace=""/absolute_ns""/>
      <!--Nodes here are namespaced with ""/absolute_ns"".-->
      <!--The following node receives an absolute namespace, so it will ignore the others previously pushed.-->
      <!--The full path of the node will be /asd/my_node.-->
      <node pkg=""my_pkg"" exec=""my_executable"" name=""my_node"" ns=""/asd""/>
   </group>
   <!--Nodes outside the group action won't be namespaced.-->
   <!-Other tags-->

let
^^^

It's a replacement of ``arg`` tag with a value attribute.

.. code-block:: xml

   <let name=""foo"" value=""asd""/>

executable
^^^^^^^^^^

It allows running any executable.

Example
~~~~~~~

.. code-block:: xml

   <executable cmd=""ls -las"" cwd=""/var/log"" name=""my_exec"" launch-prefix=""something"" output=""screen"" shell=""true"">
      <env name=""LD_LIBRARY"" value=""/lib/some.so""/>
   </executable>

Replacing an include tag
------------------------

In order to include a launch file under a **namespace** as in ROS 1 then the ``include`` tags must be nested in a ``group`` tag.

.. code-block:: xml

   <group>
      <include file=""another_launch_file""/>
   </group>

Then, instead of using the ``ns`` attribute, add the ``push_ros_namespace`` action tag to specify the namespace:

.. code-block:: xml

   <group>
      <push_ros_namespace namespace=""my_ns""/>
      <include file=""another_launch_file""/>
   </group>

Nesting ``include`` tags under a ``group`` tag is only required when specifying a namespace

Substitutions
-------------

Documentation about ROS 1's substitutions can be found in `roslaunch XML wiki <https://wiki.ros.org/roslaunch/XML>`__.
Substitutions syntax hasn't changed, i.e. it still follows the ``$(substitution-name arg1 arg2 ...)`` pattern.
There are, however, some changes w.r.t. ROS 1:

* ``env`` and ``optenv`` tags have been replaced by the ``env`` tag.
  ``$(env <NAME>)`` will fail if the environment variable doesn't exist.
  ``$(env <NAME> '')`` does the same as ROS 1's ``$(optenv <NAME>)``.
  ``$(env <NAME> <DEFAULT>)`` does the same as ROS 1's ``$(env <NAME> <DEFAULT>)`` or ``$(optenv <NAME> <DEFAULT>)``.
* ``find`` has been replaced with ``find-pkg-share`` (substituting the share directory of an installed package).
  Alternatively ``find-pkg-prefix`` will return the root of an installed package.
* There is a new ``exec-in-pkg`` substitution.
  e.g.: ``$(exec-in-pkg <package_name> <exec_name>)``.
* There is a new ``find-exec`` substitution.
* ``arg`` has been replaced with ``var``.
  It looks at configurations defined either with ``arg`` or ``let`` tag.
* ``eval`` and ``dirname`` substitutions require escape characters for string values, e.g. ``if=""$(eval '\'$(var variable)\' == \'val1\'')""``.
* ``anon`` substitution is not supported.

Type inference rules
--------------------

The rules that were shown in ``Type inference rules`` subsection of ``param`` tag applies to any attribute.
For example:

.. code-block:: xml

   <!--Setting a string value to an attribute expecting an int will raise an error.-->
   <tag1 attr-expecting-an-int=""'1'""/>
   <!--Correct version.-->
   <tag1 attr-expecting-an-int=""1""/>
   <!--Setting an integer in an attribute expecting a string will raise an error.-->
   <tag2 attr-expecting-a-str=""1""/>
   <!--Correct version.-->
   <tag2 attr-expecting-a-str=""'1'""/>
   <!--Setting a list of strings in an attribute expecting a string will raise an error.-->
   <tag3 attr-expecting-a-str=""asd, bsd"" str-attr-sep="", ""/>
   <!--Correct version.-->
   <tag3 attr-expecting-a-str=""don't use a separator""/>

Some attributes accept more than a single type, for example ``value`` attribute of ``param`` tag.
It's usual that parameters that are of type ``int`` (or ``float``) also accept an ``str``, that will be later substituted and tried to convert to an ``int`` (or ``float``) by the action.
",What are the differences between writing launch files in ROS 1 using XML and writing launch files in ROS 2 using XML and Python scripts?
".. redirect-from::

   Migration-Guide
   Contributing/Migration-Guide
   The-ROS2-Project/Contributing/Migration-Guide

Migrating C++ Packages Reference
================================

.. contents:: Table of Contents
   :depth: 2
   :local:

This page shows how to migrate parts of a C++ package from ROS 1 to ROS 2.
If this is your first time migrating a C++ package, then read the :doc:`C++ migration example <Migrating-CPP-Package-Example>` first.
Afterwards, use this page as a reference while you migrate your own packages.

Build tool
----------

Instead of using ``catkin_make``, ``catkin_make_isolated`` or ``catkin build`` ROS 2 uses the command line tool `colcon <https://design.ros2.org/articles/build_tool.html>`__ to build and install a set of packages.
See the :doc:`beginner tutorial <../../Tutorials/Beginner-Client-Libraries/Colcon-Tutorial>` to get started with ``colcon``.

Update your ``CMakeLists.txt`` to use *ament_cmake*
---------------------------------------------------

ROS 2 C++ packages use `CMake <https://cmake.org/>`__ with convenience functions provided by `ament_cmake <https://index.ros.org/p/ament_cmake/>`__.
Apply the following changes to use ``ament_cmake`` instead of ``catkin``.


Require a newer version of CMake
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ROS 2 relies on newer versions of CMake than used by ROS 1.
Find the minimum version of CMake used by the ROS distribution you want to support in `REP 2000 <https://www.ros.org/reps/rep-2000.html>`__, and use that version at the top of your ``CMakeLists.txt``.
For example, `3.14.4 is the minimum recommended support for ROS Humble <https://www.ros.org/reps/rep-2000.html#humble-hawksbill-may-2022-may-2027>`__.

.. code-block::

   cmake_minimum_required(VERSION 3.14.4)

Set the build type to ament_cmake
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Remove any dependencies on ``catkin`` from your ``package.xml``

.. code-block::

   # Remove this!
   <buildtool_depend>catkin</buildtool_depend>

Add a new dependency on ``ament_cmake_ros`` (`example <https://github.com/ros2/geometry2/blob/d85102217f692746abea8546c8e41f0abc95c8b8/tf2/package.xml#L25>`__):

.. code-block:: xml

   <buildtool_depend>ament_cmake_ros</buildtool_depend>

Add an ``<export>`` section to your ``package.xml`` if it does not have one already.
Set the ``<build_type>`` to ``ament_cmake`` (`example <https://github.com/ros2/geometry2/blob/d85102217f692746abea8546c8e41f0abc95c8b8/tf2/package.xml#L43-L45>`__)

.. code-block:: xml

   <export>
      <build_type>ament_cmake</build_type>
   </export>

Add a call to ``ament_package()``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Insert a call to ``ament_package()`` at the bottom of your ``CMakeLists.txt`` (`example <https://github.com/ros2/geometry2/blob/d85102217f692746abea8546c8e41f0abc95c8b8/tf2/CMakeLists.txt#L127>`__)

.. code-block:: cmake

   # Add this to the bottom of your CMakeLists.txt
   ament_package()

Update ``find_package()`` calls
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Replace the ``find_package(catkin COMPONENTS ...)``  call with individual ``find_package()`` calls (`example <https://github.com/ros2/geometry2/blob/d85102217f692746abea8546c8e41f0abc95c8b8/tf2/CMakeLists.txt#L14-L18>`_):

For example, change this:

.. code-block::

   find_package(catkin REQUIRED COMPONENTS foo bar std_msgs)
   find_package(baz REQUIRED)

To this:

.. code-block:: cmake

   find_package(ament_cmake_ros REQUIRED)
   find_package(foo REQUIRED)
   find_package(bar REQUIRED)
   find_package(std_msgs REQUIRED)
   find_package(baz REQUIRED)


Use modern CMake targets
^^^^^^^^^^^^^^^^^^^^^^^^

Prefer to use per-target CMake functions so that your package can export modern CMake targets.

If your ``CMakeLists.txt`` uses ``include_directories()``, then delete those calls.

.. code-block::

   # Delete calls to include_directories like this one!
   include_directories(include ${catkin_INCLUDE_DIRS})

Add a call ``target_include_directories()`` for every library in your pacakage (`example <https://github.com/ros2/geometry2/blob/d85102217f692746abea8546c8e41f0abc95c8b8/tf2/CMakeLists.txt#L24-L26>`__).

.. code-block:: cmake

   target_include_directories(my_library PUBLIC
      ""$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>""
      ""$<INSTALL_INTERFACE:include/${PROJECT_NAME}>"")

Change all ``target_link_libraries()`` calls to use modern CMake targets.
For example, if your package in ROS 1 uses old-style standard CMake variables like this.

.. code-block::

   target_link_libraries(my_library ${catkin_LIBRARIES} ${baz_LIBRARIES})

Then change it to use specific modern CMake targets instead.
Use ``${package_name_TARGETS}`` if the package you're depending on is a message package such as ``std_msgs``.

.. code-block:: cmake

   target_link_libraries(my_library PUBLIC foo::foo bar::bar ${std_msgs_TARGETS} baz::baz)

Choose ``PUBLIC`` or ``PRIVATE`` based on how the dependency is used by your library (`example <https://github.com/ros2/geometry2/blob/d85102217f692746abea8546c8e41f0abc95c8b8/tf2/CMakeLists.txt#L27-L31>`__).

* Use ``PUBLIC`` if the dependency is needed by downstream users, for example, your library's public API uses it.
* Use ``PRIVATE`` if the dependency is only used internally by your library.

Replace ``catkin_package()`` with various ament_cmake calls
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Imagine your ``CMakeLists.txt`` has a call to ``catkin_package`` like this:

.. code-block::

   catkin_package(
       INCLUDE_DIRS include
       LIBRARIES my_library
       CATKIN_DEPENDS foo bar std_msgs
       DEPENDS baz
   )

   install(TARGETS my_library
      ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
      LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
      RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION}
   )


Replacing ``catkin_package(INCLUDE_DIRS ...)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you've used modern CMake targets and ``target_include_directories()``, you don't need to do anything further.
Downstream users will get the include directories by depending on your modern CMake targets.

Replacing ``catkin_package(LIBRARIES ...)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use ``ament_export_targets()`` and ``install(TARGETS ... EXPORT ...)`` to replace the ``LIBRARIES`` argument.

Use the ``EXPORT`` keyword when installing your ``my_library`` target (`example <https://github.com/ros2/geometry2/blob/d85102217f692746abea8546c8e41f0abc95c8b8/tf2/CMakeLists.txt#L37-L41>`__).

.. code-block:: cmake

   install(TARGETS my_library EXPORT export_my_package
      ARCHIVE DESTINATION lib
      LIBRARY DESTINATION lib
      RUNTIME DESTINATION bin
   )

The above is a good default for library targets.
If your package used different ``CATKIN_*_DESTINATION`` variables, convert them as follows:

.. list-table::
   :header-rows: 1

   * - **catkin**
     - **ament_cmake**
   * - CATKIN_GLOBAL_BIN_DESTINATION
     - bin
   * - CATKIN_GLOBAL_INCLUDE_DESTINATION
     - include
   * - CATKIN_GLOBAL_LIB_DESTINATION
     - lib
   * - CATKIN_GLOBAL_LIBEXEC_DESTINATION
     - lib
   * - CATKIN_GLOBAL_SHARE_DESTINATION
     - share
   * - CATKIN_PACKAGE_BIN_DESTINATION
     - lib/${PROJECT_NAME}
   * - CATKIN_PACKAGE_INCLUDE_DESTINATION
     - include/${PROJECT_NAME}
   * - CATKIN_PACKAGE_LIB_DESTINATION
     - lib
   * - CATKIN_PACKAGE_SHARE_DESTINATION
     - share/${PROJECT_NAME}

Add a call to ``ament_export_targets()`` with the same name you gave to the ``EXPORT`` keyword (`example <https://github.com/ros2/geometry2/blob/d85102217f692746abea8546c8e41f0abc95c8b8/tf2/CMakeLists.txt#L124-L125>`__).

.. code-block:: cmake

   ament_export_targets(export_my_package)


Replacing ``catkin_package(CATKIN_DEPENDS .. DEPENDS ..)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Your package's users must ``find_package()`` dependencies used by your package's public API.
In ROS 1 this was done for downstream users with the ``CATKIN_DEPENDS`` and ``DEPENDS`` arguments.
Use `ament_export_dependencies <https://github.com/ament/ament_cmake/blob/{REPOS_FILE_BRANCH}/ament_cmake_export_dependencies/cmake/ament_export_dependencies.cmake>`__ to do this in ROS 2.

.. code-block:: cmake

   ament_export_dependencies(
      foo
      bar
      std_msgs
      baz
   )

Generate messages
^^^^^^^^^^^^^^^^^

If your package contains both C++ code and ROS message, service, or action definitions, then consider splitting it into two packages:

* A package with only the ROS message, service, and/or action definitions
* A package with the C++ code

Add the following dependencies to the ``package.xml`` of the package that contains ROS messages:

1. Add a ``<buildtool_depend>`` on ``rosidl_default_generators`` (`example <https://github.com/ros2/common_interfaces/blob/d685509e9cb9f80bd320a347f2db954a73397ae7/std_msgs/package.xml#L19>`__)

   .. code-block:: xml

      <buildtool_depend>rosidl_default_generators</buildtool_depend>

2. Add an ``<exec_depend>`` on ``rosidl_default_runtime`` (`example <https://github.com/ros2/common_interfaces/blob/d685509e9cb9f80bd320a347f2db954a73397ae7/std_msgs/package.xml#L22>`__)

   .. code-block:: xml

      <exec_depend>rosidl_default_runtime</exec_depend>

3. Add a ``<member_of_group>`` tag with the group name ``rosidl_interface_packages`` (`example <https://github.com/ros2/common_interfaces/blob/d685509e9cb9f80bd320a347f2db954a73397ae7/std_msgs/package.xml#L26>`__)

   .. code-block:: xml

      <member_of_group>rosidl_interface_packages</member_of_group>

In your ``CMakeLists.txt``, replace the invocation of ``add_message_files``, ``add_service_files`` and ``generate_messages`` with `rosidl_generate_interfaces <https://github.com/ros2/rosidl/blob/{REPOS_FILE_BRANCH}/rosidl_cmake/cmake/rosidl_generate_interfaces.cmake>`__.
The first argument must be ``${PROJECT_NAME}`` due to `this bug <https://github.com/ros2/rosidl_typesupport/issues/120>`__.

For example, if your ROS 1 package looks like this:

.. code-block::

   add_message_files(DIRECTORY msg FILES FooBar.msg Baz.msg)
   add_service_files(DIRECTORY srv FILES Ping.srv)

   add_action_files(DIRECTORY action FILES DoPong.action)
   generate_messages(
      DEPENDENCIES actionlib_msgs std_msgs geometry_msgs
   )

Then change it to this (`example <https://github.com/ros2/geometry2/blob/d85102217f692746abea8546c8e41f0abc95c8b8/tf2_msgs/CMakeLists.txt#L18-L25>`__)

.. code-block:: cmake

       rosidl_generate_interfaces(${PROJECT_NAME}
         ""msg/FooBar.msg""
         ""msg/Baz.msg""
         ""srv/Ping.srv""
         ""action/DoPong.action""
         DEPENDENCIES actionlib_msgs std_msgs geometry_msgs
       )

Remove references to the devel space
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Remove any references to the *devel space* such as ``CATKIN_DEVEL_PREFIX``.
There is no equivalent to the *devel space* in ROS 2.


Unit tests
^^^^^^^^^^

If your package uses `gtest <https://github.com/google/googletest>`__ then:

* Replace ``CATKIN_ENABLE_TESTING`` with ``BUILD_TESTING``.
* Replace ``catkin_add_gtest`` with ``ament_add_gtest``.
* Add a ``find_package()`` for ``ament_cmake_gtest`` instead of ``GTest``

For example, if your ROS 1 package adds tests like this:

.. code-block::

      if (CATKIN_ENABLE_TESTING)
        find_package(GTest REQUIRED)
        include_directories(${GTEST_INCLUDE_DIRS})
        catkin_add_gtest(my_test src/test/some_test.cpp)
        target_link_libraries(my_test
          # ...
          ${GTEST_LIBRARIES})
      endif()

Then change it to this:

.. code-block:: CMake

      if (BUILD_TESTING)
        find_package(ament_cmake_gtest REQUIRED)
        ament_add_gtest(my_test src/test/test_something.cpp)
        target_link_libraries(my_test
          #...
         )
      endif()

Add ``<test_depend>ament_cmake_gtest</test_depend>`` to your ``package.xml`` (`example <https://github.com/ros2/geometry2/blob/d85102217f692746abea8546c8e41f0abc95c8b8/tf2/package.xml#L35>`__).

.. code-block:: xml

   <test_depend>ament_cmake_gtest</test_depend>

Linters
^^^^^^^

The ROS 2 code :doc:`style guide <../../The-ROS2-Project/Contributing/Developer-Guide>` differs from ROS 1.

If you choose to follow the ROS 2 style guide, then turn on automatic linter tests by adding these lines in a ``if(BUILD_TESTING)`` block:

.. code-block:: cmake

   if(BUILD_TESTING)
      find_package(ament_lint_auto REQUIRED)
      ament_lint_auto_find_test_dependencies()
      # ...
   endif()

Add the following dependencies to your ``package.xml``:

.. code-block:: xml

   <test_depend>ament_lint_auto</test_depend>
   <test_depend>ament_lint_common</test_depend>

Update source code
------------------

Messages, services, and actions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The namespace of ROS 2 messages, services, and actions use a subnamespace (``msg``, ``srv``, or ``action``, respectively) after the package name.
Therefore an include looks like: ``#include <my_interfaces/msg/my_message.hpp>``.
The C++ type is then named: ``my_interfaces::msg::MyMessage``.

Shared pointer types are provided as typedefs within the message structs: ``my_interfaces::msg::MyMessage::SharedPtr`` as well as ``my_interfaces::msg::MyMessage::ConstSharedPtr``.

For more details please see the article about the `generated C++ interfaces <https://design.ros2.org/articles/generated_interfaces_cpp.html>`__.

The migration requires includes to change by:


* inserting the subfolder ``msg`` between the package name and message datatype
* changing the included filename from CamelCase to underscore separation
* changing from ``*.h`` to ``*.hpp``

.. code-block:: cpp

   // ROS 1 style is in comments, ROS 2 follows, uncommented.
   // # include <geometry_msgs/PointStamped.h>
   #include <geometry_msgs/msg/point_stamped.hpp>

   // geometry_msgs::PointStamped point_stamped;
   geometry_msgs::msg::PointStamped point_stamped;

The migration requires code to insert the ``msg`` namespace into all instances.

Use of service objects
^^^^^^^^^^^^^^^^^^^^^^

Service callbacks in ROS 2 do not have boolean return values.
Instead of returning false on failures, throwing exceptions is recommended.

.. code-block:: cpp

   // ROS 1 style is in comments, ROS 2 follows, uncommented.
   // #include ""nav_msgs/GetMap.h""
   #include ""nav_msgs/srv/get_map.hpp""

   // bool service_callback(
   //   nav_msgs::GetMap::Request & request,
   //   nav_msgs::GetMap::Response & response)
   void service_callback(
     const std::shared_ptr<nav_msgs::srv::GetMap::Request> request,
     std::shared_ptr<nav_msgs::srv::GetMap::Response> response)
   {
     // ...
     // return true;  // or false for failure
   }

Usages of ros::Time
^^^^^^^^^^^^^^^^^^^

For usages of ``ros::Time``:

* Replace all instances of ``ros::Time`` with ``rclcpp::Time``

* If your messages or code makes use of std_msgs::Time:

  * Convert all instances of std_msgs::Time to builtin_interfaces::msg::Time

  * Convert all ``#include ""std_msgs/time.h`` to ``#include ""builtin_interfaces/msg/time.hpp""``

  * Convert all instances using the std_msgs::Time field ``nsec`` to the builtin_interfaces::msg::Time field ``nanosec``

Usages of ros::Rate
^^^^^^^^^^^^^^^^^^^

There is an equivalent type ``rclcpp::Rate`` object which is basically a drop in replacement for ``ros::Rate``.


Boost
^^^^^

Much of the functionality previously provided by Boost has been integrated into the C++ standard library.
As such we would like to take advantage of the new core features and avoid the dependency on boost where possible.

Shared Pointers
~~~~~~~~~~~~~~~

To switch shared pointers from boost to standard C++ replace instances of:


* ``#include <boost/shared_ptr.hpp>`` with ``#include <memory>``
* ``boost::shared_ptr`` with ``std::shared_ptr``

There may also be variants such as ``weak_ptr`` which you want to convert as well.

Also it is recommended practice to use ``using`` instead of ``typedef``.
``using`` has the ability to work better in templated logic.
For details `see here <https://stackoverflow.com/questions/10747810/what-is-the-difference-between-typedef-and-using-in-c11>`__

Thread/Mutexes
~~~~~~~~~~~~~~

Another common part of boost used in ROS codebases are mutexes in ``boost::thread``.


* Replace ``boost::mutex::scoped_lock`` with ``std::unique_lock<std::mutex>``
* Replace ``boost::mutex`` with ``std::mutex``
* Replace ``#include <boost/thread/mutex.hpp>`` with ``#include <mutex>``

Unordered Map
~~~~~~~~~~~~~

Replace:


* ``#include <boost/unordered_map.hpp>`` with ``#include <unordered_map>``
* ``boost::unordered_map`` with ``std::unordered_map``

function
~~~~~~~~

Replace:


* ``#include <boost/function.hpp>``  with ``#include <functional>``
* ``boost::function`` with ``std::function``
",How should the build type be set to accommodate the changes required in the CMakeLists.txt for migrating C++ packages from ROS 1 to ROS 2?
"Release Track
=============

.. contents:: Table of Contents
   :depth: 2
   :local:

.. _what-is-a-track:

What is a Track?
----------------

Bloom requires the user to enter configuration information when releasing packages for the first time.
It is beneficial to store such configurations in the release repository so we don't have to manually enter configurations that won't change for subsequent releases.

Since some of the configurations will differ when releasing the package for different ROS distributions, bloom uses **release tracks to store the configurations for releasing** per distribution.
By convention you should create tracks with the same name as the ROS distro you are releasing for.

All release track configurations are stored in ``tracks.yaml`` on the master branch of your release repository.

Track Configurations
--------------------

Track configurations are explained in more detail along with the prompts from bloom.

.. _release-repository-url:

Release Repository url
^^^^^^^^^^^^^^^^^^^^^^

This is the url of your release repository, and should be of form ``https://github.com/ros2-gbp/my_repo-release.git`` if your release repository is hosted on ros2-gbp.

.. code-block:: bash

   No reasonable default release repository url could be determined from previous releases.
   Release repository url [press enter to abort]:

Paste your release repository URL and press Enter.

Bloom may additionally ask you about initializing the new repository, as following:

.. code-block:: bash

   Freshly initialized git repository detected.
   An initial empty commit is going to be made.
   Continue [Y/n]?

Simply press Enter to accept the default of yes.

.. _repository-name:

Repository Name
^^^^^^^^^^^^^^^

The repository name is trivial, but it is recommended to set this to the name of your project.

.. code-block:: bash

   Repository Name:
      upstream
         Default value, leave this as upstream if you are unsure
      <name>
         Name of the repository (used in the archive name)
      ['upstream']:

Type the name of your project (eg. ``my_project``) and press Enter.

.. _upstream-repository-uri:

Upstream Repository URI
^^^^^^^^^^^^^^^^^^^^^^^

The **upstream repository** is the repository where your source code is.
This is most likely an https link to your project hosted on a git hosting service such as GitHub or GitLab.

.. code-block:: bash

   Upstream Repository URI:
      <uri>
         Any valid URI. This variable can be templated, for example an svn url
         can be templated as such: ""https://svn.foo.com/foo/tags/foo-:{version}""
         where the :{version} token will be replaced with the version for this release.
      [None]:

Make sure you **use the https address** (eg. ``https://github.com/my_organization/my_repo.git``) and not the ssh address.

.. _upstream-vcs-type:

Upstream VCS Type
^^^^^^^^^^^^^^^^^

This is the `Upstream Repository URI`_'s version control system (VCS) type.
You must specify the type of vcs your repository is using, from  ``svn``, ``git``, ``hg`` or ``tar``.

.. code-block:: bash

   Upstream VCS Type:
      svn
         Upstream URI is a svn repository
      git
         Upstream URI is a git repository
      hg
         Upstream URI is a hg repository
      tar
         Upstream URI is a tarball
      ['git']:

Most repositories will be using git, but some legacy repositories might be using hg or svn.

.. _version:

Version
^^^^^^^

This is the version of the package you are releasing. (eg. ``1.0.3``)

.. code-block:: bash

   Version:
      :{ask}
         This means that the user will be prompted for the version each release.
         This also means that the upstream devel will be ignored.
      :{auto}
         This means the version will be guessed from the devel branch.
         This means that the devel branch must be set, the devel branch must exist,
         and there must be a valid package.xml in the upstream devel branch.
      <version>
         This will be the version used.
         It must be updated for each new upstream version.
      [':{auto}']:

Setting this to ``:{auto}`` (the default, and recommended setup) will automatically determine the version from the devel branch's package.xml.

Setting this to ``:{ask}`` will bring up a prompt asking for the version every time you run a release with bloom.

.. _release-tag:

Release Tag
^^^^^^^^^^^

The Release Tag refers to which tag or branch you want to import the code from.

.. code-block:: bash

   Release Tag:
      :{version}
         This means that the release tag will match the :{version} tag.
         This can be further templated, for example: ""foo-:{version}"" or ""v:{version}""

         This can describe any vcs reference. For git that means {tag, branch, hash},
         for hg that means {tag, branch, hash}, for svn that means a revision number.
         For tar this value doubles as the sub directory (if the repository is
         in foo/ of the tar ball, putting foo here will cause the contents of
         foo/ to be imported to upstream instead of foo itself).
      :{ask}
         This means the user will be prompted for the release tag on each release.
      :{none}
         For svn and tar only you can set the release tag to :{none}, so that
         it is ignored.  For svn this means no revision number is used.
      [':{version}']:

Setting this to ``:{version}`` (the default, and recommended setup) will make the release tag match the version tag.

A less common setup is to set this to a branch name to always pull in that branch at the time of release from the upstream project.

Alternatively, if you want to be prompted to enter a different tag every time you do a release, enter ``:{ask}``.
``:{ask}`` is useful if the upstream project has frequent tagged releases and you want to refer to the new tag every time you're releasing.

.. _upstream-devel-branch:

Upstream Devel Branch
^^^^^^^^^^^^^^^^^^^^^

The upstream devel branch is the name of the branch in your :ref:`upstream repository <upstream-repository-uri>`.
If you use separate branches for each ROS distribution, this field would be different for each release track.
It is used to determine the version of the package you are releasing when :ref:`Version` is set to ``:{auto}``.

.. code-block:: bash

   Upstream Devel Branch:
      <vcs reference>
         Branch in upstream repository on which to search for the version.
         This is used only when version is set to ':{auto}'.
      [None]:

To release from a branch called ``{DISTRO}``, enter ``{DISTRO}``.
Leaving this as ``None`` would result in the version being determined from the default branch of your repository (this is not recommended).

.. _ros-distro:

ROS Distro
^^^^^^^^^^

This is the distribution you're planning on releasing the package into.

.. code-block:: bash

   ROS Distro:
      <ROS distro>
         This can be any valid ROS distro, e.g. indigo, kinetic, lunar, melodic
      ['indigo']:

If you plan on releasing into ROS {DISTRO}, enter ``{DISTRO}``.

.. _patches-directory:

Patches Directory
^^^^^^^^^^^^^^^^^

This is the directory where any additional patches to the releases are.

.. code-block:: bash

   Patches Directory:
      <path in bloom branch>
         This can be any valid relative path in the bloom branch. The contents
         of this folder will be overlaid onto the upstream branch after each
         import-upstream.  Additionally, any package.xml files found in the
         overlay will have the :{version} string replaced with the current
         version being released.
      :{none}
         Use this if you want to disable overlaying of files.
      [None]:

Adding additional patches to a release is a rarely used feature.
For almost all packages, this should be left as the default ``None``.

.. _release-repository-push-url:

Release Repository Push URL
^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: bash

   Release Repository Push URL:
      :{none}
         This indicates that the default release url should be used.
      <url>
         (optional) Used when pushing to remote release repositories. This is only
         needed when the release uri which is in the rosdistro file is not writable.
         This is useful, for example, when a releaser would like to use a ssh url
         to push rather than a https:// url.
      [None]:

Can be left as the default in most cases.
",What should the repository name be set to when configuring release track configurations according to the given text?
"Once your pull request has been submitted, usually within one or two days, one of the maintainers of rosdistro will review and merge your Pull Request.
If your package build is successful, in 24-48 hours your packages will become available in the **ros-testing** repository, where you can :doc:`test your pre-release binaries <../../../Installation/Testing>`.

Approximately every two to four weeks, the distribution's release manager manually synchronizes the contents of ros-testing into the main ROS repository.
This is when your packages actually become available to the rest of the ROS community.
To get updates on when the next synchronization (sync) is coming, subscribe to the `Packaging and Release Management Category on ROS Discourse <https://discourse.ros.org/c/release/16>`_.
",What is the purpose of the synchronization process mentioned in the text and how frequently does it occur?
".. redirect-from::

    Releasing-a-ROS-2-package-with-bloom
    Guides/Releasing-a-ROS-2-package-with-bloom
    Tutorials/Releasing-a-ROS-2-package-with-bloom
    How-To-Guides/Releasing-a-ROS-2-package-with-bloom

Releasing a Package
===================

.. toctree::
   :hidden:

   Index-Your-Packages
   First-Time-Release
   Subsequent-Releases
   Release-Team-Repository
   Release-Track

**Releasing a package makes your package available on the public ROS 2 buildfarm.**
This will:

* Make your package available to be installed via package managers (eg. ``apt`` on Ubuntu) for all supported Linux platforms in a ROS distribution as described in `REP 2000 <https://ros.org/reps/rep-2000.html>`_.
* Allow your package to have API documentation automatically generated.
* Make your package part of the `ROS Index <https://index.ros.org>`_.
* (Optionally) Allow you to have automatic CI run for pull requests in your repository.

**Follow one of the guides below to get your package released:**

* :doc:`Index Your Packages <Index-Your-Packages>` - if this is the first release for the package
* :doc:`First Time Release <First-Time-Release>` - if this is the first release for the package, but it is already indexed
* :doc:`Subsequent Releases <Subsequent-Releases>` - if you are releasing a new version of a package that has already been released

After successfully following the instructions, your package will be released into the ROS ecosystem on the next distro synchronization!
",What are the benefits of releasing a package in ROS 2 using bloom?
"First Time Release
==================

This guide explains how to release ROS 2 packages that you have not released before.
Due to numerous options available when releasing ROS packages, this guide intends to cover the most common scenario and does not cover every corner-case.

.. contents:: Table of Contents
   :depth: 1
   :local:

Be part of a release team
-------------------------

You must be part of a :ref:`release team <what-is-a-release-team>`.
If you are not part of a release team yet, follow either:

* :ref:`Join a release team <join-a-release-team>`
* :ref:`Start a new release team <start-a-new-release-team>`

Create a new release repository
-------------------------------

You need a :ref:`release repository <what-is-a-release-repository>` to release a package.
Follow :ref:`Create a new release repository <create-a-new-release-repository>`.

Install dependencies
--------------------

.. include:: _Install-Dependencies.rst

Set Up a Personal Access Token
------------------------------

.. include:: _Personal-Access-Token.rst

Ensure repositories are up-to-date
----------------------------------

.. include:: _Ensure-Repositories-Are-Up-To-Date.rst

Generate Changelog
------------------

Generate a ``CHANGELOG.rst`` file per package in your repo using the following command:

.. code-block:: bash

   catkin_generate_changelog --all

.. include:: _Clean-Up-Changelog.rst

Bump the package version
------------------------

.. include:: _Bump-Package-Version.rst

Bloom Release
-------------

Run the following command, replacing ``my_repo`` with the name of your repository:

.. code-block:: bash

  bloom-release --new-track --rosdistro {DISTRO} --track {DISTRO} my_repo

.. tip::

   * ``--new-track`` tells bloom to create a new :ref:`track <what-is-a-track>` and configure it.
   * ``--rosdistro {DISTRO}`` indicates that this release is for the ``{DISTRO}`` distro
   * ``--track {DISTRO}`` indicates that you want the track name to be ``{DISTRO}``


You will be prompted to enter information to configure a new track.
In a common scenario such as:

* Your packages are in a repository called ``my_repo``
* You are releasing a branch called ``main``
* The repository is hosted on GitHub at ``https://github.com/my_organization/my_repo.git``
* Your release repository is at ``https://github.com/ros2-gbp/my_repo-release.git``

You should respond to the prompts as following:

.. list-table::
   :header-rows: 1
   :widths: 1 2

   * - Configuration
     - Value
   * - :ref:`Release Repository url <release-repository-url>`
     - ``https://github.com/ros2-gbp/my_repo-release.git``
   * - :ref:`Repository Name <repository-name>`
     - ``my_repo``
   * - :ref:`Upstream Repository URI <upstream-repository-uri>`
     - ``https://github.com/my_organization/my_repo.git``
   * - :ref:`Upstream VCS Type <upstream-vcs-type>`
     -
   * - :ref:`Version <version>`
     -
   * - :ref:`Release Tag <release-tag>`
     -
   * - :ref:`Upstream Devel Branch <upstream-devel-branch>`
     - ``main``
   * - :ref:`ROS Distro <ros-distro>`
     -
   * - :ref:`Patches Directory <patches-directory>`
     -
   * - :ref:`Release Repository Push URL <release-repository-push-url>`
     -

.. note::

  An empty cell in the table indicates that the default value should be used.
  Simply respond to the prompt by pressing Enter.

Bloom will automatically create a pull request for you against `rosdistro <https://github.com/ros/rosdistro>`_.

Next Steps
----------

.. include:: _Next-Steps.rst
",What command is used to generate a ``CHANGELOG.rst`` file per package in the repository according to the provided text?
"Every release of the package must have a unique version number higher than the previous release.
Run:

.. code-block:: bash

   catkin_prepare_release

which performs the following:

#. increases the package version in ``package.xml``
#. replaces the heading ``Forthcoming`` with ``version (date)`` (eg. ``0.0.1 (2022-01-08)``) in ``CHANGELOG.rst``
#. commits those changes
#. creates a tag (eg. ``0.0.1``)
#. pushes the changes and the tag to your remote repository

.. note::

   By default the patch version of the package is incremented, such as from ``0.0.0`` to ``0.0.1``.
   To increment the minor or major version instead, run ``catkin_prepare_release --bump minor`` or ``catkin_prepare_release --bump major``.
   For more details, see ``catkin_prepare_release --help``.
",How does `catkin_prepare_release` ensure that every release of the package has a unique version number higher than the previous release?
".. warning::

   If the file ``~/.config/bloom`` exists on your computer, it is likely that you have done this before so you should skip this section.

During the release process, multiple HTTPS Git operations will be performed that require password authentication.
To avoid being repeatedly asked for a password, a `Personal Access Token (PAT) <https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token>`_ will be set up.
If you have multi-factor authentication setup on your GitHub account, you **must** setup a Personal Access Token.

Create a Personal Access Token by:

#. Log in to GitHub and go to `Personal access tokens <https://github.com/settings/tokens>`_.
#. Click the **Generate new token** button.
#. In the dropdown, select **Generate new token (classic)**
#. Set **Note** to something like ``Bloom token``.
#. Set **Expiration** to **No expiration**.
#. Tick the ``public_repo`` and ``workflow`` checkboxes.
#. Click the **Generate token** button.

After you have created the token, you will end up back at the *Personal access tokens* page.
**Copy the alphanumeric token** that is highlighted in green.

Save your GitHub username and PAT to a new file called ``~/.config/bloom``, with the format below:

.. code-block:: text

   {
      ""github_user"": ""<your-github-username>"",
      ""oauth_token"": ""<token-you-created-for-bloom>""
   }
",What is the purpose of creating a Personal Access Token (PAT) on GitHub in the given text?
"Open all ``CHANGELOG.rst`` files in an editor.
You will see that ``catkin_generate_changelog`` has auto-generated a forthcoming section with notes from commit messages:

.. code-block:: rst

   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   Changelog for package your_package
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

   Forthcoming
   -----------
   * you can modify this commit message
   * and this

Clean up the list of commit messages to concisely convey the notable changes that have been made to the packages since the last release, and **commit all the CHANGELOG.rst files.**
Do not modify the ``Forthcoming`` header.
",What action should be taken to the list of commit messages in the CHANGELOG.rst files to convey the notable changes concisely and then what needs to be done with the files?
"Release Team / Repository
=========================

.. contents:: Table of Contents
   :depth: 2
   :local:

This page explains the recommended method of hosting your release repositories on `ros2-gbp <https://github.com/ros2-gbp>`_.

What is ROS 2 GBP?
------------------

`ros2-gbp <https://github.com/ros2-gbp>`_ is a GitHub organization that hosts the release repositories for ROS packages.
It also maintains a list of release teams, the list of members per release team and the list of release repositories maintained by the release teams in https://github.com/ros2-gbp/ros2-gbp-github-org.
Interactions with ros2-gbp-github-org are done through raising GitHub issues.
It is recommended that you request to join a release team and set up a release repository early as it can take some time for the ros2-gbp maintainers to respond to your requests.

.. _what-is-a-release-team:

What is a release team?
-----------------------

A release team is a `GitHub team <https://docs.github.com/en/organizations/organizing-members-into-teams/about-teams>`_ that consists of a group of people who are responsible for the release process of one or more repositories.
Release teams are often made up of an organization, a working group, or even an individual, and are named after the team or group that they represent.
The list of release teams and their associated release repositories are maintained at `ros2-gbp-github-org <https://github.com/ros2-gbp/ros2-gbp-github-org>`_.

**You must be a part of the release team that you are planning on releasing the project for.**
If you intend to release the repository under an existing team, follow :ref:`Join a release team <join-a-release-team>`.
If you intend to start a new team, follow :ref:`Start a new release team <start-a-new-release-team>`.

.. _join-a-release-team:

Join a release team
^^^^^^^^^^^^^^^^^^^

Fill the `Update Release Team Membership issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=update_release_team_membership.md&title=Update+release+team+membership>`_ issue template
if a release team already exists for your project but you are not part of it.

.. _start-a-new-release-team:

Start a new release team
^^^^^^^^^^^^^^^^^^^^^^^^

If no release team exists for your project yet, fill out the `New Release Team issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=new_release_team.md&title=Add+release+team>`_ issue template to request one be created.

.. _what-is-a-release-repository:

What is a release repository?
-----------------------------

A release repository is a repository that

* stores files generated from the release process, for the ROS buildfarm to use
* caches configurations from the release process to simplify subsequent releases of the repository in the future

Having a release repository separate from your source code repository is a requirement for making a release in ROS 2.

.. _create-a-new-release-repository:

Create a new release repository
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If your repository is new to the ROS community, you should first open a pull request on `ros/rosdistro <https://github.com/ros/rosdistro>`_ adding a ``source`` entry for your repository (e.g. https://github.com/ros/rosdistro/pull/39513).
The review process for the rosdistro database will ensure your repository and packages conform to the `REP 144 package naming conventions <https://www.ros.org/reps/rep-0144.html>`_ and other requirements before release.
Once your package name has been approved and merged, fill in the `Add New Release Repositories issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=new_release_repository.md&title=Add+new+release+repositories>`_ issue template
if you don't have a release repo for your project yet.

What if my existing release repo isn't on ros2-gbp?
---------------------------------------------------

Packages released before ros2-gbp existed may have their release repositories hosted elsewhere.
It is now strongly recommended for release repositories to live in this dedicated GitHub organization.
If you are porting a ROS 1 package to ROS 2 and planning on releasing your packages into ROS 2 for the first time, follow standard procedure to request for a new release repository for your ROS 2 releases.
If you have previously released your packages for ROS 2, when raising the `Add New Release Repositories issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=new_release_repository.md&title=Add+new+release+repositories>`_, **specify your current release repository url**, and follow standard procedure for the rest.

.. note::

   Release repositories hosted elsewhere are still supported for stable distributions if you are not planning to release the repository into Rolling.
   Since stable distributions created from Rolling will start with release repositories in the ros2-gbp organization it is recommend that you use the ros2-gbp release repositories for all ROS 2 distributions to avoid fragmenting the release information.

   A ros2-gbp release repository may become a hard requirement in the future and maintaining a single release repository for all ROS 2 distributions simplifies the maintenance of releases for both the Rolling distribution maintainers and package maintainers.
",What is the purpose of a release repository in ROS 2?
"Index Your Packages
===================

Are you releasing a new ROS package into a ROS distribution?
Make the process faster by indexing your packages first.

Put your ROS packages into a public repository
----------------------------------------------

If you haven't done so already, put the source code of your ROS packages into a public git repository.
All packages released into ROS must be open source.
You can host code anywhere, but GitHub is recommended because it gives you the option to enable pull request jobs.
Here are some choices:

* `GitHub <https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository>`__ **Recommended**
* `GitLab <https://docs.gitlab.com/ee/user/project/repository/>`__
* `Bitbucket <https://support.atlassian.com/bitbucket-cloud/docs/create-a-git-repository/>`__

Give your packages an OSI Approved license
------------------------------------------
Choose an `OSI approved license <https://opensource.org/licenses>`__ and give it to your ROS packages.
If you're having trouble deciding, consider using the license used by most of the core ROS 2 packages: `Apache-2.0 license <https://opensource.org/license/apache-2-0>`__.

For each ``package.xml`` in your repository, put the SPDX short identifier of the license in the ``<license>`` tag in your ``package.xml``.

If all of your ROS packages have the same license, or if there's only one ROS package in your repository, create a file called ``LICENSE`` at the root of your repository and put the text of the license you chose in it.
If the ROS packages in your repository have different licenses, create a ``LICENSE`` file adjacent to every ``package.xml`` file.

Give your packages REP 144 compliant names
------------------------------------------
Packages released into a ROS distribution must have names that comply with `REP 144 <https://www.ros.org/reps/rep-0144.html>`__.
Read the full REP to understand the rules.
If one of your ROS package names doesn't comply, then change the name before continuing.

Decide what ROS distribution you want to release into
-----------------------------------------------------
Decide what ROS distribution you want to release your packages into.
At a minimum, you should release your packages into `ROS Rolling <https://docs.ros.org/en/rolling>`__ so that your ROS packages are automatically included in the next ROS release.
You may also want to release into any active ROS distributions, but this is up to you.

Create a GitHub account
-----------------------
`Create a GitHub account <https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github>`__ if you don't already have one.
You don't have to host the source code of your ROS packages on GitHub, but you will need an account to index and release packages.

Fork and clone ros/rosdistro
----------------------------
`Fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo>`__ the `ros/rosdistro <https://github.com/ros/rosdistro/>`__ repository.
You only need to do this step once on your account.
The fork will be used every time you do a release.

Make changes to your fork
-------------------------
Remember the ROS distributions you decided to release into?
Each ROS distribution has a folder in the `ros/rosdistro <https://github.com/ros/rosdistro/>`__ repository.
For example, the name of the ROS Rolling folder is ``rolling``.
For each ROS distribution you want to release into:

1. fill out the following template
2. put the filled-out template into the ``distribution.yaml`` file in the corresponding ROS distribution's folder

.. code-block:: yaml

  YOUR-REPO-NAME:
    source:
      type: git
      url: https://YOUR-GIT-REPO-URL.git
      version: YOUR-BRANCH-NAME
    status: YOUR-STATUS

Here's how to fill out each item:

* YOUR-REPO-NAME: This is an arbitrary human-readable name. For repos hosted on GitHub, use the lowercase name of your repository not including the organization. For example, the repository name of ``https://github.com/ros2/rosidl`` is ``rosidl``.
* YOUR-GIT-REPO-URL: This is the https URL from which one could ``git clone`` your repository. For example, the git repo URL of ``https://github.com/ros2/rosidl`` is ``https://github.com/ros2/rosidl.git``.  It is important that this URL ends in ``.git``, or it will fail to pass the linters.
* YOUR-BRANCH-NAME: This is the git branch on your repository from which you will release your package into this ROS distribution. This is commonly one of: ``main``, ``master``, or the name of the ROS distribution itself. For example, the `rosidl repository <https://github.com/ros2/rosidl>`__ uses the branch ``rolling`` to hold changes to be released into ROS Rolling.
* YOUR-STATUS: This is a status from the list in `REP 141 <https://www.ros.org/reps/rep-0141.html#distribution-file>`__. You likely want either ``maintained`` or ``developed``.

Open a pull request to ros/rosdistro
------------------------------------
`Open a pull request <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request>`__ to `ros/rosdistro <https://github.com/ros/rosdistro/>`__ with the branch that you made your changes to.
Wait a few days for it to be reviewed.

What happens next
-----------------
You've now done everything required to index your ROS packages.
One of the reviewers will look at your pull request and decide if it `satisfies the review guidelines <https://github.com/ros/rosdistro/blob/master/REVIEW_GUIDELINES.md>`__.
The reviewer may either approve your changes as is, or give you actionable feedback.
Once the pull request meets the review guidelines it will be merged, and your packages will appear on the `ROS Index <https://index.ros.org/>`__.

You've completed an important step toward releasing your package.
Proceed to the next guide: :doc:`First Time Release <First-Time-Release>`.
",What are the steps required to index your ROS packages before releasing them into a ROS distribution?
"Install tools that you will use in the upcoming steps according to your platform:

.. tabs::

   .. group-tab:: deb (eg. Ubuntu)

      .. code-block:: bash

         sudo apt install python3-bloom python3-catkin-pkg

   .. group-tab:: RPM (eg. RHEL)

      .. code-block:: bash

          sudo dnf install python3-bloom python3-catkin_pkg

   .. group-tab:: Other

      .. code-block:: bash

         pip3 install -U bloom catkin_pkg

Make sure you have rosdep initialized:

.. code-block:: bash

    sudo rosdep init
    rosdep update

Note that the ``rosdep init`` command may fail if it has already been initialized in the past; this can safely be ignored.
",What tools are needed for installation on Ubuntu according to the provided text?
"Subsequent Releases
===================

This guide explains how to release new versions of ROS packages that have already been released before.

.. contents:: Table of Contents
   :depth: 1
   :local:

Be part of the release team
---------------------------

If you are not part of the release team that has write access to the release repository, follow :ref:`Join a release team <join-a-release-team>`.

Install dependencies
--------------------

.. include:: _Install-Dependencies.rst

Set up a Personal Access Token
------------------------------

.. include:: _Personal-Access-Token.rst

Ensure repositories are up-to-date
----------------------------------

.. include:: _Ensure-Repositories-Are-Up-To-Date.rst

Updating Changelog
------------------

For your users and for the developers, keep the changelog concise and up to date.

.. code-block:: bash

   catkin_generate_changelog

.. include:: _Clean-Up-Changelog.rst

Bump the package version
------------------------

.. include:: _Bump-Package-Version.rst

Bloom Release
-------------

Run the following command, replacing ``my_repo`` with the name of your repository with the packages:

.. code-block:: bash

   bloom-release --rosdistro {DISTRO} my_repo

Bloom will automatically create a pull request for you against `rosdistro <https://github.com/ros/rosdistro>`_.

Next Steps
----------

.. include:: _Next-Steps.rst
",What command should you run to bump the package version when releasing new versions of ROS packages?
"Make sure that:

* Your repository is hosted on a remote such as GitHub.
* You have a clone of the repository on your computer and are on the right branch.
* Both the remote repository and your clone are up-to-date.
",What is the main theme of the text document?
".. redirect-from::

    Visualizing-ROS-2-Data-With-Foxglove-Studio

Visualizing ROS 2 data with Foxglove
====================================

`Foxglove <https://foxglove.dev/>`__ is a visualization and observability tool for robotics developers.
It's available in the browser or as a standalone desktop app and is free for individual, small team, and academic use.

Installation
------------

To use Foxglove, you'll need to `create an account <https://app.foxglove.dev/signup>`__. It's free and all you need is a valid email address.

Once you've created an account, you can use Foxglove on the web by opening Google Chrome and navigating to `app.foxglove.dev <https://app.foxglove.dev>`__.

To use the desktop app for Linux, macOS, or Windows, download it directly from the `Foxglove website <https://foxglove.dev/download>`__.

.. note::

  Foxglove uses specific features of Google Chrome. While some features may work, other browsers are not supported. For the best experience, we recommend using Chrome or the desktop app.

Connect to a live data source
-----------------------------

To connect to a live ROS 2 stack, you will need to `install the Foxglove ROS 2 bridge <https://docs.foxglove.dev/docs/connecting-to-data/ros-foxglove-bridge>`__ with:

.. code-block:: bash

   sudo apt install ros-$ROS_DISTRO-foxglove-bridge

Once you have the bridge installed, launch it with:

.. code-block:: bash

   ros2 launch foxglove_bridge foxglove_bridge_launch.xml

With the bridge running on your robot, you're ready to connect view data in Foxglove. Make sure you are on the same network as your robot, open Foxglove (web or desktop) and click ""Open connection"".

Select the option for ""Foxglove WebSocket"" and enter your robot's WebSocket URL. The default is ``ws://localhost:8765``, however you can read about configuration options for the ROS Foxglove bridge `here <https://docs.foxglove.dev/docs/connecting-to-data/ros-foxglove-bridge#configuration-1>`__.

.. note::

  Foxglove can also connect using rosbridge, however for performance and stability reasons we recommend using the Foxglove bridge.

View and replay recorded data
-----------------------------

If you'd rather visualize recorded data, you can use Foxglove to replay ROS 2 ``.mcap`` as well as older ROS 2 ``.db3``, and ROS 1 ``.bag`` files. Foxglove is particularly convenient for recorded data because it does not require ROS 2 to be running to view data.

Use the :doc:`ros2 bag command line tool <../Tutorials/Beginner-CLI-Tools/Recording-And-Playing-Back-Data/Recording-And-Playing-Back-Data>` to record data from your robot to a ``.mcap`` file:

.. code-block:: bash

   ros2 bag record -a

From the Foxglove dashboard or menu, select ""Open local file"" and navigate to your recorded ``.mcap`` file.

See the Foxglove documentation for `more information about the types of data sources you can use with it <https://docs.foxglove.dev/docs/connecting-to-data/introduction/>`__.

Building layouts with panels
----------------------------

`Panels <https://docs.foxglove.dev/docs/visualization/panels/introduction>`__ allow you to visualize different specific types of data such as logs, maps, plots, and 3D information. You can arrange panels by dragging and dropping them into Foxglove `layouts <https://foxglove.dev/docs/visualization/layouts>`__ to view multiple types of data simultaneously.

You can also save layouts for future use, or to share with your team.

Find the full list of available panels by clicking the ""Add panel"" icon in the upper left of the menu bar.

We've highlighted some particularly useful ones below:

3D panel: View 3D data and visualization markers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Open the panel settings by clicking the gear icon in the upper right. Choose the topics you want to display via the topic picker on the left, and configure each topic's visualization settings in the ""Edit topic settings"" menu.

Publish marker messages to add primitive shapes (arrows, spheres, etc.) and more complex visualizations (occupancy grids, point clouds, etc.) to your 3D panel's scene.

.. image:: foxglove/3d.png
  :width: 500 px
  :alt: Foxglove's 3D panel

Reference the `docs <https://foxglove.dev/docs/visualization/panels/3d>`__ for a full list of `supported message types <https://foxglove.dev/docs/visualization/panels/3d#supported-messages>`__ and some useful `user interactions <https://foxglove.dev/docs/visualization/panels/3d#user-interactions>`__.

Diagnostics panel: View and filter diagnostics messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Display the status of seen nodes (i.e. stale, error, warn, or OK) from topics with a ``diagnostic_msgs/msg/DiagnosticArray`` datatype in a running feed, and display the diagnostics data for a given ``diagnostic_name/hardware_id``.

.. image:: foxglove/diagnostics.png
  :width: 500 px
  :alt: Foxglove's Diagnostics panel

Reference the `docs <https://foxglove.dev/docs/visualization/panels/diagnostics>`__ for more details.

Image panel: View camera feed images
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Display raw and compressed images, as well as compressed videos, with 2D annotations like text labels, circles, and points. Superimpose 3D markers for additional context.

.. image:: foxglove/image.png
  :width: 500 px
  :alt: Foxglove's Image panel

Reference the `docs <https://foxglove.dev/docs/visualization/panels/image>`__ for more details.

Log panel: View log messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To view ``rcl_interfaces/msg/Log`` messages live, use the desktop app to `connect <https://docs.foxglove.dev/docs/connecting-to-data/frameworks/ros2>`__ to your running ROS stack.
To view ``rcl_interfaces/msg/Log`` messages from a pre-recorded data file, you can drag-and-drop your file into either the `web <https://app.foxglove.dev>`__ or desktop app.

Next, add a `Log <https://foxglove.dev/docs/visualization/panels/log>`__ panel to your layout.
If you've connected to your ROS stack correctly, you should now see a list of your log messages, with the ability to filter them by node name or severity level.

Reference the `docs <https://foxglove.dev/docs/visualization/panels/log>`__ for more details.

Plot panel: Plot arbitrary values over time
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Plot arbitrary numeric values from topic `message paths <https://docs.foxglove.dev/docs/visualization/message-path-syntax>`__ .

When playing back local or remote data files, this panel will preload the data belonging to the specified topic message paths for the whole playback timeline. Current playback time is indicated by a vertical gray bar.

.. image:: foxglove/plot.png
  :width: 500 px
  :alt: Foxglove's Plot panel

Reference the `docs <https://foxglove.dev/docs/visualization/panels/plot>`__ for more details.

Raw Messages panel: View incoming topic messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Inspect a particular `message path <https://docs.foxglove.dev/docs/visualization/message-path-syntax>`__ in your data source.

As new messages are received for a given path, the collapsible tree will show just the latest message. You will be able to expand and collapse keys, and have those changes persist across playback.

.. image:: foxglove/raw-messages.png
  :width: 500 px
  :alt: Foxglove's Raw Messages panel

Reference the `docs <https://foxglove.dev/docs/visualization/panels/raw-messages>`__ for more details.

Teleop panel: Teleoperate your robot
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Teleoperate your physical robot by publishing ``geometry_msgs/msg/Twist`` messages on a given topic back to your live ROS stack.

.. image:: foxglove/teleop.png
  :width: 300 px
  :alt: Foxglove's URDF Viewer panel

Reference the `docs <https://foxglove.dev/docs/visualization/panels/teleop>`__ for more details.

Visualize URDFs: View and manipulate your URDF model
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Foxglove's `3D panel supports displaying Unified Robotics Description Format (URDF) models <https://docs.foxglove.dev/docs/visualization/panels/3d/#custom-layers>`__ in the context of your robots’ world.

To visualize and control your robot model in Foxglove, open the web or desktop application and add a 3D panel to your layout.

Add as many URDF models as you want as custom layers in the 3D panel, using HTTP/HTTPS URLs (web and desktop) or ``file://`` and ``package://``-prefixed URLs (desktop only).

In addition to these URLs, the 3D panel can also display URDFs from a ``/robot_description`` topic.

Once added to the 3D panel, the URDF file will populate the transform tree with frames and transforms based on the model’s links and joints.

It’s important to note that Foxglove uses different defaults from RViz—if your meshes are not displaying properly, you may want to adjust the ""Ignore COLLADA <up_axis>"""" (for DAE meshes) and ""Mesh up axis"" (for STL and OBJ meshes) options in the panel settings’ ‘Scene’ section.

You can update this tree by publishing transform messages to move the URDF model’s joints positions—if you’ve used JointState messages before, you can use a robot_state_publisher node to transform them into TF messages at runtime.

You can also control your model’s joints manually via the panel settings interface.

.. image:: foxglove/urdf.png
  :width: 500 px
  :alt: Foxglove's URDF Viewer panel with editable joint positions

Reference the `docs <https://foxglove.dev/docs/visualization/panels/urdf-viewer>`__ for more details.

Other basic actions
-------------------

View your ROS topic graph
^^^^^^^^^^^^^^^^^^^^^^^^^

`Using the desktop app <https://foxglove.dev/download>`__, `connect <https://docs.foxglove.dev/docs/connecting-to-data/frameworks/ros2>`__ to your running ROS stack.
Next, add a `Topic Graph <https://foxglove.dev/docs/visualization/panels/topic-graph>`__ panel to your layout.
If you've connected to your ROS stack correctly, you should now see a computational graph of your ROS nodes, topics, and services in that panel.
Use the controls on the right side of the panel to select which topics to display or to toggle services.

View and edit your ROS params
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`Using the desktop app <https://foxglove.dev/download>`__, `connect <https://docs.foxglove.dev/docs/connecting-to-data/frameworks/ros2>`__ to your running ROS stack.
Next, add a `Parameters <https://foxglove.dev/docs/visualization/panels/parameters>`__ panel to your layout.
If you've connected to your ROS stack correctly, you should now see a live view of your current ``rosparams``.
You can edit these parameter values to publish ``rosparam`` updates back to your ROS stack.

Publish messages back to your live ROS stack
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`Using the desktop app <https://foxglove.dev/download>`__, `connect <https://docs.foxglove.dev/docs/connecting-to-data/frameworks/ros2>`__ to your running ROS stack.
Next, add a `Publish <https://foxglove.dev/docs/visualization/panels/publish>`__ panel to your layout.

Specify the topic you want to publish on to infer its datatype and populate the text field with a JSON message template.

Selecting a datatype in the dropdown of common ROS datatypes will also populate the text field with a JSON message template.

Edit the template to customize your message before hitting ""Publish"".

.. image:: foxglove/publish.png
  :width: 300 px
  :alt: Foxglove's Publish panel
","What types of data sources can you visualize using Foxglove, according to the documentation?"
"NVIDIA ROS 2 Projects
=====================

NVIDIA Jetson is working towards developing ROS 2 packages to ease the development of AI applications for robotics.


ROS Projects
------------
* `Isaac ROS Nvblox <https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_nvblox>`__ : Hardware-accelerated 3D scene reconstruction and Nav2 local costmap provider using nvblox.
* `Isaac ROS Object Detection <https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_object_detection>`__ : Deep learning model support for object detection including DetectNet.
* `Isaac ROS DNN Inference <https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_dnn_inference>`__ : This repository provides two NVIDIA GPU-accelerated ROS 2 nodes that perform deep learning inference using custom models. One node uses the TensorRT SDK, while the other uses the Triton SDK.
* `Isaac ROS Visual SLAM <https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam>`__ : This repository provides a ROS 2 package that estimates stereo visual inertial odometry using the Isaac Elbrus GPU-accelerated library.
* `Isaac ROS Argus Camera <https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_argus_camera>`__ : This repository provides monocular and stereo nodes that enable ROS developers to use cameras connected to Jetson platforms over a CSI interface.
* `Isaac ROS image_pipeline <https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_image_pipeline>`__ : This metapackage offers similar functionality as the standard, CPU-based image_pipeline metapackage, but does so by leveraging the Jetson platform's specialized computer vision hardware.
* `Isaac ROS Common <https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_common>`__ : Isaac ROS common utilities for use in conjunction with the Isaac ROS suite of packages.
* `Isaac ROS AprilTags <https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_apriltag>`__ : ROS 2 node uses the NVIDIA GPU-accelerated AprilTags library to detect AprilTags in images and publish their poses, ids, and additional metadata.
* `ROS and ROS 2 Docker Images <https://github.com/NVIDIA-AI-IOT/ros2_jetson/tree/main/docker>`__ : Docker images for easy deployment on the NVIDIA Jetson platform, consisting of ROS 2, PyTorch, and other important machine learning libraries.
* `ROS and ROS 2 DockerFiles <https://github.com/dusty-nv/jetson-containers>`__: Dockerfiles for ROS 2 based on l4t which all you to build your own Docker image.
* `ROS 2 Packages for PyTorch and TensorRT <https://github.com/NVIDIA-AI-IOT/ros2_torch_trt>`__: ROS 2 packageis for classification and object detection tasks using PyTorch and NVIDIA TensorRT. This tutorial is a good starting point AI integration with ROS 2 on NVIDIA Jetson.
* `ROS / ROS 2 Packages for Accelerated Deep Learning Nodes <https://github.com/dusty-nv/ros_deep_learning>`__: Deep learning image recognition, object detection, and semantic segmentation inference nodes and camera/video streaming nodes for ROS/ROS 2 using the `jetson-inference <https://github.com/dusty-nv/jetson-inference>`__ library and `NVIDIA Hello AI World tutorial <https://developer.nvidia.com/embedded/twodaystoademo>`__.
* `ROS 2 Package for Human Pose Estimation <https://github.com/NVIDIA-AI-IOT/ros2_trt_pose>`__: A ROS 2 package for human pose estimation.
* `ROS 2 Package for Hand Pose Estimation and Gesture Classification <https://github.com/NVIDIA-AI-IOT/ros2_trt_pose_hand>`__: A ROS 2 package for real-time hand pose estimation and gesture classification using TensorRT.
* `GPU accelerated ROS 2 Packages for Monocular Depth Estimation <https://github.com/NVIDIA-AI-IOT/ros2_torch2trt_examples>`__: ROS 2 package for NVIDIA GPU-accelerated torch2trtxb examples such as monocular depth estimation and text detection.
* `ROS 2 Package for Jetson stats <https://github.com/NVIDIA-AI-IOT/ros2_jetson_stats>`__: ROS 2 package for monitoring and controlling your NVIDIA Jetson [Xavier NX, Nano, AGX Xavier, TX1, TX2].
* `ROS 2 Packages for DeepStream SDK <https://github.com/NVIDIA-AI-IOT/ros2_deepstream>`__: ROS 2 package for NVIDIA DeepStream SDK.

Simulation Projects
-------------------
* `Isaac Sim Nav2 <https://docs.omniverse.nvidia.com/app_isaacsim/app_isaacsim/tutorial_ros2_navigation.html>`__ : In this ROS 2 sample, we are demonstrating Omniverse Isaac Sim integrated with the ROS 2 Nav2 project.
* `Isaac Sim Multiple Robot ROS 2 Navigation <https://docs.omniverse.nvidia.com/app_isaacsim/app_isaacsim/tutorial_ros2_multi_navigation.html>`__ : In this ROS 2 sample, we are demonstrating Omniverse Isaac Sim integrated with the ROS 2 Nav2 stack to perform simultaneous multiple robot navigation.

References
----------
More updates on NVIDIA Jetson ROS 2 can be found `here <https://nvidia-ai-iot.github.io/ros2_jetson/>`__.
",What kind of projects can be found within the NVIDIA ROS 2 ecosystem based on the text document provided?
".. redirect-from::

  Intel-ROS2-Projects

Intel ROS 2 Projects
====================

Intel® Robotics Open Source Project (Intel® ROS Project) to enable object detection/location/tracking, people detection, vehicle detection, industry robot arm grasp point analysis with kinds of Intel technologies and platforms, including CPU, GPU, `Intel® Movidius™ NCS <https://www.intel.com/content/www/us/en/developer/tools/neural-compute-stick/overview.html>`__ optimized deep learning backend, FPGA, `Intel® RealSense™ <https://www.intel.com/content/www/us/en/architecture-and-technology/realsense-overview.html>`__ camera, etc.

Key Projects
------------

We are working on below ROS 2 projects and publish source code through https://github.com/intel/ or ROS 2 GitHub repo gradually.

* `ROS2 OpenVINO <https://github.com/intel/ros2_openvino_toolkit>`__: ROS 2 package for Intel® Visual Inference and Neural Network Optimization Toolkit to develop multiplatform computer vision solutions.
* `ROS2 RealSense Camera <https://github.com/IntelRealSense/realsense-ros>`__: ROS 2 package for Intel® RealSense™ D400 serial cameras
* `ROS2 Movidius NCS <https://github.com/intel/ros2_intel_movidius_ncs>`__: ROS 2 package for object detection with Intel® Movidius™ Neural Computing Stick (NCS).
* `ROS2 Object Messages <https://github.com/intel/ros2_object_msgs>`__: ROS 2 messages for object.
* `ROS2 Object Analytics <https://github.com/intel/ros2_object_analytics>`__: ROS 2 package for object detection, tracking and 2D/3D localization.
* `ROS2 Message Filters <https://github.com/ros2/message_filters>`__: ROS 2 package for message synchronization with time stamp.
* `ROS2 CV Bridge <https://github.com/ros-perception/vision_opencv/tree/ros2/cv_bridge>`__: ROS 2 package to bridge with openCV.
* `ROS2 Object Map <https://github.com/intel/ros2_object_map>`__: ROS 2 package to mark tag of objects on map when SLAM based on information provided by ROS 2 object analytics.
* `ROS2 Moving Object <https://github.com/intel/ros2_moving_object>`__: ROS 2 package to provide object motion information (like object velocity on x, y, z axis) based on information provided by ROS 2 object analytics.
* `ROS2 Grasp Library <https://github.com/intel/ros2_grasp_library>`__: ROS 2 package for grasp position analysis, and compatible with `MoveIt <https://github.com/ros-planning/moveit2.git>`__ grasp interfaces.
* `ROS2 Navigation <https://github.com/ros-planning/navigation2>`__: ROS 2 package for robot navigation, it's already integrated to ROS 2 Crystal release.
* `Intel Robot DevKit (SDK) <https://github.com/intel/robot_devkit>`__: An open source project which enables developers to easily and efficiently create, customize, optimize, and deploy a robot software stack to an Autonomous Mobile Robot (AMR) platform based on the Robot Operating System 2 (ROS 2) framework.

Reference
---------

ROS components at: https://wiki.ros.org/IntelROSProject shows the relationship among those packages, which also applies to ROS 2.
",What is the purpose of the Intel® Robotics Open Source Project (Intel® ROS Project) and which Intel technologies and platforms are utilized in the projects?
"Beginner: Client libraries
==========================

.. toctree::
   :maxdepth: 1

   Beginner-Client-Libraries/Colcon-Tutorial
   Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace
   Beginner-Client-Libraries/Creating-Your-First-ROS2-Package
   Beginner-Client-Libraries/Writing-A-Simple-Cpp-Publisher-And-Subscriber
   Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber
   Beginner-Client-Libraries/Writing-A-Simple-Cpp-Service-And-Client
   Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client
   Beginner-Client-Libraries/Custom-ROS2-Interfaces
   Beginner-Client-Libraries/Single-Package-Define-And-Use-Interface
   Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP
   Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python
   Beginner-Client-Libraries/Getting-Started-With-Ros2doctor
   Beginner-Client-Libraries/Pluginlib
",What are some topics covered in the Beginner-Client-Libraries section related to ROS2 development?
"Demos
=====

.. toctree::
   :maxdepth: 1

   Demos/Quality-of-Service
   Demos/Managed-Nodes
   Demos/Intra-Process-Communication
   Demos/Rosbag-with-ROS1-Bridge
   Demos/Real-Time-Programming
   Demos/dummy-robot-demo
   Demos/Logging-and-logger-configuration
   Demos/Content-Filtering-Subscription
   Demos/Service-Introspection

External resources
------------------

* `Bridging communication between ROS 1 and ROS 2 <https://github.com/ros2/ros1_bridge/blob/master/README.md>`__
* `Motion planning for a MoveIt 2 arm <https://moveit.picknik.ai/main/index.html>`__
* Using Turtlebot 3 (community-contributed)

    - `Getting started <https://emanual.robotis.com/docs/en/platform/turtlebot3/quick-start/>`__
    - `Simulating <https://ubuntu.com/blog/simulate-the-turtlebot3>`__
    - `Navigating in simulation <https://github.com/cyberbotics/webots_ros2/wiki/Navigate-TurtleBot3>`__
    - `Learning SLAM in simulation <https://github.com/cyberbotics/webots_ros2/wiki/SLAM-with-TurtleBot3>`__

",What are some of the demos available for ROS 2 mentioned in the text?
"Beginner: CLI tools
===================

.. toctree::
   :maxdepth: 1

   Beginner-CLI-Tools/Configuring-ROS2-Environment
   Beginner-CLI-Tools/Introducing-Turtlesim/Introducing-Turtlesim
   Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes
   Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics
   Beginner-CLI-Tools/Understanding-ROS2-Services/Understanding-ROS2-Services
   Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters
   Beginner-CLI-Tools/Understanding-ROS2-Actions/Understanding-ROS2-Actions
   Beginner-CLI-Tools/Using-Rqt-Console/Using-Rqt-Console
   Beginner-CLI-Tools/Launching-Multiple-Nodes/Launching-Multiple-Nodes
   Beginner-CLI-Tools/Recording-And-Playing-Back-Data/Recording-And-Playing-Back-Data
","What is covered in the Beginner CLI Tools document regarding ROS2 environment configuration, Turtlesim introduction, nodes, topics, services, parameters, actions, Rqt Console usage, launching multiple nodes, and recording and playing back data?"
"Miscellaneous
=============

.. toctree::
   :maxdepth: 1

   Miscellaneous/Deploying-ROS-2-on-IBM-Cloud
   Miscellaneous/Eclipse-Oxygen-with-ROS-2-and-rviz2
   Miscellaneous/Building-Realtime-rt_preempt-kernel-for-ROS-2
   Miscellaneous/Building-ROS2-Package-with-eclipse-2021-06
",What are some of the topics covered under the Miscellaneous category in the text document?
"Intermediate
============

.. toctree::
   :maxdepth: 1

   Intermediate/Rosdep
   Intermediate/Creating-an-Action
   Intermediate/Writing-an-Action-Server-Client/Cpp
   Intermediate/Writing-an-Action-Server-Client/Py
   Intermediate/Writing-a-Composable-Node
   Intermediate/Composition
   Intermediate/Monitoring-For-Parameter-Changes-CPP
   Intermediate/Monitoring-For-Parameter-Changes-Python
   Intermediate/Launch/Launch-Main
   Intermediate/Tf2/Tf2-Main
   Intermediate/Testing/Testing-Main
   Intermediate/URDF/URDF-Main
   Intermediate/RViz/RViz-Main
","What are some topics covered in the ""Intermediate"" level section of the text document?"
"Advanced
========

.. toctree::
   :maxdepth: 1

   Advanced/Topic-Statistics-Tutorial/Topic-Statistics-Tutorial
   Advanced/Discovery-Server/Discovery-Server
   Advanced/Allocator-Template-Tutorial
   Advanced/FastDDS-Configuration
   Advanced/Improved-Dynamic-Discovery
   Advanced/Recording-A-Bag-From-Your-Own-Node-CPP
   Advanced/Recording-A-Bag-From-Your-Own-Node-Py
   Advanced/Reading-From-A-Bag-File-CPP
   Advanced/Reading-From-A-Bag-File-Python
   Advanced/ROS2-Tracing-Trace-and-Analyze
   Advanced/Simulators/Simulation-Main
   Advanced/Security/Security-Main
","What topics are covered in the ""Advanced"" section of the document?"
".. redirect-from::

    Deploying-ROS2-on-IBM-Cloud
    Tutorials/Deploying-ROS-2-on-IBM-Cloud

Deploying on IBM Cloud Kubernetes [community-contributed]
=========================================================


.. contents:: Table of Contents
   :depth: 3
   :local:

About
-----

This article describes how to get ROS 2 running on IBM Cloud using Docker files. It first gives a brief overview of docker images and how they work locally and then explores IBM Cloud and how the user can deploy their containers on it.
Afterwards, a short description of how the user can use their own custom packages for ROS 2 from github on IBM Cloud is provided.
A walkthrough of how to create a cluster and utilize Kubernetes on IBM Cloud is provided and finally the Docker image is deployed on the cluster.
Originally published `here <https://github.com/mm-nasr/ros2_ibmcloud>`__ and `here <https://medium.com/@mahmoud-nasr/running-ros2-on-ibm-cloud-1b1284cbd487>`__.

ROS 2 on IBM Cloud
------------------

In this tutorial, we show how you can easily integrate and run ROS 2 on
IBM Cloud with your custom packages.

ROS 2 is the new generation of ROS which gives more control over
multi-robot formations. With the advancements of cloud computing, cloud
robotics are becoming more important in today's age. In this tutorial,
we will go through a short introduction on running ROS 2 on IBM Cloud. By
the end of the tutorial, you will be able to create your own packages in
ROS 2 and deploy them to the cloud using docker files.

The following instructions assume you're using Linux and have been
tested with Ubuntu 18.04 (Bionic Beaver).

Step 1: Setting up your system
-------------------------------

Before we go into how the exact process works, lets first make sure all
the required software is properly installed. We'll point you towards the
appropriate sources to set up your system and only highlight the details
that pertain to our use-case.

a) Docker files?
^^^^^^^^^^^^^^^^

Docker files are a form of containers that can run separate from your
system, this way, you can set-up potentially hundreds of different
projects without affecting one another. You can even set-up different
versions of Linux on one machine, without the need for virtual machine.
Docker files have an advantage of saving space and only utilizing your
system resources when running. In addition, dockers are versatile and
transferable. They contain all the required pre-requisites to run
separately, meaning that you can easily use a docker file for a specific
system or service without any cubersome steps!

Excited yet? Let's start off by installing docker to your system by
following the following `link <https://docs.docker.com/get-docker/>`__.
From the tutorial, you should have done some sanity checks to make sure
docker is properly set-up. Just in case, however, let's run the
following command once again that uses the hello-world docker image:

.. code-block:: bash

   $ sudo docker run hello-world

You should obtain the following output:

.. code-block:: bash

   Hello from Docker!
   This message shows that your installation appears to be working correctly.

   To generate this message, Docker took the following steps:
    1. The Docker client contacted the Docker daemon.
    2. The Docker daemon pulled the ""hello-world"" image from the Docker Hub.
       (amd64)
    3. The Docker daemon created a new container from that image which runs the
       executable that produces the output you are currently reading.
    4. The Docker daemon streamed that output to the Docker client, which sent it
       to your terminal.

   To try something more ambitious, you can run an Ubuntu container with:
    $ docker run -it ubuntu bash

   Share images, automate workflows, and more with a free Docker ID:
    https://hub.docker.com/

   For more examples and ideas, visit:
    https://docs.docker.com/get-started/

b) ROS 2 Image
^^^^^^^^^^^^^^

ROS
`announced <https://discourse.ros.org/t/announcing-official-docker-images-for-ros2/7381/2>`__
image containers for several ROS distributions in January 2019. More
detailed instructions on the use of ROS 2 docker images can be found
`here <https://hub.docker.com/_/ros/>`__.

Let's skip through that and get to real-deal right away; creating a
local ROS 2 docker. We'll create our own Dockerfile (instead of using a
ready Image) since we'll need this method for deployment on IBM Cloud.
First, we create a new directory which will hold our Dockerfile and any
other files we need later on and navigate to it. Using your favorite
$EDITOR of choice, open a new file named *Dockerfile* (make sure the
file naming is correct):

.. code-block:: bash

   $ mkdir ~/ros2_docker

   $ cd ~/ros2_docker

   $ $EDITOR Dockerfile

Insert the following in the *Dockerfile*, and save it (also found
`here <https://github.com/mm-nasr/ros2_ibmcloud/blob/main/dockers/ros2_basic/Dockerfile>`__):

.. code-block:: bash

   FROM ros:foxy

   # install ros package
   RUN apt-get update && apt-get install -y \
         ros-${ROS_DISTRO}-demo-nodes-cpp \
         ros-${ROS_DISTRO}-demo-nodes-py && \
       rm -rf /var/lib/apt/lists/* && mkdir /ros2_home

   WORKDIR /ros2_home

   # launch ros package
   CMD [""ros2"", ""launch"", ""demo_nodes_cpp"", ""talker_listener_launch.py""]

-  **FROM**: creates a layer from the ros:foxy Docker image
-  **RUN**: builds your container by installing vim into it and creating
   a directory called /ros2_home
-  **WORKDIR**: informs the container where the working directory should
   be for it

Of course, you are free to change the ROS distribution (*foxy* is used
here) or change the directory name. The above docker file sets up
ROS-foxy and installs the demo nodes for C++ and Python. Then it
launches a file which runs a talker and a listener node. We will see it
in action in just a few, but they act very similar to the
publisher-subscriber example found in the `ROS
wiki <https://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29>`__

Now, we are ready to build the docker image to run ROS 2 in it (yes, it
is THAT easy!).

**Note**: if you have errors due to insufficient privileges or
*permission denied*, try running the command with *sudo* privileges:

.. code-block:: bash

   $ docker build .

   # You will see a bunch of lines that execute the docker file instructions followed by:
   Successfully built 0dc6ce7cb487

*0dc6ce7cb487* will most probably be different for you, so keep note of
it and copy it somewhere for reference. You can always go back and check
the docker images you have on your system using:

.. code-block:: bash

   $ sudo docker ps -as

Now, run the docker file using:

.. code-block:: bash

   $ docker run -it 0dc6ce7cb487
   [INFO] [launch]: All log files can be found below /root/.ros/log/2020-10-28-02-41-45-177546-0b5d9ed123be-1
   [INFO] [launch]: Default logging verbosity is set to INFO
   [INFO] [talker-1]: process started with pid [28]
   [INFO] [listener-2]: process started with pid [30]
   [talker-1] [INFO] [1603852907.249886590] [talker]: Publishing: 'Hello World: 1'
   [listener-2] [INFO] [1603852907.250964490] [listener]: I heard: [Hello World: 1]
   [talker-1] [INFO] [1603852908.249786312] [talker]: Publishing: 'Hello World: 2'
   [listener-2] [INFO] [1603852908.250453386] [listener]: I heard: [Hello World: 2]
   [talker-1] [INFO] [1603852909.249882257] [talker]: Publishing: 'Hello World: 3'
   [listener-2] [INFO] [1603852909.250536089] [listener]: I heard: [Hello World: 3]
   [talker-1] [INFO] [1603852910.249845718] [talker]: Publishing: 'Hello World: 4'
   [listener-2] [INFO] [1603852910.250509355] [listener]: I heard: [Hello World: 4]
   [talker-1] [INFO] [1603852911.249506058] [talker]: Publishing: 'Hello World: 5'
   [listener-2] [INFO] [1603852911.250152324] [listener]: I heard: [Hello World: 5]
   [talker-1] [INFO] [1603852912.249556670] [talker]: Publishing: 'Hello World: 6'
   [listener-2] [INFO] [1603852912.250212678] [listener]: I heard: [Hello World: 6]

If it works correctly, you should see something similar to what is shown
above. As can be seen, there are two ROS nodes (a publisher and a
subscriber) running and their output is provided to us through ROS INFO.

Step 2: Running the image on IBM Cloud
--------------------------------------

The following steps assume you have an IBM cloud account and have
ibmcloud CLI installed. If not, please check this
`link <https://cloud.ibm.com/docs/cli/reference/ibmcloud/download_cli.html>`__
out to get that done first.

We also need to make sure that the CLI plug-in for the IBM Cloud
Container Registry is installed by running the command

.. code-block:: bash

   $ ibmcloud plugin install container-registry

Afterwards, login to your ibmcloud account through the terminal:

.. code-block:: bash

   $ ibmcloud login --sso

From here, let's create a container registry name-space. Make sure you
use a unique name that is also descriptive as to what it is. Here, I
used *ros2nasr*.

.. code-block:: bash

   $ ibmcloud cr namespace-add ros2nasr

IBM cloud has a lot of shortcuts that would help us get our container
onto the cloud right away. The command below builds the container and
tags it with the name **ros2foxy** and the version of **1**. Make sure
you use the correct registry name you created and you are free to change
the container name as you wish. The **.** at the end indicates that the
*Dockerfile* is in the current directory (and it is important), if not,
change it to point to the directory containing the Dockerfile.

.. code-block:: bash

   $ ibmcloud cr build --tag registry.bluemix.net/ros2nasr/ros2foxy:1 .

You can now make sure that the container has been pushed to the registry
you created by running the following command

.. code-block:: bash

   $ ibmcloud cr image-list
   Listing images...

   REPOSITORY               TAG   DIGEST         NAMESPACE   CREATED         SIZE     SECURITY STATUS
   us.icr.io/ros2nasr/ros2foxy   1     031be29301e6   ros2nasr    36 seconds ago   120 MB   No Issues

   OK

Next, it is important to log-in to your registry to run the docker
image. Again, if you face a *permission denied* error, perform the
command with sudo privileges. Afterwards, run your docker file as shown
below.

.. code-block:: bash

   $ ibmcloud cr login
   Logging in to 'registry.ng.bluemix.net'...
   Logged in to 'registry.ng.bluemix.net'.
   Logging in to 'us.icr.io'...
   Logged in to 'us.icr.io'.

   OK

   $ docker run -v -it registry.ng.bluemix.net/ros2nasr/ros2foxy:1

Where *ros2nasr* is the name of the registry you created and
*ros2foxy:1* is the tag of the docker container and the version as
explained previously.

You should now see your docker file running and providing similar output
to that you saw when you ran it locally on your machine.

Step 3: Using Custom ROS 2 Packages
-----------------------------------

So now we have the full pipeline working, from creating the Dockerfile,
all the way to deploying it and seeing it work on IBM Cloud. But, what
if we want to use a custom set of packages we (or someone else) created?

Well that all has to do with how you set-up your Dockerfile. Lets use
the example provided by ROS 2 `here <https://hub.docker.com/_/ros/>`__.
Create a new directory with a new Dockerfile (or overwrite the existing
one) and add the following in it (or download the file
`here <https://github.com/mm-nasr/ros2_ibmcloud/blob/main/dockers/git_pkgs_docker/Dockerfile>`__)

.. code-block:: bash

   ARG FROM_IMAGE=ros:foxy
   ARG OVERLAY_WS=/opt/ros/overlay_ws

   # multi-stage for caching
   FROM $FROM_IMAGE AS cacher

   # clone overlay source
   ARG OVERLAY_WS
   WORKDIR $OVERLAY_WS/src
   RUN echo ""\
   repositories: \n\
     ros2/demos: \n\
       type: git \n\
       url: https://github.com/ros2/demos.git \n\
       version: ${ROS_DISTRO} \n\
   "" > ../overlay.repos
   RUN vcs import ./ < ../overlay.repos

   # copy manifests for caching
   WORKDIR /opt
   RUN mkdir -p /tmp/opt && \
       find ./ -name ""package.xml"" | \
         xargs cp --parents -t /tmp/opt && \
       find ./ -name ""COLCON_IGNORE"" | \
         xargs cp --parents -t /tmp/opt || true

   # multi-stage for building
   FROM $FROM_IMAGE AS builder

   # install overlay dependencies
   ARG OVERLAY_WS
   WORKDIR $OVERLAY_WS
   COPY --from=cacher /tmp/$OVERLAY_WS/src ./src
   RUN . /opt/ros/$ROS_DISTRO/setup.sh && \
       apt-get update && rosdep install -y \
         --from-paths \
           src/ros2/demos/demo_nodes_cpp \
           src/ros2/demos/demo_nodes_py \
         --ignore-src \
       && rm -rf /var/lib/apt/lists/*

   # build overlay source
   COPY --from=cacher $OVERLAY_WS/src ./src
   ARG OVERLAY_MIXINS=""release""
   RUN . /opt/ros/$ROS_DISTRO/setup.sh && \
       colcon build \
         --packages-select \
           demo_nodes_cpp \
           demo_nodes_py \
         --mixin $OVERLAY_MIXINS

   # source entrypoint setup
   ENV OVERLAY_WS $OVERLAY_WS
   RUN sed --in-place --expression \
         '$isource ""$OVERLAY_WS/install/setup.bash""' \
         /ros_entrypoint.sh

   # run launch file
   CMD [""ros2"", ""launch"", ""demo_nodes_cpp"", ""talker_listener_launch.py""]

Going through the lines shown, we can see how we can add custom packages
from github in 4 steps:

1. Create an overlay with custom packages cloned from Github:

.. code-block:: bash

   ARG OVERLAY_WS
   WORKDIR $OVERLAY_WS/src
   RUN echo ""\
   repositories: \n\
     ros2/demos: \n\
       type: git \n\
       url: https://github.com/ros2/demos.git \n\
       version: ${ROS_DISTRO} \n\
   "" > ../overlay.repos
   RUN vcs import ./ < ../overlay.repos

2. Install package dependencies using rosdep

.. code-block:: bash

   # install overlay dependencies
   ARG OVERLAY_WS
   WORKDIR $OVERLAY_WS
   COPY --from=cacher /tmp/$OVERLAY_WS/src ./src
   RUN . /opt/ros/$ROS_DISTRO/setup.sh && \
       apt-get update && rosdep install -y \
         --from-paths \
           src/ros2/demos/demo_nodes_cpp \
           src/ros2/demos/demo_nodes_py \
         --ignore-src \
       && rm -rf /var/lib/apt/lists/*

3. Build the packages *you need*

.. code-block:: bash

   # build overlay source
   COPY --from=cacher $OVERLAY_WS/src ./src
   ARG OVERLAY_MIXINS=""release""
   RUN . /opt/ros/$ROS_DISTRO/setup.sh && \
       colcon build \
         --packages-select \
           demo_nodes_cpp \
           demo_nodes_py \
         --mixin $OVERLAY_MIXINS

4. Running the launch file

.. code-block:: bash

   # run launch file
   CMD [""ros2"", ""launch"", ""demo_nodes_cpp"", ""talker_listener_launch.py""]

Likewise, we can change the packages used, install their dependencies,
and then run them.

**Back to IBM Cloud**

With this Dockerfile, we can follow the same steps we did before to
deploy it on IBM Cloud. Since we already have our registry created, and
we're logged in to IBM Cloud, we directly build our new Dockerfile.
Notice how I kept the tag the same but changed the version, this way I
can update the docker image created previously. (You are free to create
a completely new one if you want)

.. code-block:: bash

   $ ibmcloud cr build --tag registry.bluemix.net/ros2nasr/ros2foxy:2 .

Then, make sure you are logged in to the registry and run the new docker
image:

.. code-block:: bash

   $ ibmcloud cr login
   Logging in to 'registry.ng.bluemix.net'...
   Logged in to 'registry.ng.bluemix.net'.
   Logging in to 'us.icr.io'...
   Logged in to 'us.icr.io'.

   OK

   $ docker run -v -it registry.ng.bluemix.net/ros2nasr/ros2foxy:2

You should see, again, the same output. However, this time we did it
through custom packages from github, which allows us to utilize our
personally created packages for ROS 2 on IBM Cloud.

Extra: Deleting Docker Images
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As you may find yourself in need of deleting a specific docker image(s)
from IBM Cloud, this is how you should go about it!

1. List all the images you have and find all the ones that share the
   *IMAGE* name corresponding to
   *registry.ng.bluemix.net/ros2nasr/ros2foxy:2* (in my case). Then
   delete them using their *NAMES*

.. code-block:: bash

   $ docker rm your_docker_NAMES

2. Delete the docker image from IBM Cloud using its *IMAGE* name

.. code-block:: bash

   $ docker rmi registry.ng.bluemix.net/ros2nasr/ros2foxy:2

Step 4: Kubernetes
-------------------

a) Creating the Cluster
^^^^^^^^^^^^^^^^^^^^^^^

Create a cluster using the Console. The instructions are found
`here <https://cloud.ibm.com/docs/containers?topic=containers-clusters#clusters_ui>`__.
The settings used are detailed below. These are merely suggestions and
can be changed if you need to. However, make sure you understand the
implications of your choices:

1. Plan: *Standard*

2. Orchestration Service: *Kubernetes v1.18.10*

3. Infrastructure: *Classic*

4. Location:

-  Resource group: *Default*

-  Geography: *North America* (you are free to change this)

-  Availability: *Single zone* (you are free to change this but make
   sure you understand the impact of your choices by checking the IBM
   Cloud documentation.)

-  Worker Zone: *Toronto 01* (choose the location that is physically
   closest to you)

5. Worker Pool:

-  Virtual - shared, Ubuntu 18

-  Memory: 16 GB

-  Worker nodes per zone: *1*

6. Master service endpoint: *Both private & public endpoints*

7. Resource details (Totally flexible):

-  Cluster name: *mycluster-tor01-rosibm*

-  Tags: *version:1*

After you create your cluster, you will be redirected to a page which
details how you can set up the CLI tools and access your cluster. Please
follow these instructions (or check the instructions
`here <https://github.com/mm-nasr/ros2_ibmcloud/blob/main/Kubernetes-Cluster-Set-up.md>`__)and
wait for the progress bar to show that the worker nodes you created are
ready by indicating *Normal* next to the cluster name. You can also
reach this screen from the IBM Cloud Console inside the Kubernetes.

b) Deploying your Docker Image *Finally!*
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

1. Create a deployment configuration yaml file named
   *ros2-deployment.yaml* using your favorite $EDITOR and insert the
   following in it:

.. code-block:: bash

   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: <deployment>
   spec:
     replicas: <number_of_replicas>
     selector:
       matchLabels:
         app: <app_name>
     template:
       metadata:
         labels:
           app: <app_name>
       spec:
         containers:
         - name: <app_name>
           image: <region>.icr.io/<namespace>/<image>:<tag>

You should replace the tags shown between *""<"" "">""* as described
`here <https://cloud.ibm.com/docs/containers?topic=containers-images#namespace>`__.
The file in my case would look something like this:

.. code-block:: bash

   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: ros2-deployment
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: ros2-ibmcloud
     template:
       metadata:
         labels:
           app: ros2-ibmcloud
       spec:
         containers:
         - name: ros2-ibmcloud
           image: us.icr.io/ros2nasr/ros2foxy:2

Deploy the file using the following command

.. code-block:: bash

   $ kubectl apply -f ros2-deployment.yaml
   deployment.apps/ros2-deployment created

Now your docker image is fully deployed on your cluster!

Step 5: Using CLI for your Docker Image
---------------------------------------

1. Navigate to your cluster through the IBM Cloud console Kubernetes.

2. Click on *Kubernetes dashboard* on the top right corner of the page.

You should now be able to see a full list of all the different
parameters of your cluster as well as its CPU and Memory Usage.

3. Navigate to *Pods* and click on your deployment.

4. On the top right corner, click on *Exec into pod*

Now you are inside your docker image! You can source your workspace (if
needed) and run ROS 2! For example:

.. code-block:: bash

   root@ros2-deployment-xxxxxxxx:/opt/ros/overlay_ws# . install/setup.sh
   root@ros2-deployment-xxxxxxxx:/opt/ros/overlay_ws# ros2 launch demo_nodes_cpp talker_listener_launch.py

Final Remarks
---------------

At this point, you are capable of creating your own docker image using ROS 2 packages on github. It is also possible, with little changes to utilize local ROS 2 packages as well. This could be the topic of another article. However, you are encouraged to check out the following `Dockerfile <https://github.com/mm-nasr/ros2_ibmcloud/tree/main/dockers/local_pkgs_docker>`__ which uses a local copy of the demos repository. Similarly, you can use your own local package.
",What is the recommended method described in the text for deploying a Docker image with custom ROS 2 packages on IBM Cloud?
".. redirect-from::

    Eclipse-Oxygen-with-ROS-2-and-rviz2
    Tutorials/Eclipse-Oxygen-with-ROS-2-and-rviz2

Using Eclipse Oxygen with ``rviz2`` [community-contributed]
===========================================================

.. contents:: Table of Contents
   :depth: 1
   :local:

Setup
-----

This tutorial assumes Eclipse Oxygen, git, and Egit (http://www.eclipse.org/egit/download/) are already installed.

Throughout the tutorial we name the eclipse workspace the same name as the ros2 package, but this is not required.

HINT: We use nested projects and one Eclipse Workspace for each ROS-2 package.

.. image:: images/eclipse-oxygen-01.png


Create a C++ Project.

.. image:: images/eclipse-oxygen-02.png



.. image:: images/eclipse-oxygen-03.png


Choose the ROS 2 package name as the Project Name.
Choose a Makefile Project and Other Toolchain.

.. image:: images/eclipse-oxygen-04.png


Click on Finish

.. image:: images/eclipse-oxygen-05.png


Our project should be shown in the ""Project Explorer"".

.. image:: images/eclipse-oxygen-06.png


Inside our Project create a folder called ""src"".

.. image:: images/eclipse-oxygen-07.png


Import a git repository.

.. image:: images/eclipse-oxygen-08.png


Put in the repository URL.

.. image:: images/eclipse-oxygen-09.png


IMPORTANT: Use the source folder of the project we created before as the destination folder.

HINT: If you ran into problems choosing the destination folder path, the Eclipse Dialog needs a name in the name field.

.. image:: images/eclipse-oxygen-10.png


Import using the new project wizard.

.. image:: images/eclipse-oxygen-11.png


Create a General->Project.

.. image:: images/eclipse-oxygen-12.png


Use the git repository name as the project name.
IMPORTANT: Use the folder we cloned the git repository in as the ""Location"".

.. image:: images/eclipse-oxygen-13.png


The git project and the new project should be visible in the Project Explorer view.
The same files are listed multiple times, but only one project is linked with Egit.

.. image:: images/eclipse-oxygen-14.png


Repeat this procedure again.
Import git repository pluginlib.

.. image:: images/eclipse-oxygen-15.png


IMPORTANT: Use a folder inside the source folder as ""Destination->Directory"".

.. image:: images/eclipse-oxygen-16.png


IMPORTANT: Use the folder we cloned the git repository in as the location for the new project.

.. image:: images/eclipse-oxygen-17.png


Run the same procedure with the tinyxml2_vendor git repository.

.. image:: images/eclipse-oxygen-18.png


IMPORTANT: Again use a folder inside the source folder.

.. image:: images/eclipse-oxygen-19.png


IMPORTANT: Use the location of the folder we cloned as the new project folder.

.. image:: images/eclipse-oxygen-20.png


Now all four Projects should be visible in the Project Explorer view.

.. image:: images/eclipse-oxygen-21.png


Clicking in the top right cornder for the Project Explorer view allows us to change the Project Presentation to Hierarchical view.
Now it looks like a ROS-2 project as it is on the hard drive.
But this view loses the linkage to Egit, so use the Flat Project Presentation.
The Egit linkage is good if you want to see e.g. which author wrote which code-line, etc.

.. image:: images/eclipse-oxygen-22.png


Go to ""C/C++ build""-section and put ""ament"" into ""Build command"".

.. image:: images/eclipse-oxygen-23.png


Go to ""Behavior"" tab and unselect ""clean"" and put ""build"" into Build textbox.

.. image:: images/eclipse-oxygen-24.png


Before ""Build project"" will work, we need to close Eclipse.
Open a shell and source the ROS-2 setup.bash file, then cd into the directory of the eclipse project (here: /home/ubu/rviz2_ws/rviz2_ws) and start Eclipse from inside this directory.

.. image:: images/eclipse-oxygen-25.png


Now code completion, egit annotations, eclipse C/C++ Tools, etc. should all work.

.. image:: images/eclipse-oxygen-26.png


Eclipse-indexer
---------------

Opening the main.cpp of rviz2 may show a lot of ""unresolved inclusion"" warnings.
To fix this, go to Project->Properties->C++ General->Path and Symbols.
Click on the ""References"" tab and select ""ros2_ws"".


.. image:: images/eclipse-oxygen-27.png


Go to C/C++-General->Path-and-Symbols, click on the ""Source locations"" tab and click on ""Link folder"".
Choose the location of qt5 includes.


.. image:: images/eclipse-oxygen-28.png


The next image should be shown.
It is a good idea to add excludes to the source locations, so that some directories (like ""Build"" and ""Install"") don't get indexed.


.. image:: images/eclipse-oxygen-29.png


Go to C++General->Preprocessor includes, select ""CDT GCC Built in compiler settings [Shared]"" and enter in the ""command to get compiler specs"" text box the following:

.. code-block:: bash

   -std=c++14


.. image:: images/eclipse-oxygen-30.png


Go to ""C/C++-General->Indexer"" and select the following in the image.
E.g ""index unused headers as c files"" to resolve e.g. QApplication, because the QApplication headers content is only ""#include ""qapplication.h"".


.. image:: images/eclipse-oxygen-31.png


After running the indexer (which happens later, so you will see this also later), you can see what it added


.. image:: images/eclipse-oxygen-32.png


After that right-click on the rviz2 project and select ""Indexer->Rebuild"", which will start rebuilding the index (there is an icon in the lower right showing progress).
Once the index is finished rebuilding, it should be able to resolve all includes.


.. image:: images/eclipse-oxygen-33.png


Debugging with eclipse
----------------------

Go to ""C/C++-Build"" and add to the build command:

.. code-block:: bash

   -DCMAKE_BUILD_TYPE=Debug


.. image:: images/eclipse-oxygen-34.png


Then in eclipse go to ""Run->Debug Configurations"" and add the following and click on ""Debug"".


.. image:: images/eclipse-oxygen-35.png
","What is the recommended step to resolve ""unresolved inclusion"" warnings in Eclipse when working with the main.cpp file of rviz2?"
".. redirect-from::

    Building-Realtime-rt_preempt-kernel-for-ROS-2
    Tutorials/Building-Realtime-rt_preempt-kernel-for-ROS-2

Building a real-time Linux kernel [community-contributed]
=========================================================

This tutorial begins with a clean Ubuntu 20.04.1 install on Intel x86_64. Actual kernel is 5.4.0-54-generic, but we will install the Latest Stable RT_PREEMPT Version. To build the kernel you need at least 30GB free disk space.

Check https://wiki.linuxfoundation.org/realtime/start for the latest stable version, at the time of writing this is ""Latest Stable Version 5.4-rt"".
If we click on the `link <http://cdn.kernel.org/pub/linux/kernel/projects/rt/5.4/>`_, we get the exact version.
Currently it is patch-5.4.78-rt44.patch.gz.

.. image:: images/realtime-kernel-patch-version.png

We create a directory in our home dir with

.. code-block:: bash

   mkdir ~/kernel

and switch into it with

.. code-block:: bash

   cd ~/kernel

We can go with a browser to https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/ and see if the version is there. You can download it from the site and move it manually from /Downloads to the /kernel folder, or download it using wget by right clicking the link using ""copy link location"". Example:

.. code-block:: bash

   wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.78.tar.gz

unpack it with

.. code-block:: bash

   tar -xzf linux-5.4.78.tar.gz

download rt_preempt patch matching the Kernel version we just downloaded over at http://cdn.kernel.org/pub/linux/kernel/projects/rt/5.4/

.. code-block:: bash

   wget http://cdn.kernel.org/pub/linux/kernel/projects/rt/5.4/older/patch-5.4.78-rt44.patch.gz

unpack it with

.. code-block:: bash

   gunzip patch-5.4.78-rt44.patch.gz

Then switch into the linux directory with

.. code-block:: bash

   cd linux-5.4.78/

and patch the kernel with the realtime patch

.. code-block:: bash

   patch -p1 < ../patch-5.4.78-rt44.patch

We simply want to use the config of our Ubuntu installation, so we get the Ubuntu config with

.. code-block:: bash

   cp /boot/config-5.4.0-54-generic .config

Open Software & Updates. in the Ubuntu Software menu tick the 'Source code' box

We need some tools to build kernel, install them with

.. code-block:: bash

   sudo apt-get build-dep linux
   sudo apt-get install libncurses-dev flex bison openssl libssl-dev dkms libelf-dev libudev-dev libpci-dev libiberty-dev autoconf fakeroot

To enable all Ubuntu configurations, we simply use

.. code-block:: bash

   yes '' | make oldconfig

Then we need to enable rt_preempt in the kernel. We call

.. code-block:: bash

   make menuconfig

and set the following

.. code-block:: bash

  # Enable CONFIG_PREEMPT_RT
   -> General Setup
    -> Preemption Model (Fully Preemptible Kernel (Real-Time))
     (X) Fully Preemptible Kernel (Real-Time)

  # Enable CONFIG_HIGH_RES_TIMERS
   -> General setup
    -> Timers subsystem
     [*] High Resolution Timer Support

  # Enable CONFIG_NO_HZ_FULL
   -> General setup
    -> Timers subsystem
     -> Timer tick handling (Full dynticks system (tickless))
      (X) Full dynticks system (tickless)

  # Set CONFIG_HZ_1000 (note: this is no longer in the General Setup menu, go back twice)
   -> Processor type and features
    -> Timer frequency (1000 HZ)
     (X) 1000 HZ

  # Set CPU_FREQ_DEFAULT_GOV_PERFORMANCE [=y]
   ->  Power management and ACPI options
    -> CPU Frequency scaling
     -> CPU Frequency scaling (CPU_FREQ [=y])
      -> Default CPUFreq governor (<choice> [=y])
       (X) performance

Save and exit menuconfig. Now we're going to build the kernel which will take quite some time. (10-30min on a modern cpu)

.. code-block:: bash

   make -j `nproc` deb-pkg

After the build is finished check the deb packages

.. code-block:: bash

   ls ../*deb
   ../linux-headers-5.4.78-rt41_5.4.78-rt44-1_amd64.deb  ../linux-image-5.4.78-rt44-dbg_5.4.78-rt44-1_amd64.deb
   ../linux-image-5.4.78-rt41_5.4.78-rt44-1_amd64.deb    ../linux-libc-dev_5.4.78-rt44-1_amd64.deb

Then we install all kernel deb packages

.. code-block:: bash

   sudo dpkg -i ../*.deb

Now the real time kernel should be installed. Reboot the system and check the new kernel version

.. code-block:: bash

   sudo reboot
   uname -a
   Linux ros2host 5.4.78-rt44 #1 SMP PREEMPT_RT Fri Nov 6 10:37:59 CET 2020 x86_64 xx
",What steps are required to enable real-time kernel support in Ubuntu and install a real-time kernel version?
".. redirect-from::

    Tutorials/Building-ROS2-Package-with-eclipse-2021-06

Building a package with Eclipse 2021-06
=======================================

.. contents:: Table of Contents
   :depth: 2
   :local:

You cannot create a ROS 2 package with eclipse, you need to create it with commandline tools.
Follow the :doc:`Create a package <../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>` tutorial.

After you created your project, you can edit the source code and build it with eclipse.

We start eclipse and select a eclipse-workspace.

.. image:: images/eclipse_work_dir.png
   :target: images/eclipse_work_dir.png
   :alt: eclipse_work_dir

We create a C++ project

.. image:: images/eclipse_create_c++_project.png
   :target: images/eclipse_create_c++_project.png
   :alt: eclipse_create_c++_project


.. image:: images/eclipse_c++_project_select_type.png
   :target: images/eclipse_c++_project_select_type.png
   :alt: eclipse_c++_project_select_type

We see that we got C++ includes.

.. image:: images/eclipse_c++_project_includes.png
   :target: images/eclipse_c++_project_includes.png
   :alt: eclipse_c++_project_includes


We now import our ROS 2 project. The code is still in the old place.

.. image:: images/eclipse_import_project.png
   :target: images/eclipse_import_project.png
   :alt: eclipse_import_project

.. image:: images/eclipse_import_filesystem.png
   :target: images/eclipse_import_filesystem.png
   :alt: eclipse_import_filesystem

Click the Advanced in the Options and check the **Create links in worksapce**.

.. image:: images/eclipse_import_select_my_package.png
   :target: images/eclipse_import_select_my_package.png
   :alt: eclipse_import_select_my_package



We see in the source code that the C++ includes got resolved but not the ROS 2 ones.

.. image:: images/eclipse_c++_wo_ros_includes.png
   :target: images/eclipse_c++_wo_ros_includes.png
   :alt: eclipse_c++_wo_ros_includes


.. image:: images/eclipse_c++_path_and_symbols.png
   :target: images/eclipse_c++_path_and_symbols.png
   :alt: eclipse_c++_path_and_symbols

Add include paths of needed packages.
(e.g. **/opt/ros/iron/include/rclcpp**, **/opt/ros/iron/include/std_msgs**, etc.)

.. image:: images/eclipse_c++_add_directory_path.png
   :target: images/eclipse_c++_add_directory_path.png
   :alt: eclipse_c++_add_directory_path


We now see that the ROS 2 includes got resolved too.

.. image:: images/eclipse_c++_indexer_ok.png
   :target: images/eclipse_c++_indexer_ok.png
   :alt: eclipse_c++_indexer_ok


Adding Builder colcon, so that we can build with right-click on project and ""Build project"".

.. image:: images/eclipse_c++_properties_builders.png
   :target: images/eclipse_c++_properties_builders.png
   :alt: eclipse_c++_properties_builders


.. image:: images/eclipse_c++_builder_main.png
   :target: images/eclipse_c++_builder_main.png
   :alt: eclipse_c++_builder_main


With PYTHONPATH you can also build python projects.

.. image:: images/eclipse_c++_builder_env.png
   :target: images/eclipse_c++_builder_env.png
   :alt: eclipse_c++_builder_env


.. image:: images/eclipse_c++_properties_builders_with_colcon.png
   :target: images/eclipse_c++_properties_builders_with_colcon.png
   :alt: eclipse_c++_properties_builders_with_colcon


Right-click on the project and select ""Build Project"".

.. image:: images/eclipse_c++_build_project_with_colcon.png
   :target: images/eclipse_c++_build_project_with_colcon.png
   :alt: eclipse_c++_build_project_with_colcon
",How can you add include paths of needed packages in Eclipse for a ROS 2 project?
".. redirect-from::

    Tutorials/Configuring-ROS2-Environment

.. _ConfigROS2:

Configuring environment
=======================

**Goal:** This tutorial will show you how to prepare your ROS 2 environment.

**Tutorial level:** Beginner

**Time:** 5 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

ROS 2 relies on the notion of combining workspaces using the shell environment.
""Workspace"" is a ROS term for the location on your system where you're developing with ROS 2.
The core ROS 2 workspace is called the underlay.
Subsequent local workspaces are called overlays.
When developing with ROS 2, you will typically have several workspaces active concurrently.

Combining workspaces makes developing against different versions of ROS 2, or against different sets of packages, easier.
It also allows the installation of several ROS 2 distributions (or “distros”, e.g. Dashing and Eloquent) on the same computer and switching between them.

This is accomplished by sourcing setup files every time you open a new shell, or by adding the source command to your shell startup script once.
Without sourcing the setup files, you won't be able to access ROS 2 commands, or find or use ROS 2 packages.
In other words, you won't be able to use ROS 2.

Prerequisites
-------------

Before starting these tutorials, install ROS 2 by following the instructions on the ROS 2 :doc:`../../Installation` page.

The commands used in this tutorial assume you followed the binary packages installation guide for your operating system (deb packages for Linux).
You can still follow along if you built from source, but the path to your setup files will likely be different.
You also won't be able to use the ``sudo apt install ros-<distro>-<package>`` command (used frequently in the beginner level tutorials) if you install from source.

If you are using Linux or macOS, but are not already familiar with the shell, `this tutorial <https://www.linux.com/training-tutorials/bash-101-working-cli/>`__ will help.

Tasks
-----

1 Source the setup files
^^^^^^^^^^^^^^^^^^^^^^^^

You will need to run this command on every new shell you open to have access to the ROS 2 commands, like so:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: bash

        # Replace "".bash"" with your shell if you're not using bash
        # Possible values are: setup.bash, setup.sh, setup.zsh
        source /opt/ros/{DISTRO}/setup.bash

   .. group-tab:: macOS

      .. code-block:: console

        . ~/ros2_install/ros2-osx/setup.bash

   .. group-tab:: Windows

      .. code-block:: console

        call C:\dev\ros2\local_setup.bat

.. note::
    The exact command depends on where you installed ROS 2.
    If you're having problems, ensure the file path leads to your installation.

2 Add sourcing to your shell startup script
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you don't want to have to source the setup file every time you open a new shell (skipping task 1), then you can add the command to your shell startup script:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        echo ""source /opt/ros/{DISTRO}/setup.bash"" >> ~/.bashrc

     To undo this, locate your system's shell startup script and remove the appended source command.

   .. group-tab:: macOS

      .. code-block:: console

        echo ""source ~/ros2_install/ros2-osx/setup.bash"" >> ~/.bash_profile

      To undo this, locate your system's shell startup script and remove the appended source command.

   .. group-tab:: Windows

      Only for PowerShell users, create a folder in 'My Documents' called 'WindowsPowerShell'.
      Within 'WindowsPowerShell', create file 'Microsoft.PowerShell_profile.ps1'.
      Inside the file, paste:

      .. code-block:: console

        C:\dev\ros2_{DISTRO}\local_setup.ps1

      PowerShell will request permission to run this script everytime a new shell is opened.
      To avoid that issue you can run:

      .. code-block:: console

        Unblock-File C:\dev\ros2_{DISTRO}\local_setup.ps1

      To undo this, remove the new 'Microsoft.PowerShell_profile.ps1' file.

3 Check environment variables
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sourcing ROS 2 setup files will set several environment variables necessary for operating ROS 2.
If you ever have problems finding or using your ROS 2 packages, make sure that your environment is properly set up using the following command:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        printenv | grep -i ROS

   .. group-tab:: macOS

      .. code-block:: console

        printenv | grep -i ROS

   .. group-tab:: Windows

      .. code-block:: console

        set | findstr -i ROS

Check that variables like ``ROS_DISTRO`` and ``ROS_VERSION`` are set.

::

  ROS_VERSION=2
  ROS_PYTHON_VERSION=3
  ROS_DISTRO={DISTRO}

If the environment variables are not set correctly, return to the ROS 2 package installation section of the installation guide you followed.
If you need more specific help (because environment setup files can come from different places), you can `get answers <https://robotics.stackexchange.com/>`__ from the community.

3.1 The ``ROS_DOMAIN_ID`` variable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

See the `domain ID <../../Concepts/Intermediate/About-Domain-ID>` article for details on ROS domain IDs.

Once you have determined a unique integer for your group of ROS 2 nodes, you can set the environment variable with the following command:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        export ROS_DOMAIN_ID=<your_domain_id>

      To maintain this setting between shell sessions, you can add the command to your shell startup script:

      .. code-block:: console

        echo ""export ROS_DOMAIN_ID=<your_domain_id>"" >> ~/.bashrc

   .. group-tab:: macOS

      .. code-block:: console

        export ROS_DOMAIN_ID=<your_domain_id>

      To maintain this setting between shell sessions, you can add the command to your shell startup script:

      .. code-block:: console

        echo ""export ROS_DOMAIN_ID=<your_domain_id>"" >> ~/.bash_profile

   .. group-tab:: Windows

      .. code-block:: console

        set ROS_DOMAIN_ID=<your_domain_id>

      If you want to make this permanent between shell sessions, also run:

      .. code-block:: console

        setx ROS_DOMAIN_ID <your_domain_id>

3.2 The ``ROS_AUTOMATIC_DISCOVERY_RANGE`` variable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, ROS 2 communication is not limited to localhost.
``ROS_AUTOMATIC_DISCOVERY_RANGE`` environment variable allows you to limit ROS 2 discovery range.
Using ``ROS_AUTOMATIC_DISCOVERY_RANGE`` is helpful in certain settings, such as classrooms, where multiple robots may publish to the same topic causing strange behaviors.
See :ref:`Improved Dynamic Discovery <ImprovedDynamicDiscovery>` for more details.

Summary
-------

The ROS 2 development environment needs to be correctly configured before use.
This can be done in two ways: either sourcing the setup files in every new shell you open, or adding the source command to your startup script.

If you ever face any problems locating or using packages with ROS 2, the first thing you should do is check your environment variables and ensure they are set to the version and distro you intended.

Next steps
----------

Now that you have a working ROS 2 installation and you know how to source its setup files, you can start learning the ins and outs of ROS 2 with the :doc:`turtlesim tool <./Introducing-Turtlesim/Introducing-Turtlesim>`.
",What are the two ways mentioned in the text to configure the ROS 2 development environment before use?
".. redirect-from::

    Tutorials/Understanding-ROS2-Actions

.. _ROS2Actions:

Understanding actions
=====================

**Goal:** Introspect actions in ROS 2.

**Tutorial level:** Beginner

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

Actions are one of the communication types in ROS 2 and are intended for long running tasks.
They consist of three parts: a goal, feedback, and a result.

Actions are built on topics and services.
Their functionality is similar to services, except actions can be canceled.
They also provide steady feedback, as opposed to services which return a single response.

Actions use a client-server model, similar to the publisher-subscriber model (described in the :doc:`topics tutorial <../Understanding-ROS2-Topics/Understanding-ROS2-Topics>`).
An ""action client"" node sends a goal to an ""action server"" node that acknowledges the goal and returns a stream of feedback and a result.

.. image:: images/Action-SingleActionClient.gif

Prerequisites
-------------

This tutorial builds off concepts, like :doc:`nodes <../Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>` and :doc:`topics <../Understanding-ROS2-Topics/Understanding-ROS2-Topics>`, covered in previous tutorials.

This tutorial uses the :doc:`turtlesim package <../Introducing-Turtlesim/Introducing-Turtlesim>`.

As always, don't forget to source ROS 2 in :doc:`every new terminal you open <../Configuring-ROS2-Environment>`.

Tasks
-----

1 Setup
^^^^^^^

Start up the two turtlesim nodes, ``/turtlesim`` and ``/teleop_turtle``.

Open a new terminal and run:

.. code-block:: console

    ros2 run turtlesim turtlesim_node

Open another terminal and run:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key


2 Use actions
^^^^^^^^^^^^^

When you launch the ``/teleop_turtle`` node, you will see the following message in your terminal:

.. code-block:: console

    Use arrow keys to move the turtle.
    Use G|B|V|C|D|E|R|T keys to rotate to absolute orientations. 'F' to cancel a rotation.

Let's focus on the second line, which corresponds to an action.
(The first instruction corresponds to the ""cmd_vel"" topic, discussed previously in the :doc:`topics tutorial <../Understanding-ROS2-Topics/Understanding-ROS2-Topics>`.)

Notice that the letter keys ``G|B|V|C|D|E|R|T`` form a ""box"" around the ``F`` key on a US QWERTY keyboard (if you are not using a QWERTY keyboard, see `this link <https://upload.wikimedia.org/wikipedia/commons/d/da/KB_United_States.svg>`__ to follow along).
Each key's position around ``F`` corresponds to that orientation in turtlesim.
For example, the ``E`` will rotate the turtle's orientation to the upper left corner.

Pay attention to the terminal where the ``/turtlesim`` node is running.
Each time you press one of these keys, you are sending a goal to an action server that is part of the ``/turtlesim`` node.
The goal is to rotate the turtle to face a particular direction.
A message relaying the result of the goal should display once the turtle completes its rotation:

.. code-block:: console

    [INFO] [turtlesim]: Rotation goal completed successfully

The ``F`` key will cancel a goal mid-execution.

Try pressing the ``C`` key, and then pressing the ``F`` key before the turtle can complete its rotation.
In the terminal where the ``/turtlesim`` node is running, you will see the message:

.. code-block:: console

  [INFO] [turtlesim]: Rotation goal canceled

Not only can the client-side (your input in the teleop) stop a goal, but the server-side (the ``/turtlesim`` node) can as well.
When the server-side chooses to stop processing a goal, it is said to ""abort"" the goal.

Try hitting the ``D`` key, then the ``G`` key before the first rotation can complete.
In the terminal where the ``/turtlesim`` node is running, you will see the message:

.. code-block:: console

  [WARN] [turtlesim]: Rotation goal received before a previous goal finished. Aborting previous goal

This action server chose to abort the first goal because it got a new one.
It could have chosen something else, like reject the new goal or execute the second goal after the first one finished.
Don't assume every action server will choose to abort the current goal when it gets a new one.

3 ros2 node info
^^^^^^^^^^^^^^^^

To see the list of actions a node provides, ``/turtlesim`` in this case, open a new terminal and run the command:

.. code-block:: console

    ros2 node info /turtlesim

Which will return a list of ``/turtlesim``'s subscribers, publishers, services, action servers and action clients:

.. code-block:: console

  /turtlesim
    Subscribers:
      /parameter_events: rcl_interfaces/msg/ParameterEvent
      /turtle1/cmd_vel: geometry_msgs/msg/Twist
    Publishers:
      /parameter_events: rcl_interfaces/msg/ParameterEvent
      /rosout: rcl_interfaces/msg/Log
      /turtle1/color_sensor: turtlesim_msgs/msg/Color
      /turtle1/pose: turtlesim_msgs/msg/Pose
    Service Servers:
      /clear: std_srvs/srv/Empty
      /kill: turtlesim_msgs/srv/Kill
      /reset: std_srvs/srv/Empty
      /spawn: turtlesim_msgs/srv/Spawn
      /turtle1/set_pen: turtlesim_msgs/srv/SetPen
      /turtle1/teleport_absolute: turtlesim_msgs/srv/TeleportAbsolute
      /turtle1/teleport_relative: turtlesim_msgs/srv/TeleportRelative
      /turtlesim/describe_parameters: rcl_interfaces/srv/DescribeParameters
      /turtlesim/get_parameter_types: rcl_interfaces/srv/GetParameterTypes
      /turtlesim/get_parameters: rcl_interfaces/srv/GetParameters
      /turtlesim/list_parameters: rcl_interfaces/srv/ListParameters
      /turtlesim/set_parameters: rcl_interfaces/srv/SetParameters
      /turtlesim/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically
    Service Clients:

    Action Servers:
      /turtle1/rotate_absolute: turtlesim_msgs/action/RotateAbsolute
    Action Clients:

Notice that the ``/turtle1/rotate_absolute`` action for ``/turtlesim`` is under ``Action Servers``.
This means ``/turtlesim`` responds to and provides feedback for the ``/turtle1/rotate_absolute`` action.

The ``/teleop_turtle`` node has the name ``/turtle1/rotate_absolute`` under ``Action Clients`` meaning that it sends goals for that action name.
To see that, run:

.. code-block:: console

    ros2 node info /teleop_turtle

Which will return:

.. code-block:: console

  /teleop_turtle
    Subscribers:
      /parameter_events: rcl_interfaces/msg/ParameterEvent
    Publishers:
      /parameter_events: rcl_interfaces/msg/ParameterEvent
      /rosout: rcl_interfaces/msg/Log
      /turtle1/cmd_vel: geometry_msgs/msg/Twist
    Service Servers:
      /teleop_turtle/describe_parameters: rcl_interfaces/srv/DescribeParameters
      /teleop_turtle/get_parameter_types: rcl_interfaces/srv/GetParameterTypes
      /teleop_turtle/get_parameters: rcl_interfaces/srv/GetParameters
      /teleop_turtle/list_parameters: rcl_interfaces/srv/ListParameters
      /teleop_turtle/set_parameters: rcl_interfaces/srv/SetParameters
      /teleop_turtle/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically
    Service Clients:

    Action Servers:

    Action Clients:
      /turtle1/rotate_absolute: turtlesim_msgs/action/RotateAbsolute

4 ros2 action list
^^^^^^^^^^^^^^^^^^

To identify all the actions in the ROS graph, run the command:

.. code-block:: console

    ros2 action list

Which will return:

.. code-block:: console

    /turtle1/rotate_absolute

This is the only action in the ROS graph right now.
It controls the turtle's rotation, as you saw earlier.
You also already know that there is one action client (part of ``/teleop_turtle``) and one action server (part of ``/turtlesim``) for this action from using the ``ros2 node info <node_name>`` command.

4.1 ros2 action list -t
~~~~~~~~~~~~~~~~~~~~~~~

Actions have types, similar to topics and services.
To find ``/turtle1/rotate_absolute``'s type, run the command:

.. code-block:: console

    ros2 action list -t

Which will return:

.. code-block:: console

    /turtle1/rotate_absolute [turtlesim_msgs/action/RotateAbsolute]

In brackets to the right of each action name (in this case only ``/turtle1/rotate_absolute``) is the action type, ``turtlesim_msgs/action/RotateAbsolute``.
You will need this when you want to execute an action from the command line or from code.

5 ros2 action type
^^^^^^^^^^^^^^^^^^

If you want to check the action type for the action, run the command:

.. code-block:: console

    ros2 action type /turtle1/rotate_absolute

Which will return:

.. code-block:: console

    turtlesim_msgs/action/RotateAbsolute

6 ros2 action info
^^^^^^^^^^^^^^^^^^

You can further introspect the ``/turtle1/rotate_absolute`` action with the command:

.. code-block:: console

    ros2 action info /turtle1/rotate_absolute

Which will return

.. code-block:: console

  Action: /turtle1/rotate_absolute
  Action clients: 1
      /teleop_turtle
  Action servers: 1
      /turtlesim

This tells us what we learned earlier from running ``ros2 node info`` on each node:
The ``/teleop_turtle`` node has an action client and the ``/turtlesim`` node has an action server for the ``/turtle1/rotate_absolute`` action.

7 ros2 interface show
^^^^^^^^^^^^^^^^^^^^^

One more piece of information you will need before sending or executing an action goal yourself is the structure of the action type.

Recall that you identified ``/turtle1/rotate_absolute``'s type when running the command ``ros2 action list -t``.
Enter the following command with the action type in your terminal:

.. code-block:: console

  ros2 interface show turtlesim_msgs/action/RotateAbsolute

Which will return:

.. code-block:: console

  # The desired heading in radians
  float32 theta
  ---
  # The angular displacement in radians to the starting position
  float32 delta
  ---
  # The remaining rotation in radians
  float32 remaining

The section of this message above the first ``---`` is the structure (data type and name) of the goal request.
The next section is the structure of the result.
The last section is the structure of the feedback.

8 ros2 action send_goal
^^^^^^^^^^^^^^^^^^^^^^^

Now let's send an action goal from the command line with the following syntax:

.. code-block:: console

    ros2 action send_goal <action_name> <action_type> <values>

``<values>`` need to be in YAML format.

Keep an eye on the turtlesim window, and enter the following command into your terminal:

.. code-block:: console

    ros2 action send_goal /turtle1/rotate_absolute turtlesim_msgs/action/RotateAbsolute ""{theta: 1.57}""

You should see the turtle rotating, as well as the following message in your terminal:

.. code-block:: console

  Waiting for an action server to become available...
  Sending goal:
     theta: 1.57

  Goal accepted with ID: f8db8f44410849eaa93d3feb747dd444

  Result:
    delta: -1.568000316619873

  Goal finished with status: SUCCEEDED

All goals have a unique ID, shown in the return message.
You can also see the result, a field with the name ``delta``, which is the displacement to the starting position.

To see the feedback of this goal, add ``--feedback`` to the ``ros2 action send_goal`` command:

.. code-block:: console

    ros2 action send_goal /turtle1/rotate_absolute turtlesim_msgs/action/RotateAbsolute ""{theta: -1.57}"" --feedback

Your terminal will return the message:

.. code-block:: console

  Sending goal:
     theta: -1.57

  Goal accepted with ID: e6092c831f994afda92f0086f220da27

  Feedback:
    remaining: -3.1268222332000732

  Feedback:
    remaining: -3.1108222007751465

  …

  Result:
    delta: 3.1200008392333984

  Goal finished with status: SUCCEEDED

You will continue to receive feedback, the remaining radians, until the goal is complete.

Summary
-------

Actions are like services that allow you to execute long running tasks, provide regular feedback, and are cancelable.

A robot system would likely use actions for navigation.
An action goal could tell a robot to travel to a position.
While the robot navigates to the position, it can send updates along the way (i.e. feedback), and then a final result message once it's reached its destination.

Turtlesim has an action server that action clients can send goals to for rotating turtles.
In this tutorial, you introspected that action, ``/turtle1/rotate_absolute``, to get a better idea of what actions are and how they work.

Next steps
----------

Now you've covered all of the core ROS 2 concepts.
The last few tutorials in this set will introduce you to some tools and techniques that will make using ROS 2 easier, starting with :doc:`../Using-Rqt-Console/Using-Rqt-Console`.

Related content
---------------

You can read more about the design decisions behind actions in ROS 2 `here <https://design.ros2.org/articles/actions.html>`__.
",What are the three parts that make up an action in ROS 2?
".. redirect-from::

    Tutorials/Rqt-Console/Using-Rqt-Console

.. _rqt_console:

Using ``rqt_console`` to view logs
==================================

**Goal:** Get to know ``rqt_console``, a tool for introspecting log messages.

**Tutorial level:** Beginner

**Time:** 5 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

``rqt_console`` is a GUI tool used to introspect log messages in ROS 2.
Typically, log messages show up in your terminal.
With ``rqt_console``, you can collect those messages over time, view them closely and in a more organized manner, filter them, save them and even reload the saved files to introspect at a different time.

Nodes use logs to output messages concerning events and status in a variety of ways.
Their content is usually informational, for the sake of the user.

Prerequisites
-------------

You will need :doc:`rqt_console and turtlesim <../Introducing-Turtlesim/Introducing-Turtlesim>` installed.

As always, don't forget to source ROS 2 in :doc:`every new terminal you open <../Configuring-ROS2-Environment>`.


Tasks
-----

1 Setup
^^^^^^^

Start ``rqt_console`` in a new terminal with the following command:

.. code-block:: console

    ros2 run rqt_console rqt_console

The ``rqt_console`` window will open:

.. image:: images/console.png

The first section of the console is where log messages from your system will display.

In the middle you have the option to filter messages by excluding severity levels.
You can also add more exclusion filters using the plus-sign button to the right.

The bottom section is for highlighting messages that include a string you input.
You can add more filters to this section as well.

Now start ``turtlesim`` in a new terminal with the following command:

.. code-block:: console

    ros2 run turtlesim turtlesim_node

2 Messages on rqt_console
^^^^^^^^^^^^^^^^^^^^^^^^^

To produce log messages for ``rqt_console`` to display, let's have the turtle run into the wall.
In a new terminal, enter the ``ros2 topic pub`` command (discussed in detail in the :doc:`topics tutorial <../Understanding-ROS2-Topics/Understanding-ROS2-Topics>`) below:

.. code-block:: console

    ros2 topic pub -r 1 /turtle1/cmd_vel geometry_msgs/msg/Twist ""{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}""

Since the above command is publishing the topic at a steady rate, the turtle is continuously running into the wall.
In ``rqt_console`` you will see the same message with the ``Warn`` severity level displayed over and over, like so:

.. image:: images/warn.png

Press ``Ctrl+C`` in the terminal where you ran the ``ros2 topic pub`` command to stop your turtle from running into the wall.

3 Logger levels
^^^^^^^^^^^^^^^

ROS 2's logger levels are ordered by severity:

.. code-block:: console

    Fatal
    Error
    Warn
    Info
    Debug

There is no exact standard for what each level indicates, but it's safe to assume that:

* ``Fatal`` messages indicate the system is going to terminate to try to protect itself from detriment.
* ``Error`` messages indicate significant issues that won't necessarily damage the system, but are preventing it from functioning properly.
* ``Warn`` messages indicate unexpected activity or non-ideal results that might represent a deeper issue, but don't harm functionality outright.
* ``Info`` messages indicate event and status updates that serve as a visual verification that the system is running as expected.
* ``Debug`` messages detail the entire step-by-step process of the system execution.

The default level is ``Info``.
You will only see messages of the default severity level and more-severe levels.

Normally, only ``Debug`` messages are hidden because they're the only level less severe than ``Info``.
For example, if you set the default level to ``Warn``, you would only see messages of severity ``Warn``, ``Error``, and ``Fatal``.

3.1 Set the default logger level
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can set the default logger level when you first run the ``/turtlesim`` node using remapping.
Enter the following command in your terminal:

.. code-block:: console

    ros2 run turtlesim turtlesim_node --ros-args --log-level WARN

Now you won't see the initial ``Info`` level messages that came up in the console last time you started ``turtlesim``.
That's because ``Info`` messages are lower priority than the new default severity, ``Warn``.

Summary
-------

``rqt_console`` can be very helpful if you need to closely examine the log messages from your system.
You might want to examine log messages for any number of reasons, usually to find out where something went wrong and the series of events leading up to that.

Next steps
----------

The next tutorial will teach you about starting multiple nodes at once with :doc:`ROS 2 Launch <../Launching-Multiple-Nodes/Launching-Multiple-Nodes>`.
",How can you set the default logger level when running the ``/turtlesim`` node using remapping?
".. redirect-from::

    Tutorials/Turtlesim/Introducing-Turtlesim

.. _Turtlesim:

Using ``turtlesim``, ``ros2``, and ``rqt``
==========================================

**Goal:** Install and use the turtlesim package and rqt tools to prepare for upcoming tutorials.

**Tutorial level:** Beginner

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

Turtlesim is a lightweight simulator for learning ROS 2.
It illustrates what ROS 2 does at the most basic level to give you an idea of what you will do with a real robot or a robot simulation later on.

The ros2 tool is how the user manages, introspects, and interacts with a ROS system.
It supports multiple commands that target different aspects of the system and its operation.
One might use it to start a node, set a parameter, listen to a topic, and many more.
The ros2 tool is part of the core ROS 2 installation.

rqt is a graphical user interface (GUI) tool for ROS 2.
Everything done in rqt can be done on the command line, but rqt provides a more user-friendly way to manipulate ROS 2 elements.

This tutorial touches upon core ROS 2 concepts, like nodes, topics, and services.
All of these concepts will be elaborated on in later tutorials; for now, you will simply set up the tools and get a feel for them.

Prerequisites
-------------

The previous tutorial, :doc:`../Configuring-ROS2-Environment`, will show you how to set up your environment.

Tasks
-----

1 Install turtlesim
^^^^^^^^^^^^^^^^^^^

As always, start by sourcing your setup files in a new terminal, as described in the :doc:`previous tutorial <../Configuring-ROS2-Environment>`.

Install the turtlesim package for your ROS 2 distro:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        sudo apt update

        sudo apt install ros-{DISTRO}-turtlesim

   .. group-tab:: macOS

      As long as the archive you installed ROS 2 from contains the ``ros_tutorials`` repository, you should already have turtlesim installed.

   .. group-tab:: Windows

      As long as the archive you installed ROS 2 from contains the ``ros_tutorials`` repository, you should already have turtlesim installed.

Check that the package is installed:

.. code-block:: console

  ros2 pkg executables turtlesim

The above command should return a list of turtlesim's executables:

.. code-block:: console

  turtlesim draw_square
  turtlesim mimic
  turtlesim turtle_teleop_key
  turtlesim turtlesim_node

2 Start turtlesim
^^^^^^^^^^^^^^^^^

To start turtlesim, enter the following command in your terminal:

.. code-block:: console

  ros2 run turtlesim turtlesim_node

The simulator window should appear, with a random turtle in the center.

.. image:: images/turtlesim.png

In the terminal, under the command, you will see messages from the node:

.. code-block:: console

  [INFO] [turtlesim]: Starting turtlesim with node name /turtlesim
  [INFO] [turtlesim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]

There you can see the default turtle's name and the coordinates where it spawns.

3 Use turtlesim
^^^^^^^^^^^^^^^

Open a new terminal and source ROS 2 again.

Now you will run a new node to control the turtle in the first node:

.. code-block:: console

  ros2 run turtlesim turtle_teleop_key

At this point you should have three windows open: a terminal running ``turtlesim_node``, a terminal running ``turtle_teleop_key`` and the turtlesim window.
Arrange these windows so that you can see the turtlesim window, but also have the terminal running ``turtle_teleop_key`` active so that you can control the turtle in turtlesim.

Use the arrow keys on your keyboard to control the turtle.
It will move around the screen, using its attached ""pen"" to draw the path it followed so far.

.. note::

  Pressing an arrow key will only cause the turtle to move a short distance and then stop.
  This is because, realistically, you wouldn't want a robot to continue carrying on an instruction if, for example, the operator lost the connection to the robot.

You can see the nodes, and their associated topics, services, and actions, using the ``list`` subcommands of the respective commands:

.. code-block:: console

  ros2 node list
  ros2 topic list
  ros2 service list
  ros2 action list

You will learn more about these concepts in the coming tutorials.
Since the goal of this tutorial is only to get a general overview of turtlesim, you will use rqt to call some of the turtlesim services and interact with ``turtlesim_node``.

4 Install rqt
^^^^^^^^^^^^^

Open a new terminal to install ``rqt`` and its plugins:

.. tabs::

  .. group-tab:: Ubuntu

    .. code-block:: console

      sudo apt update

      sudo apt install '~nros-{DISTRO}-rqt*'

  .. group-tab:: RHEL

    .. code-block:: console

      sudo dnf install 'ros-{DISTRO}-rqt*'

  .. group-tab:: macOS

    The standard archive for installing ROS 2 on macOS contains ``rqt`` and its plugins, so you should already have ``rqt`` installed.

  .. group-tab:: Windows

    The standard archive for installing ROS 2 on Windows contains ``rqt`` and its plugins, so you should already have ``rqt`` installed.

To run rqt:

.. code-block:: console

  rqt

5 Use rqt
^^^^^^^^^

When running rqt for the first time, the window will be blank.
No worries; just select **Plugins** > **Services** > **Service Caller** from the menu bar at the top.

.. note::

  It may take some time for rqt to locate all the plugins.
  If you click on **Plugins** but don't see **Services** or any other options, you should close rqt and enter the command ``rqt --force-discover`` in your terminal.

.. image:: images/rqt.png

Use the refresh button to the left of the **Service** dropdown list to ensure all the services of your turtlesim node are available.

Click on the **Service** dropdown list to see turtlesim's services, and select the ``/spawn`` service.

5.1 Try the spawn service
~~~~~~~~~~~~~~~~~~~~~~~~~

Let's use rqt to call the ``/spawn`` service.
You can guess from its name that ``/spawn`` will create another turtle in the turtlesim window.

Give the new turtle a unique name, like ``turtle2``, by double-clicking between the empty single quotes in the **Expression** column.
You can see that this expression corresponds to the value of **name** and is of type **string**.

Next enter some valid coordinates at which to spawn the new turtle, like ``x = 1.0`` and ``y = 1.0``.

.. image:: images/spawn.png

.. note::

  If you try to spawn a new turtle with the same name as an existing turtle, like the default ``turtle1``, you will get an error message in the terminal running ``turtlesim_node``:

  .. code-block:: console

    [ERROR] [turtlesim]: A turtle named [turtle1] already exists

To spawn ``turtle2``, you then need to call the service by clicking the **Call** button on the upper right side of the rqt window.

If the service call was successful, you should see a new turtle (again with a random design) spawn at the coordinates you input for **x** and **y**.

If you refresh the service list in rqt, you will also see that now there are services related to the new turtle, ``/turtle2/...``, in addition to ``/turtle1/...``.

5.2 Try the set_pen service
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now let's give ``turtle1`` a unique pen using the ``/set_pen`` service:

.. image:: images/set_pen.png

The values for **r**, **g** and **b**, which are between 0 and 255, set the color of the pen ``turtle1`` draws with, and **width** sets the thickness of the line.

To have ``turtle1`` draw with a distinct red line, change the value of **r** to 255, and the value of **width** to 5.
Don't forget to call the service after updating the values.

If you return to the terminal where ``turtle_teleop_key`` is running and press the arrow keys, you will see ``turtle1``'s pen has changed.

.. image:: images/new_pen.png

You've probably also noticed that there's no way to move ``turtle2``.
That's because there is no teleop node for ``turtle2``.

6 Remapping
^^^^^^^^^^^

You need a second teleop node in order to control ``turtle2``.
However, if you try to run the same command as before, you will notice that this one also controls ``turtle1``.
The way to change this behavior is by remapping the ``cmd_vel`` topic.

In a new terminal, source ROS 2, and run:

.. code-block:: console

  ros2 run turtlesim turtle_teleop_key --ros-args --remap turtle1/cmd_vel:=turtle2/cmd_vel


Now, you can move ``turtle2`` when this terminal is active, and ``turtle1`` when the other terminal running ``turtle_teleop_key`` is active.

.. image:: images/remap.png

7 Close turtlesim
^^^^^^^^^^^^^^^^^

To stop the simulation, you can enter ``Ctrl + C`` in the ``turtlesim_node`` terminal, and ``q`` in the ``turtle_teleop_key`` terminals.

Summary
-------

Using turtlesim and rqt is a great way to learn the core concepts of ROS 2.

Next steps
----------

Now that you have turtlesim and rqt up and running, and an idea of how they work, let's dive into the first core ROS 2 concept with the next tutorial, :doc:`../Understanding-ROS2-Nodes/Understanding-ROS2-Nodes`.

Related content
---------------

The turtlesim package can be found in the `ros_tutorials <https://github.com/ros/ros_tutorials/tree/{REPOS_FILE_BRANCH}/turtlesim>`_ repo.

`This community contributed video <https://youtu.be/xwT7XWflMdc>`_ demonstrates many of the items covered in this tutorial.
",What tool is used for manipulating ROS 2 elements in a more user-friendly way in the tutorial?
".. redirect-from::

    Tutorials/Services/Understanding-ROS2-Services

.. _ROS2Services:

Understanding services
======================

**Goal:** Learn about services in ROS 2 using command line tools.

**Tutorial level:** Beginner

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

Services are another method of communication for nodes in the ROS graph.
Services are based on a call-and-response model versus the publisher-subscriber model of topics.
While topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client.

.. image:: images/Service-SingleServiceClient.gif

.. image:: images/Service-MultipleServiceClient.gif

Prerequisites
-------------

Some concepts mentioned in this tutorial, like :doc:`Nodes <../Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>` and :doc:`Topics <../Understanding-ROS2-Topics/Understanding-ROS2-Topics>`, were covered in previous tutorials in the series.

You will need the :doc:`turtlesim package <../Introducing-Turtlesim/Introducing-Turtlesim>`.

As always, don't forget to source ROS 2 in :doc:`every new terminal you open <../Configuring-ROS2-Environment>`.

Tasks
-----

1 Setup
^^^^^^^
Start up the two turtlesim nodes, ``/turtlesim`` and ``/teleop_turtle``.

Open a new terminal and run:

.. code-block:: console

    ros2 run turtlesim turtlesim_node

Open another terminal and run:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

2 ros2 service list
^^^^^^^^^^^^^^^^^^^

Running the ``ros2 service list`` command in a new terminal will return a list of all the services currently active in the system:

.. code-block:: console

  /clear
  /kill
  /reset
  /spawn
  /teleop_turtle/describe_parameters
  /teleop_turtle/get_parameter_types
  /teleop_turtle/get_parameters
  /teleop_turtle/list_parameters
  /teleop_turtle/set_parameters
  /teleop_turtle/set_parameters_atomically
  /turtle1/set_pen
  /turtle1/teleport_absolute
  /turtle1/teleport_relative
  /turtlesim/describe_parameters
  /turtlesim/get_parameter_types
  /turtlesim/get_parameters
  /turtlesim/list_parameters
  /turtlesim/set_parameters
  /turtlesim/set_parameters_atomically

You will see that both nodes have the same six services with ``parameters`` in their names.
Nearly every node in ROS 2 has these infrastructure services that parameters are built off of.
There will be more about parameters in the next tutorial.
In this tutorial, the parameter services will be omitted from the discussion.

For now, let's focus on the turtlesim-specific services, ``/clear``, ``/kill``, ``/reset``, ``/spawn``, ``/turtle1/set_pen``, ``/turtle1/teleport_absolute``, and ``/turtle1/teleport_relative``.
You may recall interacting with some of these services using rqt in the :doc:`Use turtlesim, ros2, and rqt <../Introducing-Turtlesim/Introducing-Turtlesim>` tutorial.


3 ros2 service type
^^^^^^^^^^^^^^^^^^^

Services have types that describe how the request and response data of a service is structured.
Service types are defined similarly to topic types, except service types have two parts: one message for the request and another for the response.

To find out the type of a service, use the command:

.. code-block:: console

  ros2 service type <service_name>

Let's take a look at turtlesim's ``/clear`` service.
In a new terminal, enter the command:

.. code-block:: console

  ros2 service type /clear

Which should return:

.. code-block:: console

  std_srvs/srv/Empty

The ``Empty`` type means the service call sends no data when making a request and receives no data when receiving a response.

3.1 ros2 service list -t
~~~~~~~~~~~~~~~~~~~~~~~~

To see the types of all the active services at the same time, you can append the ``--show-types`` option, abbreviated as ``-t``, to the ``list`` command:

.. code-block:: console

  ros2 service list -t

Which will return:

.. code-block:: console

  /clear [std_srvs/srv/Empty]
  /kill [turtlesim_msgs/srv/Kill]
  /reset [std_srvs/srv/Empty]
  /spawn [turtlesim_msgs/srv/Spawn]
  ...
  /turtle1/set_pen [turtlesim_msgs/srv/SetPen]
  /turtle1/teleport_absolute [turtlesim_msgs/srv/TeleportAbsolute]
  /turtle1/teleport_relative [turtlesim_msgs/srv/TeleportRelative]
  ...

4 ros2 service info
^^^^^^^^^^^^^^^^^^^

To see information of a particular service, use the command:

.. code-block:: console

  ros2 service info <service_name>

This returns the service type and the count of service clients and servers.

For example, you can find the count of clients and servers for the ``/clear`` service:

.. code-block:: console

   ros2 service info /clear

Which will return:

.. code-block:: console

   Type: std_srvs/srv/Empty
   Clients count: 0
   Services count: 1

5 ros2 service find
^^^^^^^^^^^^^^^^^^^

If you want to find all the services of a specific type, you can use the command:

.. code-block:: console

  ros2 service find <type_name>

For example, you can find all the ``Empty`` typed services like this:

.. code-block:: console

  ros2 service find std_srvs/srv/Empty

Which will return:

.. code-block:: console

  /clear
  /reset

6 ros2 interface show
^^^^^^^^^^^^^^^^^^^^^

You can call services from the command line, but first you need to know the structure of the input arguments.

.. code-block:: console

  ros2 interface show <type_name>

Try this on the ``/clear`` service's type, ``Empty``:

.. code-block:: console

  ros2 interface show std_srvs/srv/Empty

Which will return:

.. code-block:: console

  ---

The ``---`` separates the request structure (above) from the response structure (below).
But, as you learned earlier, the ``Empty`` type doesn't send or receive any data.
So, naturally, its structure is blank.

Let's introspect a service with a type that sends and receives data, like ``/spawn``.
From the results of ``ros2 service list -t``, we know ``/spawn``'s type is ``turtlesim_msgs/srv/Spawn``.

To see the request and response arguments of the ``/spawn`` service, run the command:

.. code-block:: console

  ros2 interface show turtlesim_msgs/srv/Spawn

Which will return:

.. code-block:: console

  float32 x
  float32 y
  float32 theta
  string name # Optional.  A unique name will be created and returned if this is empty
  ---
  string name

The information above the ``---`` line tells us the arguments needed to call ``/spawn``.
``x``, ``y`` and ``theta`` determine the 2D pose of the spawned turtle, and ``name`` is clearly optional.

The information below the line isn't something you need to know in this case, but it can help you understand the data type of the response you get from the call.

7 ros2 service call
^^^^^^^^^^^^^^^^^^^

Now that you know what a service type is, how to find a service's type, and how to find the structure of that type's arguments, you can call a service using:

.. code-block:: console

  ros2 service call <service_name> <service_type> <arguments>

The ``<arguments>`` part is optional.
For example, you know that ``Empty`` typed services don't have any arguments:

.. code-block:: console

  ros2 service call /clear std_srvs/srv/Empty

This command will clear the turtlesim window of any lines your turtle has drawn.

.. image:: images/clear.png

Now let's spawn a new turtle by calling ``/spawn`` and setting arguments.
Input ``<arguments>`` in a service call from the command-line need to be in YAML syntax.

Enter the command:

.. code-block:: console

  ros2 service call /spawn turtlesim_msgs/srv/Spawn ""{x: 2, y: 2, theta: 0.2, name: ''}""

You will get this method-style view of what's happening, and then the service response:

.. code-block:: console

  requester: making request: turtlesim.srv.Spawn_Request(x=2.0, y=2.0, theta=0.2, name='')

  response:
  turtlesim.srv.Spawn_Response(name='turtle2')

Your turtlesim window will update with the newly spawned turtle right away:

.. image:: images/spawn.png

8 ros2 service echo
^^^^^^^^^^^^^^^^^^^

To see the data communication between a service client and a service server you can ``echo`` the service using:

.. code-block:: console

   ros2 service echo <service_name | service_type> <arguments>

``ros2 service echo`` depends on service introspection of a service client and server, that is disabled by default.
To enable it, users must call ``configure_introspection`` after creating a server client or server.

Start up the ``introspection_client`` and ``introspection_service`` service introspection demo.

.. code-block:: console

   ros2 launch demo_nodes_cpp introspect_services_launch.py

Open another terminal and run the following to enable service introspection for ``introspection_client`` and ``introspection_service``.

.. code-block:: console

   ros2 param set /introspection_service service_configure_introspection contents
   ros2 param set /introspection_client client_configure_introspection contents

Now we are able to see the service communication between ``introspection_client`` and ``introspection_service`` via ``ros2 service echo``.

.. code-block:: console

   ros2 service echo --flow-style /add_two_ints
   info:
     event_type: REQUEST_SENT
     stamp:
       sec: 1709408301
       nanosec: 423227292
     client_gid: [1, 15, 0, 18, 250, 205, 12, 100, 0, 0, 0, 0, 0, 0, 21, 3]
     sequence_number: 618
   request: [{a: 2, b: 3}]
   response: []
   ---
   info:
     event_type: REQUEST_RECEIVED
     stamp:
       sec: 1709408301
       nanosec: 423601471
     client_gid: [1, 15, 0, 18, 250, 205, 12, 100, 0, 0, 0, 0, 0, 0, 20, 4]
     sequence_number: 618
   request: [{a: 2, b: 3}]
   response: []
   ---
   info:
     event_type: RESPONSE_SENT
     stamp:
       sec: 1709408301
       nanosec: 423900744
     client_gid: [1, 15, 0, 18, 250, 205, 12, 100, 0, 0, 0, 0, 0, 0, 20, 4]
     sequence_number: 618
   request: []
   response: [{sum: 5}]
   ---
   info:
     event_type: RESPONSE_RECEIVED
     stamp:
       sec: 1709408301
       nanosec: 424153133
     client_gid: [1, 15, 0, 18, 250, 205, 12, 100, 0, 0, 0, 0, 0, 0, 21, 3]
     sequence_number: 618
   request: []
   response: [{sum: 5}]
   ---

Summary
-------

Nodes can communicate using services in ROS 2.
Unlike a topic - a one way communication pattern where a node publishes information that can be consumed by one or more subscribers - a service is a request/response pattern where a client makes a request to a node providing the service and the service processes the request and generates a response.

You generally don't want to use a service for continuous calls; topics or even actions would be better suited.

In this tutorial you used command line tools to identify, introspect, and call services.

Next steps
----------

In the next tutorial, :doc:`../Understanding-ROS2-Parameters/Understanding-ROS2-Parameters`, you will learn about configuring node settings.

Related content
---------------

Check out `this tutorial <https://discourse.ubuntu.com/t/call-services-in-ros-2/15261>`_; it's an excellent realistic application of ROS services using a Robotis robot arm.
",What command in ROS 2 can be used to return a list of all the services currently active in the system?
".. redirect-from::

    Tutorials/Parameters/Understanding-ROS2-Parameters

.. _ROS2Params:

Understanding parameters
========================

**Goal:** Learn how to get, set, save and reload parameters in ROS 2.

**Tutorial level:** Beginner

**Time:** 5 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

A parameter is a configuration value of a node.
You can think of parameters as node settings.
A node can store parameters as integers, floats, booleans, strings, and lists.
In ROS 2, each node maintains its own parameters.
For more background on parameters, please see :doc:`the concept document <../../../Concepts/Basic/About-Parameters>`.

Prerequisites
-------------

This tutorial uses the :doc:`turtlesim package <../Introducing-Turtlesim/Introducing-Turtlesim>`.

As always, don't forget to source ROS 2 in :doc:`every new terminal you open <../Configuring-ROS2-Environment>`.

Tasks
-----

1 Setup
^^^^^^^

Start up the two turtlesim nodes, ``/turtlesim`` and ``/teleop_turtle``.

Open a new terminal and run:

.. code-block:: console

    ros2 run turtlesim turtlesim_node

Open another terminal and run:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key


2 ros2 param list
^^^^^^^^^^^^^^^^^

To see the parameters belonging to your nodes, open a new terminal and enter the command:

.. code-block:: console

    ros2 param list

You will see the node namespaces, ``/teleop_turtle`` and ``/turtlesim``, followed by each node's parameters:

.. code-block:: console

  /teleop_turtle:
    qos_overrides./parameter_events.publisher.depth
    qos_overrides./parameter_events.publisher.durability
    qos_overrides./parameter_events.publisher.history
    qos_overrides./parameter_events.publisher.reliability
    scale_angular
    scale_linear
    use_sim_time
  /turtlesim:
    background_b
    background_g
    background_r
    qos_overrides./parameter_events.publisher.depth
    qos_overrides./parameter_events.publisher.durability
    qos_overrides./parameter_events.publisher.history
    qos_overrides./parameter_events.publisher.reliability
    use_sim_time

Every node has the parameter ``use_sim_time``; it's not unique to turtlesim.

Based on their names, it looks like ``/turtlesim``'s parameters determine the background color of the turtlesim window using RGB color values.

To determine a parameter's type, you can use ``ros2 param get``.


3 ros2 param get
^^^^^^^^^^^^^^^^

To display the type and current value of a parameter, use the command:

.. code-block:: console

    ros2 param get <node_name> <parameter_name>

Let's find out the current value of ``/turtlesim``'s parameter ``background_g``:

.. code-block:: console

    ros2 param get /turtlesim background_g

Which will return the value:

.. code-block:: console

    Integer value is: 86

Now you know ``background_g`` holds an integer value.

If you run the same command on ``background_r`` and ``background_b``, you will get the values ``69`` and ``255``, respectively.

4 ros2 param set
^^^^^^^^^^^^^^^^

To change a parameter's value at runtime, use the command:

.. code-block:: console

    ros2 param set <node_name> <parameter_name> <value>

Let's change ``/turtlesim``'s background color:

.. code-block:: console

    ros2 param set /turtlesim background_r 150

Your terminal should return the message:

.. code-block:: console

  Set parameter successful

And the background of your turtlesim window should change colors:

.. image:: images/set.png

Setting parameters with the ``set`` command will only change them in your current session, not permanently.
However, you can save your settings and reload them the next time you start a node.

5 ros2 param dump
^^^^^^^^^^^^^^^^^

You can view all of a node's current parameter values by using the command:

.. code-block:: console

  ros2 param dump <node_name>

The command prints to the standard output (stdout) by default but you can also redirect the parameter values into a file to save them for later.
To save your current configuration of ``/turtlesim``'s parameters into the file ``turtlesim.yaml``, enter the command:

.. code-block:: console

  ros2 param dump /turtlesim > turtlesim.yaml

You will find a new file in the current working directory your shell is running in.
If you open this file, you'll see the following content:

.. code-block:: YAML

  /turtlesim:
    ros__parameters:
      background_b: 255
      background_g: 86
      background_r: 150
      qos_overrides:
        /parameter_events:
          publisher:
            depth: 1000
            durability: volatile
            history: keep_last
            reliability: reliable
      use_sim_time: false

Dumping parameters comes in handy if you want to reload the node with the same parameters in the future.

6 ros2 param load
^^^^^^^^^^^^^^^^^

You can load parameters from a file to a currently running node using the command:

.. code-block:: console

  ros2 param load <node_name> <parameter_file>

To load the ``turtlesim.yaml`` file generated with ``ros2 param dump`` into ``/turtlesim`` node's parameters, enter the command:

.. code-block:: console

  ros2 param load /turtlesim turtlesim.yaml

Your terminal will return the message:

.. code-block:: console

  Set parameter background_b successful
  Set parameter background_g successful
  Set parameter background_r successful
  Set parameter qos_overrides./parameter_events.publisher.depth failed: parameter 'qos_overrides./parameter_events.publisher.depth' cannot be set because it is read-only
  Set parameter qos_overrides./parameter_events.publisher.durability failed: parameter 'qos_overrides./parameter_events.publisher.durability' cannot be set because it is read-only
  Set parameter qos_overrides./parameter_events.publisher.history failed: parameter 'qos_overrides./parameter_events.publisher.history' cannot be set because it is read-only
  Set parameter qos_overrides./parameter_events.publisher.reliability failed: parameter 'qos_overrides./parameter_events.publisher.reliability' cannot be set because it is read-only
  Set parameter use_sim_time successful

.. note::

  Read-only parameters can only be modified at startup and not afterwards, that is why there are some warnings for the ""qos_overrides"" parameters.

7 Load parameter file on node startup
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To start the same node using your saved parameter values, use:

.. code-block:: console

  ros2 run <package_name> <executable_name> --ros-args --params-file <file_name>

This is the same command you always use to start turtlesim, with the added flags ``--ros-args`` and ``--params-file``, followed by the file you want to load.

Stop your running turtlesim node, and try reloading it with your saved parameters, using:

.. code-block:: console

  ros2 run turtlesim turtlesim_node --ros-args --params-file turtlesim.yaml

The turtlesim window should appear as usual, but with the purple background you set earlier.

.. note::

  When a parameter file is used at node startup, all parameters, including the read-only ones, will be updated.

Summary
-------

Nodes have parameters to define their default configuration values.
You can ``get`` and ``set`` parameter values from the command line.
You can also save the parameter settings to a file to reload them in a future session.

Next steps
----------

Jumping back to ROS 2 communication methods, in the next tutorial you'll learn about :doc:`actions <../Understanding-ROS2-Actions/Understanding-ROS2-Actions>`.
",What command can you use to change a parameter's value at runtime in ROS 2?
".. redirect-from::

    Tutorials/Topics/Understanding-ROS2-Topics

.. _ROS2Topics:

Understanding topics
====================

**Goal:** Use rqt_graph and command line tools to introspect ROS 2 topics.

**Tutorial level:** Beginner

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

ROS 2 breaks complex systems down into many modular nodes.
Topics are a vital element of the ROS graph that act as a bus for nodes to exchange messages.

.. image:: images/Topic-SinglePublisherandSingleSubscriber.gif

A node may publish data to any number of topics and simultaneously have subscriptions to any number of topics.

.. image:: images/Topic-MultiplePublisherandMultipleSubscriber.gif

Topics are one of the main ways in which data is moved between nodes and therefore between different parts of the system.


Prerequisites
-------------

The :doc:`previous tutorial <../Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>` provides some useful background information on nodes that is built upon here.

As always, don't forget to source ROS 2 in :doc:`every new terminal you open <../Configuring-ROS2-Environment>`.

Tasks
-----

1 Setup
^^^^^^^

By now you should be comfortable starting up turtlesim.

Open a new terminal and run:

.. code-block:: console

    ros2 run turtlesim turtlesim_node

Open another terminal and run:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

Recall from the :doc:`previous tutorial <../Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>` that the names of these nodes are ``/turtlesim`` and ``/teleop_turtle`` by default.


2 rqt_graph
^^^^^^^^^^^

Throughout this tutorial, we will use ``rqt_graph`` to visualize the changing nodes and topics, as well as the connections between them.

The :doc:`turtlesim tutorial <../Introducing-Turtlesim/Introducing-Turtlesim>` tells you how to install rqt and all its plugins, including ``rqt_graph``.

To run rqt_graph, open a new terminal and enter the command:

.. code-block:: console

    rqt_graph

You can also open rqt_graph by opening ``rqt`` and selecting **Plugins** > **Introspection** > **Node Graph**.

.. image:: images/rqt_graph.png

You should see the above nodes and topic, as well as two actions around the periphery of the graph (let's ignore those for now).
If you hover your mouse over the topic in the center, you'll see the color highlighting like in the image above.

The graph is depicting how the ``/turtlesim`` node and the ``/teleop_turtle`` node are communicating with each other over a topic.
The ``/teleop_turtle`` node is publishing data (the keystrokes you enter to move the turtle around) to the ``/turtle1/cmd_vel`` topic, and the ``/turtlesim`` node is subscribed to that topic to receive the data.

The highlighting feature of rqt_graph is very helpful when examining more complex systems with many nodes and topics connected in many different ways.

rqt_graph is a graphical introspection tool.
Now we'll look at some command line tools for introspecting topics.


3 ros2 topic list
^^^^^^^^^^^^^^^^^

Running the ``ros2 topic list`` command in a new terminal will return a list of all the topics currently active in the system:

.. code-block:: console

  /parameter_events
  /rosout
  /turtle1/cmd_vel
  /turtle1/color_sensor
  /turtle1/pose

``ros2 topic list -t`` will return the same list of topics, this time with the topic type appended in brackets:

.. code-block:: console

  /parameter_events [rcl_interfaces/msg/ParameterEvent]
  /rosout [rcl_interfaces/msg/Log]
  /turtle1/cmd_vel [geometry_msgs/msg/Twist]
  /turtle1/color_sensor [turtlesim_msgs/msg/Color]
  /turtle1/pose [turtlesim_msgs/msg/Pose]

These attributes, particularly the type, are how nodes know they're talking about the same information as it moves over topics.

If you're wondering where all these topics are in rqt_graph, you can uncheck all the boxes under **Hide:**

.. image:: images/unhide.png

For now, though, leave those options checked to avoid confusion.

4 ros2 topic echo
^^^^^^^^^^^^^^^^^

To see the data being published on a topic, use:

.. code-block:: console

    ros2 topic echo <topic_name>

Since we know that ``/teleop_turtle`` publishes data to ``/turtlesim`` over the ``/turtle1/cmd_vel`` topic, let's use ``echo`` to introspect that topic:

.. code-block:: console

    ros2 topic echo /turtle1/cmd_vel

At first, this command won't return any data.
That's because it's waiting for ``/teleop_turtle`` to publish something.

Return to the terminal where ``turtle_teleop_key`` is running and use the arrows to move the turtle around.
Watch the terminal where your ``echo`` is running at the same time, and you'll see position data being published for every movement you make:

.. code-block:: console

  linear:
    x: 2.0
    y: 0.0
    z: 0.0
  angular:
    x: 0.0
    y: 0.0
    z: 0.0
    ---

Now return to rqt_graph and uncheck the **Debug** box.

.. image:: images/debug.png

``/_ros2cli_26646`` is the node created by the ``echo`` command we just ran (the number might be different).
Now you can see that the publisher is publishing data over the ``cmd_vel`` topic, and two subscribers are subscribed to it.

5 ros2 topic info
^^^^^^^^^^^^^^^^^

Topics don't have to only be one-to-one communication; they can be one-to-many, many-to-one, or many-to-many.

Another way to look at this is running:

.. code-block:: console

    ros2 topic info /turtle1/cmd_vel

Which will return:

.. code-block:: console

  Type: geometry_msgs/msg/Twist
  Publisher count: 1
  Subscription count: 2

6 ros2 interface show
^^^^^^^^^^^^^^^^^^^^^

Nodes send data over topics using messages.
Publishers and subscribers must send and receive the same type of message to communicate.

The topic types we saw earlier after running ``ros2 topic list -t`` let us know what message type is used on each topic.
Recall that the ``cmd_vel`` topic has the type:

.. code-block:: console

    geometry_msgs/msg/Twist

This means that in the package ``geometry_msgs`` there is a ``msg`` called ``Twist``.

Now we can run ``ros2 interface show <msg_type>`` on this type to learn its details.
Specifically, what structure of data the message expects.

.. code-block:: console

    ros2 interface show geometry_msgs/msg/Twist

For the message type from above it yields:

.. code-block:: console

  # This expresses velocity in free space broken into its linear and angular parts.

      Vector3  linear
              float64 x
              float64 y
              float64 z
      Vector3  angular
              float64 x
              float64 y
              float64 z

This tells you that the ``/turtlesim`` node is expecting a message with two vectors, ``linear`` and ``angular``, of three elements each.
If you recall the data we saw ``/teleop_turtle`` passing to ``/turtlesim`` with the ``echo`` command, it's in the same structure:

.. code-block:: console

  linear:
    x: 2.0
    y: 0.0
    z: 0.0
  angular:
    x: 0.0
    y: 0.0
    z: 0.0
    ---

7 ros2 topic pub
^^^^^^^^^^^^^^^^

Now that you have the message structure, you can publish data to a topic directly from the command line using:

.. code-block:: console

    ros2 topic pub <topic_name> <msg_type> '<args>'

The ``'<args>'`` argument is the actual data you'll pass to the topic, in the structure you just discovered in the previous section.

The turtle (and commonly the real robots which it is meant to emulate) require a steady stream of commands to operate continuously.
So, to get the turtle moving, and keep it moving, you can use the following command.
It's important to note that this argument needs to be input in YAML syntax.
Input the full command like so:

.. code-block:: console

  ros2 topic pub /turtle1/cmd_vel geometry_msgs/msg/Twist ""{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}""

With no command-line options, ``ros2 topic pub`` publishes the command in a steady stream at 1 Hz.

.. image:: images/pub_stream.png

At times you may want to publish data to your topic only once (rather than continuously).
To publish your command just once add the ``--once`` option.

.. code-block:: console

  ros2 topic pub --once -w 2 /turtle1/cmd_vel geometry_msgs/msg/Twist ""{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}""

``--once`` is an optional argument meaning “publish one message then exit”.

``-w 2`` is an optional argument meaning “wait for two matching subscriptions”.
This is needed because we have both turtlesim and the topic echo subscribed.

You will see the following output in the terminal:

.. code-block:: console

  Waiting for at least 2 matching subscription(s)...
  publisher: beginning loop
  publishing #1: geometry_msgs.msg.Twist(linear=geometry_msgs.msg.Vector3(x=2.0, y=0.0, z=0.0), angular=geometry_msgs.msg.Vector3(x=0.0, y=0.0, z=1.8))

And you will see your turtle move like so:

.. image:: images/pub_once.png


You can refresh rqt_graph to see what's happening graphically.
You will see that the ``ros2 topic pub ...`` node (``/_ros2cli_30358``) is publishing over the ``/turtle1/cmd_vel`` topic, which is being received by both the ``ros2 topic echo ...`` node (``/_ros2cli_26646``) and the ``/turtlesim`` node now.

.. image:: images/rqt_graph2.png

Finally, you can run ``echo`` on the ``pose`` topic and recheck rqt_graph:

.. code-block:: console

  ros2 topic echo /turtle1/pose

.. image:: images/rqt_graph3.png

You can see that the ``/turtlesim`` node is also publishing to the ``pose`` topic, which the new ``echo`` node has subscribed to.

When publishing messages with timestamps, ``pub`` has two methods to automatically fill them out with the current time.
For messages with a ``std_msgs/msg/Header``, the header field can be set to ``auto`` to fill out the ``stamp`` field.

.. code-block:: console

  ros2 topic pub /pose geometry_msgs/msg/PoseStamped '{header: ""auto"", pose: {position: {x: 1.0, y: 2.0, z: 3.0}}}'

If the message does not use a full header, but just has a field with type ``builtin_interfaces/msg/Time``, that can be set to the value ``now``.

.. code-block:: console

  ros2 topic pub /reference sensor_msgs/msg/TimeReference '{header: ""auto"", time_ref: ""now"", source: ""dumy""}'

8 ros2 topic hz
^^^^^^^^^^^^^^^

You can also view the rate at which data is published using:

.. code-block:: console

    ros2 topic hz /turtle1/pose

It will return data on the rate at which the ``/turtlesim`` node is publishing data to the ``pose`` topic.

.. code-block:: console

  average rate: 59.354
    min: 0.005s max: 0.027s std dev: 0.00284s window: 58

Recall that you set the rate of ``turtle1/cmd_vel`` to publish at a steady 1 Hz using ``ros2 topic pub --rate 1``.
If you run the above command with ``turtle1/cmd_vel`` instead of ``turtle1/pose``, you will see an average reflecting that rate.

9 ros2 topic bw
^^^^^^^^^^^^^^^

The bandwidth used by a topic can be viewed using:

.. code-block:: console

    ros2 topic bw /turtle1/pose

It returns the bandwidth utilization and number of messages being published to the ``/turtle1/pose`` topic.

.. code-block:: console

    Subscribed to [/turtle1/pose]
    1.51 KB/s from 62 messages
        Message size mean: 0.02 KB min: 0.02 KB max: 0.02 KB

10 ros2 topic find
^^^^^^^^^^^^^^^^^^

To list a list of available topics of a given type use:

.. code-block:: console

    ros2 topic find <topic_type>

Recall that the ``cmd_vel`` topic has the type:

.. code-block:: console

    geometry_msgs/msg/Twist

Using the ``find`` command outputs topics available when given the message type:

.. code-block:: console

    ros2 topic find geometry_msgs/msg/Twist

This outputs:

.. code-block:: console

    /turtle1/cmd_vel

11 Clean up
^^^^^^^^^^^

At this point you'll have a lot of nodes running.
Don't forget to stop them by entering ``Ctrl+C`` in each terminal.

Summary
-------

Nodes publish information over topics, which allows any number of other nodes to subscribe to and access that information.
In this tutorial you examined the connections between several nodes over topics using rqt_graph and command line tools.
You should now have a good idea of how data moves around a ROS 2 system.

Next steps
----------

Next you'll learn about another communication type in the ROS graph with the tutorial :doc:`../Understanding-ROS2-Services/Understanding-ROS2-Services`.
",What command can you use to view the rate at which data is published to a specific topic in ROS 2?
".. redirect-from::

    Tutorials/Understanding-ROS2-Nodes

.. _ROS2Nodes:

Understanding nodes
===================

**Goal:** Learn about the function of nodes in ROS 2, and the tools to interact with them.

**Tutorial level:** Beginner

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

1 The ROS 2 graph
^^^^^^^^^^^^^^^^^

Over the next few tutorials, you will learn about a series of core ROS 2 concepts that make up what is referred to as the “ROS (2) graph”.

The ROS graph is a network of ROS 2 elements processing data together at the same time.
It encompasses all executables and the connections between them if you were to map them all out and visualize them.

2 Nodes in ROS 2
^^^^^^^^^^^^^^^^

Each node in ROS should be responsible for a single, modular purpose, e.g. controlling the wheel motors or publishing the sensor data from a laser range-finder.
Each node can send and receive data from other nodes via topics, services, actions, or parameters.

.. image:: images/Nodes-TopicandService.gif

A full robotic system is comprised of many nodes working in concert.
In ROS 2, a single executable (C++ program, Python program, etc.) can contain one or more nodes.

Prerequisites
-------------

The :doc:`previous tutorial <../Introducing-Turtlesim/Introducing-Turtlesim>` shows you how to install the ``turtlesim`` package used here.

As always, don't forget to source ROS 2 in :doc:`every new terminal you open <../Configuring-ROS2-Environment>`.

Tasks
-----

1 ros2 run
^^^^^^^^^^

The command ``ros2 run`` launches an executable from a package.

.. code-block:: console

    ros2 run <package_name> <executable_name>

To run turtlesim, open a new terminal, and enter the following command:

.. code-block:: console

    ros2 run turtlesim turtlesim_node

The turtlesim window will open, as you saw in the :doc:`previous tutorial <../Introducing-Turtlesim/Introducing-Turtlesim>`.

Here, the package name is ``turtlesim`` and the executable name is ``turtlesim_node``.

We still don't know the node name, however.
You can find node names by using ``ros2 node list``

2 ros2 node list
^^^^^^^^^^^^^^^^

``ros2 node list`` will show you the names of all running nodes.
This is especially useful when you want to interact with a node, or when you have a system running many nodes and need to keep track of them.

Open a new terminal while turtlesim is still running in the other one, and enter the following command:

.. code-block:: console

    ros2 node list

The terminal will return the node name:

.. code-block:: console

  /turtlesim

Open another new terminal and start the teleop node with the command:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

Here, we are referring to the ``turtlesim`` package again, but this time we target the executable named ``turtle_teleop_key``.

Return to the terminal where you ran ``ros2 node list`` and run it again.
You will now see the names of two active nodes:

.. code-block:: console

  /turtlesim
  /teleop_turtle

2.1 Remapping
~~~~~~~~~~~~~

`Remapping <https://design.ros2.org/articles/ros_command_line_arguments.html#name-remapping-rules>`__ allows you to reassign default node properties, like node name, topic names, service names, etc., to custom values.
In the last tutorial, you used remapping on ``turtle_teleop_key`` to change the cmd_vel topic and target **turtle2**.

Now, let's reassign the name of our ``/turtlesim`` node.
In a new terminal, run the following command:

.. code-block:: console

  ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle

Since you're calling ``ros2 run`` on turtlesim again, another turtlesim window will open.
However, now if you return to the terminal where you ran ``ros2 node list``, and run it again, you will see three node names:

.. code-block:: console

    /my_turtle
    /turtlesim
    /teleop_turtle

3 ros2 node info
^^^^^^^^^^^^^^^^

Now that you know the names of your nodes, you can access more information about them with:

.. code-block:: console

    ros2 node info <node_name>

To examine your latest node, ``my_turtle``, run the following command:

.. code-block:: console

    ros2 node info /my_turtle

``ros2 node info`` returns a list of subscribers, publishers, services, and actions. i.e. the ROS graph connections that interact with that node.
The output should look like this:

.. code-block:: console

  /my_turtle
    Subscribers:
      /parameter_events: rcl_interfaces/msg/ParameterEvent
      /turtle1/cmd_vel: geometry_msgs/msg/Twist
    Publishers:
      /parameter_events: rcl_interfaces/msg/ParameterEvent
      /rosout: rcl_interfaces/msg/Log
      /turtle1/color_sensor: turtlesim_msgs/msg/Color
      /turtle1/pose: turtlesim_msgs/msg/Pose
    Service Servers:
      /clear: std_srvs/srv/Empty
      /kill: turtlesim_msgs/srv/Kill
      /my_turtle/describe_parameters: rcl_interfaces/srv/DescribeParameters
      /my_turtle/get_parameter_types: rcl_interfaces/srv/GetParameterTypes
      /my_turtle/get_parameters: rcl_interfaces/srv/GetParameters
      /my_turtle/list_parameters: rcl_interfaces/srv/ListParameters
      /my_turtle/set_parameters: rcl_interfaces/srv/SetParameters
      /my_turtle/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically
      /reset: std_srvs/srv/Empty
      /spawn: turtlesim_msgs/srv/Spawn
      /turtle1/set_pen: turtlesim_msgs/srv/SetPen
      /turtle1/teleport_absolute: turtlesim_msgs/srv/TeleportAbsolute
      /turtle1/teleport_relative: turtlesim_msgs/srv/TeleportRelative
    Service Clients:

    Action Servers:
      /turtle1/rotate_absolute: turtlesim_msgs/action/RotateAbsolute
    Action Clients:

Now try running the same command on the ``/teleop_turtle`` node, and see how its connections differ from ``my_turtle``.

You will learn more about the ROS graph connection concepts including the message types in the upcoming tutorials.

Summary
-------

A node is a fundamental ROS 2 element that serves a single, modular purpose in a robotics system.

In this tutorial, you utilized nodes created in the ``turtlesim`` package by running the executables ``turtlesim_node`` and ``turtle_teleop_key``.

You learned how to use ``ros2 node list`` to discover active node names and ``ros2 node info`` to introspect a single node.
These tools are vital to understanding the flow of data in a complex, real-world robot system.

Next steps
----------

Now that you understand nodes in ROS 2, you can move on to the :doc:`topics tutorial <../Understanding-ROS2-Topics/Understanding-ROS2-Topics>`.
Topics are one of the communication types that connects nodes.

Related content
---------------

The :doc:`../../../Concepts` page adds some more detail to the concept of nodes.
","What command allows you to show the names of all running nodes in ROS 2, especially useful when interacting with nodes or managing a system with multiple nodes?"
".. redirect-from::

    Tutorials/Launch/CLI-Intro

.. _ROS2Launch:

Launching nodes
===============

**Goal:** Use a command line tool to launch multiple nodes at once.

**Tutorial Level:** Beginner

**Time:** 5 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In most of the introductory tutorials, you have been opening new terminals for every new node you run.
As you create more complex systems with more and more nodes running simultaneously, opening terminals and reentering configuration details becomes tedious.

Launch files allow you to start up and configure a number of executables containing ROS 2 nodes simultaneously.

Running a single launch file with the ``ros2 launch`` command will start up your entire system - all nodes and their configurations - at once.

Prerequisites
-------------

Before starting these tutorials, install ROS 2 by following the instructions on the ROS 2 :doc:`../../../Installation/` page.

The commands used in this tutorial assume you followed the binary packages installation guide for your operating system (deb packages for Linux).
You can still follow along if you built from source, but the path to your setup files will likely be different.
You also won't be able to use the ``sudo apt install ros-<distro>-<package>`` command (used frequently in the beginner level tutorials) if you install from source.

If you are using Linux and are not already familiar with the shell, `this tutorial <https://www.linux.com/training-tutorials/bash-101-working-cli/>`__ will help.

Tasks
-----

Running a Launch File
^^^^^^^^^^^^^^^^^^^^^

Open a new terminal and run:

.. code-block:: console

   ros2 launch turtlesim multisim.launch.py

This command will run the following launch file:

.. code-block:: python

   # turtlesim/launch/multisim.launch.py

   from launch import LaunchDescription
   import launch_ros.actions

   def generate_launch_description():
       return LaunchDescription([
           launch_ros.actions.Node(
               namespace= ""turtlesim1"", package='turtlesim', executable='turtlesim_node', output='screen'),
           launch_ros.actions.Node(
               namespace= ""turtlesim2"", package='turtlesim', executable='turtlesim_node', output='screen'),
       ])

.. note::

  The launch file above is written in Python, but you can also use XML and YAML to create launch files.
  You can see a comparison of these different ROS 2 launch formats in :doc:`../../../How-To-Guides/Launch-file-different-formats`.

This will run two turtlesim nodes:

.. image:: images/turtlesim_multisim.png

For now, don't worry about the contents of this launch file.
You can find more information on ROS 2 launch in the :doc:`ROS 2 launch tutorials <../../Intermediate/Launch/Launch-Main>`.

(Optional) Control the Turtlesim Nodes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now that these nodes are running, you can control them like any other ROS 2 nodes.
For example, you can make the turtles drive in opposite directions by opening up two additional terminals and running the following commands:

In the second terminal:

.. code-block:: console

   ros2 topic pub  /turtlesim1/turtle1/cmd_vel geometry_msgs/msg/Twist ""{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}""

In the third terminal:

.. code-block:: console

   ros2 topic pub  /turtlesim2/turtle1/cmd_vel geometry_msgs/msg/Twist ""{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: -1.8}}""

After running these commands, you should see something like the following:

.. image:: images/turtlesim_multisim_spin.png

Summary
-------

The significance of what you've done so far is that you've run two turtlesim nodes with one command.
Once you learn to write your own launch files, you'll be able to run multiple nodes - and set up their configuration - in a similar way, with the ``ros2 launch`` command.

For more tutorials on ROS 2 launch files, see the :doc:`main launch file tutorial page<../../Intermediate/Launch/Launch-Main>`.

Next steps
----------

In the next tutorial, :doc:`../Recording-And-Playing-Back-Data/Recording-And-Playing-Back-Data`, you'll learn about another helpful tool, ``ros2 bag``.
",What command is used to launch multiple nodes at once using a launch file in ROS 2?
".. redirect-from::

    Tutorials/Ros2bag/Recording-And-Playing-Back-Data

.. _ROS2Bag:

Recording and playing back data
===============================

**Goal:** Record data published on a topic and a service so you can replay and examine it any time.

**Tutorial level:** Beginner

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

``ros2 bag`` is a command line tool for recording data published on topics and services in your ROS 2 system.
It accumulates the data passed on any number of topics and services, then saves it in a database.
You can then replay the data to reproduce the results of your tests and experiments.
Recording topics and services is also a great way to share your work and allow others to recreate it.


Prerequisites
-------------

You should have ``ros2 bag`` installed as a part of your regular ROS 2 setup.

If you need to install ROS 2, see the :doc:`Installation instructions <../../../Installation>`.

This tutorial talks about concepts covered in previous tutorials, like :doc:`nodes <../Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>`, :doc:`topics <../Understanding-ROS2-Topics/Understanding-ROS2-Topics>` and :doc:`services <../Understanding-ROS2-Services/Understanding-ROS2-Services>`.
It also uses the :doc:`turtlesim package <../Introducing-Turtlesim/Introducing-Turtlesim>` and  :doc:`Service Introspection Demo <../../Demos/Service-Introspection>`.

As always, don't forget to source ROS 2 in :doc:`every new terminal you open <../Configuring-ROS2-Environment>`.


Managing Topic Data
-------------------

1 Setup
^^^^^^^

You'll be recording your keyboard input in the ``turtlesim`` system to save and replay later on, so begin by starting up the ``/turtlesim`` and ``/teleop_turtle`` nodes.

Open a new terminal and run:

.. code-block:: console

    ros2 run turtlesim turtlesim_node

Open another terminal and run:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

Let's also make a new directory to store our saved recordings, just as good practice:

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            mkdir bag_files
            cd bag_files

    .. group-tab:: macOS

        .. code-block:: console

            mkdir bag_files
            cd bag_files

    .. group-tab:: Windows

        .. code-block:: console

            md bag_files
            cd bag_files


2 Choose a topic
^^^^^^^^^^^^^^^^

``ros2 bag`` can record data from messages published to topics.
To see the list of your system's topics, open a new terminal and run the command:

.. code-block:: console

  ros2 topic list

Which will return:

.. code-block:: console

  /parameter_events
  /rosout
  /turtle1/cmd_vel
  /turtle1/color_sensor
  /turtle1/pose

In the topics tutorial, you learned that the ``/turtle_teleop`` node publishes commands on the ``/turtle1/cmd_vel`` topic to make the turtle move in turtlesim.

To see the data that ``/turtle1/cmd_vel`` is publishing, run the command:

.. code-block:: console

  ros2 topic echo /turtle1/cmd_vel

Nothing will show up at first because no data is being published by the teleop.
Return to the terminal where you ran the teleop and select it so it's active.
Use the arrow keys to move the turtle around, and you will see data being published on the terminal running ``ros2 topic echo``.

.. code-block:: console

  linear:
    x: 2.0
    y: 0.0
    z: 0.0
  angular:
    x: 0.0
    y: 0.0
    z: 0.0
    ---


3 Record topics
^^^^^^^^^^^^^^^

3.1 Record a single topic
~~~~~~~~~~~~~~~~~~~~~~~~~

To record the data published to a topic use the command syntax:

.. code-block:: console

    ros2 bag record <topic_name>

Before running this command on your chosen topic, open a new terminal and move into the ``bag_files`` directory you created earlier, because the rosbag file will save in the directory where you run it.

Run the command:

.. code-block:: console

    ros2 bag record /turtle1/cmd_vel

You will see the following messages in the terminal (the date and time will be different):

.. code-block:: console

    [INFO] [rosbag2_storage]: Opened database 'rosbag2_2019_10_11-05_18_45'.
    [INFO] [rosbag2_transport]: Listening for topics...
    [INFO] [rosbag2_transport]: Subscribed to topic '/turtle1/cmd_vel'
    [INFO] [rosbag2_transport]: All requested topics are subscribed. Stopping discovery...

Now ``ros2 bag`` is recording the data published on the ``/turtle1/cmd_vel`` topic.
Return to the teleop terminal and move the turtle around again.
The movements don't matter, but try to make a recognizable pattern to see when you replay the data later.

.. image:: images/record.png

Press ``Ctrl+C`` to stop recording.

The data will be accumulated in a new bag directory with a name in the pattern of ``rosbag2_year_month_day-hour_minute_second``.
This directory will contain a ``metadata.yaml`` along with the bag file in the recorded format.

3.2 Record multiple topics
~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also record multiple topics, as well as change the name of the file ``ros2 bag`` saves to.

Run the following command:

.. code-block:: console

  ros2 bag record -o subset /turtle1/cmd_vel /turtle1/pose

The ``-o`` option allows you to choose a unique name for your bag file.
The following string, in this case ``subset``, is the file name.

To record more than one topic at a time, simply list each topic separated by a space.

You will see the following message, confirming that both topics are being recorded.

.. code-block:: console

  [INFO] [rosbag2_storage]: Opened database 'subset'.
  [INFO] [rosbag2_transport]: Listening for topics...
  [INFO] [rosbag2_transport]: Subscribed to topic '/turtle1/cmd_vel'
  [INFO] [rosbag2_transport]: Subscribed to topic '/turtle1/pose'
  [INFO] [rosbag2_transport]: All requested topics are subscribed. Stopping discovery...

You can move the turtle around and press ``Ctrl+C`` when you're finished.

.. note::

    There is another option you can add to the command, ``-a``, which records all the topics on your system.

4 Inspect topic data
^^^^^^^^^^^^^^^^^^^^

You can see details about your recording by running:

.. code-block:: console

    ros2 bag info <bag_file_name>

Running this command on the ``subset`` bag file will return a list of information on the file:

.. code-block:: console

    ros2 bag info subset

.. code-block:: console

  Files:             subset.mcap
  Bag size:          228.5 KiB
  Storage id:        mcap
  Duration:          48.47s
  Start:             Oct 11 2019 06:09:09.12 (1570799349.12)
  End                Oct 11 2019 06:09:57.60 (1570799397.60)
  Messages:          3013
  Topic information: Topic: /turtle1/cmd_vel | Type: geometry_msgs/msg/Twist | Count: 9 | Serialization Format: cdr
                   Topic: /turtle1/pose | Type: turtlesim_msgs/msg/Pose | Count: 3004 | Serialization Format: cdr

5 Play topic data
^^^^^^^^^^^^^^^^^

Before replaying the bag file, enter ``Ctrl+C`` in the terminal where the teleop is running.
Then make sure your turtlesim window is visible so you can see the bag file in action.

Enter the command:

.. code-block:: console

    ros2 bag play subset

The terminal will return the message:

.. code-block:: console

    [INFO] [rosbag2_storage]: Opened database 'subset'.

Your turtle will follow the same path you entered while recording (though not 100% exactly; turtlesim is sensitive to small changes in the system's timing).

.. image:: images/playback.png

Because the ``subset`` file recorded the ``/turtle1/pose`` topic, the ``ros2 bag play`` command won't quit for as long as you had turtlesim running, even if you weren't moving.

This is because as long as the ``/turtlesim`` node is active, it publishes data on the  ``/turtle1/pose`` topic at regular intervals.
You may have noticed in the ``ros2 bag info`` example result above that the  ``/turtle1/cmd_vel`` topic's ``Count`` information was only 9; that's how many times we pressed the arrow keys while recording.

Notice that ``/turtle1/pose`` has a ``Count`` value of over 3000; while we were recording, data was published on that topic 3000 times.

To get an idea of how often position data is published, you can run the command:

.. code-block:: console

    ros2 topic hz /turtle1/pose

Managing Service Data
---------------------

1 Setup
^^^^^^^

You'll be recording service data between ``introspection_client`` and ``introspection_service``, then display and replay that same data later on.
To record service data between service client and server, ``Service Introspection`` must be enabled on the node.

Let's start ``introspection_client`` and ``introspection_service`` nodes and enable ``Service Introspection``.
You can see more details for :doc:`Service Introspection Demo <../../Demos/Service-Introspection>`.

Open a new terminal and run ``introspection_service``, enabling ``Service Introspection``:

.. code-block:: console

  ros2 run demo_nodes_cpp introspection_service --ros-args -p service_configure_introspection:=contents

Open another terminal and run ``introspection_client``, enabling ``Service Introspection``:

.. code-block:: console

  ros2 run demo_nodes_cpp introspection_client --ros-args -p client_configure_introspection:=contents

2 Check service availability
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``ros2 bag`` can only record data from available services.
To see the list of your system's services, open a new terminal and run the command:

.. code-block:: console

  ros2 service list

Which will return:

.. code-block:: console

  /add_two_ints
  /introspection_client/describe_parameters
  /introspection_client/get_parameter_types
  /introspection_client/get_parameters
  /introspection_client/get_type_description
  /introspection_client/list_parameters
  /introspection_client/set_parameters
  /introspection_client/set_parameters_atomically
  /introspection_service/describe_parameters
  /introspection_service/get_parameter_types
  /introspection_service/get_parameters
  /introspection_service/get_type_description
  /introspection_service/list_parameters
  /introspection_service/set_parameters
  /introspection_service/set_parameters_atomically

To check if ``Service Introspection`` is enabled on the client and service, run the command:

.. code-block:: console

  ros2 service echo --flow-style /add_two_ints

You should see service communication like below:

.. code-block:: console

  info:
    event_type: REQUEST_SENT
    stamp:
      sec: 1713995389
      nanosec: 386809259
    client_gid: [1, 15, 96, 219, 162, 1, 108, 201, 0, 0, 0, 0, 0, 0, 21, 3]
    sequence_number: 133
  request: [{a: 2, b: 3}]
  response: []
  ---

3 Record services
^^^^^^^^^^^^^^^^^

To record service data, the following options are supported.
Service data can be recorded with topics at the same time.

To record specific services:

.. code-block:: console

  ros2 bag record --service <service_names>

To record all services:

.. code-block:: console

  ros2 bag record --all-services

Run the command:

.. code-block:: console

  ros2 bag record --service /add_two_ints

You will see the following messages in the terminal (the date and time will be different):

.. code-block:: console

  [INFO] [1713995957.643573503] [rosbag2_recorder]: Press SPACE for pausing/resuming
  [INFO] [1713995957.662067587] [rosbag2_recorder]: Event publisher thread: Starting
  [INFO] [1713995957.662067614] [rosbag2_recorder]: Listening for topics...
  [INFO] [1713995957.666048323] [rosbag2_recorder]: Subscribed to topic '/add_two_ints/_service_event'
  [INFO] [1713995957.666092458] [rosbag2_recorder]: Recording...

Now ``ros2 bag`` is recording the service data published on the ``/add_two_ints`` service.
To stop the recording, enter ``Ctrl+C`` in the terminal.

The data will be accumulated in a new bag directory with a name in the pattern of ``rosbag2_year_month_day-hour_minute_second``.
This directory will contain a ``metadata.yaml`` along with the bag file in the recorded format.

4 Inspect service data
^^^^^^^^^^^^^^^^^^^^^^

You can see details about your recording by running:

.. code-block:: console

  ros2 bag info <bag_file_name>

Running this command will return a list of information on the file:

.. code-block:: console

  Files:             rosbag2_2024_04_24-14_59_17_0.mcap
  Bag size:          15.1 KiB
  Storage id:        mcap
  ROS Distro:        rolling
  Duration:          9.211s
  Start:             Apr 24 2024 14:59:17.676 (1713995957.676)
  End:               Apr 24 2024 14:59:26.888 (1713995966.888)
  Messages:          0
  Topic information:
  Service:           1
  Service information: Service: /add_two_ints | Type: example_interfaces/srv/AddTwoInts | Event Count: 78 | Serialization Format: cdr

5 Play service data
^^^^^^^^^^^^^^^^^^^

Before replaying the bag file, enter ``Ctrl+C`` in the terminal where ``introspection_client`` is running.
When ``introspection_client`` stops running, ``introspection_service`` also stops printing the result because there are no incoming requests.

Replaying the service data from the bag file will start sending the requests to ``introspection_service``.

Enter the command:

.. code-block:: console

    ros2 bag play --publish-service-requests <bag_file_name>

The terminal will return the message:

.. code-block:: console

  [INFO] [1713997477.870856190] [rosbag2_player]: Set rate to 1
  [INFO] [1713997477.877417477] [rosbag2_player]: Adding keyboard callbacks.
  [INFO] [1713997477.877442404] [rosbag2_player]: Press SPACE for Pause/Resume
  [INFO] [1713997477.877447855] [rosbag2_player]: Press CURSOR_RIGHT for Play Next Message
  [INFO] [1713997477.877452655] [rosbag2_player]: Press CURSOR_UP for Increase Rate 10%
  [INFO] [1713997477.877456954] [rosbag2_player]: Press CURSOR_DOWN for Decrease Rate 10%
  [INFO] [1713997477.877573647] [rosbag2_player]: Playback until timestamp: -1

Your ``introspection_service`` terminal will once again start printing the following service messages:

.. code-block:: console

  [INFO] [1713997478.090466075] [introspection_service]: Incoming request
  a: 2 b: 3

This is because ``ros2 bag play`` sends the service request data from the bag file to the ``/add_two_ints`` service.

We can also introspect service communication as ``ros2 bag play`` is playing it back to verify the ``introspection_service``.

Run this command before ``ros2 bag play`` to see the ``introspection_service``:

.. code-block:: console

  ros2 service echo --flow-style /add_two_ints

You can see the service request from the bag file and the service response from  ``introspection_service``.

.. code-block:: console

  info:
    event_type: REQUEST_RECEIVED
    stamp:
      sec: 1713998176
      nanosec: 372700698
    client_gid: [1, 15, 96, 219, 80, 2, 158, 123, 0, 0, 0, 0, 0, 0, 20, 4]
    sequence_number: 1
  request: [{a: 2, b: 3}]
  response: []
  ---
  info:
    event_type: RESPONSE_SENT
    stamp:
      sec: 1713998176
      nanosec: 373016882
    client_gid: [1, 15, 96, 219, 80, 2, 158, 123, 0, 0, 0, 0, 0, 0, 20, 4]
    sequence_number: 1
  request: []
  response: [{sum: 5}]

Summary
-------

You can record data passed on topics and services in your ROS 2 system using the ``ros2 bag`` command.
Whether you're sharing your work with others or introspecting your own experiments, it's a great tool to know about.

Next steps
----------

You've completed the ""Beginner: CLI Tools"" tutorials!
The next step is tackling the ""Beginner: Client Libraries"" tutorials, starting with :doc:`../../Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace`.

Related content
---------------

A more thorough explanation of ``ros2 bag`` can be found in the README `here <https://github.com/ros2/rosbag2>`__.
For more information on service recording and playback can be found in the design document `here <https://github.com/ros2/rosbag2/blob/{DISTRO}/docs/design/rosbag2_record_replay_service.md>`__.
For more information on QoS compatibility and ``ros2 bag``, see :doc:`../../../How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback`.
",What commands can be used to record service data using `ros2 bag`?
".. redirect-from::

    Managed-Nodes
    Tutorials/Managed-Nodes

Managing nodes with managed lifecycles
======================================

This page lives now directly side-by-side with the `code <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/lifecycle/README.rst>`__.
For more information about the ``lifecycle`` package, refer to `rosindex <https://index.ros.org/p/lifecycle/github-ros2-demos/>`__.
","Where can more information about the ""lifecycle"" package be found?"
".. redirect-from::

    dummy-robot-demo
    Tutorials/dummy-robot-demo

Experimenting with a dummy robot
================================

In this demo, we present a simple demo robot with all components from publishing joint states over publishing fake laser data until visualizing the robot model on a map in RViz.

Launching the demo
------------------

We assume your ROS 2 installation dir as ``~/ros2_ws``. Please change the directories according to your platform.

To start the demo, we execute the demo bringup launch file, which we are going to explain in more details in the next section.

.. tabs::

  .. group-tab:: Source Build

    mkdir -p ~/ros2_ws/src
    cd ~/ros2_ws/src
    git clone -b ${ROS_DISTRO} https://github.com/ros2/demos
    cd .. && colcon build --packages-up-to dummy_robot_bringup
    source ~/ros2_ws/install/setup.bash
    ros2 launch dummy_robot_bringup dummy_robot_bringup_launch.py

  .. group-tab:: deb Package

    sudo apt install ros-${ROS_DISTRO}-dummy-robot-bringup
    ros2 launch dummy_robot_bringup dummy_robot_bringup_launch.py

You should see some prints inside your terminal along the lines of the following:

.. code-block:: bash

   [INFO] [launch]: Default logging verbosity is set to INFO
   [INFO] [dummy_map_server-1]: process started with pid [2922]
   [INFO] [robot_state_publisher-2]: process started with pid [2923]
   [INFO] [dummy_joint_states-3]: process started with pid [2924]
   [INFO] [dummy_laser-4]: process started with pid [2925]
   [dummy_laser-4] [INFO] [1714837459.645517297] [dummy_laser]: angle inc:    0.004363
   [dummy_laser-4] [INFO] [1714837459.645613393] [dummy_laser]: scan size:    1081
   [dummy_laser-4] [INFO] [1714837459.645626640] [dummy_laser]: scan time increment:     0.000000
   [robot_state_publisher-2] [INFO] [1714837459.652977937] [robot_state_publisher]: Robot initialized

If you now open RViz2 in a new terminal, you'll see your robot. 🎉

.. code-block:: bash

   $ source ~/ros2_ws/install/setup.bash
   $ rviz2

This opens RViz2. Assuming you have your dummy_robot_bringup still launched, you can now add the TF display plugin and configure your global frame to ``world``. Once you did that, you should see a similar picture:


.. image:: images/rviz-dummy-robot.png


What's happening?
^^^^^^^^^^^^^^^^^

If you have a closer look at the launch file, we start a couple of nodes at the same time.


* dummy_map_server
* dummy_laser
* dummy_joint_states
* robot_state_publisher

The first two packages are relatively simple. The ``dummy_map_server`` constantly publishes an empty map with a periodic update. The ``dummy_laser`` does basically the same; publishing dummy fake laser scans.

The ``dummy_joint_states`` node is publishing fake joint state data. As we are publishing a simple RRbot with only two joints, this node publishes joint states values for these two joints.

The ``robot_state_publisher`` is doing the actual interesting work. It parses the given URDF file, extracts the robot model and listens to the incoming joint states. With this information, it publishes TF values for our robot which we visualize in RViz.

Hooray!
",What are the different nodes that are started simultaneously in the dummy robot demo and what are their respective functionalities?
".. redirect-from::

    Rosbag-with-ROS1-Bridge
    Tutorials/Rosbag-with-ROS1-Bridge

Recording and playing back data with ``rosbag`` using the ROS 1 bridge
======================================================================

This tutorial is a follow up to the *Bridge communication between ROS 1 and ROS 2* demo as can be found `here <https://github.com/ros2/ros1_bridge/blob/master/README.md>`__, and in the following it is assumed you have completed that tutorial already.

The ros1_bridge can be built from :doc:`source <../../How-To-Guides/Using-ros1_bridge-Jammy-upstream>` for these examples.

What follows is a series of additional examples, like that ones that come at the end of the aforementioned *Bridge communication between ROS 1 and ROS 2* demo.

Recording topic data with rosbag and ROS 1 Bridge
-------------------------------------------------

In this example, we'll be using the ``cam2image`` demo program that comes with ROS 2 and a Python script to emulate a simple turtlebot-like robot's sensor data so that we can bridge it to ROS 1 and use rosbag to record it.

First we'll run a ROS 1 ``roscore`` in a new shell:

.. code-block:: bash

   # Shell A:
   . /opt/ros/kinetic/setup.bash
   # Or, on OSX, something like:
   # . ~/ros_catkin_ws/install_isolated/setup.bash
   roscore

Then we'll run the ROS 1 <=> ROS 2 ``dynamic_bridge`` with the ``--bridge-all-topics`` option (so we can do ``rostopic list`` and see them) in another shell:

.. code-block:: bash

   # Shell B:
   . /opt/ros/kinetic/setup.bash
   # Or, on OSX, something like:
   # . ~/ros_catkin_ws/install_isolated/setup.bash
   . /opt/ros/ardent/setup.bash
   # Or, if building ROS 2 from source:
   # . <workspace-with-bridge>/install/setup.bash
   export ROS_MASTER_URI=http://localhost:11311
   ros2 run ros1_bridge dynamic_bridge --bridge-all-topics

Remember to replace ``<workspace-with-bridge>`` with the path to where you either extracted the ROS 2 binary or where you built ROS 2 from source.

----

Now we can start up the ROS 2 programs that will emulate our turtlebot-like robot.
First we'll run the ``cam2image`` program with the ``-b`` option so it doesn't require a camera to work:

.. code-block:: bash

   # Shell C:
   . /opt/ros/ardent/setup.bash
   # Or, if building ROS 2 from source:
   # . <workspace-with-bridge>/install/setup.bash
   ros2 run image_tools cam2image -- -b

TODO: use namespaced topic names

Then we'll run a simple Python script to emulate the ``odom`` and ``imu_data`` topics from a Kobuki base.
I would use the more accurate ``~sensors/imu_data`` topic name for the imu data, but we don't have namespace support just yet in ROS 2 (it's coming!).
Place this script in a file called ``emulate_kobuki_node.py``:

.. code-block:: python

   #!/usr/bin/env python3

   import sys
   import time

   import rclpy

   from nav_msgs.msg import Odometry
   from sensor_msgs.msg import Imu

   def main():
       rclpy.init(args=sys.argv)

       node = rclpy.create_node('emulate_kobuki_node')

       imu_publisher = node.create_publisher(Imu, 'imu_data')
       odom_publisher = node.create_publisher(Odometry, 'odom')

       imu_msg = Imu()
       odom_msg = Odometry()
       counter = 0
       while True:
           counter += 1
           now = time.time()
           if (counter % 50) == 0:
               odom_msg.header.stamp.sec = int(now)
               odom_msg.header.stamp.nanosec = int(now * 1e9) % 1000000000
               odom_publisher.publish(odom_msg)
           if (counter % 100) == 0:
               imu_msg.header.stamp.sec = int(now)
               imu_msg.header.stamp.nanosec = int(now * 1e9) % 1000000000
               imu_publisher.publish(imu_msg)
               counter = 0
           time.sleep(0.001)


   if __name__ == '__main__':
       sys.exit(main())

You can run this python script in a new ROS 2 shell:

.. code-block:: bash

   # Shell D:
   . /opt/ros/ardent/setup.bash
   # Or, if building ROS 2 from source:
   # . <workspace-with-bridge>/install/setup.bash
   python3 emulate_kobuki_node.py

----

Now that all the data sources and the dynamic bridge are running, we can look at the available topics in a new ROS 1 shell:

.. code-block:: bash

   # Shell E:
   . /opt/ros/kinetic/setup.bash
   # Or, on OSX, something like:
   # . ~/ros_catkin_ws/install_isolated/setup.bash
   rostopic list

You should see something like this:

::

   % rostopic list
   /image
   /imu_data
   /odom
   /rosout
   /rosout_agg

We can now record this data with ``rosbag record`` in the same shell:

.. code-block:: bash

   # Shell E:
   rosbag record /image /imu_data /odom

After a few seconds you can ``Ctrl-c`` the ``rosbag`` command and do an ``ls -lh`` to see how big the file is, you might see something like this:

.. code-block:: bash

   % ls -lh
   total 0
   -rw-rw-r-- 1 william william  12M Feb 23 16:59 2017-02-23-16-59-47.bag

Though the file name will be different for your bag (since it is derived from the date and time).

Playing back topic data with rosbag and ROS 1 Bridge
----------------------------------------------------

Now that we have a bag file you can use any of the ROS 1 tools to introspect the bag file, like ``rosbag info <bag file>``, ``rostopic list -b <bag file>``, or ``rqt_bag <bag file>``.
However, we can also playback bag data into ROS 2 using ``rosbag play`` and the ROS 1 <=> ROS 2 ``dynamic_bridge``.

First close out all the shells you opened for the previous tutorial, stopping any running programs.

Then in a new shell start the ``roscore``:

.. code-block:: bash

   # Shell P:
   . /opt/ros/kinetic/setup.bash
   # Or, on OSX, something like:
   # . ~/ros_catkin_ws/install_isolated/setup.bash
   roscore

Then run the ``dynamic_bridge`` in another shell:

.. code-block:: bash

   # Shell Q:
   . /opt/ros/kinetic/setup.bash
   # Or, on OSX, something like:
   # . ~/ros_catkin_ws/install_isolated/setup.bash
   . /opt/ros/ardent/setup.bash
   # Or, if building ROS 2 from source:
   # . <workspace-with-bridge>/install/setup.bash
   export ROS_MASTER_URI=http://localhost:11311
   ros2 run ros1_bridge dynamic_bridge --bridge-all-topics

Then play the bag data back with ``rosbag play`` in another new shell, using the ``--loop`` option so that we don't have to keep restarting it for short bags:

.. code-block:: bash

   # Shell R:
   . /opt/ros/kinetic/setup.bash
   # Or, on OSX, something like:
   # . ~/ros_catkin_ws/install_isolated/setup.bash
   rosbag play --loop path/to/bag_file

Make sure to replace ``path/to/bag_file`` with the path to the bag file you want to playback.

----

Now that the data is being played back and the bridge is running we can see the data coming across in ROS 2.

.. code-block:: bash

   # Shell S:
   . /opt/ros/ardent/setup.bash
   # Or, if building ROS 2 from source:
   # . <workspace-with-bridge>/install/setup.bash
   ros2 topic list
   ros2 topic echo /odom

You should see something like:

::

   % ros2 topic list
   /clock
   /image
   /imu_data
   /odom
   /parameter_events

You can also see the image being played from the bag by using the ``showimage`` tool:

.. code-block:: bash

   ros2 run image_tools showimage
",What command can be used to record topic data with rosbag and ROS 1 Bridge?
".. redirect-from::

    Tutorials/Content-Filtering-Subscription

Creating a content filtering subscription
=========================================

**Goal:** Create a content filtering subscription.

**Tutorial level:** Advanced

**Time:** 15 minutes

.. contents:: Table of Contents
   :depth: 1
   :local:

Overview
--------

ROS 2 applications typically consist of topics to transmit data from publishers to subscriptions.
Basically, subscriptions receive all published data from publishers on the topic.
But sometimes, a subscription might be interested in only a subset of the data which is being sent by publishers.
A content filtering subscription allows to receive only the data of interest for the application.

In this demo, we'll be highlighting how to create a content filtering subscription and how they work.

RMW Support
-----------

Content filtering subscriptions require RMW implementation support.

.. list-table::  Content-Filtering-Subscription Support Status
   :widths: 25 25

   * - rmw_fastrtps
     - supported
   * - rmw_connextdds
     - supported
   * - rmw_cyclonedds
     - not supported

Currently all RMW implementations that support content filtering subscriptions are `DDS <https://www.omg.org/omg-dds-portal/>`__ based.
That means that the supported filtering expressions and parameters are also dependent on `DDS <https://www.omg.org/omg-dds-portal/>`__, you can refer to `DDS specification <https://www.omg.org/spec/DDS/1.4/PDF>`__ ``Annex B - Syntax for Queries and Filters`` for details.

Installing the demo
-------------------

See the :doc:`installation instructions <../../Installation>` for details on installing ROS 2.

If you've installed ROS 2 from packages, ensure that you have ``ros-{DISTRO}-demo-nodes-cpp`` installed.
If you downloaded the archive or built ROS 2 from source, it will already be part of the installation.

Temperature filtering demo
--------------------------

This demo shows how a content filtering subscription can be used to only receive temperature values that are out of the acceptable temperature range, detecting emergencies.
The content filtering subscription filters out the uninteresting temperature data, so that the subscription callback is not issued.

ContentFilteringPublisher:

https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/topics/content_filtering_publisher.cpp

.. code-block:: c++

    #include <chrono>
    #include <cstdio>
    #include <memory>
    #include <utility>

    #include ""rclcpp/rclcpp.hpp""
    #include ""rclcpp_components/register_node_macro.hpp""

    #include ""std_msgs/msg/float32.hpp""

    #include ""demo_nodes_cpp/visibility_control.h""

    using namespace std::chrono_literals;

    namespace demo_nodes_cpp
    {
    // The simulated temperature data starts from -100.0 and ends at 150.0 with a step size of 10.0
    constexpr std::array<float, 3> TEMPERATURE_SETTING {-100.0f, 150.0f, 10.0f};

    // Create a ContentFilteringPublisher class that subclasses the generic rclcpp::Node base class.
    // The main function below will instantiate the class as a ROS node.
    class ContentFilteringPublisher : public rclcpp::Node
    {
    public:
      DEMO_NODES_CPP_PUBLIC
      explicit ContentFilteringPublisher(const rclcpp::NodeOptions & options)
      : Node(""content_filtering_publisher"", options)
      {
        // Create a function for when messages are to be sent.
        setvbuf(stdout, NULL, _IONBF, BUFSIZ);
        auto publish_message =
          [this]() -> void
          {
            msg_ = std::make_unique<std_msgs::msg::Float32>();
            msg_->data = temperature_;
            temperature_ += TEMPERATURE_SETTING[2];
            if (temperature_ > TEMPERATURE_SETTING[1]) {
              temperature_ = TEMPERATURE_SETTING[0];
            }
            RCLCPP_INFO(this->get_logger(), ""Publishing: '%f'"", msg_->data);
            // Put the message into a queue to be processed by the middleware.
            // This call is non-blocking.
            pub_->publish(std::move(msg_));
          };
        // Create a publisher with a custom Quality of Service profile.
        // Uniform initialization is suggested so it can be trivially changed to
        // rclcpp::KeepAll{} if the user wishes.
        // (rclcpp::KeepLast(7) -> rclcpp::KeepAll() fails to compile)
        rclcpp::QoS qos(rclcpp::KeepLast{7});
        pub_ = this->create_publisher<std_msgs::msg::Float32>(""temperature"", qos);

        // Use a timer to schedule periodic message publishing.
        timer_ = this->create_wall_timer(1s, publish_message);
      }

    private:
      float temperature_ = TEMPERATURE_SETTING[0];
      std::unique_ptr<std_msgs::msg::Float32> msg_;
      rclcpp::Publisher<std_msgs::msg::Float32>::SharedPtr pub_;
      rclcpp::TimerBase::SharedPtr timer_;
    };

    }  // namespace demo_nodes_cpp

The content filter is defined in the subscription side, publishers don't need to be configured in any special way to allow content filtering.
The ``ContentFilteringPublisher`` node publishes simulated temperature data starting from -100.0 and ending at 150.0 with a step size of 10.0 every second.

We can run the demo by running the ``ros2 run demo_nodes_cpp content_filtering_publisher`` executable (don't forget to source the setup file first):

.. code-block:: bash

    $ ros2 run demo_nodes_cpp content_filtering_publisher
    [INFO] [1651094594.822753479] [content_filtering_publisher]: Publishing: '-100.000000'
    [INFO] [1651094595.822723857] [content_filtering_publisher]: Publishing: '-90.000000'
    [INFO] [1651094596.822752996] [content_filtering_publisher]: Publishing: '-80.000000'
    [INFO] [1651094597.822752475] [content_filtering_publisher]: Publishing: '-70.000000'
    [INFO] [1651094598.822721485] [content_filtering_publisher]: Publishing: '-60.000000'
    [INFO] [1651094599.822696188] [content_filtering_publisher]: Publishing: '-50.000000'
    [INFO] [1651094600.822699217] [content_filtering_publisher]: Publishing: '-40.000000'
    [INFO] [1651094601.822744113] [content_filtering_publisher]: Publishing: '-30.000000'
    [INFO] [1651094602.822694805] [content_filtering_publisher]: Publishing: '-20.000000'
    [INFO] [1651094603.822735805] [content_filtering_publisher]: Publishing: '-10.000000'
    [INFO] [1651094604.822722094] [content_filtering_publisher]: Publishing: '0.000000'
    [INFO] [1651094605.822699960] [content_filtering_publisher]: Publishing: '10.000000'
    [INFO] [1651094606.822748946] [content_filtering_publisher]: Publishing: '20.000000'
    [INFO] [1651094607.822694017] [content_filtering_publisher]: Publishing: '30.000000'
    [INFO] [1651094608.822708798] [content_filtering_publisher]: Publishing: '40.000000'
    [INFO] [1651094609.822692417] [content_filtering_publisher]: Publishing: '50.000000'
    [INFO] [1651094610.822696426] [content_filtering_publisher]: Publishing: '60.000000'
    [INFO] [1651094611.822751913] [content_filtering_publisher]: Publishing: '70.000000'
    [INFO] [1651094612.822692231] [content_filtering_publisher]: Publishing: '80.000000'
    [INFO] [1651094613.822745549] [content_filtering_publisher]: Publishing: '90.000000'
    [INFO] [1651094614.822701982] [content_filtering_publisher]: Publishing: '100.000000'
    [INFO] [1651094615.822691465] [content_filtering_publisher]: Publishing: '110.000000'
    [INFO] [1651094616.822649070] [content_filtering_publisher]: Publishing: '120.000000'
    [INFO] [1651094617.822693616] [content_filtering_publisher]: Publishing: '130.000000'
    [INFO] [1651094618.822691832] [content_filtering_publisher]: Publishing: '140.000000'
    [INFO] [1651094619.822688452] [content_filtering_publisher]: Publishing: '150.000000'
    [INFO] [1651094620.822645327] [content_filtering_publisher]: Publishing: '-100.000000'
    [INFO] [1651094621.822689219] [content_filtering_publisher]: Publishing: '-90.000000'
    [INFO] [1651094622.822694292] [content_filtering_publisher]: Publishing: '-80.000000'
    [...]

ContentFilteringSubscriber:

https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/topics/content_filtering_subscriber.cpp

.. code-block:: c++

    #include ""rclcpp/rclcpp.hpp""
    #include ""rclcpp_components/register_node_macro.hpp""
    #include ""rcpputils/join.hpp""

    #include ""std_msgs/msg/float32.hpp""

    #include ""demo_nodes_cpp/visibility_control.h""

    namespace demo_nodes_cpp
    {
    // Emergency temperature data less than -30 or greater than 100
    constexpr std::array<float, 2> EMERGENCY_TEMPERATURE {-30.0f, 100.0f};

    // Create a ContentFilteringSubscriber class that subclasses the generic rclcpp::Node base class.
    // The main function below will instantiate the class as a ROS node.
    class ContentFilteringSubscriber : public rclcpp::Node
    {
    public:
      DEMO_NODES_CPP_PUBLIC
      explicit ContentFilteringSubscriber(const rclcpp::NodeOptions & options)
      : Node(""content_filtering_subscriber"", options)
      {
        setvbuf(stdout, NULL, _IONBF, BUFSIZ);
        // Create a callback function for when messages are received.
        auto callback =
          [this](const std_msgs::msg::Float32 & msg) -> void
          {
            if (msg.data < EMERGENCY_TEMPERATURE[0] || msg.data > EMERGENCY_TEMPERATURE[1]) {
              RCLCPP_INFO(
                this->get_logger(),
                ""I receive an emergency temperature data: [%f]"", msg.data);
            } else {
              RCLCPP_INFO(this->get_logger(), ""I receive a temperature data: [%f]"", msg.data);
            }
          };

        // Initialize a subscription with a content filter to receive emergency temperature data that
        // are less than -30 or greater than 100.
        rclcpp::SubscriptionOptions sub_options;
        sub_options.content_filter_options.filter_expression = ""data < %0 OR data > %1"";
        sub_options.content_filter_options.expression_parameters = {
          std::to_string(EMERGENCY_TEMPERATURE[0]),
          std::to_string(EMERGENCY_TEMPERATURE[1])
        };

        sub_ = create_subscription<std_msgs::msg::Float32>(""temperature"", 10, callback, sub_options);

        if (!sub_->is_cft_enabled()) {
          RCLCPP_WARN(
            this->get_logger(), ""Content filter is not enabled since it's not supported"");
        } else {
          RCLCPP_INFO(
            this->get_logger(),
            ""subscribed to topic \""%s\"" with content filter options \""%s, {%s}\"""",
            sub_->get_topic_name(),
            sub_options.content_filter_options.filter_expression.c_str(),
            rcpputils::join(sub_options.content_filter_options.expression_parameters, "", "").c_str());
        }
      }

    private:
      rclcpp::Subscription<std_msgs::msg::Float32>::SharedPtr sub_;
    };

    }  // namespace demo_nodes_cpp

To enable content filtering, applications can set the filtering expression and the expression parameters in ``SubscriptionOptions``.
The application can also check if content filtering is enabled on the subscription.

In this demo, the ``ContentFilteringSubscriber`` node creates a content filtering subscription that receives a message only if the temperature value is less than -30.0 or greater than 100.0.

As commented before, content filtering subscription support depends on the RMW implementation.
Applications can use the ``is_cft_enabled`` method to check if content filtering is actually enabled on the subscription.

To test content filtering subscription, let's run it:

.. code-block:: bash

    $ ros2 run demo_nodes_cpp content_filtering_subscriber
    [INFO] [1651094590.682660703] [content_filtering_subscriber]: subscribed to topic ""/temperature"" with content filter options ""data < %0 OR data > %1, {-30.000000, 100.000000}""
    [INFO] [1651094594.823805294] [content_filtering_subscriber]: I receive an emergency temperature data: [-100.000000]
    [INFO] [1651094595.823419993] [content_filtering_subscriber]: I receive an emergency temperature data: [-90.000000]
    [INFO] [1651094596.823410859] [content_filtering_subscriber]: I receive an emergency temperature data: [-80.000000]
    [INFO] [1651094597.823350377] [content_filtering_subscriber]: I receive an emergency temperature data: [-70.000000]
    [INFO] [1651094598.823282657] [content_filtering_subscriber]: I receive an emergency temperature data: [-60.000000]
    [INFO] [1651094599.823297857] [content_filtering_subscriber]: I receive an emergency temperature data: [-50.000000]
    [INFO] [1651094600.823355597] [content_filtering_subscriber]: I receive an emergency temperature data: [-40.000000]
    [INFO] [1651094615.823315377] [content_filtering_subscriber]: I receive an emergency temperature data: [110.000000]
    [INFO] [1651094616.823258458] [content_filtering_subscriber]: I receive an emergency temperature data: [120.000000]
    [INFO] [1651094617.823323525] [content_filtering_subscriber]: I receive an emergency temperature data: [130.000000]
    [INFO] [1651094618.823315527] [content_filtering_subscriber]: I receive an emergency temperature data: [140.000000]
    [INFO] [1651094619.823331424] [content_filtering_subscriber]: I receive an emergency temperature data: [150.000000]
    [INFO] [1651094620.823271748] [content_filtering_subscriber]: I receive an emergency temperature data: [-100.000000]
    [INFO] [1651094621.823343550] [content_filtering_subscriber]: I receive an emergency temperature data: [-90.000000]
    [INFO] [1651094622.823286326] [content_filtering_subscriber]: I receive an emergency temperature data: [-80.000000]
    [INFO] [1651094623.823371031] [content_filtering_subscriber]: I receive an emergency temperature data: [-70.000000]
    [INFO] [1651094624.823333112] [content_filtering_subscriber]: I receive an emergency temperature data: [-60.000000]
    [INFO] [1651094625.823266469] [content_filtering_subscriber]: I receive an emergency temperature data: [-50.000000]
    [INFO] [1651094626.823284093] [content_filtering_subscriber]: I receive an emergency temperature data: [-40.000000]

You should see a message showing the content filtering options used and logs for each message received only if the temperature value is less than -30.0 or greater than 100.0.

If content filtering is not supported by the RMW implementation, the subscription will still be created without content filtering enabled.
We can try that by executing ``RMW_IMPLEMENTATION=rmw_cyclonedds_cpp ros2 run demo_nodes_cpp content_filtering_publisher``.

.. code-block:: bash

    $ RMW_IMPLEMENTATION=rmw_cyclonedds_cpp ros2 run demo_nodes_cpp content_filtering_subscriber
    [WARN] [1651096637.893842072] [content_filtering_subscriber]: Content filter is not enabled since it is not supported
    [INFO] [1651096641.246043703] [content_filtering_subscriber]: I receive an emergency temperature data: [-100.000000]
    [INFO] [1651096642.245833527] [content_filtering_subscriber]: I receive an emergency temperature data: [-90.000000]
    [INFO] [1651096643.245743471] [content_filtering_subscriber]: I receive an emergency temperature data: [-80.000000]
    [INFO] [1651096644.245833932] [content_filtering_subscriber]: I receive an emergency temperature data: [-70.000000]
    [INFO] [1651096645.245916679] [content_filtering_subscriber]: I receive an emergency temperature data: [-60.000000]
    [INFO] [1651096646.245861895] [content_filtering_subscriber]: I receive an emergency temperature data: [-50.000000]
    [INFO] [1651096647.245946352] [content_filtering_subscriber]: I receive an emergency temperature data: [-40.000000]
    [INFO] [1651096648.245934569] [content_filtering_subscriber]: I receive a temperature data: [-30.000000]
    [INFO] [1651096649.245877906] [content_filtering_subscriber]: I receive a temperature data: [-20.000000]
    [INFO] [1651096650.245939068] [content_filtering_subscriber]: I receive a temperature data: [-10.000000]
    [INFO] [1651096651.245911450] [content_filtering_subscriber]: I receive a temperature data: [0.000000]
    [INFO] [1651096652.245879830] [content_filtering_subscriber]: I receive a temperature data: [10.000000]
    [INFO] [1651096653.245858329] [content_filtering_subscriber]: I receive a temperature data: [20.000000]
    [INFO] [1651096654.245916370] [content_filtering_subscriber]: I receive a temperature data: [30.000000]
    [INFO] [1651096655.245933741] [content_filtering_subscriber]: I receive a temperature data: [40.000000]
    [INFO] [1651096656.245833975] [content_filtering_subscriber]: I receive a temperature data: [50.000000]
    [INFO] [1651096657.245971483] [content_filtering_subscriber]: I receive a temperature data: [60.000000]

You can see the message ``Content filter is not enabled`` because underlying RMW implementation does not support the feature, but the demo still successfully creates the normal subscription to receive all temperature data.

Related content
---------------

- `content filtering examples <https://github.com/ros2/examples/blob/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_subscriber/content_filtering.cpp>`__ that covers all interfaces for content filtering subscription.
- `content filtering design PR <https://github.com/ros2/design/pull/282>`__
",What is the purpose of creating a content filtering subscription in ROS 2 applications?
".. redirect-from::

    Intra-Process-Communication
    Tutorials/Intra-Process-Communication

Setting up efficient intra-process communication
================================================

.. contents:: Table of Contents
   :depth: 1
   :local:

Background
----------

ROS applications typically consist of a composition of individual ""nodes"" which perform narrow tasks and are decoupled from other parts of the system.
This promotes fault isolation, faster development, modularity, and code reuse, but it often comes at the cost of performance.
After ROS 1 was initially developed, the need for efficient composition of nodes became obvious and Nodelets were developed.
In ROS 2 we aim to improve on the design of Nodelets by addressing some fundamental problems that required restructuring of nodes.

In this demo we'll be highlighting how nodes can be composed manually, by defining the nodes separately but combining them in different process layouts without changing the node's code or limiting its abilities.

Installing the demos
--------------------

See the :doc:`installation instructions <../../Installation>` for details on installing ROS 2.

If you've installed ROS 2 from packages, ensure that you have ``ros-{DISTRO}-intra-process-demo`` installed.
If you downloaded the archive or built ROS 2 from source, it will already be part of the installation.

Running and understanding the demos
-----------------------------------

There are a few different demos: some are toy problems designed to highlight features of the intra process communications functionality and some are end to end examples which use OpenCV and demonstrate the ability to recombine nodes into different configurations.

The two node pipeline demo
^^^^^^^^^^^^^^^^^^^^^^^^^^

This demo is designed to show that the intra process publish/subscribe connection can result in zero-copy transport of messages when publishing and subscribing with ``std::unique_ptr``\ s.

First let's take a look at the source:

https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/intra_process_demo/src/two_node_pipeline/two_node_pipeline.cpp

.. code-block:: c++

   #include <chrono>
   #include <cinttypes>
   #include <cstdio>
   #include <memory>
   #include <string>
   #include <utility>

   #include ""rclcpp/rclcpp.hpp""
   #include ""std_msgs/msg/int32.hpp""

   using namespace std::chrono_literals;

   // Node that produces messages.
   struct Producer : public rclcpp::Node
   {
     Producer(const std::string & name, const std::string & output)
     : Node(name, rclcpp::NodeOptions().use_intra_process_comms(true))
     {
       // Create a publisher on the output topic.
       pub_ = this->create_publisher<std_msgs::msg::Int32>(output, 10);
       std::weak_ptr<std::remove_pointer<decltype(pub_.get())>::type> captured_pub = pub_;
       // Create a timer which publishes on the output topic at ~1Hz.
       auto callback = [captured_pub]() -> void {
           auto pub_ptr = captured_pub.lock();
           if (!pub_ptr) {
             return;
           }
           static int32_t count = 0;
           std_msgs::msg::Int32::UniquePtr msg(new std_msgs::msg::Int32());
           msg->data = count++;
           printf(
             ""Published message with value: %d, and address: 0x%"" PRIXPTR ""\n"", msg->data,
             reinterpret_cast<std::uintptr_t>(msg.get()));
           pub_ptr->publish(std::move(msg));
         };
       timer_ = this->create_wall_timer(1s, callback);
     }

     rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr pub_;
     rclcpp::TimerBase::SharedPtr timer_;
   };

   // Node that consumes messages.
   struct Consumer : public rclcpp::Node
   {
     Consumer(const std::string & name, const std::string & input)
     : Node(name, rclcpp::NodeOptions().use_intra_process_comms(true))
     {
       // Create a subscription on the input topic which prints on receipt of new messages.
       sub_ = this->create_subscription<std_msgs::msg::Int32>(
         input,
         10,
         [](std_msgs::msg::Int32::UniquePtr msg) {
           printf(
             "" Received message with value: %d, and address: 0x%"" PRIXPTR ""\n"", msg->data,
             reinterpret_cast<std::uintptr_t>(msg.get()));
         });
     }

     rclcpp::Subscription<std_msgs::msg::Int32>::SharedPtr sub_;
   };

   int main(int argc, char * argv[])
   {
     setvbuf(stdout, NULL, _IONBF, BUFSIZ);
     rclcpp::init(argc, argv);
     rclcpp::executors::SingleThreadedExecutor executor;

     auto producer = std::make_shared<Producer>(""producer"", ""number"");
     auto consumer = std::make_shared<Consumer>(""consumer"", ""number"");

     executor.add_node(producer);
     executor.add_node(consumer);
     executor.spin();

     rclcpp::shutdown();

     return 0;
   }

As you can see by looking at the ``main`` function, we have a producer and a consumer node, we add them to a single threaded executor, and then call spin.

If you look at the ""producer"" node's implementation in the ``Producer`` struct, you can see that we have created a publisher which publishes on the ""number"" topic and a timer which periodically creates a new message, prints out its address in memory and its content's value and then publishes it.

The ""consumer"" node is a bit simpler, you can see its implementation in the ``Consumer`` struct, as it only subscribes to the ""number"" topic and prints the address and value of the message it receives.

The expectation is that the producer will print out an address and value and the consumer will print out a matching address and value.
This demonstrates that intra process communication is indeed working and unnecessary copies are avoided, at least for simple graphs.

Let's run the demo by executing ``ros2 run intra_process_demo two_node_pipeline`` executable (don't forget to source the setup file first):

.. code-block:: bash

   $ ros2 run intra_process_demo two_node_pipeline
   Published message with value: 0, and address: 0x7fb02303faf0
   Published message with value: 1, and address: 0x7fb020cf0520
    Received message with value: 1, and address: 0x7fb020cf0520
   Published message with value: 2, and address: 0x7fb020e12900
    Received message with value: 2, and address: 0x7fb020e12900
   Published message with value: 3, and address: 0x7fb020cf0520
    Received message with value: 3, and address: 0x7fb020cf0520
   Published message with value: 4, and address: 0x7fb020e12900
    Received message with value: 4, and address: 0x7fb020e12900
   Published message with value: 5, and address: 0x7fb02303cea0
    Received message with value: 5, and address: 0x7fb02303cea0
   [...]

One thing you'll notice is that the messages tick along at about one per second.
This is because we told the timer to fire at about once per second.

Also you may have noticed that the first message (with value ``0``) does not have a corresponding ""Received message ..."" line.
This is because publish/subscribe is ""best effort"" and we do not have any ""latching"" like behavior enabled.
This means that if the publisher publishes a message before the subscription has been established, the subscription will not receive that message.
This race condition can result in the first few messages being lost.
In this case, since they only come once per second, usually only the first message is lost.

Finally, you can see that ""Published message..."" and ""Received message ..."" lines with the same value also have the same address.
This shows that the address of the message being received is the same as the one that was published and that it is not a copy.
This is because we're publishing and subscribing with ``std::unique_ptr``\ s which allow ownership of a message to be moved around the system safely.
You can also publish and subscribe with ``const &`` and ``std::shared_ptr``, but zero-copy will not occur in that case.

The cyclic pipeline demo
^^^^^^^^^^^^^^^^^^^^^^^^

This demo is similar to the previous one, but instead of the producer creating a new message for each iteration, this demo only ever uses one message instance.
This is achieved by creating a cycle in the graph and ""kicking off"" communication by externally making one of the nodes publish before spinning the executor:

https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/intra_process_demo/src/cyclic_pipeline/cyclic_pipeline.cpp

.. code-block:: c++

   #include <chrono>
   #include <cinttypes>
   #include <cstdio>
   #include <memory>
   #include <string>
   #include <utility>

   #include ""rclcpp/rclcpp.hpp""
   #include ""std_msgs/msg/int32.hpp""

   using namespace std::chrono_literals;

   // This node receives an Int32, waits 1 second, then increments and sends it.
   struct IncrementerPipe : public rclcpp::Node
   {
     IncrementerPipe(const std::string & name, const std::string & in, const std::string & out)
     : Node(name, rclcpp::NodeOptions().use_intra_process_comms(true))
     {
       // Create a publisher on the output topic.
       pub = this->create_publisher<std_msgs::msg::Int32>(out, 10);
       std::weak_ptr<std::remove_pointer<decltype(pub.get())>::type> captured_pub = pub;
       // Create a subscription on the input topic.
       sub = this->create_subscription<std_msgs::msg::Int32>(
         in,
         10,
         [captured_pub](std_msgs::msg::Int32::UniquePtr msg) {
           auto pub_ptr = captured_pub.lock();
           if (!pub_ptr) {
             return;
           }
           printf(
             ""Received message with value:         %d, and address: 0x%"" PRIXPTR ""\n"", msg->data,
             reinterpret_cast<std::uintptr_t>(msg.get()));
           printf(""  sleeping for 1 second...\n"");
           if (!rclcpp::sleep_for(1s)) {
             return;    // Return if the sleep failed (e.g. on :kbd:`ctrl-c`).
           }
           printf(""  done.\n"");
           msg->data++;    // Increment the message's data.
           printf(
             ""Incrementing and sending with value: %d, and address: 0x%"" PRIXPTR ""\n"", msg->data,
             reinterpret_cast<std::uintptr_t>(msg.get()));
           pub_ptr->publish(std::move(msg));    // Send the message along to the output topic.
         });
     }

     rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr pub;
     rclcpp::Subscription<std_msgs::msg::Int32>::SharedPtr sub;
   };

   int main(int argc, char * argv[])
   {
     setvbuf(stdout, NULL, _IONBF, BUFSIZ);
     rclcpp::init(argc, argv);
     rclcpp::executors::SingleThreadedExecutor executor;

     // Create a simple loop by connecting the in and out topics of two IncrementerPipe's.
     // The expectation is that the address of the message being passed between them never changes.
     auto pipe1 = std::make_shared<IncrementerPipe>(""pipe1"", ""topic1"", ""topic2"");
     auto pipe2 = std::make_shared<IncrementerPipe>(""pipe2"", ""topic2"", ""topic1"");
     rclcpp::sleep_for(1s);  // Wait for subscriptions to be established to avoid race conditions.
     // Publish the first message (kicking off the cycle).
     std::unique_ptr<std_msgs::msg::Int32> msg(new std_msgs::msg::Int32());
     msg->data = 42;
     printf(
       ""Published first message with value:  %d, and address: 0x%"" PRIXPTR ""\n"", msg->data,
       reinterpret_cast<std::uintptr_t>(msg.get()));
     pipe1->pub->publish(std::move(msg));

     executor.add_node(pipe1);
     executor.add_node(pipe2);
     executor.spin();

     rclcpp::shutdown();

     return 0;
   }

Unlike the previous demo, this demo uses only one Node, instantiated twice with different names and configurations.
The graph ends up being ``pipe1`` -> ``pipe2`` -> ``pipe1`` ... in a loop.

The line ``pipe1->pub->publish(msg);`` kicks the process off, but from then on the messages are passed back and forth between the nodes by each one calling publish within its own subscription callback.

The expectation here is that the nodes pass the message back and forth, once a second, incrementing the value of the message each time.
Because the message is being published and subscribed to as a ``unique_ptr`` the same message created at the beginning is continuously used.

To test those expectations, let's run it:

.. code-block:: bash

   $ ros2 run intra_process_demo cyclic_pipeline
   Published first message with value:  42, and address: 0x7fd2ce0a2bc0
   Received message with value:         42, and address: 0x7fd2ce0a2bc0
     sleeping for 1 second...
     done.
   Incrementing and sending with value: 43, and address: 0x7fd2ce0a2bc0
   Received message with value:         43, and address: 0x7fd2ce0a2bc0
     sleeping for 1 second...
     done.
   Incrementing and sending with value: 44, and address: 0x7fd2ce0a2bc0
   Received message with value:         44, and address: 0x7fd2ce0a2bc0
     sleeping for 1 second...
     done.
   Incrementing and sending with value: 45, and address: 0x7fd2ce0a2bc0
   Received message with value:         45, and address: 0x7fd2ce0a2bc0
     sleeping for 1 second...
     done.
   Incrementing and sending with value: 46, and address: 0x7fd2ce0a2bc0
   Received message with value:         46, and address: 0x7fd2ce0a2bc0
     sleeping for 1 second...
     done.
   Incrementing and sending with value: 47, and address: 0x7fd2ce0a2bc0
   Received message with value:         47, and address: 0x7fd2ce0a2bc0
     sleeping for 1 second...
   [...]

You should see ever increasing numbers on each iteration, starting with 42... because 42, and the whole time it reuses the same message, as demonstrated by the pointer addresses which do not change, which avoids unnecessary copies.

The image pipeline demo
^^^^^^^^^^^^^^^^^^^^^^^

In this demo we'll use OpenCV to capture, annotate, and then view images.

.. note::

  If you are on macOS and these examples do not work or you receive an error like ``ddsi_conn_write failed -1``, then you'll need to increase your system wide UDP packet size:

  .. code-block:: bash

    $ sudo sysctl -w net.inet.udp.recvspace=209715
    $ sudo sysctl -w net.inet.udp.maxdgram=65500

  These changes will not persist after a reboot.

Simple pipeline
~~~~~~~~~~~~~~~

First we'll have a pipeline of three nodes, arranged as such: ``camera_node`` -> ``watermark_node`` -> ``image_view_node``

The ``camera_node`` reads from camera device ``0`` on your computer, writes some information on the image and publishes it.
The ``watermark_node`` subscribes to the output of the ``camera_node`` and adds more text before publishing it too.
Finally, the ``image_view_node`` subscribes to the output of the ``watermark_node``, writes more text to the image and then visualizes it with ``cv::imshow``.

In each node the address of the message which is being sent, or which has been received, or both, is written to the image.
The watermark and image view nodes are designed to modify the image without copying it and so the addresses imprinted on the image should all be the same as long as the nodes are in the same process and the graph remains organized in a pipeline as sketched above.

.. note::

   On some systems (we've seen it happen on Linux), the address printed to the screen might not change.
   This is because the same unique pointer is being reused. In this situation, the pipeline is still running.

Let's run the demo by executing the following executable:

.. code-block:: bash

   ros2 run intra_process_demo image_pipeline_all_in_one

You should see something like this:


.. image:: images/intra-process-demo-pipeline-single-window.png


You can pause the rendering of the image by pressing the spacebar and you can resume by pressing the spacebar again.
You can also press ``q`` or ``ESC`` to exit.

If you pause the image viewer, you should be able to compare the addresses written on the image and see that they are the same.

Pipeline with two image viewers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now let's look at an example just like the one above, except it has two image view nodes.
All the nodes are still in the same process, but now two image view windows should show up. (Note for macOS users: your image view windows might be on top of each other).
Let's run it with the command:

.. code-block:: bash

   ros2 run intra_process_demo image_pipeline_with_two_image_view


.. image:: images/intra-process-demo-pipeline-two-windows-copy.png


Just like the last example, you can pause the rendering with the spacebar and continue by pressing the spacebar a second time. You can stop the updating to inspect the pointers written to the screen.

As you can see in the example image above, we have one image with all of the pointers the same and then another image with the same pointers as the first image for the first two entries, but the last pointer on the second image is different. To understand why this is happening consider the graph's topology:

.. code-block:: bash

   camera_node -> watermark_node -> image_view_node
                                 -> image_view_node2

The link between the ``camera_node`` and the ``watermark_node`` can use the same pointer without copying because there is only one intra process subscription to which the message should be delivered. But for the link between the ``watermark_node`` and the two image view nodes the relationship is one to many, so if the image view nodes were using ``unique_ptr`` callbacks then it would be impossible to deliver the ownership of the same pointer to both. It can be, however, delivered to one of them. Which one would get the original pointer is not defined, but instead is simply the last to be delivered.

Note that the image view nodes are not subscribed with ``unique_ptr`` callbacks. Instead they are subscribed with ``const shared_ptr``\ s. This means the system deliveres the same ``shared_ptr`` to both callbacks. When the first intraprocess subscription is handled, the internally stored ``unique_ptr`` is promoted to a ``shared_ptr``. Each of the callbacks will receive shared ownership of the same message.

Pipeline with interprocess viewer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One other important thing to get right is to avoid interruption of the intra process zero-copy behavior when interprocess subscriptions are made. To test this we can run the first image pipeline demo, ``image_pipeline_all_in_one``, and then run an instance of the stand alone ``image_view_node`` (don't forget to prefix them with ``ros2 run intra_process_demo`` in the terminal). This will look something like this:


.. image:: images/intra-process-demo-pipeline-inter-process.png


It's hard to pause both images at the same time so the images may not line up, but the important thing to notice is that the ``image_pipeline_all_in_one`` image view shows the same address for each step. This means that the intra process zero-copy is preserved even when an external view is subscribed as well. You can also see that the interprocess image view has different process IDs for the first two lines of text and the process ID of the standalone image viewer in the third line of text.
",How can the concepts of intra-process communication in ROS applications be leveraged to achieve efficient composition of nodes without impacting their code or limiting their capabilities?
".. redirect-from::

    Quality-of-Service
    Tutorials/Quality-of-Service

Using quality-of-service settings for lossy networks
====================================================

.. contents:: Table of Contents
   :depth: 2
   :local:

Background
----------

Please read the documentation page `about QoS settings <../../Concepts/Intermediate/About-Quality-of-Service-Settings>` for background information on available support in ROS 2.

In this demo, we will spawn a node that publishes a camera image and another that subscribes to the image and shows it on the screen.
We will then simulate a lossy network connection between them and show how different quality of service settings handle the bad link.


Prerequisites
-------------
This tutorial assumes you have a :doc:`working ROS 2 installation <../../Installation>` and OpenCV.
See the `OpenCV documentation <http://docs.opencv.org/doc/tutorials/introduction/table_of_content_introduction/table_of_content_introduction.html#table-of-content-introduction>`__ for its installation instructions.
You will also need the ROS package ``image_tools``.

.. tabs::

   .. group-tab:: Linux Binaries

      .. code-block:: bash

        sudo apt-get install ros-{DISTRO}-image-tools

   .. group-tab:: From Source

      .. code-block:: bash

        # Clone and build the demos repo using the branch that matches your installation
        git clone https://github.com/ros2/demos.git -b {REPOS_FILE_BRANCH}


Run the demo
------------

Before running the demo, make sure you have a working webcam connected to your computer.

Once you've installed ROS 2, source your setup file:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

       . <path to ROS 2 install space>/setup.bash

  .. group-tab:: macOS

    .. code-block:: bash

       . <path to ROS 2 install space>/setup.bash

  .. group-tab:: Windows

    .. code-block:: bash

       call <path to ROS 2 install space>/local_setup.bat

Then run:

.. code-block:: bash

   ros2 run image_tools showimage

Nothing will happen yet.
``showimage`` is a subscriber node that is waiting for a publisher on the ``image`` topic.

Note: you have to close the ``showimage`` process with ``Ctrl-C`` later.
You can't just close the window.

In a separate terminal, source the install file and run the publisher node:

.. code-block:: bash

   ros2 run image_tools cam2image

This will publish an image from your webcam.
In case you don't have a camera attached to your computer, there is a commandline option which publishes predefined images.


.. code-block:: bash

   ros2 run image_tools cam2image --ros-args -p burger_mode:=True


In this window, you'll see terminal output:

.. code-block:: bash

   [INFO] [1715662452.055277255] [cam2image]: Publishing image #1
   [INFO] [1715662452.119336061] [cam2image]: Publishing image #2
   [INFO] [1715662452.187315139] [cam2image]: Publishing image #3
   ...

A window will pop up with the title ""view"" showing your camera feed.
In the first window, you'll see output from the subscriber:

.. code-block:: bash

   [INFO] [1715662452.188906764] [showimage]: Received image #camera_frame
   Received image #camera_frame
   [INFO] [1715662452.252836919] [showimage]: Received image #camera_frame
   Received image #camera_frame
   [INFO] [1715662452.320878578] [showimage]: Received image #camera_frame
   Received image #camera_frame
   ...

.. note::

   macOS users: If these examples do not work or you receive an error like ``ddsi_conn_write failed -1`` then you'll need to increase your system wide UDP packet size:

   .. code-block:: bash

      $ sudo sysctl -w net.inet.udp.recvspace=209715
      $ sudo sysctl -w net.inet.udp.maxdgram=65500

   These changes will not persist a reboot. If you want the changes to persist, add these lines to ``/etc/sysctl.conf`` (create the file if it doesn't exist already):

   .. code-block:: bash

      net.inet.udp.recvspace=209715
      net.inet.udp.maxdgram=65500

Command line options
^^^^^^^^^^^^^^^^^^^^

In one of your terminals, add a -h flag to the original command:


.. code-block:: bash

   ros2 run image_tools showimage -h



Add network traffic
^^^^^^^^^^^^^^^^^^^

.. warning::

  This section of the demo won’t work on RTI’s Connext DDS and Fast-DDS.
  When running multiple nodes in the same host, the those DDS implementation use shared memory along with the loopback interface.
  Degrading the loopback interface throughput won’t affect shared memory, thus traffic between the two nodes won’t be affected.

.. note::

   This next section is Linux-specific.

   However, for macOS and Windows you can achieve a similar effect with the utilities ""Network Link Conditioner"" (part of the xcode tool suite) and ""Clumsy"" (http://jagt.github.io/clumsy/index.html), respectively, but they will not be covered in this tutorial.

We are going to use the Linux network traffic control utility, ``tc`` (http://linux.die.net/man/8/tc).

.. code-block:: bash

   sudo tc qdisc add dev lo root netem loss 5%

This magical incantation will simulate 5% packet loss over the local loopback device.
If you use a higher resolution of the images (e.g. ``--ros-args -p width:=640 -p height:=480``) you might want to try a lower packet loss rate (e.g. ``1%``).

Next we start the ``cam2image`` and ``showimage``, and we'll soon notice that both programs seem to have slowed down the rate at which images are transmitted.
This is caused by the behavior of the default QoS settings.
Enforcing reliability on a lossy channel means that the publisher (in this case, ``cam2image``) will resend the network packets until it receives acknowledgement from the consumer (i.e. ``showimage``).

Let's now try running both programs, but with more suitable settings.
First of all, we'll use the ``-p reliability:=best_effort`` option to enable best effort communication.
The publisher will now just attempt to deliver the network packets, and don't expect acknowledgement from the consumer.
We see now that some of the frames on the ``showimage`` side were dropped, so the frame numbers in the shell running ``showimage`` won't be consecutive anymore:


.. image:: https://raw.githubusercontent.com/ros2/demos/{REPOS_FILE_BRANCH}/image_tools/doc/qos-best-effort.png
   :target: https://raw.githubusercontent.com/ros2/demos/{REPOS_FILE_BRANCH}/image_tools/doc/qos-best-effort.png
   :alt: Best effort image transfer


When you're done, remember to delete the queueing discipline:

.. code-block:: bash

   sudo tc qdisc delete dev lo root netem loss 5%
",What command is used to simulate packet loss over the local loopback device in Linux?
".. redirect-from::

    Tutorials/Service-Introspection

Configure service introspection
===============================

**Goal:** Configure service introspection for a service client and a server.

**Tutorial level:** Advanced

**Time:** 15 minutes

.. contents:: Table of Contents
   :depth: 1
   :local:

Overview
--------

ROS 2 applications usually consist of services to execute specific procedures in remote nodes.
It is possible to introspect service data communication with service introspection.

In this demo, we'll be highlighting how to configure service introspection state for a service client and a server and monitor service communication with ``ros2 service echo``.

Installing the demo
-------------------

See the :doc:`installation instructions <../../Installation>` for details on installing ROS 2.

If you've installed ROS 2 binary packages, ensure that you have ``ros-{DISTRO}-demo-nodes-cpp`` installed.
If you downloaded the archive or built ROS 2 from source, it will already be part of the installation.

Introspection Configuration State
---------------------------------

There are 3 configuration states for service introspection.

.. list-table::  Service Introspection Configuration State
   :widths: 25 25

   * - RCL_SERVICE_INTROSPECTION_OFF
     - Disabled
   * - RCL_SERVICE_INTROSPECTION_METADATA
     - Only metadata without any user data contents
   * - RCL_SERVICE_INTROSPECTION_CONTENTS
     - User data contents with metadata

Introspection demo
------------------

This demo shows how to manage service introspection and monitor the service data communication with using ``ros2 service echo``.

IntrospectionServiceNode:

https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/services/introspection_service.cpp

.. code-block:: c++

    namespace demo_nodes_cpp
    {

    class IntrospectionServiceNode : public rclcpp::Node
    {
    public:
      DEMO_NODES_CPP_PUBLIC
      explicit IntrospectionServiceNode(const rclcpp::NodeOptions & options)
      : Node(""introspection_service"", options)
      {
        auto handle_add_two_ints =
          [this](const std::shared_ptr<rmw_request_id_t> request_header,
            const std::shared_ptr<example_interfaces::srv::AddTwoInts::Request> request,
            std::shared_ptr<example_interfaces::srv::AddTwoInts::Response> response) -> void
          {
            (void)request_header;
            RCLCPP_INFO(
              this->get_logger(), ""Incoming request\na: %"" PRId64 "" b: %"" PRId64,
              request->a, request->b);
            response->sum = request->a + request->b;
          };
        // Create a service that will use the callback function to handle requests.
        srv_ = create_service<example_interfaces::srv::AddTwoInts>(""add_two_ints"", handle_add_two_ints);

        auto on_set_parameter_callback =
          [](std::vector<rclcpp::Parameter> parameters) {
            rcl_interfaces::msg::SetParametersResult result;
            result.successful = true;
            for (const rclcpp::Parameter & param : parameters) {
              if (param.get_name() != ""service_configure_introspection"") {
                continue;
              }

              if (param.get_type() != rclcpp::ParameterType::PARAMETER_STRING) {
                result.successful = false;
                result.reason = ""must be a string"";
                break;
              }

              if (param.as_string() != ""disabled"" && param.as_string() != ""metadata"" &&
                param.as_string() != ""contents"")
              {
                result.successful = false;
                result.reason = ""must be one of 'disabled', 'metadata', or 'contents'"";
                break;
              }
            }

            return result;
          };

        auto post_set_parameter_callback =
          [this](const std::vector<rclcpp::Parameter> & parameters) {
            for (const rclcpp::Parameter & param : parameters) {
              if (param.get_name() != ""service_configure_introspection"") {
                continue;
              }

              rcl_service_introspection_state_t introspection_state = RCL_SERVICE_INTROSPECTION_OFF;

              if (param.as_string() == ""disabled"") {
                introspection_state = RCL_SERVICE_INTROSPECTION_OFF;
              } else if (param.as_string() == ""metadata"") {
                introspection_state = RCL_SERVICE_INTROSPECTION_METADATA;
              } else if (param.as_string() == ""contents"") {
                introspection_state = RCL_SERVICE_INTROSPECTION_CONTENTS;
              }

              this->srv_->configure_introspection(
                this->get_clock(), rclcpp::SystemDefaultsQoS(), introspection_state);
              break;
            }
          };

        on_set_parameters_callback_handle_ = this->add_on_set_parameters_callback(
          on_set_parameter_callback);
        post_set_parameters_callback_handle_ = this->add_post_set_parameters_callback(
          post_set_parameter_callback);

        this->declare_parameter(""service_configure_introspection"", ""disabled"");
      }

    private:
      rclcpp::Service<example_interfaces::srv::AddTwoInts>::SharedPtr srv_;
      rclcpp::node_interfaces::OnSetParametersCallbackHandle::SharedPtr
        on_set_parameters_callback_handle_;
      rclcpp::node_interfaces::PostSetParametersCallbackHandle::SharedPtr
        post_set_parameters_callback_handle_;
    };

    }  // namespace demo_nodes_cpp

Service introspection is disable in default, so users need to enable it to call ``configure_introspection`` on service server.
In this demo, ``IntrospectionServiceNode`` uses a parameter named ```service_configure_introspection`` to configure the service introspection state.

1st we need to start ``IntrospectionServiceNode``.

.. code-block:: bash

    $ ros2 run demo_nodes_cpp introspection_service

To change service introspection state, we need to set the ``configure_introspection`` parameter as following.

.. code-block:: bash

    ### User data contents with metadata
    $ ros2 param set /introspection_service service_configure_introspection contents
    ### Or only metadata
    $ ros2 param set /introspection_service service_configure_introspection metadata
    ### To disable
    $ ros2 param set /introspection_service service_configure_introspection disabled

IntrospectionClientNode:

https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/services/introspection_client.cpp

.. code-block:: c++

    namespace demo_nodes_cpp
    {
    class IntrospectionClientNode : public rclcpp::Node
    {
    public:
      DEMO_NODES_CPP_PUBLIC
      explicit IntrospectionClientNode(const rclcpp::NodeOptions & options)
      : Node(""introspection_client"", options)
      {
        client_ = create_client<example_interfaces::srv::AddTwoInts>(""add_two_ints"");

        auto on_set_parameter_callback =
          [](std::vector<rclcpp::Parameter> parameters) {
            rcl_interfaces::msg::SetParametersResult result;
            result.successful = true;
            for (const rclcpp::Parameter & param : parameters) {
              if (param.get_name() != ""client_configure_introspection"") {
                continue;
              }

              if (param.get_type() != rclcpp::ParameterType::PARAMETER_STRING) {
                result.successful = false;
                result.reason = ""must be a string"";
                break;
              }

              if (param.as_string() != ""disabled"" && param.as_string() != ""metadata"" &&
                param.as_string() != ""contents"")
              {
                result.successful = false;
                result.reason = ""must be one of 'disabled', 'metadata', or 'contents'"";
                break;
              }
            }

            return result;
          };

        auto post_set_parameter_callback =
          [this](const std::vector<rclcpp::Parameter> & parameters) {
            for (const rclcpp::Parameter & param : parameters) {
              if (param.get_name() != ""client_configure_introspection"") {
                continue;
              }

              rcl_service_introspection_state_t introspection_state = RCL_SERVICE_INTROSPECTION_OFF;

              if (param.as_string() == ""disabled"") {
                introspection_state = RCL_SERVICE_INTROSPECTION_OFF;
              } else if (param.as_string() == ""metadata"") {
                introspection_state = RCL_SERVICE_INTROSPECTION_METADATA;
              } else if (param.as_string() == ""contents"") {
                introspection_state = RCL_SERVICE_INTROSPECTION_CONTENTS;
              }

              this->client_->configure_introspection(
                this->get_clock(), rclcpp::SystemDefaultsQoS(), introspection_state);
              break;
            }
          };

        on_set_parameters_callback_handle_ = this->add_on_set_parameters_callback(
          on_set_parameter_callback);
        post_set_parameters_callback_handle_ = this->add_post_set_parameters_callback(
          post_set_parameter_callback);

        this->declare_parameter(""client_configure_introspection"", ""disabled"");

        timer_ = this->create_wall_timer(
          std::chrono::milliseconds(500),
          [this]() {
            if (!client_->service_is_ready()) {
              return;
            }

            if (!request_in_progress_) {
              auto request = std::make_shared<example_interfaces::srv::AddTwoInts::Request>();
              request->a = 2;
              request->b = 3;
              request_in_progress_ = true;
              client_->async_send_request(
                request,
                [this](rclcpp::Client<example_interfaces::srv::AddTwoInts>::SharedFuture cb_f)
                {
                  request_in_progress_ = false;
                  RCLCPP_INFO(get_logger(), ""Result of add_two_ints: %ld"", cb_f.get()->sum);
                }
              );
              return;
            }
          });
      }

    private:
      rclcpp::Client<example_interfaces::srv::AddTwoInts>::SharedPtr client_;
      rclcpp::TimerBase::SharedPtr timer_;
      rclcpp::node_interfaces::OnSetParametersCallbackHandle::SharedPtr
        on_set_parameters_callback_handle_;
      rclcpp::node_interfaces::PostSetParametersCallbackHandle::SharedPtr
        post_set_parameters_callback_handle_;
      bool request_in_progress_{false};
    };

    }  // namespace demo_nodes_cpp

And then, we start and configure ``IntrospectionClientNode`` in the same way.

.. code-block:: bash

    $ ros2 run demo_nodes_cpp introspection_client

Change service introspection state to set ``configure_introspection`` parameter as following.

.. code-block:: bash

    ### User data contents with metadata
    $ ros2 param set /introspection_client client_configure_introspection contents
    ### Or only metadata
    $ ros2 param set /introspection_client client_configure_introspection metadata
    ### To disable
    $ ros2 param set /introspection_client client_configure_introspection disabled

In this tutorial the following is example output with service introspection state ``CONTENTS`` on ``IntrospectionServiceNode`` and ``METADATA`` on ``IntrospectionClientNode``.
To monitor service communication between ``IntrospectionClientNode`` and ``IntrospectionServiceNode``, let's run it:

.. code-block:: bash

    $ ros2 service echo --flow-style /add_two_ints
    info:
      event_type: REQUEST_SENT
      stamp:
        sec: 1709432402
        nanosec: 680094264
      client_gid: [1, 15, 0, 18, 86, 208, 115, 86, 0, 0, 0, 0, 0, 0, 21, 3]
      sequence_number: 247
    request: []
    response: []
    ---
    info:
      event_type: REQUEST_RECEIVED
      stamp:
        sec: 1709432402
        nanosec: 680459568
      client_gid: [1, 15, 0, 18, 86, 208, 115, 86, 0, 0, 0, 0, 0, 0, 20, 4]
      sequence_number: 247
    request: [{a: 2, b: 3}]
    response: []
    ---
    info:
      event_type: RESPONSE_SENT
      stamp:
        sec: 1709432402
        nanosec: 680765280
      client_gid: [1, 15, 0, 18, 86, 208, 115, 86, 0, 0, 0, 0, 0, 0, 20, 4]
      sequence_number: 247
    request: []
    response: [{sum: 5}]
    ---
    info:
      event_type: RESPONSE_RECEIVED
      stamp:
        sec: 1709432402
        nanosec: 681027998
      client_gid: [1, 15, 0, 18, 86, 208, 115, 86, 0, 0, 0, 0, 0, 0, 21, 3]
      sequence_number: 247
    request: []
    response: []
    ---
    ...

You can see the ``event_type: REQUEST_SENT`` and ``event_type: RESPONSE_RECEIVED``, those introspection service event take place in ``IntrospectionClientNode``.
And those events does not include any contents in ``request`` and ``response`` field, this is because ``IntrospectionClientNode``'s service introspection state is set to ``METADATA``.
On the other hand, ``event_type: REQUEST_RECEIVED`` and ``event_type: RESPONSE_SENT`` event from ``IntrospectionServiceNode`` includes ``request: [{a: 2, b: 3}]`` and ``response: [{sum: 5}]`` as introspection state is set to ``CONTENTS``.

Related content
---------------

- `service introspection client example (rclcpp) <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/services/introspection_client.cpp>`__ and `service introspection service example (rclcpp) <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/services/introspection_service.cpp>`__.
- `service introspection client and service example (rclpy) <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_py/demo_nodes_py/services/introspection.py>`__.
- `Service Introspection REP-2012 <https://github.com/ros-infrastructure/rep/pull/360>`__.
",What are the three configuration states for service introspection mentioned in the text document?
".. redirect-from::

    Logging-and-logger-configuration
    Tutorials/Logging-and-logger-configuration

Logging
=======

.. contents:: Table of Contents
   :depth: 2
   :local:

See `the logging page <../../Concepts/Intermediate/About-Logging>` for details on available functionality.

Using log statements in code
----------------------------

Basic logging
^^^^^^^^^^^^^

The following code will output a log message from a ROS 2 node at ``DEBUG`` severity:

.. tabs::

    .. group-tab:: C++

        .. code-block:: C++

            // printf style
            RCLCPP_DEBUG(node->get_logger(), ""My log message %d"", 4);

            // C++ stream style
            RCLCPP_DEBUG_STREAM(node->get_logger(), ""My log message "" << 4);

    .. group-tab:: Python

        .. code-block:: python

            node.get_logger().debug('My log message %d' % (4))

Note that in both cases, no trailing newline is added, as the logging infrastructure will automatically add one.

Logging only the first time
^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following code will output a log message from a ROS 2 node at ``INFO`` severity, but only the first time it is hit:

.. tabs::

    .. group-tab:: C++

        .. code-block:: C++

            // printf style
            RCLCPP_INFO_ONCE(node->get_logger(), ""My log message %d"", 4);

            // C++ stream style
            RCLCPP_INFO_STREAM_ONCE(node->get_logger(), ""My log message "" << 4);

    .. group-tab:: Python

        .. code-block:: python

            num = 4
            node.get_logger().info(f'My log message {num}', once=True)

Logging all but the first time
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following code will output a log message from a ROS 2 node at ``WARN`` severity, but not the very first time it is hit:

.. tabs::

    .. group-tab:: C++

        .. code-block:: C++

            // printf style
            RCLCPP_WARN_SKIPFIRST(node->get_logger(), ""My log message %d"", 4);

            // C++ stream style
            RCLCPP_WARN_STREAM_SKIPFIRST(node->get_logger(), ""My log message "" << 4);

    .. group-tab:: Python

        .. code-block:: python

            num = 4
            node.get_logger().warning('My log message {0}'.format(num), skip_first=True)

Logging throttled
^^^^^^^^^^^^^^^^^

The following code will output a log message from a ROS 2 node at ``ERROR`` severity, but no more than once per second.

The interval parameter specifying milliseconds between messages should have an integer data type so it can be converted to a ``rcutils_duration_value_t`` (an ``int64_t``):

.. tabs::

    .. group-tab:: C++

        .. code-block:: C++

            // printf style
            RCLCPP_ERROR_THROTTLE(node->get_logger(), *node->get_clock(), 1000, ""My log message %d"", 4);

            // C++ stream style
            RCLCPP_ERROR_STREAM_THROTTLE(node->get_logger(), *node->get_clock(), 1000, ""My log message "" << 4);

            // For now, use the nanoseconds() method to use an existing rclcpp::Duration value, see https://github.com/ros2/rclcpp/issues/1929
            RCLCPP_ERROR_STREAM_THROTTLE(node->get_logger(), *node->get_clock(), msg_interval.nanoseconds()/1000000, ""My log message "" << 4);

    .. group-tab:: Python

        .. code-block:: python

            num = 4
            node.get_logger().error(f'My log message {num}', throttle_duration_sec=1)

Logging throttled all but the first time
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following code will output a log message from a ROS 2 node at ``DEBUG`` severity, no more than once per second, skipping the very first time it is hit:

.. tabs::

    .. group-tab:: C++

        .. code-block:: C++

            // printf style
            RCLCPP_DEBUG_SKIPFIRST_THROTTLE(node->get_logger(), *node->get_clock(), 1000, ""My log message %d"", 4);

            RCLCPP_DEBUG_SKIPFIRST_THROTTLE(node->get_logger(), *node->get_clock(), 1000, ""My log message "" << 4);

    .. group-tab:: Python

        .. code-block:: python

            num = 4
            node.get_logger().debug(f'My log message {num}', skip_first=True, throttle_duration_sec=1.0)

Logging demo
------------

In this `demo <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/logging_demo>`_, different types of log calls are shown and the severity level of different loggers is configured locally and externally.

Start the demo with:

.. code-block:: bash

   ros2 run logging_demo logging_demo_main

Over time you will see output from various log calls with different properties.
To start with you will only see output from log calls with severity ``INFO`` and above (``WARN``, ``ERROR``, ``FATAL``).
Note that the first message will only be logged once, though the line is reached on each iteration, as that is a property of the log call used for that message.

Logging directory configuration
-------------------------------

The logging directory can be configured through two environment variables: ``ROS_LOG_DIR`` and ``ROS_HOME``.
The logic is as follows:

* Use ``$ROS_LOG_DIR`` if ``ROS_LOG_DIR`` is set and not empty.
* Otherwise, use ``$ROS_HOME/log``, using ``~/.ros`` for ``ROS_HOME`` if not set or if empty.

For example, to set the logging directory to ``~/my_logs``:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      export ROS_LOG_DIR=~/my_logs
      ros2 run logging_demo logging_demo_main

  .. group-tab:: macOS

    .. code-block:: bash

      export ROS_LOG_DIR=~/my_logs
      ros2 run logging_demo logging_demo_main

  .. group-tab:: Windows

    .. code-block:: bash

      set ""ROS_LOG_DIR=~/my_logs""
      ros2 run logging_demo logging_demo_main

You will then find the logs under ``~/my_logs/``.

Alternatively, you can set ``ROS_HOME`` and the logging directory will be relative to it (``$ROS_HOME/log``).
``ROS_HOME`` is intended to be used by anything that needs a base directory.
Note that ``ROS_LOG_DIR`` has to be either unset or empty.
For example, with ``ROS_HOME`` set to ``~/my_ros_home``:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      export ROS_HOME=~/my_ros_home
      ros2 run logging_demo logging_demo_main

  .. group-tab:: macOS

    .. code-block:: bash

      export ROS_HOME=~/my_ros_home
      ros2 run logging_demo logging_demo_main

  .. group-tab:: Windows

    .. code-block:: bash

      set ""ROS_HOME=~/my_ros_home""
      ros2 run logging_demo logging_demo_main

You will then find the logs under ``~/my_ros_home/log/``.

Logger level configuration: programmatically
--------------------------------------------

After 10 iterations the level of the logger will be set to ``DEBUG``, which will cause additional messages to be logged.

Some of these debug messages cause additional functions/expressions to be evaluated, which were previously skipped as ``DEBUG`` log calls were not enabled.
See `the source code <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/logging_demo/src/logger_usage_component.cpp>`__ of the demo for further explanation of the calls used, and see the rclcpp logging documentation for a full list of supported logging calls.

Logger level configuration: externally
--------------------------------------

ROS 2 nodes have services available to configure the logging level externally at runtime.
These services are disabled by default.
The following code shows how to enable the logger service while creating the node.

.. tabs::

  .. group-tab:: C++

    .. code-block:: C++

        // Create a node with logger service enabled
        auto node = std::make_shared<rclcpp::Node>(""NodeWithLoggerService"", rclcpp::NodeOptions().enable_logger_service(true))

  .. group-tab:: Python

    .. code-block:: python

        # Create a node with logger service enabled
        node = Node('NodeWithLoggerService', enable_logger_service=True)

If you run one of the nodes as configured above, you will find 2 services when running ``ros2 service list``:

.. code-block:: bash

    $ ros2 service list
    ...
    /NodeWithLoggerService/get_logger_levels
    /NodeWithLoggerService/set_logger_levels
    ...

* get_logger_levels

    Use this service to get logger levels for specified logger names.

    Run ``ros2 service call`` to get logger levels for ``NodeWithLoggerService`` and ``rcl``.

    .. code-block:: bash

        $ ros2 service call /NodeWithLoggerService/get_logger_levels rcl_interfaces/srv/GetLoggerLevels '{names: [""NodeWithLoggerService"", ""rcl""]}'

        requester: making request: rcl_interfaces.srv.GetLoggerLevels_Request(names=['NodeWithLoggerService', 'rcl'])

        response:
        rcl_interfaces.srv.GetLoggerLevels_Response(levels=[rcl_interfaces.msg.LoggerLevel(name='NodeWithLoggerService', level=0), rcl_interfaces.msg.LoggerLevel(name='rcl', level=0)])

* set_logger_levels

    Use this service to set logger levels for specified logger names.

    Run ``ros2 service call`` to set logger levels for ``NodeWithLoggerService`` and ``rcl``.

    .. code-block:: bash

        $ ros2 service call /NodeWithLoggerService/set_logger_levels rcl_interfaces/srv/SetLoggerLevels '{levels: [{name: ""NodeWithLoggerService"", level: 20}, {name: ""rcl"", level: 10}]}'

        requester: making request: rcl_interfaces.srv.SetLoggerLevels_Request(levels=[rcl_interfaces.msg.LoggerLevel(name='NodeWithLoggerService', level=20), rcl_interfaces.msg.LoggerLevel(name='rcl', level=10)])

        response:
        rcl_interfaces.srv.SetLoggerLevels_Response(results=[rcl_interfaces.msg.SetLoggerLevelsResult(successful=True, reason=''), rcl_interfaces.msg.SetLoggerLevelsResult(successful=True, reason='')])


There is also demo code showing how to set or get the logger level via the logger service.

  * rclcpp: `demo code <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/logging/use_logger_service.cpp>`__

      .. code-block:: bash

          $ ros2 run demo_nodes_cpp use_logger_service

  * rclpy: `demo code <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/demo_nodes_py/demo_nodes_py/logging/use_logger_service.py>`__

      .. code-block:: bash

          $ ros2 run demo_nodes_py use_logger_service

.. warning::

    Currently, there is a limitation that ``get_logger_levels`` and ``set_logger_levels`` services are not thread-safe.
    This means that you need to ensure that only one thread is calling the services at a time.
    Please see the details in https://github.com/ros2/rcutils/issues/397

Using the logger config component
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The server that responds to the logger configuration requests has been developed as a component so that it may be added to an existing composition-based system.
For example, if you are using `a container to run your nodes <../Intermediate/Composition>`, to be able to configure your loggers you only need to request that it additionally load the ``logging_demo::LoggerConfig`` component into the container.

As an example, if you want to debug the ``composition::Talker`` demo, you can start the talker as normal with:

Shell 1:

.. code-block:: bash

   ros2 run rclcpp_components component_container

Shell 2:

.. code-block:: bash

   ros2 component load /ComponentManager composition composition::Talker

And then when you want to enable debug logging, load the ``LoggerConfig`` component with:

Shell 2

.. code-block:: bash

   ros2 component load /ComponentManager logging_demo logging_demo::LoggerConfig

And finally, configure all unset loggers to the debug severity by addressing the empty-named logger.
Note that loggers that have been specifically configured to use a particular severity will not be affected by this call.

Shell 2:

.. code-block:: bash

   ros2 service call /config_logger logging_demo/srv/ConfigLogger ""{logger_name: '', level: DEBUG}""

You should see debug output from any previously unset loggers in the process start to appear, including from the ROS 2 core.

Logger level configuration: command line
----------------------------------------

As of the Bouncy ROS 2 release, the severity level for loggers that have not had their severity set explicitly can be configured from the command line.
Restart the demo including the following command line argument:


.. code-block:: bash

   ros2 run logging_demo logging_demo_main --ros-args --log-level debug

This configures the default severity for any unset logger to the debug severity level.
You should see debug output from loggers from the demo itself and from the ROS 2 core.

The severity level for individual loggers can be configured from the command-line.
Restart the demo including the following command line arguments:

.. code-block:: bash

   ros2 run logging_demo logging_demo_main --ros-args --log-level logger_usage_demo:=debug


Console output formatting
^^^^^^^^^^^^^^^^^^^^^^^^^

If you would like more or less verbose formatting, you can use the ``RCUTILS_CONSOLE_OUTPUT_FORMAT`` environment variable.
For example, to additionally get the timestamp and location of the log calls, stop the demo and restart it with the environment variable set:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      export RCUTILS_CONSOLE_OUTPUT_FORMAT=""[{severity} {time}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})""
      ros2 run logging_demo logging_demo_main

  .. group-tab:: macOS

    .. code-block:: bash

      export RCUTILS_CONSOLE_OUTPUT_FORMAT=""[{severity} {time}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})""
      ros2 run logging_demo logging_demo_main

  .. group-tab:: Windows

    .. code-block:: bash

      set ""RCUTILS_CONSOLE_OUTPUT_FORMAT=[{severity} {time}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})""
      ros2 run logging_demo logging_demo_main

You should see the timestamp in seconds and the function name, filename and line number additionally printed with each message.

For more information on configuring the console logger formatting, see the :ref:`logger console configuration <logging-configuration-environment-variables>`

Console output colorizing
^^^^^^^^^^^^^^^^^^^^^^^^^

By default, the output is colorized when it's targeting a terminal.
If you would like to force enabling or disabling it, you can use the ``RCUTILS_COLORIZED_OUTPUT`` environment variable.
For example:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      export RCUTILS_COLORIZED_OUTPUT=0  # 1 for forcing it
      ros2 run logging_demo logging_demo_main

  .. group-tab:: macOS

    .. code-block:: bash

      export RCUTILS_COLORIZED_OUTPUT=0  # 1 for forcing it
      ros2 run logging_demo logging_demo_main

  .. group-tab:: Windows

    .. code-block:: bash

      set ""RCUTILS_COLORIZED_OUTPUT=0"" :: 1 for forcing it
      ros2 run logging_demo logging_demo_main

You should see that debug, warn, error and fatal logs aren't colorized now.

.. note::

   In Linux and MacOS forcing colorized output means that if you redirect the output to a file, the ansi escape color codes will appear on it.
   In windows the colorization method relies on console APIs.
   If it is forced you will get a new warning saying that colorization failed.
   The default behavior already checks if the output is a console or not, so forcing colorization is not recommended.

Default stream for console output
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In Foxy and later, the output from all debug levels goes to stderr by default.  It is possible to force all output to go to stdout by setting the ``RCUTILS_LOGGING_USE_STDOUT`` environment variable to ``1``.
For example:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      export RCUTILS_LOGGING_USE_STDOUT=1

  .. group-tab:: macOS

    .. code-block:: bash

      export RCUTILS_LOGGING_USE_STDOUT=1

  .. group-tab:: Windows

    .. code-block:: bash

      set ""RCUTILS_LOGGING_USE_STDOUT=1""


Line buffered console output
^^^^^^^^^^^^^^^^^^^^^^^^^^^^


By default, all logging output is unbuffered.
You can force it to be buffered by setting the ``RCUTILS_LOGGING_BUFFERED_STREAM`` environment variable to 1.
For example:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      export RCUTILS_LOGGING_BUFFERED_STREAM=1

  .. group-tab:: macOS

    .. code-block:: bash

      export RCUTILS_LOGGING_BUFFERED_STREAM=1

  .. group-tab:: Windows

    .. code-block:: bash

      set ""RCUTILS_LOGGING_BUFFERED_STREAM=1""

Then run:

.. code-block:: bash

    ros2 run logging_demo logging_demo_main

Setting the log file name prefix
--------------------------------

By default, the log file name is based on the executable file name followed by process ID and system timestamp on file creation.
You can change the log file name prefix to one of your choice using the ``--log-file-name`` command line argument:

.. code-block:: bash

   ros2 run demo_nodes_cpp talker --ros-args --log-file-name filename

This configures the log file name prefix to ``filename``, instead of the executable file name (which is ``talker`` in this case).
",What services are available for configuring the logging level of ROS 2 nodes externally at runtime?
".. redirect-from::

    Real-Time-Programming
    Tutorials/Real-Time-Programming

Understanding real-time programming
===================================

.. contents:: Table of Contents
   :depth: 2
   :local:

Background
----------

Real-time computing is a key feature of many robotics systems, particularly safety- and mission-critical applications such as autonomous vehicles, spacecrafts, and industrial manufacturing.
We are designing and prototyping ROS 2 with real-time performance constraints in mind, since this is a requirement that was not considered in the early stages of ROS 1 and it is now intractable to refactor ROS 1 to be real-time friendly.

`This document <https://design.ros2.org/articles/realtime_background.html>`__ outlines the requirements of real-time computing and best practices for software engineers.  In short:

To make a real-time computer system, our real-time loop must update periodically to meet deadlines.
We can only tolerate a small margin of error on these deadlines (our maximum allowable jitter).
To do this, we must avoid nondeterministic operations in the execution path, things like: pagefault events, dynamic memory allocation/deallocation, and synchronization primitives that block indefinitely.

A classic example of a controls problem commonly solved by real-time computing is balancing an `inverted pendulum <https://en.wikipedia.org/wiki/Inverted_pendulum>`__.
If the controller blocked for an unexpectedly long amount of time, the pendulum would fall down or go unstable.
But if the controller reliably updates at a rate faster than the motor controlling the pendulum can operate, the pendulum will successfully adapt react to sensor data to balance the pendulum.

Now that you know everything about real-time computing, let's try a demo!

Install and run the demo
------------------------

The real-time demo was written with Linux operating systems in mind, since many members of the ROS community doing real-time computing use Xenomai or RT_PREEMPT as their real-time solutions.
Since many of the operations done in the demo to optimize performance are OS-specific, the demo only builds and runs on Linux systems.
**So, if you are an OSX or Windows user, don't try this part!**

Also this must be built from source using a static DDS API. **Currently the only supported implementation is Connext**.

First, follow the instructions to build ROS 2 :doc:`from source <../../Installation/Alternatives/Ubuntu-Development-Setup>` using Connext DDS as the middleware.

Run the tests
^^^^^^^^^^^^^

**Before you run make sure you have at least 8Gb of RAM free. With the memory locking, swap will not work anymore.**

Source your ROS 2 setup.bash.

Run the demo binary, and redirect the output. You may want to use ``sudo`` in case you get permission error:

.. code-block:: bash

   pendulum_demo > output.txt

What the heck just happened?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First, even though you redirected stdout, you will see some output to the console (from stderr):

::

   mlockall failed: Cannot allocate memory
   Couldn't lock all cached virtual memory.
   Pagefaults from reading pages not yet mapped into RAM will be recorded.

After the initialization stage of the demo program, it will attempt to lock all cached memory into RAM and prevent future dynamic memory allocations using ``mlockall``.
This is to prevent pagefaults from loading lots of new memory into RAM.
(See `the realtime design article <https://design.ros2.org/articles/realtime_background.html#memory-management>`__ for more information.)

The demo will continue on as usual when this occurs.
At the bottom of the output.txt file generated by the demo, you'll see the number of pagefaults encountered during execution:

::

   rttest statistics:
     - Minor pagefaults: 20
     - Major pagefaults: 0

If we want those pagefaults to go away, we'll have to...

Adjust permissions for memory locking
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Add to ``/etc/security/limits.conf`` (as sudo):

::

   <your username>    -   memlock   <limit in kB>

A limit of ``-1`` is unlimited.
If you choose this, you may need to accompany it with ``ulimit -l unlimited`` (as root) after editing the file.

After saving the file, log out and log back in.
Then rerun the ``pendulum_demo`` invocation.

You'll either see zero pagefaults in your output file, or an error saying that a bad_alloc exception was caught.
If this happened, you didn't have enough free memory available to lock the memory allocated for the process into RAM.
You'll need to install more RAM in your computer to see zero pagefaults!

Output overview
^^^^^^^^^^^^^^^

To see more output, we have to run the ``pendulum_logger`` node.

In one shell with your ``install/setup.bash`` sourced, invoke:

.. code-block:: bash

   pendulum_logger


You should see the output message:

::

   Logger node initialized.

In another shell with setup.bash sourced, invoke ``pendulum_demo`` again.

As soon as this executable starts, you should see the other shell constantly printing output:

::

   Commanded motor angle: 1.570796
   Actual motor angle: 1.570796
   Mean latency: 210144.000000 ns
   Min latency: 4805 ns
   Max latency: 578137 ns
   Minor pagefaults during execution: 0
   Major pagefaults during execution: 0

The demo is controlling a very simple inverted pendulum simulation.
The pendulum simulation calculates its position in its own thread.
A ROS node simulates a motor encoder sensor for the pendulum and publishes its position.
Another ROS node acts as a simple PID controller and calculates the next command message.

The logger node periodically prints out the pendulum's state and the runtime performance statistics of the demo during its execution phase.

After the ``pendulum_demo`` is finished, you'll have to CTRL-C out of the logger node to exit.

Latency
^^^^^^^

At the ``pendulum_demo`` execution, you'll see the final statistics collected for the demo:

::

   rttest statistics:
     - Minor pagefaults: 0
     - Major pagefaults: 0
     Latency (time after deadline was missed):
       - Min: 3354 ns
       - Max: 2752187 ns
       - Mean: 19871.8 ns
       - Standard deviation: 1.35819e+08

   PendulumMotor received 985 messages
   PendulumController received 987 messages

The latency fields show you the minimum, maximum, and average latency of the update loop in nanoseconds.
Here, latency means the amount of time after the update was expected to occur.

The requirements of a real-time system depend on the application, but let's say in this demo we have a 1kHz (1 millisecond) update loop, and we're aiming for a maximum allowable latency of 5% of our update period.

So, our average latency was really good in this run, but the maximum latency was unacceptable because it actually exceeded our update loop! What happened?

We may be suffering from a non-deterministic scheduler.
If you're running a vanilla Linux system and you don't have the RT_PREEMPT kernel installed, you probably won't be able to meet the real-time goal we set for ourselves, because the Linux scheduler won't allow you to arbitrarily pre-empt threads at the user level.

See the `realtime design article <https://design.ros2.org/articles/realtime_background.html#multithreaded-programming-and-synchronization>`__ for more information.

The demo attempts to set the scheduler and thread priority of the demo to be suitable for real-time performance.
If this operation failed, you'll see an error message: ""Couldn't set scheduling priority and policy: Operation not permitted"".
You can get slightly better performance by following the instructions in the next section:

Setting permissions for the scheduler
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Add to ``/etc/security/limits.conf`` (as sudo):

::

   <your username>    -   rtprio   98

The range of the rtprio (real-time priority) field is 0-99.
However, do NOT set the limit to 99 because then your processes could interfere with important system processes that run at the top priority (e.g. watchdog).
This demo will attempt to run the control loop at priority 98.

Plotting results
^^^^^^^^^^^^^^^^

You can plot the latency and pagefault statistics that are collected in this demo after the demo runs.

Because the code has been instrumented with `rttest <https://github.com/ros2/rttest>`__, there are useful command line arguments available:

+---------+---------------------------------------------------------------------+---------------+
| Command | Description                                                         | Default value |
+---------+---------------------------------------------------------------------+---------------+
| -i      | Specify how many iterations to run the real-time loop               | 1000          |
+---------+---------------------------------------------------------------------+---------------+
| -u      | Specify the update period with the default unit being microseconds. | 1ms           |
|         |                                                                     |               |
|         | Use the suffix ""s"" for seconds, ""ms"" for milliseconds,              |               |
|         |                                                                     |               |
|         | ""us"" for microseconds, and ""ns"" for nanoseconds.                    |               |
+---------+---------------------------------------------------------------------+---------------+
| -f      | Specify the name of the file for writing the collected data.        |               |
+---------+---------------------------------------------------------------------+---------------+

Run the demo again with a filename to save results:

.. code-block:: bash

   pendulum_demo -f pendulum_demo_results

Then run the ``rttest_plot`` script on the resulting file:

.. code-block:: bash

   ros2 run rttest rttest_plot pendulum_demo_results

This script will produce a number of files:

::

   pendulum_demo_results_plot_latency.svg
   pendulum_demo_results_plot_latency_hist.svg
   pendulum_demo_results_plot_majflts.svg
   pendulum_demo_results_plot_minflts.svg

You can view these plots in an image viewer of your choice.
",What are the requirements and best practices for real-time computing outlined in the document?
".. redirect-from::

    Tutorials/Ros2bag/Recording-A-Bag-From-Your-Own-Node-Cpp

.. _ROS2BagOwnNode:

Recording a bag from a node (C++)
=================================

**Goal:** Record data from your own C++ node to a bag.

**Tutorial level:** Advanced

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

``rosbag2`` doesn't just provide the ``ros2 bag`` command line tool.
It also provides a C++ API for reading from and writing to a bag from your own source code.
This allows you to subscribe to a topic and save the received data to a bag at the same time as performing any other processing of your choice on that data.

Prerequisites
-------------

You should have the ``rosbag2`` packages installed as part of your regular ROS 2 setup.

If you've installed from deb packages on Linux, it may be installed by default.
If it is not, you can install it using this command.

.. code-block:: console

  sudo apt install ros-{DISTRO}-rosbag2

This tutorial discusses using ROS 2 bags, including from the terminal.
You should have already completed the :doc:`basic ROS 2 bag tutorial <../Beginner-CLI-Tools/Recording-And-Playing-Back-Data/Recording-And-Playing-Back-Data>`.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

Open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

Navigate into the ``ros2_ws`` directory created in a :ref:`previous tutorial <new-directory>`.
Navigate into the ``ros2_ws/src`` directory and create a new package:

.. code-block:: console

  ros2 pkg create --build-type ament_cmake --license Apache-2.0 bag_recorder_nodes --dependencies example_interfaces rclcpp rosbag2_cpp std_msgs

Your terminal will return a message verifying the creation of your package ``bag_recorder_nodes`` and all its necessary files and folders.
The ``--dependencies`` argument will automatically add the necessary dependency lines to ``package.xml`` and ``CMakeLists.txt``.
In this case, the package will use the ``rosbag2_cpp`` package as well as the ``rclcpp`` package.
A dependency on the ``example_interfaces`` package is also required for later parts of this tutorial.

1.1 Update ``package.xml``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Because you used the ``--dependencies`` option during package creation, you don't have to manually add dependencies to ``package.xml`` or ``CMakeLists.txt``.
As always, though, make sure to add the description, maintainer email and name, and license information to ``package.xml``.

.. code-block:: xml

  <description>C++ bag writing tutorial</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>

2 Write the C++ node
^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/bag_recorder_nodes/src`` directory, create a new file called ``simple_bag_recorder.cpp`` and paste the following code into it.

.. code-block:: C++


    #include <rclcpp/rclcpp.hpp>
    #include <std_msgs/msg/string.hpp>

    #include <rosbag2_cpp/writer.hpp>

    class SimpleBagRecorder : public rclcpp::Node
    {
    public:
      SimpleBagRecorder()
      : Node(""simple_bag_recorder"")
      {
        writer_ = std::make_unique<rosbag2_cpp::Writer>();

        writer_->open(""my_bag"");

        auto subscription_callback_lambda = [this](std::shared_ptr<rclcpp::SerializedMessage> msg){
          rclcpp::Time time_stamp = this->now();

          writer_->write(msg, ""chatter"", ""std_msgs/msg/String"", time_stamp);
        };

        subscription_ = create_subscription<std_msgs::msg::String>(
          ""chatter"", 10, subscription_callback_lambda);
      }

    private:

      rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
      std::unique_ptr<rosbag2_cpp::Writer> writer_;
    };

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<SimpleBagRecorder>());
      rclcpp::shutdown();
      return 0;
    }

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

The ``#include`` statements at the top are the package dependencies.
Note the inclusion of headers from the ``rosbag2_cpp`` package for the functions and structures necessary to work with bag files.

In the class constructor we begin by creating the writer object we will use to write to the bag.

.. code-block:: C++

        writer_ = std::make_unique<rosbag2_cpp::Writer>();

Now that we have a writer object, we can open the bag using it.
We specify just the URI of the bag to create, leaving other options at their defaults.
The default storage options are used, which means that an ``mcap``-format bag will be created.
The default conversion options are used, too, which will perform no conversion, instead storing messages in the serialisation format they are received in.

.. code-block:: C++

        writer_->open(""my_bag"");

With the writer now set up to record data we pass to it, we create a subscription and specify a callback for it.
We will write data to the bag in the callback.

.. code-block:: C++

        auto subscription_callback_lambda = [this](std::shared_ptr<rclcpp::SerializedMessage> msg){
          rclcpp::Time time_stamp = this->now();

          writer_->write(msg, ""chatter"", ""std_msgs/msg/String"", time_stamp);
        };

        subscription_ = create_subscription<std_msgs::msg::String>(
          ""chatter"", 10, subscription_callback_lambda);

The callback itself is different from a typical callback.
Rather than receiving an instance of the data type of the topic, we instead receive a ``rclcpp::SerializedMessage``.
We do this for two reasons.

1. The message data will need to be serialized by ``rosbag2`` before being written to the bag, so rather than unserializing it when receiving the data and then re-serializing it, we ask ROS to just give us the serialized message as-is.
2. The writer API can accept a serialized message.

.. code-block:: C++

        auto subscription_callback_lambda = [this](std::shared_ptr<rclcpp::SerializedMessage> msg){

Within the subscription callback, the first thing to do is determine the time stamp to use for the stored message.
This can be anything appropriate to your data, but two common values are the time at which the data was produced, if known, and the time it is received.
The second option, the time of reception, is used here.

.. code-block:: C++

        rclcpp::Time time_stamp = this->now();

We can then write the message into the bag.
Because we have not yet registered any topics with the bag, we must specify the full topic information with the message.
This is why we pass in the topic name and the topic type.

.. code-block:: C++

        writer_->write(msg, ""chatter"", ""std_msgs/msg/String"", time_stamp);

The class contains two member variables.

1. The subscription object.
2. A managed pointer to the writer object used to write to the bag.
   Note the type of writer used here is the ``rosbag2_cpp::Writer``, the generic writer interface.
   Other writers may be available with different behaviours.

.. code-block:: C++

      rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
      std::unique_ptr<rosbag2_cpp::Writer> writer_;

The file finishes with the ``main`` function used to create an instance of the node and start ROS processing it.

.. code-block:: C++

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<SimpleBagRecorder>());
      rclcpp::shutdown();
      return 0;
    }

2.2 Add executable
~~~~~~~~~~~~~~~~~~

Now open the ``CMakeLists.txt`` file.

Near the top of the file, change ``CMAKE_CXX_STANDARD`` from ``14`` to ``17``.

.. code-block:: console

    # Default to C++17
    if(NOT CMAKE_CXX_STANDARD)
      set(CMAKE_CXX_STANDARD 17)
    endif()

Below the dependencies block, which contains ``find_package(rosbag2_cpp REQUIRED)``, add the following lines of code.

.. code-block:: console

    add_executable(simple_bag_recorder src/simple_bag_recorder.cpp)
    ament_target_dependencies(simple_bag_recorder rclcpp rosbag2_cpp std_msgs)

    install(TARGETS
      simple_bag_recorder
      DESTINATION lib/${PROJECT_NAME}
    )

3 Build and run
^^^^^^^^^^^^^^^

Navigate back to the root of your workspace, ``ros2_ws``, and build your new package.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select bag_recorder_nodes

Open a new terminal, navigate to ``ros2_ws``, and source the setup files.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the node:

.. code-block:: console

    ros2 run bag_recorder_nodes simple_bag_recorder

Open a second terminal and run the ``talker`` example node.

.. code-block:: console

    ros2 run demo_nodes_cpp talker

This will start publishing data on the ``chatter`` topic.
As the bag-writing node receives this data, it will write it to the ``my_bag`` bag.

Terminate both nodes.
Then, in one terminal start the ``listener`` example node.

.. code-block:: console

    ros2 run demo_nodes_cpp listener

In the other terminal, use ``ros2 bag`` to play the bag recorded by your node.

.. code-block:: console

    ros2 bag play my_bag

You will see the messages from the bag being received by the ``listener`` node.

If you wish to run the bag-writing node again, you will first need to delete the ``my_bag`` directory.

4 Record synthetic data from a node
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Any data can be recorded into a bag, not just data received over a topic.
A common use case for writing to a bag from your own node is to generate and store synthetic data.
In this section you will learn how to write a node that generates some data and stores it in a bag.
We will demonstrate two approaches for doing this.
The first uses a node with a timer; this is the approach that you would use if your data generation is external to the node, such as reading data directly from hardware (e.g. a camera).
The second approach does not use a node; this is the approach you can use when you do not need to use any functionality from the ROS infrastructure.

4.1 Write a C++ node
~~~~~~~~~~~~~~~~~~~~

Inside the ``ros2_ws/src/bag_recorder_nodes/src`` directory, create a new file called ``data_generator_node.cpp`` and paste the following code into it.

.. code-block:: C++

    #include <chrono>

    #include <example_interfaces/msg/int32.hpp>
    #include <rclcpp/rclcpp.hpp>

    #include <rosbag2_cpp/writer.hpp>

    using namespace std::chrono_literals;

    class DataGenerator : public rclcpp::Node
    {
    public:
      DataGenerator()
      : Node(""data_generator"")
      {
        data_.data = 0;
        writer_ = std::make_unique<rosbag2_cpp::Writer>();

        writer_->open(""timed_synthetic_bag"");

        writer_->create_topic(
        {
          0u,
          ""synthetic"",
          ""example_interfaces/msg/Int32"",
          rmw_get_serialization_format(),
          {},
          """",
        });

        auto timer_callback_lambda = [this](){return this->timer_callback();};
        timer_ = create_wall_timer(1s, timer_callback_lambda);
      }

    private:
      void timer_callback()
      {
        writer_->write(data_, ""synthetic"", now());

        ++data_.data;
      }

      rclcpp::TimerBase::SharedPtr timer_;
      std::unique_ptr<rosbag2_cpp::Writer> writer_;
      example_interfaces::msg::Int32 data_;
    };

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<DataGenerator>());
      rclcpp::shutdown();
      return 0;
    }

4.2 Examine the code
~~~~~~~~~~~~~~~~~~~~

Much of this code is the same as the first example.
The important differences are described here.

First, the name of the bag is changed.

.. code-block:: C++

        writer_->open(""timed_synthetic_bag"");

In this example we are registering the topic with the bag in advance.
This is optional in most cases, but it must be done when passing in a serialized message without topic information.

.. code-block:: C++

        writer_->create_topic(
        {
          0u,
          ""synthetic"",
          ""example_interfaces/msg/Int32"",
          rmw_get_serialization_format(),
          {},
          """",
        });

Rather than a subscription to a topic, this node has a timer.
The timer fires with a one-second period, and calls the given member function when it does.

.. code-block:: C++

        auto timer_callback_lambda = [this](){return this->timer_callback();};
        timer_ = create_wall_timer(1s, timer_callback_lambda);

Within the timer callback, we generate (or otherwise obtain, e.g. read from a serial port connected to some hardware) the data we wish to store in the bag.
The important difference between this and the previous sample is that the data is not yet serialized.
Instead we are passing a ROS message data type to the writer object, in this case an instance of ``example_interfaces/msg/Int32``.
The writer will serialize the data for us before writing it into the bag.

.. code-block:: C++

        writer_->write(data_, ""synthetic"", now());

4.3 Add executable
~~~~~~~~~~~~~~~~~~

Open the ``CMakeLists.txt`` file and add the following lines after the previously-added lines (specifically, after the ``install(TARGETS ...)`` macro call).

.. code-block:: console

    add_executable(data_generator_node src/data_generator_node.cpp)
    ament_target_dependencies(data_generator_node rclcpp rosbag2_cpp example_interfaces)

    install(TARGETS
      data_generator_node
      DESTINATION lib/${PROJECT_NAME}
    )

4.4 Build and run
~~~~~~~~~~~~~~~~~

Navigate back to the root of your workspace, ``ros2_ws``, and build your package.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select bag_recorder_nodes

Open a new terminal, navigate to ``ros2_ws``, and source the setup files.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

(If the ``timed_synthetic_bag`` directory already exists, you must first delete it before running the node.)

Now run the node:

.. code-block:: console

    ros2 run bag_recorder_nodes data_generator_node

Wait for 30 seconds or so, then terminate the node with :kbd:`ctrl-c`.
Next, play back the created bag.

.. code-block:: console

    ros2 bag play timed_synthetic_bag

Open a second terminal and echo the ``/synthetic`` topic.

.. code-block:: console

    ros2 topic echo /synthetic

You will see the data that was generated and stored in the bag printed to the console at a rate of one message per second.

5 Record synthetic data from an executable
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now that you can create a bag that stores data from a source other than a topic, you will learn how to generate and record synthetic data from a non-node executable.
The advantage of this approach is simpler code and rapid creation of a large quantity of data.

5.1 Write a C++ executable
~~~~~~~~~~~~~~~~~~~~~~~~~~

Inside the ``ros2_ws/src/bag_recorder_nodes/src`` directory, create a new file called ``data_generator_executable.cpp`` and paste the following code into it.

.. code-block:: C++

    #include <chrono>

    #include <rclcpp/rclcpp.hpp>  // For rclcpp::Clock, rclcpp::Duration and rclcpp::Time
    #include <example_interfaces/msg/int32.hpp>

    #include <rosbag2_cpp/writer.hpp>
    #include <rosbag2_cpp/writers/sequential_writer.hpp>
    #include <rosbag2_storage/serialized_bag_message.hpp>

    using namespace std::chrono_literals;

    int main(int, char**)
    {
      example_interfaces::msg::Int32 data;
      data.data = 0;
      std::unique_ptr<rosbag2_cpp::Writer> writer_ = std::make_unique<rosbag2_cpp::Writer>();

      writer_->open(""big_synthetic_bag"");

      writer_->create_topic(
      {
        0u,
        ""synthetic"",
        ""example_interfaces/msg/Int32"",
        rmw_get_serialization_format(),
        {},
        """",
      });

      rclcpp::Clock clock;
      rclcpp::Time time_stamp = clock.now();
      for (int32_t ii = 0; ii < 100; ++ii) {
        writer_->write(data, ""synthetic"", time_stamp);
        ++data.data;
        time_stamp += rclcpp::Duration(1s);
      }

      return 0;
    }

5.2 Examine the code
~~~~~~~~~~~~~~~~~~~~

A comparison of this sample and the previous sample will reveal that they are not that different.
The only significant difference is the use of a for loop to drive the data generation rather than a timer.

Notice that we are also now generating time stamps for the data rather than relying on the current system time for each sample.
The time stamp can be any value you need it to be.
The data will be played back at the rate given by these time stamps, so this is a useful way to control the default playback speed of the samples.
Notice also that while the gap between each sample is a full second in time, this executable does not need to wait a second between each sample.
This allows us to generate a lot of data covering a wide span of time in much less time than playback will take.

.. code-block:: C++

      rclcpp::Clock clock;
      rclcpp::Time time_stamp = clock.now();
      for (int32_t ii = 0; ii < 100; ++ii) {
        writer_->write(data, ""synthetic"", time_stamp);
        ++data.data;
        time_stamp += rclcpp::Duration(1s);
      }

5.3 Add executable
~~~~~~~~~~~~~~~~~~

Open the ``CMakeLists.txt`` file and add the following lines after the previously-added lines.

.. code-block:: console

    add_executable(data_generator_executable src/data_generator_executable.cpp)
    ament_target_dependencies(data_generator_executable rclcpp rosbag2_cpp example_interfaces)

    install(TARGETS
      data_generator_executable
      DESTINATION lib/${PROJECT_NAME}
    )

5.4 Build and run
~~~~~~~~~~~~~~~~~

Navigate back to the root of your workspace, ``ros2_ws``, and build your package.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select bag_recorder_nodes

Open a terminal, navigate to ``ros2_ws``, and source the setup files.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

(If the ``big_synthetic_bag`` directory already exists, you must first delete it before running the executable.)

Now run the executable:

.. code-block:: console

    ros2 run bag_recorder_nodes data_generator_executable

Note that the executable runs and finishes very quickly.

Now play back the created bag.

.. code-block:: console

    ros2 bag play big_synthetic_bag

Open a second terminal and echo the ``/synthetic`` topic.

.. code-block:: console

    ros2 topic echo /synthetic

You will see the data that was generated and stored in the bag printed to the console at a rate of one message per second.
Even though the bag was generated rapidly it is still played back at the rate the time stamps indicate.

Summary
-------

You created a node that records data it receives on a topic into a bag.
You tested recording a bag using the node, and verified the data was recorded by playing back the bag.
You then went on to create a node and an executable to generate synthetic data and store it in a bag.
",What are the steps involved in creating a package for recording data from a C++ node to a bag in ROS 2?
".. redirect-from::

    FastDDS-Configuration
    Tutorials/FastDDS-Configuration/FastDDS-Configuration

Unlocking the potential of Fast DDS middleware [community-contributed]
======================================================================

**Goal:** This tutorial will show how to use the extended configuration capabilities of Fast DDS in ROS 2.

**Tutorial level:** Advanced

**Time:** 20 minutes

.. contents:: Table of Contents
   :depth: 2
   :local:

Background
----------

The interface between the ROS 2 stack and *Fast DDS* is provided by the ROS 2 middleware implementation `rmw_fastrtps <https://github.com/ros2/rmw_fastrtps>`_.
This implementation is available in all ROS 2 distributions, both from binaries and from sources.

ROS 2 RMW only allows for the configuration of certain middleware QoS
(see :doc:`ROS 2 QoS policies <../../Concepts/Intermediate/About-Quality-of-Service-Settings>`).
However, ``rmw_fastrtps`` offers extended configuration capabilities to take full advantage of the features in *Fast DDS*.
This tutorial will guide you through a series of examples explaining how to use XML files to unlock this extended configuration.

In order to get more information about using *Fast DDS* on ROS 2, please check the `following documentation <https://fast-dds.docs.eprosima.com/en/latest/fastdds/ros2/ros2.html>`__.


Prerequisites
-------------

This tutorial assumes that you know how to :doc:`create a package <../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>`.
It also assumes you know how to write a :doc:`simple publisher and subscriber<../Beginner-Client-Libraries/Writing-A-Simple-Cpp-Publisher-And-Subscriber>` and a :doc:`simple service and client <../Beginner-Client-Libraries/Writing-A-Simple-Cpp-Service-And-Client>`.
Although the examples are implemented in C++, the same concepts apply to Python packages.


Mixing synchronous and asynchronous publications in the same node
-----------------------------------------------------------------

In this first example, a node with two publishers, one of them with synchronous publication mode and the other one with asynchronous publication mode, will be created.

``rmw_fastrtps`` uses synchronous publication mode by default.

With synchronous publication mode the data is sent directly within the context of the user thread.
This entails that any blocking call occurring during the write operation would block the user thread, thus preventing the application from continuing its operation.
However, this mode typically yields higher throughput rates at lower latencies, since there is no notification nor context switching between threads.

On the other hand, with asynchronous publication mode, each time the publisher invokes the write operation, the data is copied into a queue,
a background thread (asynchronous thread) is notified about the addition to the queue, and control of the thread is returned to the user before the data is actually sent.
The background thread is in charge of consuming the queue and sending the data to every matched reader.

Create the node with the publishers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First, create a new package named ``sync_async_node_example_cpp`` on a new workspace:

.. tabs::

    .. group-tab:: Linux

       .. code-block:: console

         mkdir -p ~/ros2_ws/src
         cd ~/ros2_ws/src
         ros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies rclcpp std_msgs -- sync_async_node_example_cpp

    .. group-tab:: macOS

      .. code-block:: console

        mkdir -p ~/ros2_ws/src
        cd ~/ros2_ws/src
        ros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies rclcpp std_msgs -- sync_async_node_example_cpp

    .. group-tab:: Windows

      .. code-block:: console

        md \ros2_ws\src
        cd \ros2_ws\src
        ros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies rclcpp std_msgs -- sync_async_node_example_cpp


Then, add a file named ``src/sync_async_writer.cpp`` to the package, with the following content.
Note that the synchronous publisher will be publishing on topic ``sync_topic``, while the asynchronous one will be publishing on topic ``async_topic``.

.. code-block:: C++

    #include <chrono>
    #include <functional>
    #include <memory>
    #include <string>

    #include ""rclcpp/rclcpp.hpp""
    #include ""std_msgs/msg/string.hpp""

    using namespace std::chrono_literals;

    class SyncAsyncPublisher : public rclcpp::Node
    {
    public:
        SyncAsyncPublisher()
            : Node(""sync_async_publisher""), count_(0)
        {
            // Create the synchronous publisher on topic 'sync_topic'
            sync_publisher_ = this->create_publisher<std_msgs::msg::String>(""sync_topic"", 10);

            // Create the asynchronous publisher on topic 'async_topic'
            async_publisher_ = this->create_publisher<std_msgs::msg::String>(""async_topic"", 10);

            // Actions to run every time the timer expires
            auto timer_callback = [this](){

                // Create a new message to be sent
                auto sync_message = std_msgs::msg::String();
                sync_message.data = ""SYNC: Hello, world! "" + std::to_string(count_);

                // Log the message to the console to show progress
                RCLCPP_INFO(this->get_logger(), ""Synchronously publishing: '%s'"", sync_message.data.c_str());

                // Publish the message using the synchronous publisher
                sync_publisher_->publish(sync_message);

                // Create a new message to be sent
                auto async_message = std_msgs::msg::String();
                async_message.data = ""ASYNC: Hello, world! "" + std::to_string(count_);

                // Log the message to the console to show progress
                RCLCPP_INFO(this->get_logger(), ""Asynchronously publishing: '%s'"", async_message.data.c_str());

                // Publish the message using the asynchronous publisher
                async_publisher_->publish(async_message);

                // Prepare the count for the next message
                count_++;
            };

            // This timer will trigger the publication of new data every half a second
            timer_ = this->create_wall_timer(500ms, timer_callback);
        }

    private:
        // This timer will trigger the publication of new data every half a second
        rclcpp::TimerBase::SharedPtr timer_;

        // A publisher that publishes asynchronously
        rclcpp::Publisher<std_msgs::msg::String>::SharedPtr async_publisher_;

        // A publisher that publishes synchronously
        rclcpp::Publisher<std_msgs::msg::String>::SharedPtr sync_publisher_;

        // Number of messages sent so far
        size_t count_;
    };

    int main(int argc, char * argv[])
    {
        rclcpp::init(argc, argv);
        rclcpp::spin(std::make_shared<SyncAsyncPublisher>());
        rclcpp::shutdown();
        return 0;
    }

Now open the ``CMakeLists.txt`` file and add a new executable and name it ``SyncAsyncWriter`` so you can run your node using ``ros2 run``:

.. code-block:: cmake

    add_executable(SyncAsyncWriter src/sync_async_writer.cpp)
    ament_target_dependencies(SyncAsyncWriter rclcpp std_msgs)

Finally, add the ``install(TARGETS…)`` section so ``ros2 run`` can find your executable:

.. code-block:: cmake

    install(TARGETS
        SyncAsyncWriter
        DESTINATION lib/${PROJECT_NAME})

You can clean up your ``CMakeLists.txt`` by removing some unnecessary sections and comments, so it looks like this:

.. code-block:: cmake

    cmake_minimum_required(VERSION 3.8)
    project(sync_async_node_example_cpp)

    # Default to C++14
    if(NOT CMAKE_CXX_STANDARD)
      set(CMAKE_CXX_STANDARD 14)
    endif()

    if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES ""Clang"")
      add_compile_options(-Wall -Wextra -Wpedantic)
    endif()

    find_package(ament_cmake REQUIRED)
    find_package(rclcpp REQUIRED)
    find_package(std_msgs REQUIRED)

    add_executable(SyncAsyncWriter src/sync_async_writer.cpp)
    ament_target_dependencies(SyncAsyncWriter rclcpp std_msgs)

    install(TARGETS
        SyncAsyncWriter
        DESTINATION lib/${PROJECT_NAME})

    ament_package()

If this node is built and run now, both publishers will behave the same, publishing asynchronously in both topics, because this is the default publication mode.
The default publication mode configuration can be changed in runtime during the node launching, using an XML file.

Create the XML file with the profile configuration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Create a file with name ``SyncAsync.xml`` and the following content:

.. code-block:: XML

    <?xml version=""1.0"" encoding=""UTF-8"" ?>
    <profiles xmlns=""http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles"">

        <!-- default publisher profile -->
        <publisher profile_name=""default_publisher"" is_default_profile=""true"">
            <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
        </publisher>

        <!-- default subscriber profile -->
        <subscriber profile_name=""default_subscriber"" is_default_profile=""true"">
            <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
        </subscriber>

        <!-- publisher profile for topic sync_topic -->
        <publisher profile_name=""/sync_topic"">
            <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
            <qos>
                <publishMode>
                    <kind>SYNCHRONOUS</kind>
                </publishMode>
            </qos>
        </publisher>

        <!-- publisher profile for topic async_topic -->
        <publisher profile_name=""/async_topic"">
            <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
            <qos>
                <publishMode>
                    <kind>ASYNCHRONOUS</kind>
                </publishMode>
            </qos>
        </publisher>

     </profiles>

Note that several profiles for publisher and subscriber are defined.
Two default profiles which are defined setting the ``is_default_profile`` to ``true``, and two profiles with names that coincide with those of the previously defined topics: ``sync_topic`` and another one for ``async_topic``.
These last two profiles set the publication mode to ``SYNCHRONOUS`` or ``ASYNCHRONOUS`` accordingly.
Note also that all profiles specify a ``historyMemoryPolicy`` value, which is needed for the example to work, and the reason will be explained later on this tutorial.

Execute the publisher node
^^^^^^^^^^^^^^^^^^^^^^^^^^

You will need to export the following environment variables for the XML to be loaded:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      export RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      export RMW_FASTRTPS_USE_QOS_FROM_XML=1
      export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

  .. group-tab:: macOS

    .. code-block:: console

      export RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      export RMW_FASTRTPS_USE_QOS_FROM_XML=1
      export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

  .. group-tab:: Windows

    .. code-block:: console

      SET RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      SET RMW_FASTRTPS_USE_QOS_FROM_XML=1
      SET FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

Finally, ensure you have sourced your setup files and run the node:

.. code-block:: console

    source install/setup.bash
    ros2 run sync_async_node_example_cpp SyncAsyncWriter

You should see the publishers sending the data from the publishing node, like so:

.. code-block:: console

    [INFO] [1612972049.994630332] [sync_async_publisher]: Synchronously publishing: 'SYNC: Hello, world! 0'
    [INFO] [1612972049.995097767] [sync_async_publisher]: Asynchronously publishing: 'ASYNC: Hello, world! 0'
    [INFO] [1612972050.494478706] [sync_async_publisher]: Synchronously publishing: 'SYNC: Hello, world! 1'
    [INFO] [1612972050.494664334] [sync_async_publisher]: Asynchronously publishing: 'ASYNC: Hello, world! 1'
    [INFO] [1612972050.994368474] [sync_async_publisher]: Synchronously publishing: 'SYNC: Hello, world! 2'
    [INFO] [1612972050.994549851] [sync_async_publisher]: Asynchronously publishing: 'ASYNC: Hello, world! 2'

Now you have a synchronous publisher and an asynchronous publisher running inside the same node.


Create a node with the subscribers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Next, a new node with the subscribers that will listen to the ``sync_topic`` and ``async_topic`` publications is going to be created.
In a new source file named ``src/sync_async_reader.cpp`` write the following content:

.. code-block:: C++

    #include <memory>

    #include ""rclcpp/rclcpp.hpp""
    #include ""std_msgs/msg/string.hpp""

    class SyncAsyncSubscriber : public rclcpp::Node
    {
    public:

        SyncAsyncSubscriber()
            : Node(""sync_async_subscriber"")
        {
            // Lambda function to run every time a new message is received
            auto topic_callback = [this](const std_msgs::msg::String & msg){
                RCLCPP_INFO(this->get_logger(), ""I heard: '%s'"", msg.data.c_str());
            };

            // Create the synchronous subscriber on topic 'sync_topic'
            // and tie it to the topic_callback
            sync_subscription_ = this->create_subscription<std_msgs::msg::String>(
                ""sync_topic"", 10, topic_callback);

            // Create the asynchronous subscriber on topic 'async_topic'
            // and tie it to the topic_callback
            async_subscription_ = this->create_subscription<std_msgs::msg::String>(
                ""async_topic"", 10, topic_callback);
        }

    private:

        // A subscriber that listens to topic 'sync_topic'
        rclcpp::Subscription<std_msgs::msg::String>::SharedPtr sync_subscription_;

        // A subscriber that listens to topic 'async_topic'
        rclcpp::Subscription<std_msgs::msg::String>::SharedPtr async_subscription_;
    };

    int main(int argc, char * argv[])
    {
        rclcpp::init(argc, argv);
        rclcpp::spin(std::make_shared<SyncAsyncSubscriber>());
        rclcpp::shutdown();
        return 0;
    }


Open the ``CMakeLists.txt`` file and add a new executable and name it ``SyncAsyncReader`` under the previous ``SyncAsyncWriter``:

.. code-block:: cmake

    add_executable(SyncAsyncReader src/sync_async_reader.cpp)
    ament_target_dependencies(SyncAsyncReader rclcpp std_msgs)

    install(TARGETS
        SyncAsyncReader
        DESTINATION lib/${PROJECT_NAME})


Execute the subscriber node
^^^^^^^^^^^^^^^^^^^^^^^^^^^

With the publisher node running in one terminal, open another one and export the required environment variables for the XML to be loaded:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      export RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      export RMW_FASTRTPS_USE_QOS_FROM_XML=1
      export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

  .. group-tab:: macOS

    .. code-block:: console

      export RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      export RMW_FASTRTPS_USE_QOS_FROM_XML=1
      export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

  .. group-tab:: Windows

    .. code-block:: console

      SET RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      SET RMW_FASTRTPS_USE_QOS_FROM_XML=1
      SET FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

Finally, ensure you have sourced your setup files and run the node:

.. code-block:: console

    source install/setup.bash
    ros2 run sync_async_node_example_cpp SyncAsyncReader

You should see the subscribers receiving the data from the publishing node, like so:

.. code-block:: console

    [INFO] [1612972054.495429090] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 10'
    [INFO] [1612972054.995410057] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 10'
    [INFO] [1612972055.495453494] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 11'
    [INFO] [1612972055.995396561] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 11'
    [INFO] [1612972056.495534818] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 12'
    [INFO] [1612972056.995473953] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 12'


Analysis of the example
^^^^^^^^^^^^^^^^^^^^^^^

Configuration profiles XML
~~~~~~~~~~~~~~~~~~~~~~~~~~

The XML file defines several configurations for publishers and subscribers.
You can have a default publisher configuration profile and several topic-specific publisher profiles.
The only requirement is that all publisher profiles have a different name and that there is only a single default profile.
The same goes for subscribers.

In order to define a configuration for a specific topic, just name the profile after the the ROS 2 topic name (like ``/sync_topic`` and ``/async_topic`` in the example),
and ``rmw_fastrtps`` will apply this profile to all publishers and subscribers for that topic.
The default configuration profile is identified by the attribute ``is_default_profile`` set to ``true``, and acts as a fallback profile when there is no other one with a name matching the topic name.

The environment variable ``FASTRTPS_DEFAULT_PROFILES_FILE`` is used to inform *Fast DDS* the path to the XML file with the configuration profiles to load.

RMW_FASTRTPS_USE_QOS_FROM_XML
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Among all the configurable attributes, ``rmw_fastrtps`` treats ``publishMode`` and ``historyMemoryPolicy`` differently.
By default, these values are set to ``ASYNCHRONOUS`` and ``PREALLOCATED_WITH_REALLOC`` within the ``rmw_fastrtps`` implementation, and the values set on the XML file are ignored.
In order to use the values in the XML file, the environment variable ``RMW_FASTRTPS_USE_QOS_FROM_XML`` must be set to ``1``.

However, this entails **another caveat**: If ``RMW_FASTRTPS_USE_QOS_FROM_XML`` is set, but the XML file does not define
``publishMode`` or ``historyMemoryPolicy``, these attributes take the *Fast DDS* default value instead of the ``rmw_fastrtps`` default value.
This is important, especially for ``historyMemoryPolicy``, because the *Fast DDS* deafult value is ``PREALLOCATED`` which does not work with ROS2 topic data types.
Therefore, in the example, a valid value for this policy has been explicitly set (``DYNAMIC``).


Prioritization of rmw_qos_profile_t
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ROS 2 QoS contained in `rmw_qos_profile_t <http://docs.ros.org/en/{DISTRO}/p/rmw/generated/structrmw__qos__profile__s.html>`_ are always honored, unless set to ``*_SYSTEM_DEFAULT``.
In that case, XML values (or *Fast DDS* default values in the absence of XML ones) are applied.
This means that if any QoS in ``rmw_qos_profile_t`` is set to something other than ``*_SYSTEM_DEFAULT``, the corresponding value in the XML is ignored.


Using other FastDDS capabilities with XML
-----------------------------------------

Although we have created a node with two publishers with different configuration, it is not easy to check that they are behaving differently.
Now that the basics of XML profiles have been covered, let us use them to configure something which has some visual effect on the nodes.
Specifically, a maximum number of matching subscribers on one of the publishers and a partition definition on the other will be set.
Note that these are only very simple examples among all the configuration attributes that can be tuned on ``rmw_fastrtps`` through XML files.
Please refer to `*Fast DDS* documentation <https://fast-dds.docs.eprosima.com/en/latest/fastdds/xml_configuration/xml_configuration.html#xml-profiles>`__ to  see the whole list of attributes that can be configured through XML files.

Limiting the number of matching subscribers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Add a maximum number of matched subscribers to the ``/async_topic`` publisher profile.
It should look like this:

.. code-block:: XML

    <!-- publisher profile for topic async_topic -->
    <publisher profile_name=""/async_topic"">
        <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
        <qos>
            <publishMode>
                <kind>ASYNCHRONOUS</kind>
            </publishMode>
        </qos>
        <matchedSubscribersAllocation>
            <initial>0</initial>
            <maximum>1</maximum>
            <increment>1</increment>
        </matchedSubscribersAllocation>
    </publisher>

The number of matching subscribers is being limited to one.

Now open three terminals and do not forget to source the setup files and to set the required environment variables.
On the first terminal run the publisher node, and the subscriber node on the other two.
You should see that only the first subscriber node receives the messages from both topics.
The second one could not complete the matching process in the ``/async_topic`` because the publisher prevented it, as it had already reached its maximum of matched publishers.
Consequently, only the messages from the ``/sync_topic`` are going to be received in this third terminal:

.. code-block:: console

    [INFO] [1613127657.088860890] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 18'
    [INFO] [1613127657.588896594] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 19'
    [INFO] [1613127658.088849401] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 20'


Using partitions within the topic
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The partitions feature can be used to control which publishers and subscribers exchange information within the same topic.

Partitions introduce a logical entity isolation level concept inside the physical isolation induced by a Domain ID.
For a publisher to communicate with a subscriber, they have to belong at least to one common partition.
Partitions represent another level to separate publishers and subscribers beyond domain and topic.
Unlike domain and topic, an endpoint can belong to several partitions at the same time.
For certain data to be shared over different domains or topics, there must be a different publisher for each, sharing its own history of changes.
However, a single publisher can share the same data sample over different partitions using a single topic data change, thus reducing network overload.

Let us change the ``/sync_topic`` publisher to partition ``part1`` and create a new ``/sync_topic`` subscriber which uses partition ``part2``.
Their profiles should now look like this:

.. code-block:: XML

    <!-- publisher profile for topic sync_topic -->
    <publisher profile_name=""/sync_topic"">
        <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
        <qos>
            <publishMode>
                <kind>SYNCHRONOUS</kind>
            </publishMode>
            <partition>
                <names>
                    <name>part1</name>
                </names>
            </partition>
        </qos>
    </publisher>

    <!-- subscriber profile for topic sync_topic -->
    <subscriber profile_name=""/sync_topic"">
        <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
        <qos>
            <partition>
                <names>
                    <name>part2</name>
                </names>
            </partition>
        </qos>
    </subscriber>

Open two terminals.
Do not forget to source the setup files and to set the required environment variables.
On the first terminal run the publisher node, and the subscriber node on the other one.
You should see that only the ``/async_topic`` messages are reaching the subscriber.
The ``/sync_topic`` subscriber is not receiving the data as it is in a different partition from the corresponding publisher.

.. code-block:: console

    [INFO] [1612972054.995410057] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 10'
    [INFO] [1612972055.995396561] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 11'
    [INFO] [1612972056.995473953] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 12'


Configuring a service and a client
----------------------------------

Services and clients have a publisher and a subscriber each, that communicate through two different topics.
For example, for a service named ``ping`` there is:

* A service subscriber listening to requests on ``/rq/ping``.
* A service publisher sending responses on ``/rr/ping``.
* A client publisher sending requests on ``/rq/ping``.
* A client subscriber listening to responses on ``/rr/ping``.

Although you can use these topic names to set the configuration profiles on the XML, sometimes you may wish to apply the same profile to all services or clients on a node.
Instead of copying the same profile with all topic names generated for all services, you can just create a publisher and subscriber profile pair named ``service``.
The same can be done for clients creating a pair named ``client``.


Create the nodes with the service and client
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Start creating the node with the service.
Add a new source file named ``src/ping_service.cpp`` on your package with the following content:

.. code-block:: C++

    #include <memory>

    #include ""rclcpp/rclcpp.hpp""
    #include ""example_interfaces/srv/trigger.hpp""

    /**
     * Service action: responds with success=true and prints the request on the console
     */
    void ping(const std::shared_ptr<example_interfaces::srv::Trigger::Request> request,
            std::shared_ptr<example_interfaces::srv::Trigger::Response> response)
    {
        // The request data is unused
        (void) request;

        // Build the response
        response->success = true;

        // Log to the console
        RCLCPP_INFO(rclcpp::get_logger(""ping_server""), ""Incoming request"");
        RCLCPP_INFO(rclcpp::get_logger(""ping_server""), ""Sending back response"");
    }

    int main(int argc, char **argv)
    {
        rclcpp::init(argc, argv);

        // Create the node and the service
        std::shared_ptr<rclcpp::Node> node = rclcpp::Node::make_shared(""ping_server"");
        rclcpp::Service<example_interfaces::srv::Trigger>::SharedPtr service =
            node->create_service<example_interfaces::srv::Trigger>(""ping"", &ping);

        // Log that the service is ready
        RCLCPP_INFO(rclcpp::get_logger(""ping_server""), ""Ready to serve."");

        // run the node
        rclcpp::spin(node);
        rclcpp::shutdown();
    }

Create the client in a file named ``src/ping_client.cpp`` with the following content:

.. code-block:: C++

    #include <chrono>
    #include <memory>

    #include ""rclcpp/rclcpp.hpp""
    #include ""example_interfaces/srv/trigger.hpp""

    using namespace std::chrono_literals;

    int main(int argc, char **argv)
    {
        rclcpp::init(argc, argv);

        // Create the node and the client
        std::shared_ptr<rclcpp::Node> node = rclcpp::Node::make_shared(""ping_client"");
        rclcpp::Client<example_interfaces::srv::Trigger>::SharedPtr client =
            node->create_client<example_interfaces::srv::Trigger>(""ping"");

        // Create a request
        auto request = std::make_shared<example_interfaces::srv::Trigger::Request>();

        // Wait for the service to be available
        while (!client->wait_for_service(1s)) {
            if (!rclcpp::ok()) {
                RCLCPP_ERROR(rclcpp::get_logger(""ping_client""), ""Interrupted while waiting for the service. Exiting."");
                return 0;
            }
            RCLCPP_INFO(rclcpp::get_logger(""ping_client""), ""Service not available, waiting again..."");
        }

        // Now that the service is available, send the request
        RCLCPP_INFO(rclcpp::get_logger(""ping_client""), ""Sending request"");
        auto result = client->async_send_request(request);

        // Wait for the result and log it to the console
        if (rclcpp::spin_until_future_complete(node, result) ==
            rclcpp::FutureReturnCode::SUCCESS)
        {
            RCLCPP_INFO(rclcpp::get_logger(""ping_client""), ""Response received"");
        } else {
            RCLCPP_ERROR(rclcpp::get_logger(""ping_client""), ""Failed to call service ping"");
        }

        rclcpp::shutdown();
        return 0;
    }

Open the ``CMakeLists.txt`` file and add two new executables ``ping_service`` and ``ping_client``:

.. code-block:: cmake

    find_package(example_interfaces REQUIRED)

    add_executable(ping_service src/ping_service.cpp)
    ament_target_dependencies(ping_service example_interfaces rclcpp)

    add_executable(ping_client src/ping_client.cpp)
    ament_target_dependencies(ping_client example_interfaces rclcpp)

    install(TARGETS
        ping_service
        DESTINATION lib/${PROJECT_NAME})

    install(TARGETS
        ping_client
        DESTINATION lib/${PROJECT_NAME})

Finally, build the package.


Create the XML profiles for the service and client
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Create a file with name ``ping.xml`` with the following content:

.. code-block:: XML

    <?xml version=""1.0"" encoding=""UTF-8"" ?>
    <profiles xmlns=""http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles"">

        <!-- default publisher profile -->
        <publisher profile_name=""default_publisher"" is_default_profile=""true"">
            <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
        </publisher>

        <!-- default subscriber profile -->
        <subscriber profile_name=""default_subscriber"" is_default_profile=""true"">
            <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
        </subscriber>

        <!-- service publisher is SYNC -->
        <publisher profile_name=""service"">
            <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
            <qos>
                <publishMode>
                    <kind>SYNCHRONOUS</kind>
                </publishMode>
            </qos>
        </publisher>

        <!-- client publisher is ASYNC -->
        <publisher profile_name=""client"">
            <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
            <qos>
                <publishMode>
                    <kind>ASYNCHRONOUS</kind>
                </publishMode>
            </qos>
        </publisher>

    </profiles>


This configuration file sets the publication mode to ``SYNCHRONOUS`` on the service and to ``ASYNCHRONOUS`` on the client.
Note that we are only defining the publisher profiles for both the service and the client, but subscriber profiles could be provided too.


Execute the nodes
^^^^^^^^^^^^^^^^^

Open two terminals and source the setup files on each one.
Then set the required environment variables for the XML to be loaded:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      export RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      export RMW_FASTRTPS_USE_QOS_FROM_XML=1
      export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/ping.xml

  .. group-tab:: macOS

    .. code-block:: console

      export RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      export RMW_FASTRTPS_USE_QOS_FROM_XML=1
      export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/ping.xml

  .. group-tab:: Windows

    .. code-block:: console

      SET RMW_IMPLEMENTATION=rmw_fastrtps_cpp
      SET RMW_FASTRTPS_USE_QOS_FROM_XML=1
      SET FASTRTPS_DEFAULT_PROFILES_FILE=path/to/ping.xml


On the first terminal run the service node.

.. code-block:: console

    ros2 run sync_async_node_example_cpp ping_service

You should see the service waiting for requests:

.. code-block:: console

    [INFO] [1612977403.805799037] [ping_server]: Ready to serve.

On the second terminal, run the client node.


.. code-block:: console

    ros2 run sync_async_node_example_cpp ping_client

You should see the client sending the request and receiving the response:

.. code-block:: console

    [INFO] [1612977404.805799037] [ping_client]: Sending request
    [INFO] [1612977404.825473835] [ping_client]: Response received

At the same time, the output in the server console has been updated:

.. code-block:: console

    [INFO] [1612977403.805799037] [ping_server]: Ready to serve.
    [INFO] [1612977404.807314904] [ping_server]: Incoming request
    [INFO] [1612977404.836405125] [ping_server]: Sending back response
",How can you limit the number of matching subscribers for a specific topic in Fast DDS middleware using XML profiles?
"Reading from a bag file (C++)
=============================

**Goal:** Read data from a bag file to your own C++ node.

**Tutorial level:** Advanced

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

``rosbag2`` doesn't just provide the ``ros2 bag`` command line tool.
It also provides a C++ API for reading from and writing to a bag from your own source code.
This allows you to read the contents from a bag without having to play the bag, which can sometimes be useful.

Prerequisites
-------------

You should have the ``rosbag2`` packages installed as part of your regular ROS 2 setup.

If you need to install ROS 2, see the :doc:`Installation instructions <../../Installation>`.

You should have already completed the :doc:`basic ROS 2 bag tutorial <../Beginner-CLI-Tools/Recording-And-Playing-Back-Data/Recording-And-Playing-Back-Data>`, and we will be using the ``subset`` bag you created there.

Tasks
-----

1 Create a Package
^^^^^^^^^^^^^^^^^^

Open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

In a new or existing :ref:`workspace <new-directory>`, navigate to the ``src`` directory and create
a new package:

.. code-block:: console

  ros2 pkg create --build-type ament_cmake --license Apache-2.0 bag_reading_cpp --dependencies rclcpp rosbag2_transport turtlesim

Your terminal will return a message verifying the creation of your package ``bag_reading_cpp`` and all its necessary files and folders.
The ``--dependencies`` argument will automatically add the necessary dependency lines to ``package.xml`` and ``CMakeLists.txt``.
In this case, the package will use the ``rosbag2_transport`` package as well as the ``rclcpp`` package.
A dependency on the ``turtlesim`` package is also required for working with the custom turtlesim messages.

1.1 Update ``package.xml``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Because you used the ``--dependencies`` option during package creation, you don't have to manually add dependencies to ``package.xml`` or ``CMakeLists.txt``.
As always, though, make sure to add the description, maintainer email and name, and license information to ``package.xml``.

.. code-block:: xml

  <description>C++ bag reading tutorial</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>

2 Write the C++ Reader
^^^^^^^^^^^^^^^^^^^^^^

Inside your package's ``src`` directory, create a new file called ``simple_bag_reader.cpp`` and paste the following code into it.

.. code-block:: C++

    #include <chrono>
    #include <functional>
    #include <iostream>
    #include <memory>
    #include <string>

    #include ""rclcpp/rclcpp.hpp""
    #include ""rclcpp/serialization.hpp""
    #include ""rosbag2_transport/reader_writer_factory.hpp""
    #include ""turtlesim_msgs/msg/pose.hpp""

    using namespace std::chrono_literals;

    class PlaybackNode : public rclcpp::Node
    {
      public:
        PlaybackNode(const std::string & bag_filename)
        : Node(""playback_node"")
        {
          publisher_ = this->create_publisher<turtlesim_msgs::msg::Pose>(""/turtle1/pose"", 10);

          timer_ = this->create_wall_timer(100ms,
              [this](){return this->timer_callback();}
          );

          rosbag2_storage::StorageOptions storage_options;
          storage_options.uri = bag_filename;
          reader_ = rosbag2_transport::ReaderWriterFactory::make_reader(storage_options);
          reader_->open(storage_options);
        }

      private:
        void timer_callback()
        {
          while (reader_->has_next()) {
            rosbag2_storage::SerializedBagMessageSharedPtr msg = reader_->read_next();

            if (msg->topic_name != ""/turtle1/pose"") {
              continue;
            }

            rclcpp::SerializedMessage serialized_msg(*msg->serialized_data);
            turtlesim_msgs::msg::Pose::SharedPtr ros_msg = std::make_shared<turtlesim_msgs::msg::Pose>();

            serialization_.deserialize_message(&serialized_msg, ros_msg.get());

            publisher_->publish(*ros_msg);
            std::cout << '(' << ros_msg->x << "", "" << ros_msg->y << "")\n"";

            break;
          }
        }

        rclcpp::TimerBase::SharedPtr timer_;
        rclcpp::Publisher<turtlesim_msgs::msg::Pose>::SharedPtr publisher_;

        rclcpp::Serialization<turtlesim_msgs::msg::Pose> serialization_;
        std::unique_ptr<rosbag2_cpp::Reader> reader_;
    };

    int main(int argc, char ** argv)
    {
      if (argc != 2) {
        std::cerr << ""Usage: "" << argv[0] << "" <bag>"" << std::endl;
        return 1;
      }

      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<PlaybackNode>(argv[1]));
      rclcpp::shutdown();

      return 0;
    }

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

The ``#include`` statements at the top are the package dependencies.
Note the inclusion of headers from the ``rosbag2_transport`` package for the functions and structures necessary to work with bag files.

The next line creates the node which will read from the bag file and play back the data.

.. code-block:: C++

    class PlaybackNode : public rclcpp::Node

Now, we can create a timer callback which will run at 10 hz.
Our goal is to replay one message to the ``/turtle1/pose`` topic each time the callback is run.
Note the constructor takes a path to the bag file as a parameter.

.. code-block:: C++

    public:
      PlaybackNode(const std::string & bag_filename)
      : Node(""playback_node"")
      {
        publisher_ = this->create_publisher<turtlesim_msgs::msg::Pose>(""/turtle1/pose"", 10);

        timer_ = this->create_wall_timer(100ms,
          [this](){return this->timer_callback();}
        );

We also open the bag in the constructor.
The ``rosbag2_transport::ReaderWriterFactory`` is a class that can construct a compressed or uncompressed reader or writer based on the storage options.

.. code-block:: C++

      rosbag2_storage::StorageOptions storage_options;
      storage_options.uri = bag_filename;
      reader_ = rosbag2_transport::ReaderWriterFactory::make_reader(storage_options);
      reader_->open(storage_options);

Now, inside our timer callback, we loop through messages in the bag until we read a message recorded from our desired topic.
Note that the serialized message has timestamp metadata in addition to the topic name.

.. code-block:: C++

    void timer_callback()
    {
      while (reader_->has_next()) {
        rosbag2_storage::SerializedBagMessageSharedPtr msg = reader_->read_next();

        if (msg->topic_name != ""/turtle1/pose"") {
          continue;
        }

We then construct an ``rclcpp::SerializedMessage`` object from the serialized data we just read.
Additionally, we need to create a ROS 2 deserialized message which will hold the result of our deserialization.
Then, we can pass both these objects to the ``rclcpp::Serialization::deserialize_message`` method.

.. code-block:: C++

    rclcpp::SerializedMessage serialized_msg(*msg->serialized_data);
    turtlesim_msgs::msg::Pose::SharedPtr ros_msg = std::make_shared<turtlesim_msgs::msg::Pose>();

    serialization_.deserialize_message(&serialized_msg, ros_msg.get());

Finally, we publish the deserialized message and print out the xy coordinate to the terminal.
We also break out of the loop so that we publish the next message during the next timer calback.

.. code-block:: C++

      publisher_->publish(*ros_msg);
      std::cout << '(' << ros_msg->x << "", "" << ros_msg->y << "")\n"";

      break;
    }

We must also declare the private variables used throughout the node.

.. code-block:: C++

      rclcpp::TimerBase::SharedPtr timer_;
      rclcpp::Publisher<turtlesim_msgs::msg::Pose>::SharedPtr publisher_;

      rclcpp::Serialization<turtlesim_msgs::msg::Pose> serialization_;
      std::unique_ptr<rosbag2_cpp::Reader> reader_;
    };

Lastly, we create the main function which will check that the user passes an argument for the bag file path and spins our node.

.. code-block:: C++

    int main(int argc, char ** argv)
    {
      if (argc != 2) {
        std::cerr << ""Usage: "" << argv[0] << "" <bag>"" << std::endl;
        return 1;
      }

      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<PlaybackNode>(argv[1]));
      rclcpp::shutdown();

      return 0;
    }

2.2 Add executable
~~~~~~~~~~~~~~~~~~

Now open the ``CMakeLists.txt`` file.

Below the dependencies block, which contains ``find_package(rosbag2_transport REQUIRED)``, add the following lines of code.

.. code-block:: console

    add_executable(simple_bag_reader src/simple_bag_reader.cpp)
    ament_target_dependencies(simple_bag_reader rclcpp rosbag2_transport turtlesim)

    install(TARGETS
      simple_bag_reader
      DESTINATION lib/${PROJECT_NAME}
    )

3 Build and run
^^^^^^^^^^^^^^^

Navigate back to the root of your workspace and build your new package.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select bag_reading_cpp

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select bag_reading_cpp

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select bag_reading_cpp

Next, source the setup files.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now, run the script.
Make sure to replace ``/path/to/subset`` with the path to your ``subset`` bag.

.. code-block:: console

    ros2 run bag_reading_cpp simple_bag_reader /path/to/subset

You should see the (x, y) coordinates of the turtle printed to the console.

Summary
-------

You created a C++ executable that reads data from a bag.
You then compiled and ran the executable which printed some information from the bag to the console.
",What are the steps involved in creating a C++ executable that reads data from a ROS 2 bag file?
".. redirect-from::

    Tutorials/Ros2bag/Recording-A-Bag-From-Your-Own-Node-Python

.. _ROS2BagOwnNodePython:

Recording a bag from a node (Python)
====================================

**Goal:** Record data from your own Python node to a bag.

**Tutorial level:** Advanced

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

``rosbag2`` doesn't just provide the ``ros2 bag`` command line tool.
It also provides a Python API for reading from and writing to a bag from your own source code.
This allows you to subscribe to a topic and save the received data to a bag at the same time as performing any other processing of your choice on that data.
You may do this, for example, to save data from a topic and the result of processing that data without needing to send the processed data over a topic just to record it.
Because any data can be recorded in a bag, it is also possible to save data generated by another source than a topic, such as synthetic data for training sets.
This is useful, for example, for quickly generating a bag that contains a large number of samples spread over a long playback time.

Prerequisites
-------------

You should have the ``rosbag2`` packages installed as part of your regular ROS 2 setup.

If you've installed from deb packages on Linux, it may be installed by default.
If it is not, you can install it using this command.

.. code-block:: console

  sudo apt install ros-{DISTRO}-rosbag2

This tutorial discusses using ROS 2 bags, including from the terminal.
You should have already completed the :doc:`basic ROS 2 bag tutorial <../Beginner-CLI-Tools/Recording-And-Playing-Back-Data/Recording-And-Playing-Back-Data>`.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

Open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

Follow :ref:`these instructions <new-directory>` to create a new workspace named ``ros2_ws``.

Navigate into the ``ros2_ws/src`` directory and create a new package:

.. code-block:: console

  ros2 pkg create --build-type ament_python --license Apache-2.0 bag_recorder_nodes_py --dependencies rclpy rosbag2_py example_interfaces std_msgs

Your terminal will return a message verifying the creation of your package ``bag_recorder_nodes_py`` and all its necessary files and folders.
The ``--dependencies`` argument will automatically add the necessary dependency lines to the ``package.xml``.
In this case, the package will use the ``rosbag2_py`` package as well as the ``rclpy`` package.
A dependency on the ``std_msgs`` and ``example_interfaces`` packages are also required for message definitions.

1.1 Update ``package.xml`` and ``setup.py``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Because you used the ``--dependencies`` option during package creation, you don't have to manually add dependencies to ``package.xml``.
As always, though, make sure to add the description, maintainer email and name, and license information to ``package.xml``.

.. code-block:: xml

  <description>Python bag writing tutorial</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>

Also be sure to add this information to the ``setup.py`` file as well.

.. code-block:: Python

   maintainer='Your Name',
   maintainer_email='you@email.com',
   description='Python bag writing tutorial',
   license='Apache-2.0',

2 Write the Python node
^^^^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/bag_recorder_nodes_py/bag_recorder_nodes_py`` directory, create a new file called ``simple_bag_recorder.py`` and paste the following code into it.

.. code-block:: Python

   import rclpy
   from rclpy.executors import ExternalShutdownException
   from rclpy.node import Node
   from rclpy.serialization import serialize_message
   from std_msgs.msg import String

   import rosbag2_py

   class SimpleBagRecorder(Node):
       def __init__(self):
           super().__init__('simple_bag_recorder')
           self.writer = rosbag2_py.SequentialWriter()

           storage_options = rosbag2_py._storage.StorageOptions(
               uri='my_bag',
               storage_id='mcap')
           converter_options = rosbag2_py._storage.ConverterOptions('', '')
           self.writer.open(storage_options, converter_options)

           topic_info = rosbag2_py._storage.TopicMetadata(
               id=0,
               name='chatter',
               type='std_msgs/msg/String',
               serialization_format='cdr')
           self.writer.create_topic(topic_info)

           self.subscription = self.create_subscription(
               String,
               'chatter',
               self.topic_callback,
               10)
           self.subscription

       def topic_callback(self, msg):
           self.writer.write(
               'chatter',
               serialize_message(msg),
               self.get_clock().now().nanoseconds)


   def main(args=None):
       try:
           with rclpy.init(args=args):
               sbr = SimpleBagRecorder()
               rclpy.spin(sbr)
       except (KeyboardInterrupt, ExternalShutdownException):
           pass


   if __name__ == '__main__':
       main()

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

The ``import`` statements at the top are the package dependencies.
Note the importation of the ``rosbag2_py`` package for the functions and structures necessary to work with bag files.

In the class constructor, we begin by creating the writer object that we will use to write to the bag.
We are creating a ``SequentialWriter``, which writes messages into the bag in the order they are received.
Other writers with different behaviors may be available in `rosbag2 writer <https://github.com/ros2/rosbag2/tree/{REPOS_FILE_BRANCH}/rosbag2_py/rosbag2_py/_writer.pyi>`__.

.. code-block:: Python

   self.writer = rosbag2_py.SequentialWriter()

Now that we have a writer object, we can open the bag using it.
We specify the URI of the bag to create and the format (``mcap``), leaving other options at their defaults.
The default conversion options are used, which will perform no conversion and store the messages in the serialization format they are received in.

.. code-block:: Python

   storage_options = rosbag2_py._storage.StorageOptions(
       uri='my_bag',
       storage_id='mcap')
   converter_options = rosbag2_py._storage.ConverterOptions('', '')
   self.writer.open(storage_options, converter_options)

Next, we need to tell the writer about the topics we wish to store.
This is done by creating a ``TopicMetadata`` object and registering it with the writer.
This object specifies the topic name, topic data type, and serialization format used.

.. code-block:: Python

   topic_info = rosbag2_py._storage.TopicMetadata(
       id=0,
       name='chatter',
       type='std_msgs/msg/String',
       serialization_format='cdr')
   self.writer.create_topic(topic_info)

With the writer now set up to record data we pass to it, we create a subscription and specify a callback for it.
We will write data to the bag in the callback.

.. code-block:: Python

   self.subscription = self.create_subscription(
       String,
       'chatter',
       self.topic_callback,
       10)
   self.subscription

The callback receives the message in unserialized form (as is standard for the ``rclpy`` API) and passes the message to the writer, specifying the topic that the data is for and the timestamp to record with the message.
However, the writer requires serialized messages to store in the bag.
This means that we need to serialize the data before passing it to the writer.
For this reason, we call ``serialize_message()`` and pass the result of that to the writer, rather than passing in the message directly.

.. code-block:: Python

   def topic_callback(self, msg):
       self.writer.write(
           'chatter',
           serialize_message(msg),
           self.get_clock().now().nanoseconds)

The file finishes with the ``main`` function used to create an instance of the node and start ROS processing it.

.. code-block:: Python

   def main(args=None):
       try:
           with rclpy.init(args=args):
               sbr = SimpleBagRecorder()
               rclpy.spin(sbr)
       except (KeyboardInterrupt, ExternalShutdownException):
           pass

2.2 Add entry point
~~~~~~~~~~~~~~~~~~~

Open the ``setup.py`` file in the ``bag_recorder_nodes_py`` package and add an entry point for your node.

.. code-block:: Python

   entry_points={
       'console_scripts': [
           'simple_bag_recorder = bag_recorder_nodes_py.simple_bag_recorder:main',
       ],
   },


3 Build and run
^^^^^^^^^^^^^^^

Navigate back to the root of your workspace, ``ros2_ws``, and build your new package.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes_py

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes_py

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select bag_recorder_nodes_py

Open a new terminal, navigate to ``ros2_ws``, and source the setup files.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the node:

.. code-block:: console

   ros2 run bag_recorder_nodes_py simple_bag_recorder

Open a second terminal and run the ``talker`` example node.

.. code-block:: console

   ros2 run demo_nodes_py talker

This will start publishing data on the ``chatter`` topic.
As the bag-writing node receives this data, it will write it to the ``my_bag`` bag.
If the ``my_bag`` directory already exists, you must first delete it before running the ``simple_bag_recorder`` node.
This is because ``rosbag2`` will not overwrite existing bags by default, and so the destination directory cannot exist.

Terminate both nodes.
Then, in one terminal start the ``listener`` example node.

.. code-block:: console

   ros2 run demo_nodes_py listener

In the other terminal, use ``ros2 bag`` to play the bag recorded by your node.

.. code-block:: console

   ros2 bag play my_bag

You will see the messages from the bag being received by the ``listener`` node.

If you wish to run the bag-writing node again, you will first need to delete the ``my_bag`` directory.

4 Record synthetic data from a node
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Any data can be recorded into a bag, not just data received over a topic.
A common use case for writing to a bag from your own node is to generate and store synthetic data.
In this section you will learn how to write a node that generates some data and stores it in a bag.
We will demonstrate two approaches for doing this.
The first uses a node with a timer; this is the approach that you would use if your data generation is external to the node, such as reading data directly from hardware (e.g. a camera).
The second approach does not use a node; this is the approach you can use when you do not need to use any functionality from the ROS infrastructure.

4.1 Write a Python node
~~~~~~~~~~~~~~~~~~~~~~~

Inside the ``ros2_ws/src/bag_recorder_nodes_py/bag_recorder_nodes_py`` directory, create a new file called ``data_generator_node.py`` and paste the following code into it.

.. code-block:: Python

   import rclpy
   from rclpy.executors import ExternalShutdownException
   from rclpy.node import Node
   from rclpy.serialization import serialize_message
   from example_interfaces.msg import Int32

   import rosbag2_py

   class DataGeneratorNode(Node):
       def __init__(self):
           super().__init__('data_generator_node')
           self.data = Int32()
           self.data.data = 0
           self.writer = rosbag2_py.SequentialWriter()

           storage_options = rosbag2_py._storage.StorageOptions(
               uri='timed_synthetic_bag',
               storage_id='mcap')
           converter_options = rosbag2_py._storage.ConverterOptions('', '')
           self.writer.open(storage_options, converter_options)

           topic_info = rosbag2_py._storage.TopicMetadata(
               id=0,
               name='synthetic',
               type='example_interfaces/msg/Int32',
               serialization_format='cdr')
           self.writer.create_topic(topic_info)

           self.timer = self.create_timer(1, self.timer_callback)

       def timer_callback(self):
           self.writer.write(
               'synthetic',
               serialize_message(self.data),
               self.get_clock().now().nanoseconds)
           self.data.data += 1


   def main(args=None):
       try:
           with rclpy.init(args=args):
               dgn = DataGeneratorNode()
               rclpy.spin(dgn)
       except (KeyboardInterrupt, ExternalShutdownException):
           pass


   if __name__ == '__main__':
       main()

4.2 Examine the code
~~~~~~~~~~~~~~~~~~~~

Much of this code is the same as the first example.
The important differences are described here.

First, the name of the bag is changed.

.. code-block:: Python

   storage_options = rosbag2_py._storage.StorageOptions(
       uri='timed_synthetic_bag',
       storage_id='mcap')

The name of the topic is also changed, as is the data type stored.

.. code-block:: Python

   topic_info = rosbag2_py._storage.TopicMetadata(
       id=0,
       name='synthetic',
       type='example_interfaces/msg/Int32',
       serialization_format='cdr')
   self.writer.create_topic(topic_info)

Rather than a subscription to a topic, this node has a timer.
The timer fires with a one-second period, and calls the given member function when it does.

.. code-block:: Python

   self.timer = self.create_timer(1, self.timer_callback)

Within the timer callback, we generate (or otherwise obtain, e.g. read from a serial port connected to some hardware) the data we wish to store in the bag.
As with the previous example, the data is not yet serialized, so we must serialize it before passing it to the writer.

.. code-block:: Python

   self.writer.write(
       'synthetic',
       serialize_message(self.data),
       self.get_clock().now().nanoseconds)

4.3 Add executable
~~~~~~~~~~~~~~~~~~

Open the ``setup.py`` file in the ``bag_recorder_nodes_py`` package and add an entry point for your node.

.. code-block:: Python

   entry_points={
       'console_scripts': [
           'simple_bag_recorder = bag_recorder_nodes_py.simple_bag_recorder:main',
           'data_generator_node = bag_recorder_nodes_py.data_generator_node:main',
       ],
   },

4.4 Build and run
~~~~~~~~~~~~~~~~~

Navigate back to the root of your workspace, ``ros2_ws``, and build your package.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes_py

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes_py

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select bag_recorder_nodes_py

Open a new terminal, navigate to ``ros2_ws``, and source the setup files.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

If the ``timed_synthetic_bag`` directory already exists, you must first delete it before running the node.

Now run the node:

.. code-block:: console

   ros2 run bag_recorder_nodes_py data_generator_node

Wait for 30 seconds or so, then terminate the node with :kbd:`ctrl-c`.
Next, play back the created bag.

.. code-block:: console

   ros2 bag play timed_synthetic_bag

Open a second terminal and echo the ``/synthetic`` topic.

.. code-block:: console

   ros2 topic echo /synthetic

You will see the data that was generated and stored in the bag printed to the console at a rate of one message per second.

5 Record synthetic data from an executable
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now that you can create a bag that stores data from a source other than a topic, you will learn how to generate and record synthetic data from a non-node executable.
The advantage of this approach is simpler code and rapid creation of a large quantity of data.

5.1 Write a Python executable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Inside the ``ros2_ws/src/bag_recorder_nodes_py/bag_recorder_nodes_py`` directory, create a new file called ``data_generator_executable.py`` and paste the following code into it.

.. code-block:: Python

   from rclpy.clock import Clock
   from rclpy.duration import Duration
   from rclpy.serialization import serialize_message
   from example_interfaces.msg import Int32

   import rosbag2_py


   def main(args=None):
       writer = rosbag2_py.SequentialWriter()

       storage_options = rosbag2_py._storage.StorageOptions(
           uri='big_synthetic_bag',
           storage_id='mcap')
       converter_options = rosbag2_py._storage.ConverterOptions('', '')
       writer.open(storage_options, converter_options)

       topic_info = rosbag2_py._storage.TopicMetadata(
           id=0,
           name='synthetic',
           type='example_interfaces/msg/Int32',
           serialization_format='cdr')
       writer.create_topic(topic_info)

       time_stamp = Clock().now()
       for ii in range(0, 100):
           data = Int32()
           data.data = ii
           writer.write(
               'synthetic',
               serialize_message(data),
               time_stamp.nanoseconds)
           time_stamp += Duration(seconds=1)

   if __name__ == '__main__':
       main()

5.2 Examine the code
~~~~~~~~~~~~~~~~~~~~

A comparison of this sample and the previous sample will reveal that they are not that different.
The only significant difference is the use of a for loop to drive the data generation rather than a timer.

Notice that we are also now generating time stamps for the data rather than relying on the current system time for each sample.
The time stamp can be any value you need it to be.
The data will be played back at the rate given by these time stamps, so this is a useful way to control the default playback speed of the samples.
Notice also that while the gap between each sample is a full second in time, this executable does not need to wait a second between each sample.
This allows us to generate a lot of data covering a wide span of time in much less time than playback will take.

.. code-block:: Python

   time_stamp = Clock().now()
   for ii in range(0, 100):
       data = Int32()
       data.data = ii
       writer.write(
           'synthetic',
           serialize_message(data),
           time_stamp.nanoseconds)
       time_stamp += Duration(seconds=1)

5.3 Add executable
~~~~~~~~~~~~~~~~~~

Open the ``setup.py`` file in the ``bag_recorder_nodes_py`` package and add an entry point for your node.

.. code-block:: Python

   entry_points={
       'console_scripts': [
           'simple_bag_recorder = bag_recorder_nodes_py.simple_bag_recorder:main',
           'data_generator_node = bag_recorder_nodes_py.data_generator_node:main',
           'data_generator_executable = bag_recorder_nodes_py.data_generator_executable:main',
       ],
   },

5.4 Build and run
~~~~~~~~~~~~~~~~~

Navigate back to the root of your workspace, ``ros2_ws``, and build your package.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes_py

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select bag_recorder_nodes_py

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select bag_recorder_nodes_py

Open a terminal, navigate to ``ros2_ws``, and source the setup files.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

If the ``big_synthetic_bag`` directory already exists, you must first delete it before running the executable.

Now run the executable:

.. code-block:: console

   ros2 run bag_recorder_nodes_py data_generator_executable

Note that the executable runs and finishes very quickly.

Now play back the created bag.

.. code-block:: console

   ros2 bag play big_synthetic_bag

Open a second terminal and echo the ``/synthetic`` topic.

.. code-block:: console

   ros2 topic echo /synthetic

You will see the data that was generated and stored in the bag printed to the console at a rate of one message per second.
Even though the bag was generated rapidly it is still played back at the rate the time stamps indicate.

Summary
-------

You created a node that records data it receives on a topic into a bag.
You tested recording a bag using the node, and verified the data was recorded by playing back the bag.
This approach can be used to record a bag with additional data than it received over a topic, for example with results obtained from processing the received data.
You then went on to create a node and an executable to generate synthetic data and store it in a bag.
The latter approaches are useful especially for generating synthetic data that can be used, for example, as training sets.
",What is the purpose of the Python node described in the text document?
".. redirect-from::

    Allocator-Template-Tutorial
    Tutorials/Allocator-Template-Tutorial

Implementing a custom memory allocator
======================================

**Goal:** This tutorial will show how to use a custom memory allocator when writing ROS 2 C++ code.

**Tutorial level:** Advanced

**Time:** 20 minutes

.. contents:: Table of Contents
   :depth: 2
   :local:

This tutorial will teach you how to integrate a custom allocator for publishers and subscribers so that the default heap allocator is never called while your ROS nodes are executing.
The code for this tutorial is available `here <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/topics/allocator_tutorial_pmr.cpp>`__.

Background
----------

Suppose you want to write real-time safe code, and you've heard about the many dangers of calling ``new`` during the real-time critical section, because the default heap allocator on most platforms is nondeterministic.

By default, many C++ standard library structures will implicitly allocate memory as they grow, such as ``std::vector``.
However, these data structures also accept an ""Allocator"" template argument.
If you specify a custom allocator to one of these data structures, it will use that allocator instead of the system allocator to grow or shrink the data structure.
Your custom allocator could have a pool of memory preallocated on the stack, which might be better suited to real-time applications.

In the ROS 2 C++ client library (rclcpp), we are following a similar philosophy to the C++ standard library.
Publishers, subscribers, and the Executor accept an Allocator template parameter that controls allocations made by that entity during execution.

Writing an allocator
--------------------

To write an allocator compatible with ROS 2's allocator interface, your allocator must be compatible with the C++ standard library allocator interface.

Since C++17, the standard library provides something called ``std::pmr::memory_resource``.
This is a class that can be derived from to create a custom allocator that fulfills a minimum set of requirements.

For example, the following declaration for a custom memory resource fulfills the requirements (of course, you would still need to implement the declared functions in this class):

.. code-block:: c++

    class CustomMemoryResource : public std::pmr::memory_resource
    {
    private:
      void * do_allocate(std::size_t bytes, std::size_t alignment) override;

      void do_deallocate(
        void * p, std::size_t bytes,
        std::size_t alignment) override;

      bool do_is_equal(
        const std::pmr::memory_resource & other) const noexcept override;
    };

To learn about the full capabilities of ``std::pmr::memory_resource``, see https://en.cppreference.com/w/cpp/memory/memory_resource.

The full implementation of the custom allocator for this tutorial is in https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/topics/allocator_tutorial_pmr.cpp.

Writing an example main
-----------------------

Once you have written a valid C++ allocator, you must pass it as a shared pointer to your publisher, subscriber, and executor.
But first, we'll declare a few aliases to shorten the names.

.. code-block:: c++

     using rclcpp::memory_strategies::allocator_memory_strategy::AllocatorMemoryStrategy;
     using Alloc = std::pmr::polymorphic_allocator<void>;
     using MessageAllocTraits =
       rclcpp::allocator::AllocRebind<std_msgs::msg::UInt32, Alloc>;
     using MessageAlloc = MessageAllocTraits::allocator_type;
     using MessageDeleter = rclcpp::allocator::Deleter<MessageAlloc, std_msgs::msg::UInt32>;
     using MessageUniquePtr = std::unique_ptr<std_msgs::msg::UInt32, MessageDeleter>;

Now we can create our resources with the custom allocator:

.. code-block:: c++

     CustomMemoryResource mem_resource{};
     auto alloc = std::make_shared<Alloc>(&mem_resource);
     rclcpp::PublisherOptionsWithAllocator<Alloc> publisher_options;
     publisher_options.allocator = alloc;
     auto publisher = node->create_publisher<std_msgs::msg::UInt32>(
       ""allocator_tutorial"", 10, publisher_options);

     rclcpp::SubscriptionOptionsWithAllocator<Alloc> subscription_options;
     subscription_options.allocator = alloc;
     auto msg_mem_strat = std::make_shared<
       rclcpp::message_memory_strategy::MessageMemoryStrategy<
         std_msgs::msg::UInt32, Alloc>>(alloc);
     auto subscriber = node->create_subscription<std_msgs::msg::UInt32>(
       ""allocator_tutorial"", 10, callback, subscription_options, msg_mem_strat);

     std::shared_ptr<rclcpp::memory_strategy::MemoryStrategy> memory_strategy =
       std::make_shared<AllocatorMemoryStrategy<Alloc>>(alloc);

     rclcpp::ExecutorOptions options;
     options.memory_strategy = memory_strategy;
     rclcpp::executors::SingleThreadedExecutor executor(options);

You must also instantiate a custom deleter and allocator for use when allocating messages:

.. code-block:: c++

     MessageDeleter message_deleter;
     MessageAlloc message_alloc = *alloc;
     rclcpp::allocator::set_allocator_for_deleter(&message_deleter, &message_alloc);

Once you've add the node to the executor, it is time to spin.
We'll use the custom allocator to allocate each message:

.. code-block:: c++

     uint32_t i = 0;
     while (rclcpp::ok()) {
       auto ptr = MessageAllocTraits::allocate(message_alloc, 1);
       MessageAllocTraits::construct(message_alloc, ptr);
       MessageUniquePtr msg(ptr, message_deleter);
       msg->data = i;
       ++i;
       publisher->publish(std::move(msg));
       rclcpp::sleep_for(10ms);
       executor.spin_some();
     }

Passing an allocator to the intra-process pipeline
--------------------------------------------------

Even though we instantiated a publisher and subscriber in the same process, we aren't using the intra-process pipeline yet.

The IntraProcessManager is a class that is usually hidden from the user, but in order to pass a custom allocator to it we need to expose it by getting it from the rclcpp Context.
The IntraProcessManager makes use of several standard library structures, so without a custom allocator it will call the default ``new``.

.. code-block:: c++

    auto context = rclcpp::contexts::get_global_default_context();
    auto options = rclcpp::NodeOptions()
      .context(context)
      .use_intra_process_comms(true);
    auto node = rclcpp::Node::make_shared(""allocator_example"", options);

Make sure to instantiate publishers and subscribers AFTER constructing the node in this way.

Testing and verifying the code
------------------------------

How do you know that your custom allocator is actually getting called?

The obvious thing to do would be to count the calls made to your custom allocator's ``allocate`` and ``deallocate`` functions and compare that to the calls to ``new`` and ``delete``.

Adding counting to the custom allocator is easy:

.. code-block:: c++

     void * do_allocate(std::size_t size, std::size_t alignment) override
     {
       // ...
       num_allocs++;
       // ...
     }

     void do_deallocate(
       void * p, std::size_t bytes,
       std::size_t alignment) override
     {
       // ...
       num_deallocs++;
       // ...
     }

You can also override the global ``new`` and ``delete`` operators:

.. code-block:: c++

     void * operator new(std::size_t size)
     {
       if (is_running) {
         global_runtime_allocs++;
       }
       return std::malloc(size);
     }

     void operator delete(void * ptr, size_t) noexcept
     {
       if (ptr != nullptr) {
         if (is_running) {
           global_runtime_deallocs++;
         }
         std::free(ptr);
       }
     }

     void operator delete(void * ptr) noexcept
     {
       if (ptr != nullptr) {
         if (is_running) {
           global_runtime_deallocs++;
         }
         std::free(ptr);
       }
     }

where the variables we are incrementing are just global static integers, and ``is_running`` is a global static boolean that gets toggled right before the call to ``spin``.

The `example executable <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/topics/allocator_tutorial_pmr.cpp>`__ prints the value of the variables.
To run the example executable, use:

.. code-block:: console

     ros2 run demo_nodes_cpp allocator_tutorial

or, to run the example with the intra-process pipeline on:

.. code-block:: console

     ros2 run demo_nodes_cpp allocator_tutorial intra

You should get numbers like:

.. code-block:: console

     Global new was called 15590 times during spin
     Global delete was called 15590 times during spin
     Allocator new was called 27284 times during spin
     Allocator delete was called 27281 times during spin

We've caught about 2/3 of the allocations/deallocations that happen on the execution path, but where do the remaining 1/3 come from?

As a matter of fact, these allocations/deallocations originate in the underlying DDS implementation used in this example.

Proving this is out of the scope of this tutorial, but you can check out the test for the allocation path that gets run as part of the ROS 2 continuous integration testing, which backtraces through the code and figures out whether certain function calls originate in the rmw implementation or in a DDS implementation:

https://github.com/ros2/realtime_support/blob/{REPOS_FILE_BRANCH}/tlsf_cpp/test/test_tlsf.cpp#L41

Note that this test is not using the custom allocator we just created, but the TLSF allocator (see below).

The TLSF allocator
------------------

ROS 2 offers support for the TLSF (Two Level Segregate Fit) allocator, which was designed to meet real-time requirements:

https://github.com/ros2/realtime_support/tree/{REPOS_FILE_BRANCH}/tlsf_cpp

For more information about TLSF, see http://www.gii.upv.es/tlsf/

Note that the TLSF allocator is licensed under a dual-GPL/LGPL license.

A full working example using the TLSF allocator is here:
https://github.com/ros2/realtime_support/blob/{REPOS_FILE_BRANCH}/tlsf_cpp/example/allocator_example.cpp
",How can you determine if your custom allocator is being utilized during the execution of your ROS nodes according to the text provided?
"Reading from a bag file (Python)
================================

**Goal:** Read data from a bag file to your own Python node.

**Tutorial level:** Advanced

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

``rosbag2`` doesn't just provide the ``ros2 bag`` command line tool.
It also provides a Python API for reading from and writing to a bag from your own source code.
This allows you to read the contents from a bag without having to play the bag, which can sometimes be useful.

Prerequisites
-------------

You should have the ``rosbag2`` packages installed as part of your regular ROS 2 setup.

If you need to install ROS 2, see the :doc:`Installation instructions <../../Installation>`.

You should have already completed the :doc:`basic ROS 2 bag tutorial <../Beginner-CLI-Tools/Recording-And-Playing-Back-Data/Recording-And-Playing-Back-Data>`, and we will be using the ``subset`` bag you created there.

Tasks
-----

1 Create a Package
^^^^^^^^^^^^^^^^^^

Open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

In a new or existing :ref:`workspace <new-directory>`, navigate to the ``src`` directory and create
a new package:

.. code-block:: console

  ros2 pkg create --build-type ament_python --license Apache-2.0 bag_reader_node_py --dependencies rclpy rosbag2_py std_msgs

Your terminal will return a message verifying the creation of your package ``bag_reader_node_py`` and all its necessary files and folders.
The ``--dependencies`` argument will automatically add the necessary dependency lines to ``package.xml``.
In this case, the package will use the ``rosbag2_py`` package as well as the ``rclpy`` package.
A dependency on the ``std_msgs`` package is also required for message definitions.

1.1 Update ``package.xml`` and ``setup.py``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Because you used the ``--dependencies`` option during package creation, you don't have to manually add dependencies to ``package.xml``.
As always, though, make sure to add the description, maintainer email and name, and license information to ``package.xml``.

.. code-block:: xml

  <description>Python bag reading tutorial</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>

Also be sure to add this information to the ``setup.py`` file as well.

.. code-block:: Python

   maintainer='Your Name',
   maintainer_email='you@email.com',
   description='Python bag reading tutorial',
   license='Apache-2.0',

2 Write the C++ Reader
^^^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/bag_reader_node_py/bag_reader_node_py`` directory, create a new file called ``simple_bag_reader.py`` and paste the following code into it.

.. code-block:: Python

    import rclpy
    from rclpy.executors import ExternalShutdownException
    from rclpy.node import Node
    import rosbag2_py
    from std_msgs.msg import String


    class SimpleBagReader(Node):

        def __init__(self):
            super().__init__('simple_bag_reader')
            self.reader = rosbag2_py.SequentialReader()
            storage_options = rosbag2_py._storage.StorageOptions(
                uri='my_bag',
                storage_id='mcap')
            converter_options = rosbag2_py._storage.ConverterOptions('', '')
            self.reader.open(storage_options, converter_options)

            self.publisher = self.create_publisher(String, 'chatter', 10)
            self.timer = self.create_timer(0.1, self.timer_callback)

        def timer_callback(self):
            while self.reader.has_next():
                msg = self.reader.read_next()
                if msg[0] != 'chatter':
                    continue
                self.publisher.publish(msg[1])
                self.get_logger().info('Publish serialized data to ' + msg[0])
                break


    def main(args=None):
        try:
            with rclpy.init(args=args):
                sbr = SimpleBagReader()
                rclpy.spin(sbr)
        except (KeyboardInterrupt, ExternalShutdownException):
            pass


    if __name__ == '__main__':
        main()

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

The ``import`` statements at the top are the package dependencies.
Note the importation of the ``rosbag2_py`` package for the functions and structures necessary to work with bag files.

In the class constructor, we begin by creating the bag reader object that we will use to read from the bag.
We are creating a ``SequentialReader``, which reads messages from the bag in the order they are stored.
Other readers with different behaviors may be available in `rosbag2_py reader <https://github.com/ros2/rosbag2/tree/{REPOS_FILE_BRANCH}/rosbag2_py/rosbag2_py/_reader.pyi>`__.

.. code-block:: Python

   self.reader = rosbag2_py.SequentialReader()

Now that we have a bag reader object, we can open the bag using it.
We specify the URI of the bag and the format (``mcap``), leaving other options at their defaults.
The default conversion options are used, which will perform no conversion and store the messages in the serialization format they are received in.

.. code-block:: Python

   storage_options = rosbag2_py._storage.StorageOptions(
       uri='my_bag',
       storage_id='mcap')
   converter_options = rosbag2_py._storage.ConverterOptions('', '')
   self.reader.open(storage_options, converter_options)

Next, we create a publisher and a timer to publish the data that reader object reads from the bag file.

.. code-block:: Python

   self.publisher = self.create_publisher(String, 'chatter', 10)
   self.timer = self.create_timer(0.1, self.timer_callback)

The timer callback publishes all messages from the bag file only to the ``chatter`` topic as long as it can read out the data.

.. code-block:: Python

   def timer_callback(self):
       while self.reader.has_next():
           msg = self.reader.read_next()
           if msg[0] != 'chatter':
               continue
           self.publisher.publish(msg[1])
           self.get_logger().info('Publish serialized data to ' + msg[0])

Finally, it finishes with the ``main`` function used to create an instance of the node and start ROS processing it.

.. code-block:: Python

   def main(args=None):
       try:
           with rclpy.init(args=args):
               sbr = SimpleBagReader()
               rclpy.spin(sbr)
       except (KeyboardInterrupt, ExternalShutdownException):
           pass

2.2 Add executable
~~~~~~~~~~~~~~~~~~

Open the ``setup.py`` file in the ``bag_reader_node_py`` package and add an entry point for your node.

.. code-block:: Python

   entry_points={
       'console_scripts': [
           'simple_bag_reader = bag_reader_node_py.simple_bag_reader:main',
       ],
   },

3 Build and run
^^^^^^^^^^^^^^^

Navigate back to the root of your workspace, ``ros2_ws``, and build your new package.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select bag_reader_node_py

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select bag_reader_node_py

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select bag_reader_node_py

Open a new terminal, navigate to ``ros2_ws``, and source the setup files.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the node:

.. code-block:: console

   ros2 run bag_reader_node_py simple_bag_reader

This will start publishing data on the ``chatter`` topic from the ``my_bag`` bag file.
If the ``my_bag`` directory does not exists, ``simple_bag_reader`` will return failure since it can not open the bag file.

Open a second terminal and run the ``listener`` example node.

.. code-block:: console

   ros2 run demo_nodes_py listener

This will start receiving data on the ``chatter`` topic, published by ``simple_bag_reader`` from the bag file.

Summary
-------

You created a Python node that reads data from a bag.
You tested reading a bag using the node, and publishing the data by playing back the bag.
This approach can be used to read and publish the data with additional data from the bag file, for example modifying the original data stored in the bag file.
",What are the steps involved in creating a Python node that reads data from a bag file in ROS 2 using the `rosbag2_py` package and the `std_msgs` package?
"How to use ros2_tracing to trace and analyze an application
===========================================================

This tutorial shows how to use `ros2_tracing <https://github.com/ros2/ros2_tracing>`_ to trace and analyze a ROS 2 application.
For this tutorial, the application will be `performance_test <https://gitlab.com/ApexAI/performance_test>`_.

Overview
--------

This tutorial covers:

1. running and tracing a ``performance_test`` run
2. analyzing the trace data using `tracetools_analysis <https://github.com/ros-tracing/tracetools_analysis>`_ to plot the callback durations

Prerequisites
-------------

This tutorial is aimed at real-time Linux systems.
See the :doc:`real-time system setup tutorial <../Miscellaneous/Building-Realtime-rt_preempt-kernel-for-ROS-2>`.
However, the tutorial will work if you are using a non-real-time Linux system.

Installing and building
-----------------------

Install ROS 2 on Linux by following the :doc:`installation instructions <../../Installation>`.

.. note::

  This tutorial should generally work with all supported Linux distributions.
  However, you might need to adapt some commands.

Install ``babeltrace`` and ``ros2trace``.

.. code-block:: bash

  sudo apt-get update
  sudo apt-get install -y babeltrace ros-{DISTRO}-ros2trace ros-{DISTRO}-tracetools-analysis


Source the ROS 2 installation and verify that tracing is enabled:

.. code-block:: bash

  source /opt/ros/{DISTRO}/setup.bash
  ros2 run tracetools status

You should see ``Tracing enabled`` in the output.

Then create a workspace, and clone ``performance_test`` and ``tracetools_analysis``.

.. code-block:: bash

  cd ~/
  mkdir -p tracing_ws/src
  cd tracing_ws/src/
  git clone https://gitlab.com/ApexAI/performance_test.git
  git clone https://github.com/ros-tracing/tracetools_analysis.git -b {DISTRO}
  cd ..

Install dependencies with rosdep.

.. code-block:: bash

  rosdep update
  rosdep install --from-paths src --ignore-src -y

Then build and configure ``performance_test`` for ROS 2.
See its `documentation <https://gitlab.com/ApexAI/performance_test/-/tree/master/performance_test#performance_test>`_.

.. code-block:: bash

  colcon build --packages-select performance_test --cmake-args -DPERFORMANCE_TEST_RCLCPP_ENABLED=ON

Next, we will run a ``performance_test`` experiment and trace it.

Tracing
-------

Step 1: Trace
^^^^^^^^^^^^^

In one terminal, source the workspace and set up tracing.
When running the command, a list of ROS 2 userspace events will be printed.
It will also print the path to the directory that will contain the resulting trace (under ``~/.ros/tracing``).

.. code-block:: bash

  # terminal 1
  cd ~/tracing_ws
  source install/setup.bash
  ros2 trace --session-name perf-test --list

Press enter to start tracing.

Step 2: Run Application
^^^^^^^^^^^^^^^^^^^^^^^

In a second terminal, source the workspace.

.. code-block:: bash

  # terminal 2
  cd ~/tracing_ws
  source install/setup.bash

Then run the ``performance_test`` experiment (or your own application).
We simply create an experiment with a node publishing ~1 MB messages to another node as fast as possible for 60 seconds using the second highest real-time priority so that we don't interfere with critical kernel threads.
We need to run ``performance_test`` as ``root`` to be able to use real-time priorities.

.. code-block:: bash

  # terminal 2
  sudo ./install/performance_test/lib/performance_test/perf_test -c rclcpp-single-threaded-executor -p 1 -s 1 -r 0 -m Array1m --reliability RELIABLE --max-runtime 60 --use-rt-prio 98

If that last command doesn't work for you (with an error like: ""error while loading shared libraries""), run the slightly-different command below.
This is because, for security reasons, we need to manually pass ``*PATH`` environment variables for some shared libraries to be found (see `this explanation <https://unix.stackexchange.com/a/251374>`_).

.. code-block:: bash

  # terminal 2
  sudo env PATH=""$PATH"" LD_LIBRARY_PATH=""$LD_LIBRARY_PATH"" ./install/performance_test/lib/performance_test/perf_test -c rclcpp-single-threaded-executor -p 1 -s 1 -r 0 -m Array1m --reliability RELIABLE --max-runtime 60 --use-rt-prio 98

.. note::

  If you're not using a real-time kernel, simply run:

  .. code-block:: bash

    # terminal 2
    ./install/performance_test/lib/performance_test/perf_test -c rclcpp-single-threaded-executor -p 1 -s 1 -r 0 -m Array1m --reliability RELIABLE --max-runtime 60

Step 3: Validate Trace
^^^^^^^^^^^^^^^^^^^^^^

Once the experiment is done, in the first terminal, press enter again to stop tracing.
Use ``babeltrace`` to quickly look at the resulting trace.

.. code-block:: bash

  babeltrace ~/.ros/tracing/perf-test | less

The output of the above command is a human-readable version of the raw Common Trace Format (CTF) data, which is a list of trace events.
Each event has a timestamp, an event type, some information on the process that generated the event, and the values of the fields of the given event type.

Use the arrow keys to scroll, or press ``q`` to exit.

Next, we will analyze the trace.

Analysis
--------

`tracetools_analysis <https://github.com/ros-tracing/tracetools_analysis>`_ provides a Python API to easily analyze traces.
We can use it in a `Jupyter notebook <https://jupyter.org/>`_ with `bokeh <https://docs.bokeh.org/en/latest/index.html>`_ to plot the data.
The ``tracetools_analysis`` repository contains a `few sample notebooks <https://github.com/ros-tracing/tracetools_analysis/tree/{DISTRO}/tracetools_analysis/analysis>`_, including `one notebook to analyze subscription callback durations <https://github.com/ros-tracing/tracetools_analysis/blob/{DISTRO}/tracetools_analysis/analysis/callback_duration.ipynb>`_.

For this tutorial, we will plot the durations of the subscription callback in the subscriber node.

Install Jupyter notebook and bokeh, and then open the sample notebook.

.. code-block:: bash

  pip3 install bokeh
  jupyter notebook ~/tracing_ws/src/tracetools_analysis/tracetools_analysis/analysis/callback_duration.ipynb

This will open the notebook in the browser.

Replace the value for the ``path`` variable in the second cell to the path to the trace directory:

.. code-block:: python

  path = '~/.ros/tracing/perf-test'

Run the notebook by clicking the *Run* button for each cell.
Running the cell that does the trace processing might take a few minutes on the first run, but subsequent runs will be much quicker.

You should get a plot that looks similar to this:

.. image:: ./images/ros2_tracing_guide_result_plot.png
  :alt: callback durations result plot
  :align: center

We can see that most of the callbacks take less than 0.01 ms, but there are some outliers taking over 0.02 or 0.03 ms.

Conclusion
----------

This tutorial showed how to install tracing-related tools.
Then it showed how to trace a `performance_test <https://gitlab.com/ApexAI/performance_test>`_ experiment using `ros2_tracing <https://github.com/ros2/ros2_tracing>`_ and plot the callback durations using `tracetools_analysis <https://github.com/ros-tracing/tracetools_analysis>`_.

For more trace analyses, take a look at the `other sample notebooks <https://github.com/ros-tracing/tracetools_analysis/tree/{DISTRO}/tracetools_analysis/analysis>`_ and the `tracetools_analysis API documentation <https://docs.ros.org/en/{DISTRO}/p/tracetools_analysis/>`_.
The `ros2_tracing design document <https://github.com/ros2/ros2_tracing/blob/{DISTRO}/doc/design_ros_2.md>`_ also contains a lot of information.
",How can ros2_tracing be used to trace and analyze a ROS 2 application?
".. _ImprovedDynamicDiscovery:

Improved Dynamic Discovery
==========================

**Goal:** This tutorial will show how to use the improved dynamic discovery configuration.

**Tutorial level:** Advanced

**Time:** 15 minutes

.. contents:: Table of Contents
   :depth: 2
   :local:

Overview
--------

By default, ROS 2 will attempt to find all nodes on all hosts on the same subnet automatically.
However, the following options are available to control the ROS 2 discovery range.


Configuration Parameters
------------------------

* ``ROS_AUTOMATIC_DISCOVERY_RANGE``: controls how far ROS nodes will try to discover each other.

   Valid options are:

   * ``SUBNET`` is the default, and for DDS based middleware it means it will discover any node reachable via multicast.
   * ``LOCALHOST`` means a node will only try to discover other nodes on the same machine.
   * ``OFF`` means the node won't discover any other nodes, even on the same machine.
   * ``SYSTEM_DEFAULT`` means ""don't change any discovery settings"".

* ``ROS_STATIC_PEERS``: is a semicolon (``;``) separated list of addresses that ROS should try to discover nodes on.
  This allows connecting to nodes on specific machines (as long as their discovery range is not set to ``OFF``).

The combination of these two environment variables for local and remote nodes will enable and control the ROS 2 communication discovery range.
The following tables highlight the discovery range behavior for possible combination.

A ``X`` indicates that nodes A and B will not discover each other and communicate.
A ``O`` indicates that nodes A and B will discover each other and communicate.

.. list-table:: Node A and B running in the same host
   :widths: 20 20 20 20 20 20 20 20 20
   :header-rows: 1

   * - Same host
     -
     -
     - Node B setting
     -
     -
     -
     -
     -
   * -
     -
     -
     - No static peer
     -
     -
     - With static peer
     -
     -
   * -
     -
     -
     - Off
     - Localhost
     - Subnet
     - Off
     - Localhost
     - Subnet
   * - Node A setting
     - No static peer
     - Off
     - ``X``
     - ``X``
     - ``X``
     - ``X``
     - ``X``
     - ``X``
   * -
     -
     - Localhost
     - ``X``
     - ``O``
     - ``O``
     - ``X``
     - ``O``
     - ``O``
   * -
     -
     - Subnet
     - ``X``
     - ``O``
     - ``O``
     - ``X``
     - ``O``
     - ``O``
   * -
     - With static peer
     - Off
     - ``X``
     - ``X``
     - ``X``
     - ``X``
     - ``X``
     - ``X``
   * -
     -
     - Localhost
     - ``X``
     - ``O``
     - ``O``
     - ``X``
     - ``O``
     - ``O``
   * -
     -
     - Subnet
     - ``X``
     - ``O``
     - ``O``
     - ``X``
     - ``O``
     - ``O``


.. list-table:: Node A and B running in the different hosts
   :widths: 20 20 20 20 20 20 20 20 20
   :header-rows: 1

   * - Different hosts
     -
     -
     - Node B setting
     -
     -
     -
     -
     -
   * -
     -
     -
     - No static peer
     -
     -
     - With static peer
     -
     -
   * -
     -
     -
     - Off
     - Localhost
     - Subnet
     - Off
     - Localhost
     - Subnet
   * - Node A setting
     - No static peer
     - Off
     - ``X``
     - ``X``
     - ``X``
     - ``X``
     - ``X``
     - ``X``
   * -
     -
     - Localhost
     - ``X``
     - ``X``
     - ``X``
     - ``X``
     - ``O``
     - ``O``
   * -
     -
     - Subnet
     - ``X``
     - ``X``
     - ``O``
     - ``X``
     - ``O``
     - ``O``
   * -
     - With static peer
     - Off
     - ``X``
     - ``X``
     - ``X``
     - ``X``
     - ``X``
     - ``X``
   * -
     -
     - Localhost
     - ``X``
     - ``O``
     - ``O``
     - ``X``
     - ``O``
     - ``O``
   * -
     -
     - Subnet
     - ``X``
     - ``O``
     - ``O``
     - ``X``
     - ``O``
     - ``O``


Examples
--------

For example, the following commands will limit the ROS 2 communication only with localhost and specific peers:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        export ROS_AUTOMATIC_DISCOVERY_RANGE=LOCALHOST
        export ROS_STATIC_PEERS=192.168.0.1;remote.com

      To maintain this setting between shell sessions, you can add the command to your shell startup script:

      .. code-block:: console

        echo ""export ROS_AUTOMATIC_DISCOVERY_RANGE=LOCALHOST"" >> ~/.bashrc
        echo ""export ROS_STATIC_PEERS=192.168.0.1;remote.com"" >> ~/.bashrc

   .. group-tab:: macOS

      .. code-block:: console

        export ROS_AUTOMATIC_DISCOVERY_RANGE=LOCALHOST
        export ROS_STATIC_PEERS=192.168.0.1;remote.com

      To maintain this setting between shell sessions, you can add the command to your shell startup script:

      .. code-block:: console

        echo ""export ROS_AUTOMATIC_DISCOVERY_RANGE=LOCALHOST"" >> ~/.bash_profile
        echo ""export ROS_STATIC_PEERS=192.168.0.1;remote.com"" >> ~/.bash_profile

   .. group-tab:: Windows

      .. code-block:: console

        set ROS_AUTOMATIC_DISCOVERY_RANGE=LOCALHOST
        set ROS_STATIC_PEERS=192.168.0.1;remote.com

      If you want to make this permanent between shell sessions, also run:

      .. code-block:: console

        setx ROS_AUTOMATIC_DISCOVERY_RANGE LOCALHOST
        setx ROS_STATIC_PEERS 192.168.0.1;remote.com
",Question: What are the valid options for the ``ROS_AUTOMATIC_DISCOVERY_RANGE`` configuration parameter and what does each option signify in the improved dynamic discovery configuration in ROS 2?
".. redirect-from::

    Topic-Statistics-Tutorial
    Tutorials/Topics/Topic-Statistics-Tutorial

Enabling topic statistics (C++)
===============================

**Goal:** Enable ROS 2 Topic Statistics and view the output statistics data.

**Tutorial level:** Advanced

**Time:** 10 minutes

.. contents:: Table of Contents
   :local:

Background
----------

This is a short tutorial on how to enable topic statistics in ROS 2 and view the published statistics output using command line tools (:doc:`ros2topic <../../Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics>`).

ROS 2 provides the integrated measurement of statistics for messages received by any subscription,
called Topic Statistics.
With Topic Statistics enabled for your subscription, you can characterize the performance of your
system or use the data to help diagnose any present issues.

For more details please see the :doc:`Topic Statistics Concepts Page <../../../Concepts/Intermediate/About-Topic-Statistics>`.

Prerequisites
-------------

An installation from either binaries or source.

In previous tutorials, you learned how to :doc:`create a workspace <../../Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace>`,
:doc:`create a package <../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>`, and create a :doc:`C++ <../../Beginner-Client-Libraries/Writing-A-Simple-Cpp-Publisher-And-Subscriber>` publisher and subscriber.

This tutorial assumes that you still have your ``cpp_pubsub`` package from the :doc:`C++ <../../Beginner-Client-Libraries/Writing-A-Simple-Cpp-Publisher-And-Subscriber>` tutorial.

Tasks
-----

1 Write the subscriber node with statistics enabled
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Navigate into the ``ros2_ws/src/cpp_pubsub/src`` folder, created in the :doc:`previous tutorial <../../Beginner-Client-Libraries/Writing-A-Simple-Cpp-Publisher-And-Subscriber>`, and
download the example talker code by entering the following command:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

            wget -O member_function_with_topic_statistics.cpp https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_subscriber/member_function_with_topic_statistics.cpp

   .. group-tab:: macOS

      .. code-block:: console

            wget -O member_function_with_topic_statistics.cpp https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_subscriber/member_function_with_topic_statistics.cpp

   .. group-tab:: Windows

      Right click this link and select Save As ``publisher_member_function.cpp``:

      https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_subscriber/member_function_with_topic_statistics.cpp

Now there will be a new file named ``member_function_with_topic_statistics.cpp``.
Open the file using your preferred text editor.

.. code-block:: C++

    #include <chrono>
    #include <memory>

    #include ""rclcpp/rclcpp.hpp""
    #include ""rclcpp/subscription_options.hpp""

    #include ""std_msgs/msg/string.hpp""

    class MinimalSubscriberWithTopicStatistics : public rclcpp::Node
    {
    public:
      MinimalSubscriberWithTopicStatistics()
      : Node(""minimal_subscriber_with_topic_statistics"")
      {
        // manually enable topic statistics via options
        auto options = rclcpp::SubscriptionOptions();
        options.topic_stats_options.state = rclcpp::TopicStatisticsState::Enable;

        // configure the collection window and publish period (default 1s)
        options.topic_stats_options.publish_period = std::chrono::seconds(10);

        // configure the topic name (default '/statistics')
        // options.topic_stats_options.publish_topic = ""/topic_statistics""

        auto callback = [this](std_msgs::msg::String::SharedPtr msg) {
            this->topic_callback(msg);
          };

        subscription_ = this->create_subscription<std_msgs::msg::String>(
          ""topic"", 10, callback, options);
      }

    private:
      void topic_callback(const std_msgs::msg::String::ConstSharedPtr msg) const
      {
        RCLCPP_INFO(this->get_logger(), ""I heard: '%s'"", msg->data.c_str());
      }
      rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
    };

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<MinimalSubscriberWithTopicStatistics>());
      rclcpp::shutdown();
      return 0;
    }

1.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

As in the :doc:`C++ <../../Beginner-Client-Libraries/Writing-A-Simple-Cpp-Publisher-And-Subscriber>` tutorial, we have a subscriber node which receives string messages from the
``topic`` topic from the ``topic_callback`` function.
However, we've now added options to configure the subscription to enable topic statistics with
the ``rclcpp::SubscriptionOptions()`` options struct.

.. code-block:: C++

    // manually enable topic statistics via options
    auto options = rclcpp::SubscriptionOptions();
    options.topic_stats_options.state = rclcpp::TopicStatisticsState::Enable;

Optionally, fields such as the statistics collection/publish period and the topic used to publish
statistics can be configured as well.

.. code-block:: C++

    // configure the collection window and publish period (default 1s)
    options.topic_stats_options.publish_period = std::chrono::seconds(10);

    // configure the topic name (default '/statistics')
    // options.topic_stats_options.publish_topic = ""/my_topic""

The configurable fields are described in the following table:

==================================  =============================================================================================
Subscription Config Field            Purpose
==================================  =============================================================================================
topic_stats_options.state            Enable or disable topic statistics (default ``rclcpp::TopicStatisticsState::Disable``)
topic_stats_options.publish_period   The period in which to collect statistics data and publish a statistics message (default ``1s``)
topic_stats_options.publish_topic    The topic to use when publishing statistics data (default ``/statistics``)
==================================  =============================================================================================

1.2 CMakeLists.txt
~~~~~~~~~~~~~~~~~~

Now open the ``CMakeLists.txt`` file.

Add the executable and name it ``listener_with_topic_statistics`` so you can run your node using ``ros2 run``:

.. code-block:: console

    add_executable(listener_with_topic_statistics src/member_function_with_topic_statistics.cpp)
    ament_target_dependencies(listener_with_topic_statistics rclcpp std_msgs)

    install(TARGETS
      talker
      listener
      listener_with_topic_statistics
      DESTINATION lib/${PROJECT_NAME})

Make sure to save the file, and then your pub/sub system, with topic statistics enabled,
should be ready for use.

2 Build and run
^^^^^^^^^^^^^^^

To build, see the :ref:`Build and run <cpppubsub-build-and-run>` section in the pub/sub tutorial.

Run the subscriber with statistics enabled node:

.. code-block:: console

     ros2 run cpp_pubsub listener_with_topic_statistics

Now run the talker node:

.. code-block:: console

     ros2 run cpp_pubsub talker

The terminal should start publishing info messages every 0.5 seconds, like so:

.. code-block:: console

    [INFO] [minimal_publisher]: Publishing: ""Hello World: 0""
    [INFO] [minimal_publisher]: Publishing: ""Hello World: 1""
    [INFO] [minimal_publisher]: Publishing: ""Hello World: 2""
    [INFO] [minimal_publisher]: Publishing: ""Hello World: 3""
    [INFO] [minimal_publisher]: Publishing: ""Hello World: 4""

The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so:

.. code-block:: console

  [INFO] [minimal_subscriber_with_topic_statistics]: I heard: ""Hello World: 10""
  [INFO] [minimal_subscriber_with_topic_statistics]: I heard: ""Hello World: 11""
  [INFO] [minimal_subscriber_with_topic_statistics]: I heard: ""Hello World: 12""
  [INFO] [minimal_subscriber_with_topic_statistics]: I heard: ""Hello World: 13""
  [INFO] [minimal_subscriber_with_topic_statistics]: I heard: ""Hello World: 14""

Now that the subscriber node is receiving messages, it will periodically publish statistics messages.
We will observe these messages in the next section.

3 Observe published statistic data
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

While the nodes are running, open a new terminal window.
Execute the following command:

.. code-block:: console

    ros2 topic list

This will list all currently active topics.
You should see the following:

.. code-block:: console

    /parameter_events
    /rosout
    /statistics
    /topic

If you optionally changed the ``topic_stats_options.publish_topic`` field earlier in the tutorial,
then you will see that name instead of ``/statistics``.

The subscriber node you created is publishing statistics, for the topic ``topic``, to the output topic
``/statistics``.

We can visualize this using :doc:`RQt <../../../Concepts/Intermediate/About-RQt>`

.. image:: images/topic_stats_rqt.png

Now we can view the statistics data published to this topic with the following command:

.. code-block:: console

    ros2 topic echo /statistics

The terminal should start publishing statistics messages every 10 seconds, because the
``topic_stats_options.publish_period`` subscription configuration was optionally changed earlier in the tutorial.

.. code-block:: console

    ---
    measurement_source_name: minimal_subscriber_with_topic_statistics
    metrics_source: message_age
    unit: ms
    window_start:
      sec: 1594856666
      nanosec: 931527366
    window_stop:
      sec: 1594856676
      nanosec: 930797670
    statistics:
    - data_type: 1
      data: .nan
    - data_type: 3
      data: .nan
    - data_type: 2
      data: .nan
    - data_type: 5
      data: 0.0
    - data_type: 4
      data: .nan
    ---
    measurement_source_name: minimal_subscriber_with_topic_statistics
    metrics_source: message_period
    unit: ms
    window_start:
      sec: 1594856666
      nanosec: 931527366
    window_stop:
      sec: 1594856676
      nanosec: 930797670
    statistics:
    - data_type: 1
      data: 499.2746365105009
    - data_type: 3
      data: 500.0
    - data_type: 2
      data: 499.0
    - data_type: 5
      data: 619.0
    - data_type: 4
      data: 0.4463309283488427
    ---

From the `message definition <https://github.com/ros2/rcl_interfaces/tree/{REPOS_FILE_BRANCH}/statistics_msgs>`__
the ``data_types`` are as follows

===============    ===================
data_type value     statistics
===============    ===================
1                   average
2                   minimum
3                   maximum
4                   standard deviation
5                   sample count
===============    ===================

Here we see the two currently possible calculated statistics for the ``std_msgs::msg::String`` message published
to ``/topic`` by the ``minimal_publisher``.
Because the ``std_msgs::msg::String`` does not have a message header, the ``message_age`` calculation cannot be performed,
so NaNs are returned.
However, the ``message_period`` can be calculated and we see the statistics populated
in the message above.

Summary
-------

You created a subscriber node with topic statistics enabled, which published statistics data from
the :doc:`C++ <../../Beginner-Client-Libraries/Writing-A-Simple-Cpp-Service-And-Client>`'s publisher node. You were able to compile and run this node. While running,
you were able to observe the statistics data.

Related content
---------------

To observe how the ``message_age`` period is calculated please see the
`ROS 2 Topic Statistics demo <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/topic_statistics_demo>`__.
",What are the configurable fields for enabling topic statistics in ROS 2?
".. redirect-from::

    Tutorials/Security/The-Keystore

.. _The-Keystore:

Understanding the security keystore
===================================

**Goal:** Explore files located in the ROS 2 security keystore.

**Tutorial level:** Advanced

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:


Background
----------

Before proceeding ensure you have completed the :doc:`Introducing-ros2-security` tutorial.

The ``sros2`` package can be used to create keys, certificates and policies necessary to enable ROS 2 security.
However, the security configuration is extrememly flexible.
A basic understanding of the ROS 2 Security Keystore will allow integration with an existing PKI (Public Key Infrastructure) and managment of sensitive key materials consistent with organizational policies.


Security Artifact Locations
---------------------------

With communications security enabled in the prior tutorial, let's take a look at the files which were created when security was enabled.
These are the files which make encryption possible.

The ``sros2`` utilities (``ros2 security ...``) separate files into public, private and enclave key materials.

ROS uses the directory defined by the environmental variable ``ROS_SECURITY_KEYSTORE`` as the keystore.
For this tutorial, we use the directory ``~/sros2_demo/demo_keystore``.


Public Key Materials
^^^^^^^^^^^^^^^^^^^^

You will find three encryption certificates in the public directory at ``~/sros2_demo/demo_keystore/public``; however, the identity and permissions certificates are actually just a link to the Certificate Authority (CA) certificate.

In a public key infrastructure, the `Certificate Authority <https://en.wikipedia.org/wiki/Certificate_authority>`_ acts as a trust anchor: it validates the identities and permissions of participants.
For ROS, that means all the nodes that participate in the ROS graph (which may extend to an entire fleet of individual robots).
By placing the Certificate Authority's certificate (``ca.cert.pem``) in the proper location on the robot, all ROS nodes can establish mutual trust with other nodes using the same Certificate Authority.

Although in our tutorials we create a Certificate Authority on-the-fly, in a production system this should be done according to a pre-defined security plan.
Typically the Certificate Authority for a production system will be created off-line, and placed on the robot during initial setup.
It may be unique for each robot, or shared across a fleet of robots all intended to trust each other.

DDS (and ROS, by extension) supports separation of identity and permission trust chains, so each function has its own certificate authority.
In most cases a ROS system security plan does not require a separation between these duties, so the security utilities generate a single Certificate Authority which is used for both identity and permissions.

Use ``openssl`` to view this x509 certificate and display it as text:

.. code-block:: bash

  cd ~/sros2_demo/demo_keystore/public
  openssl x509 -in ca.cert.pem -text -noout

The output should look similar to the following::

  Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            02:8e:9a:24:ea:10:55:cb:e6:ea:e8:7a:c0:5f:58:6d:37:42:78:aa
        Signature Algorithm: ecdsa-with-SHA256
        Issuer: CN = sros2CA
        Validity
            Not Before: Jun  1 16:57:37 2021 GMT
            Not After : May 31 16:57:37 2031 GMT
        Subject: CN = sros2CA
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub:
                    04:71:e9:37:d7:32:ba:b8:a0:97:66:da:9f:e3:c4:
                    08:4f:7a:13:59:24:c6:cf:6a:f7:95:c5:cd:82:c0:
                    7f:7f:e3:90:dd:7b:0f:77:d1:ee:0e:af:68:7c:76:
                    a9:ca:60:d7:1e:2c:01:d7:bc:7e:e3:86:2a:9f:38:
                    dc:ed:39:c5:32
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Basic Constraints: critical
                CA:TRUE, pathlen:1
    Signature Algorithm: ecdsa-with-SHA256
         30:45:02:21:00:d4:fc:d8:45:ff:a4:51:49:98:4c:f0:c4:3f:
         e0:e7:33:19:8e:31:3c:d0:43:e7:e9:8f:36:f0:90:18:ed:d7:
         7d:02:20:30:84:f7:04:33:87:bb:4f:d3:8b:95:61:48:df:83:
         4b:e5:92:b3:e6:ee:3c:d5:cf:30:43:09:04:71:bd:dd:7c

Some things to note about this CA certificate:
 - The certificate subject name ``sros2CA`` is the default provided by the ``sros2`` utilities.
 - This certificate is valid for ten years from time of creation
 - Like all certificates, this contains a public key used for public-private key encryption
 - As a Root Certificate Authority, this is a `self-signed certificate <https://en.wikipedia.org/wiki/Self-signed_certificate>`_; i.e., it is signed using its own private key.

Since this is a public certificate, it can be freely copied as needed to establish trust throughout your ROS system.


Private Key Materials
^^^^^^^^^^^^^^^^^^^^^

Private key materials can be found in the keystore directory ``~/sros2_demo/demo_keystore/private``.
Similar to the ``public`` directory, this contains one certificate authority key ``ca.key.pem`` and symbolic links to it to be used as both an Identity and a Permissions CA private key.

.. warning::

  Protect this private key and create a secure backup of it!

This is the private key associated with the public Certificate Authority which serves as the anchor for all security in your ROS system.
You will use it to modify encryption policies for the ROS graph and to add new ROS participants.
Depending upon your robot's security needs, the key can be protected with access permissions and locked down to another account, or it can be moved off the robot entirely and onto another system or device.
If the file is lost, you will be unable to change access permissions and add new participants to the system.
Similarly, any user or process with access to the file has the ability to modify system policies and participants.

This file is only required for configuring the robot, but is not needed for the robot to run.
It can safely be stored offline in another system or removable media.

The ``sros2`` utilities use `elliptic curve cryptograpy <https://en.wikipedia.org/wiki/Elliptic-curve_cryptography>`_ rather than RSA for improved security and reduced key size.
Use the following command to show details about this elliptic curve private key:


.. code-block:: bash

  cd ~/sros2_demo/demo_keystore/private
  openssl ec -in ca.key.pem -text -noout

Your output should look similar to the following::

  read EC key
  Private-Key: (256 bit)
  priv:
      93:da:76:b9:e3:91:ab:e9:42:76:f2:38:f1:9d:94:
      90:5e:b5:96:7b:7f:71:ee:13:1b:d4:a0:f9:48:fb:
      ae:77
  pub:
      04:71:e9:37:d7:32:ba:b8:a0:97:66:da:9f:e3:c4:
      08:4f:7a:13:59:24:c6:cf:6a:f7:95:c5:cd:82:c0:
      7f:7f:e3:90:dd:7b:0f:77:d1:ee:0e:af:68:7c:76:
      a9:ca:60:d7:1e:2c:01:d7:bc:7e:e3:86:2a:9f:38:
      dc:ed:39:c5:32
  ASN1 OID: prime256v1
  NIST CURVE: P-256

In addition to the private key itself, note that the public key is listed, and it matches the public key listed in the Certificate Authority ``ca.cert.pem``.


Domain Governance Policy
^^^^^^^^^^^^^^^^^^^^^^^^

Find the domain governance policy in the enclave directory within the keystore, ``~/sros2_demo/demo_keystore/enclaves``.
The ``enclave`` directory contains XML governance policy document ``governance.xml``, as well as a copy of the document which has been signed by the Permissions CA as ``governance.p7s``.

The ``governance.p7s`` file contains domain-wide settings such as how to handle unauthenticated participants, whether to encrypt discovery, and default rules for access to topics.

Use the following command to validate the `S/MIME signature <https://en.wikipedia.org/wiki/S/MIME>`_ of the governance file:

.. code-block:: bash

  openssl smime -verify -in governance.p7s -CAfile ../public/permissions_ca.cert.pem

This command will print out the XML document, and the last line will be ``Verification successful`` to show that the document was properly signed by the Permissions CA.


Security Enclaves
^^^^^^^^^^^^^^^^^

Secure processes (typically ROS nodes) run within a security enclave.
In the simplest case, all the processes can be consolidated into the same enclave, and all processes will then use the same security policy.
However, to apply different policies to different processes, the processes can use different security enclaves when starting.
For more details about security enclaves, see the `design document <https://design.ros2.org/articles/ros2_security_enclaves.html>`_.
The security enclave is specifed by using the ROS argument ``--enclave`` when running a node.

**Each security enclave requires six files** in order to enable security.
Each file **must** be named as defined below, and as outlined in the `DDS Security standard <https://www.omg.org/spec/DDS-SECURITY/1.1/About-DDS-SECURITY/>`_.
In order to avoid having mulitple copies of the same files, the ``sros2`` utilities create links for each enclave to the single governance policy, the Identity CA and Permissions CA descibed above.

See the following six files within the ``listener`` enclave.
Three are specific to this enclave, while three are generic to this ROS system:

 - ``key.pem``, the private key used to encrypt and decrypt within this enclave
 - ``cert.pem``, the public certificate for this enclave; this certificate has been signed by the Identity CA
 - ``permissions.p7s``, the permissions for this enclave; this file has been signed with the Permissions CA
 - ``governance.p7s``, a link to the signed security policy file for this domain
 - ``identity_ca.cert.pem``, a link to the Identity CA for this domain
 - ``permissions_ca.cert.pem``, a link to the Permissions CA for this domain

The private encryption key ``key.pem`` should be protected according to your security plan.
This key encrypts, decrypts and validates communications within this specific enclave.
Should the key be lost or stolen, revoke the key and create a new identity for this enclave.

The file ``permissions.xml`` has also been created in this directory and can be used to recreate the signed permissions file.
However, this file is not required to enable security since DDS uses the signed version of the file instead.


Take the quiz!
--------------

See if you can answer these questions about the ROS security keystore.
Begin with a new terminal session and enable security with the keystore created in the prior tutorial:

.. code-block:: bash

  export ROS_SECURITY_KEYSTORE=~/sros2_demo/demo_keystore
  export ROS_SECURITY_ENABLE=true
  export ROS_SECURITY_STRATEGY=Enforce

  cd ~/sros2_demo/demo_keystore/enclaves/talker_listener/listener

Make a backup copy of ``permissions.p7s`` before beginning.

.. tabs::

  .. group-tab:: Question 1

    Open ``permissions.p7s`` in a text editor. Make a negligible change to the XML content (e.g., add a space or a blank line) and save the file.
    Launch the listener node:

    .. code-block:: bash

      ros2 run demo_nodes_cpp listener --ros-args --enclave /talker_listener/listener

    What do you expect to happen?

    Can you launch the talker node?

    .. code-block:: bash

      ros2 run demo_nodes_cpp talker --ros-args --enclave /talker_listener/talker

    What is the difference between launching the listener and launching the talker?

  .. group-tab:: Answer 1

    The listener fails to launch and throws an error.
    When the ``permissions.p7s`` file was modified--however minor--the file's signature became invalid.
    A node will not launch with security enabled and enforced when the permissions file is invalid.

    The talker will start as expected.
    It uses the ``permissions.p7s`` file in a different enclave, and the file is still valid.

.. tabs::

  .. group-tab:: Question 2

    What command lets you check to see if the signature on the modified ``permissions.p7s`` file is valid?

  .. group-tab:: Answer 2

    Check that ``permissions.p7s`` has been properly signed by the Permissions CA using the ``openssl smime`` command:

    .. code-block:: bash

      openssl smime -verify -in permissions.p7s -CAfile permissions_ca.cert.pem

Restore your original, properly signed ``permissions.p7s`` file before proceeding to the next tutorial.
",What command can you use to check if the signature on the modified `permissions.p7s` file is valid?
".. redirect-from::

    Tutorials/Security/Security-on-Two

.. _Security-on-Two:

Ensuring security across machines
=================================

**Goal:** Make two different machines communicate securely.

**Tutorial level:** Advanced

**Time:** 5 minutes

.. contents:: Contents
  :depth: 2
  :local:


Background
----------

Before proceeding ensure you have completed the :doc:`Introducing-ros2-security` tutorial.

The previous tutorials have used two ROS nodes on the same machine sending all network communications over the localhost interface.
Let's extend that scenario to involve multiple machines, since the benefits of authentication and encryption then become more obvious.

Suppose that the machine with the keystore created in the previous demo has a hostname ``Alice``, and that we want to also use another machine with hostname ``Bob`` for our multi-machine ``talker/listener`` demo.
We need to move some keys from ``Alice`` to ``Bob`` to allow SROS 2 to authenticate and encrypt the transmissions.


Create the second keystore
--------------------------

Begin by creating an empty keystore on ``Bob``; the keystore is actually just an empty directory:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      ssh Bob
      mkdir ~/sros2_demo
      exit

  .. group-tab:: MacOS

    .. code-block:: bash

      ssh Bob
      mkdir ~/sros2_demo
      exit

  .. group-tab:: Windows

    .. code-block:: bat

      ssh Bob
      md C:\dev\ros2\sros2_demo
      exit


Copy files
----------

Next copy the keys and certificates for the ``talker`` program from ``Alice`` to ``Bob``.
Since the keys are just text files, we can use ``scp`` to copy them.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      cd ~/sros2_demo/demo_keystore
      scp -r talker USERNAME@Bob:~/sros2_demo/demo_keystore

  .. group-tab:: MacOS

    .. code-block:: bash

      cd ~/sros2_demo/demo_keystore
      scp -r talker USERNAME@Bob:~/sros2_demo/demo_keystore

  .. group-tab:: Windows

    .. code-block:: bat

      cd C:\dev\ros2\sros2_demo\demo_keystore
      scp -r talker USERNAME@Bob:/dev/ros2/sros2_demo/demo_keystore

.. warning::

  Note that in this case the entire keystore is shared across the different machines which may not be the desired behavior, as it may result in a security risk.
  Please refer to :doc:`Deployment-Guidelines` for more information in this regard.

That will be very quick, since it's just copying some very small text files.
Now, we're ready to run a multi-machine talker/listener demo!


Launch the nodes
----------------

Once the environment is set up, run the talker on ``Bob``:

.. code-block:: bash

  ros2 run demo_nodes_cpp talker --ros-args --enclave /talker_listener/talker

and launch the listener on ``Alice``:

.. code-block:: bash

  ros2 run demo_nodes_py listener --ros-args --enclave /talker_listener/listener

Alice will now be receiving encrypted messages from Bob.

With two machines successfully communicating using both encryption and authentication, you can use the same procedure to add more machines to your ROS graph.
",Question: What is the recommended caution mentioned when copying and sharing the keystore across different machines for ensuring security in the multi-machine communication setup described in the text?
".. redirect-from::

    Tutorials/Security/Examine-Traffic

.. _Examine-Traffic:

Examining network traffic
=========================

**Goal:** Capture and examine raw ROS 2 network traffic.

**Tutorial level:** Advanced

**Time:** 20 minutes

.. contents:: Contents
  :depth: 2
  :local:


Overview
--------

ROS 2 communications security is all about protecting communications between nodes.
Prior tutorials enabled security, but how can you **really** tell if traffic is being encrypted?
In this tutorial we'll take a look at capturing live network traffic to show the difference between encrypted and unencrypted traffic.

.. note::

  ``rmw_fastrtps_cpp`` uses `Shared Memory Transport <https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/shared_memory/shared_memory.html>`_ by default to improve the performance in the transport layer when the endpoints are in the same host system.
  Security enclaves are still applied, and data will be encrypted.
  However, you cannot capture live network traffic since the data will not be on the network interface.
  If you are using  ``rmw_fastrtps_cpp``, you need to either go through this tutorial and use a different host system between the publisher and subscriber, or disable shared memory transport with `Enabling UDP Transport <https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/udp/udp.html#enabling-udp-transport>`_ and `How to set Fast-DDS XML configuration <https://github.com/ros2/rmw_fastrtps#full-qos-configuration>`_.

Prerequisites
-------------

This guide only runs on Linux, and assumes you have already :doc:`installed ROS 2 <../../../Installation>`.

Run the demo
------------

Install ``tcpdump``
^^^^^^^^^^^^^^^^^^^

Begin in a new terminal window by installing `tcpdump <https://www.tcpdump.org/manpages/tcpdump.1.html>`_, a command-line tool for capturing and displaying network traffic.
Although this tutorial describes ``tcpdump`` commands, you can also use `Wireshark <https://www.wireshark.org/>`_, a similar graphical tool for capturing and analyzing traffic.

.. code-block:: bash

  sudo apt update
  sudo apt install tcpdump

Run following commands on a single machine through multiple ``ssh`` sessions.

Start the talker and listener
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Start both the talker and the listener again, each in its own terminal.
The security environment variables are not set so security is not enabled for these sessions.

.. code-block:: bash

  # Disable ROS Security for both terminals
  unset ROS_SECURITY_ENABLE

  # In terminal 1:
  ros2 run demo_nodes_cpp talker --ros-args --enclave /talker_listener/talker

  # In terminal 2:
  ros2 run demo_nodes_cpp listener --ros-args --enclave /talker_listener/listener


Display unencrypted discovery packets
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

With the talker and listener running, open another terminal and start ``tcpdump`` to look at the network traffic.
You need to use ``sudo`` since reading raw network traffic is a privileged operation.

The command below uses the ``-X`` option to print packet contents, the ``-i`` option to listen for packets on any interface, and captures only `UDP <https://en.wikipedia.org/wiki/User_Datagram_Protocol>`_ port 7400 traffic.

.. code-block:: bash

  sudo tcpdump -X -i any udp port 7400

You should see packets like the following::

  20:18:04.400770 IP 8_xterm.46392 > 239.255.0.1.7400: UDP, length 252
    0x0000:  4500 0118 d48b 4000 0111 7399 c0a8 8007  E.....@...s.....
    0x0010:  efff 0001 b538 1ce8 0104 31c6 5254 5053  .....8....1.RTPS
    ...
    0x00c0:  5800 0400 3f0c 3f0c 6200 1c00 1800 0000  X...?.?.b.......
    0x00d0:  2f74 616c 6b65 725f 6c69 7374 656e 6572  /talker_listener
    0x00e0:  2f74 616c 6b65 7200 2c00 2800 2100 0000  /talker.,.(.!...
    0x00f0:  656e 636c 6176 653d 2f74 616c 6b65 725f  enclave=/talker_
    0x0100:  6c69 7374 656e 6572 2f74 616c 6b65 723b  listener/talker;
    0x0110:  0000 0000 0100 0000                      ........

This is a discovery datagram--the talker looking for subscribers.
As you can see, the node name (``/talker_listener/talker``) and the enclave (also ``/talker_listener/talker``) are passed in plain text.
You should also see similar discovery datagrams from the ``listener`` node.
Some other features of a typical discovery packet:

- The destination address is 239.255.0.1, which is a multicast IP address; ROS 2 uses multicast traffic for discovery by default.
- UDP 7400 is the destination port, as per the `DDS-RTPS specification <https://www.omg.org/spec/DDSI-RTPS/About-DDSI-RTPS/>`_.
- The packet contains the ""RTPS"" tag, also as defined to the DDS-RTPS specification.


Display unencrypted data packets
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Use ``tcpdump`` to capture non-discovery RTPS packets by filtering on UDP ports above 7400:

.. code-block:: bash

  sudo tcpdump -i any -X udp portrange 7401-7500

You will see few different types of packets, but watch for something like the following which is obviously data being sent from a talker to a listener::

  20:49:17.927303 IP localhost.46392 > localhost.7415: UDP, length 84
    0x0000:  4500 0070 5b53 4000 4011 e127 7f00 0001  E..p[S@.@..'....
    0x0010:  7f00 0001 b538 1cf7 005c fe6f 5254 5053  .....8...\.oRTPS
    0x0020:  0203 010f 010f 4874 e752 0000 0100 0000  ......Ht.R......
    0x0030:  0901 0800 cdee b760 5bf3 5aed 1505 3000  .......`[.Z...0.
    0x0040:  0000 1000 0000 1204 0000 1203 0000 0000  ................
    0x0050:  5708 0000 0001 0000 1200 0000 4865 6c6c  W...........Hell
    0x0060:  6f20 576f 726c 643a 2032 3133 3500 0000  o.World:.2135...

Some features to note about this packet:

- The message contents, ""Hello World: 2135"", are sent in clear text
- The source and destination IP address is ``localhost``: since both nodes are running on the same machine, the nodes discovered each other on the ``localhost`` interface


Enable encryption
^^^^^^^^^^^^^^^^^

Stop both the talker and the listener nodes.
Enable encryption for both by setting the security environment variables and run them again.

.. code-block:: bash

  # In terminal 1:
  export ROS_SECURITY_KEYSTORE=~/sros2_demo/demo_keystore
  export ROS_SECURITY_ENABLE=true
  export ROS_SECURITY_STRATEGY=Enforce
  ros2 run demo_nodes_cpp talker --ros-args --enclave /talker_listener/talker

  # In terminal 2:
  export ROS_SECURITY_KEYSTORE=~/sros2_demo/demo_keystore
  export ROS_SECURITY_ENABLE=true
  export ROS_SECURITY_STRATEGY=Enforce
  ros2 run demo_nodes_cpp listener --ros-args --enclave /talker_listener/listener


Display encrypted discovery packets
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Run the same ``tcpdump`` command used earlier to examine the output of discovery traffic with encryption enabled:

.. code-block:: bash

  sudo tcpdump -X -i any udp port 7400

The typical discovery packet looks somewhat like the following::

  21:09:07.336617 IP 8_xterm.60409 > 239.255.0.1.7400: UDP, length 596
    0x0000:  4500 0270 c2f6 4000 0111 83d6 c0a8 8007  E..p..@.........
    0x0010:  efff 0001 ebf9 1ce8 025c 331e 5254 5053  .........\3.RTPS
    0x0020:  0203 010f bbdd 199c 7522 b6cb 699f 74ae  ........u""..i.t.
    ...
    0x00c0:  5800 0400 3f0c ff0f 6200 2000 1a00 0000  X...?...b.......
    0x00d0:  2f74 616c 6b65 725f 6c69 7374 656e 6572  /talker_listener
    0x00e0:  2f6c 6973 7465 6e65 7200 0000 2c00 2800  /listener...,.(.
    0x00f0:  2300 0000 656e 636c 6176 653d 2f74 616c  #...enclave=/tal
    0x0100:  6b65 725f 6c69 7374 656e 6572 2f6c 6973  ker_listener/lis
    0x0110:  7465 6e65 723b 0000 0110 c400 1400 0000  tener;..........
    0x0120:  4444 533a 4175 7468 3a50 4b49 2d44 483a  DDS:Auth:PKI-DH:
    0x0130:  312e 3000 0400 0000 0c00 0000 6464 732e  1.0.........dds.
    ...
    0x0230:  1100 0000 6464 732e 7065 726d 5f63 612e  ....dds.perm_ca.
    0x0240:  616c 676f 0000 0000 0d00 0000 4543 4453  algo........ECDS
    0x0250:  412d 5348 4132 3536 0000 0000 0000 0000  A-SHA256........
    0x0260:  0510 0800 0700 0080 0600 0080 0100 0000  ................

This packet is much larger and includes information which can be used to set up encryption among ROS nodes.
As we will see shortly, this actually includes some of the security configuration files that were created when we enabled security.
Interested in learning more? Take a look at the excellent paper `Network Reconnaissance and Vulnerability Excavation of Secure DDS Systems <https://arxiv.org/abs/1908.05310>`_ to understand why this matters.


Display encrypted data packets
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now use ``tcpdump`` to capture data packets:

.. code-block:: bash

  sudo tcpdump -i any -X udp portrange 7401-7500

A typical data packet looks like the following::

  21:18:14.531102 IP localhost.54869 > localhost.7415: UDP, length 328
    0x0000:  4500 0164 bb42 4000 4011 8044 7f00 0001  E..d.B@.@..D....
    0x0010:  7f00 0001 d655 1cf7 0150 ff63 5254 5053  .....U...P.cRTPS
    0x0020:  0203 010f daf7 10ce d977 449b bb33 f04a  .........wD..3.J
    0x0030:  3301 1400 0000 0003 492a 6066 8603 cdb5  3.......I*`f....
    0x0040:  9df6 5da6 8402 2136 0c01 1400 0000 0000  ..]...!6........
    0x0050:  0203 010f daf7 10ce d977 449b bb33 f04a  .........wD..3.J
    ...
    0x0130:  7905 d390 3201 1400 3ae5 0b60 3906 967e  y...2...:..`9..~
    0x0140:  5b17 fd42 de95 54b9 0000 0000 3401 1400  [..B..T.....4...
    0x0150:  42ae f04d 0559 84c5 7116 1c51 91ba 3799  B..M.Y..q..Q..7.
    0x0160:  0000 0000                                ....

The data in this RTPS packet is all encrypted.

In addition to this data packet, you should see additional packets with node and enclave names; these support other ROS features such as parameters and services.
Encryption options for these packets can also be controlled by security policy.
",What command can be used to capture encrypted data packets using `tcpdump` with encryption enabled?
"Security
========

.. toctree::
   :maxdepth: 1

   Introducing-ros2-security
   The-Keystore
   Security-on-Two
   Examine-Traffic
   Access-Controls
   Deployment-Guidelines
",What are some of the topics covered in the document related to security in ROS 2?
"Deployment Guidelines
=====================

**Goal:** Understand the best practices when deploying security artifacts into production systems.

**Tutorial level:** Advanced

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:


Background
----------

Typical deployment scenarios often involve shipping containerized applications, or packages, into remote systems.
Special attention should be payed when deploying security enabled applications, requiring users to reason about the sensitivity of packaged files.

Complying with the `DDS Security standard <https://www.omg.org/spec/DDS-SECURITY/1.1/About-DDS-SECURITY/>`_,
the ``sros2`` package provides a collection of utilities for managing security under ROS 2 environments in a highly modular and flexible fashion.

Basic core guidelines on how to organize the different certificates, keys and directories remains a critical factor to avoid compromising the security of the system.
This includes protection-awareness and criteria for selecting the minimum set of necessary files to be deployed upon remote production systems for minimizing security exposure.

Prerequisites
-------------

* A docker installation with the compose plugin.
  Please refer to the installation steps detailed in `Docker installation <https://docs.docker.com/engine/install/>`_ and `Compose Plugin <https://docs.docker.com/compose/install>`_.
* (Recommended) A basic understanding on `ROS 2 Security design <https://design.ros2.org/articles/ros2_dds_security.html>`_.
* (Recommended) Previous security tutorials completion. In particular:

    * :doc:`Introducing-ros2-security`
    * :doc:`The-Keystore`
    * :doc:`Access-Controls`

General Guidelines
------------------

ROS 2 leverages DDS Security extensions to ensure security on message exchanges within the same enclave.
The different signed files and certificates within an enclave are generated from the private keys and certificates of a `Certificate Authority (CA) <https://en.wikipedia.org/wiki/Certificate_authority>`_ trusted entity.
In fact, two different CA's can be selected for identity and permissions, per enclave.
Those CA artifacts are stored inside ``private/`` and ``public/`` sub-directories of a `Keystore <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ with the following folder structure:

.. code-block:: text

  keystore
  ├── enclaves
  │   └── ...
  │       └── ...
  ├── private
  │   └── ...
  └── public
      └── ...

A good practice for the creation and usage of a certain Certificate Authority on a typical deployment for a production system, is to:

#. Create it within the organization system intended for internal use only.
#. Generate/modify desired enclaves bearing in mind that:

    * Not all the generated enclaves should be deployed to all target devices.
    * A reasonable way to proceed would be having one enclave per application, allowing for a separation of concerns.

#. Ship ``public/`` alongside with corresponding ``enclaves/`` into the different remote production devices during setup.
#. Keep and protect ``private/`` keys and/or certification requests in the organization.

It is important to note that if ``private/`` files are lost, it won't be possible to change access permissions, add or modify security profiles anymore.

In addition, further practices may be taken into consideration:

* Granting read-only permissions to the ``enclaves/`` directory contents.
* If a PKCS#11 compliant URI is given for generating enclave's private keys, a `Hardware Security Module (HSM) <https://en.wikipedia.org/wiki/Hardware_security_module>`_ could be used to store them.

The following table depicts a summary of the previous statements relating the Keystore directory with the Recommended location:

+------------------------+--------------+---------------+---------------------+
| Directory / Location   | Organization | Target Device | Material Sensitivity|
+========================+==============+===============+=====================+
| public                 |       ✓      |       ✓       |         Low         |
+------------------------+--------------+---------------+---------------------+
| private                |       ✓      |       ✕       |         High        |
+------------------------+--------------+---------------+---------------------+
| enclaves               |       ✓      |       ✓       |        Medium       |
+------------------------+--------------+---------------+---------------------+


Building a deployment scenario
------------------------------

To illustrate a simple deployment scenario, a new docker image will be built on top of the one provided by ``ros:<DISTRO>``.
Starting from the image, three containers will be created with the aim of:

* Initializing the keystore in a local host's shared volume.
* Simulating two deployed remote devices that interact with each other in a secure way.

In this example, the local host serves as the organization's system.
Let us start by creating a workspace folder:

.. code-block:: bash

  mkdir ~/security_gd_tutorial
  cd ~/security_gd_tutorial

Generating the Docker Image
^^^^^^^^^^^^^^^^^^^^^^^^^^^

In order to build a new docker image, a Dockerfile is required.
The one proposed for this tutorial can be retrieved with the following command:

.. code-block:: bash

  # Download the Dockerfile
  wget https://raw.githubusercontent.com/ros2/ros2_documentation/{DISTRO}/source/Tutorials/Advanced/Security/resources/deployment_gd/Dockerfile

Now, build the docker image with the command:

.. code-block:: bash

  # Build the base image
  docker build -t ros2_security/deployment_tutorial --build-arg ROS_DISTRO={DISTRO} .

Understanding the compose file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A compose configration file takes an image to create containers as services.
In this tutorial, three services are defined within the configuration:

* *keystore-creator*: That, similarly to previous tutorials, it internally initializes a new keystore tree directory.
  This will create *enclaves/* *public/* and *private/*, which are explained in more detail in `ROS 2 Security enclaves <https://design.ros2.org/articles/ros2_security_enclaves.html>`_.
  The ``keystore`` directory is configured to be a shared volume across containers.

* *listener* and *talker*: Act as the remote device actors in this tutorial.
  Required ``Security`` environment variables are sourced as well as the necessary keystore files from the shared volume.

The compose configuration yaml file can be downloaded with:

.. code-block:: bash

  # Download the compose file
  wget https://raw.githubusercontent.com/ros2/ros2_documentation/{DISTRO}/source/Tutorials/Advanced/Security/resources/deployment_gd/compose.deployment.yaml

Running the example
-------------------

In the same working directory ``~/security_gd_tutorial``, run:

.. code-block:: bash

  # Start the example
  docker compose -f compose.deployment.yaml up

This should result in the following output:

- *tutorial-listener-1*: ``Found security directory: /keystore/enclaves/talker_listener/listener``
- *tutorial-talker-1*: ``Found security directory: /keystore/enclaves/talker_listener/talker``
- *tutorial-listener-1*: ``Publishing: 'Hello World: <number>'``
- *tutorial-talker-1*: ``I heard: [Hello World: <number>]``

Examining the containers
^^^^^^^^^^^^^^^^^^^^^^^^

While having the containers running that simulate the two remote devices for this tutorial, attach to each of them by opening two different terminals and enter:

.. code-block:: bash

  # Terminal 1
  docker exec -it tutorial-listener-1 bash
  cd keystore
  tree

  # Terminal 2
  docker exec -it tutorial-talker-1 bash
  cd keystore
  tree

A similar output to the one depicted below should be obtained:

.. code-block:: bash

  # Terminal 1
  keystore
   ├── enclaves
   │   ├── governance.p7s
   │   ├── governance.xml
   │   └── talker_listener
   │       └── listener
   │           ├── cert.pem
   │           ├── governance.p7s
   │           ├── identity_ca.cert.pem
   │           ├── key.pem
   │           ├── permissions_ca.cert.pem
   │           ├── permissions.p7s
   │           └── permissions.xml
   └── public
       ├── ca.cert.pem
       ├── identity_ca.cert.pem
       └── permissions_ca.cert.pem

  # Terminal 2
  keystore
   ├── enclaves
   │   ├── governance.p7s
   │   ├── governance.xml
   │   └── talker_listener
   │       └── talker
   │           ├── cert.pem
   │           ├── governance.p7s
   │           ├── identity_ca.cert.pem
   │           ├── key.pem
   │           ├── permissions_ca.cert.pem
   │           ├── permissions.p7s
   │           └── permissions.xml
   └── public
       ├── ca.cert.pem
       ├── identity_ca.cert.pem
       └── permissions_ca.cert.pem

Note that:

* *private/* folder is not moved but left in the local host (organization).
* Each one of the deployed devices contain its own minimum enclave required for its application.

.. note::

  For the sake of simplicity, the same CA is used within this enclave for both identity and permissions.
",What are some best practices to consider when deploying security artifacts into production systems?
".. redirect-from::

    Tutorials/Security/Introducing-ros2-security

.. _sros2:
.. _ROS-2-Security-Tutorials:

Setting up security
===================

**Goal:** Set up security with ``sros2``.

**Tutorial level:** Advanced

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:


Background
----------

The ``sros2`` package provides the tools and instructions to use ROS 2 on top of DDS-Security.
The security features have been tested across platforms (Linux, macOS, and Windows) as well as across different languages (C++ and Python).
The SROS2 has been designed to work with any secure middleware, although not all middleware is open source and support varies depending on the ROS distribution in use.


Installation
------------

Typically security is available following installation using the :doc:`ROS 2 Installation Guide <../../../Installation>` and the :doc:`configuration guide <../../Beginner-CLI-Tools/Configuring-ROS2-Environment>`.
However, if you intend to install from source or switch middleware implementations, consider the following caveats:


Installing from source
^^^^^^^^^^^^^^^^^^^^^^

Before installing from source, you will need to have a recent version openssl (1.0.2g or later) installed:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      sudo apt update
      sudo apt install libssl-dev

  .. group-tab:: MacOS

    .. code-block:: bash

      brew install openssl

    You will need to have OpenSSL on your library path to run DDS-Security demos.
    Run the following command, and consider adding to your ``~/.bash_profile``:

    .. code-block:: bash

      export DYLD_LIBRARY_PATH=`brew --prefix openssl`/lib:$DYLD_LIBRARY_PATH
      export OPENSSL_ROOT_DIR=`brew --prefix openssl`


  .. group-tab:: Windows

    If you don't have OpenSSL installed, please follow :ref:`these instructions <windows-install-binary-installing-prerequisites>`

Fast DDS requires an additional CMake flag to build the security plugins, so the colcon invocation needs to be modified to pass:

.. code-block:: bash

  colcon build --symlink-install --cmake-args -DSECURITY=ON


Selecting an alternate middleware
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you choose not to use the default middleware implementation, be sure to :doc:`change your DDS implementation <../../../Installation/DDS-Implementations/>` before proceeding.

ROS 2 allows you to change the DDS implementation at runtime.
See `how to work with mulitple RMW implementations <../../../How-To-Guides/Working-with-multiple-RMW-implementations>` to explore different middleware implementations.

Note that secure communication between vendors is not supported.



Run the demo
------------

1\. Create a folder for the security files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  Begin by creating folder to store all the files necessary for this demo:

  .. tabs::

    .. group-tab:: Linux

      .. code-block:: bash

        mkdir ~/sros2_demo

    .. group-tab:: MacOS

      .. code-block:: bash

        mkdir ~/sros2_demo

    .. group-tab:: Windows

      .. code-block:: bat

        md C:\dev\ros2\sros2_demo

2\. Generate a keystore
^^^^^^^^^^^^^^^^^^^^^^^

Use the ``sros2`` utilities to create the keystore.
Files in the keystore will be used to enable security for all the participants in the ROS 2 graph.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      cd ~/sros2_demo
      ros2 security create_keystore demo_keystore

  .. group-tab:: MacOS

    .. code-block:: bash

      cd ~/sros2_demo
      ros2 security create_keystore demo_keystore

  .. group-tab:: Windows

    .. code-block:: bat

      cd sros2_demo
      ros2 security create_keystore demo_keystore

3\. Generate keys and certificates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Once the keystore is created, create keys and certificates for each node with security enabled.
For our demo, that includes the talker and listener nodes.
This command uses the ``create_enclave`` feature which is covered in more detail in the next tutorial.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      ros2 security create_enclave demo_keystore /talker_listener/talker
      ros2 security create_enclave demo_keystore /talker_listener/listener

  .. group-tab:: MacOS

    .. code-block:: bash

      ros2 security create_enclave demo_keystore /talker_listener/talker
      ros2 security create_enclave demo_keystore /talker_listener/listener

  .. group-tab:: Windows

    .. code-block:: bat

      ros2 security create_enclave demo_keystore /talker_listener/talker
      ros2 security create_enclave demo_keystore /talker_listener/listener


    If ``unable to write 'random state'`` appears then set the environment variable ``RANDFILE``.

    .. code-block:: bat

      set RANDFILE=C:\dev\ros2\sros2_demo\.rnd

    Then re-run the commands above.


4\. Configure environment variables
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Three environment variables allow the middleware to locate encryption materials and enable (and possibly enforce) security.
These and other security-related environment variables are described in the `ROS 2 DDS-Security Integration design document <https://design.ros2.org/articles/ros2_dds_security.html>`_.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      export ROS_SECURITY_KEYSTORE=~/sros2_demo/demo_keystore
      export ROS_SECURITY_ENABLE=true
      export ROS_SECURITY_STRATEGY=Enforce

  .. group-tab:: MacOS

    .. code-block:: bash

      export ROS_SECURITY_KEYSTORE=~/sros2_demo/demo_keystore
      export ROS_SECURITY_ENABLE=true
      export ROS_SECURITY_STRATEGY=Enforce

  .. group-tab:: Windows

    .. code-block:: bat

      set ROS_SECURITY_KEYSTORE=%cd%/demo_keystore
      set ROS_SECURITY_ENABLE=true
      set ROS_SECURITY_STRATEGY=Enforce

These variables need to be defined in each terminal used for the demo.
For convenience you can add them to your boot environment.


5\. Run the ``talker/listener`` demo
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Begin the demo by launching the talker node.

.. code-block:: bash

  ros2 run demo_nodes_cpp talker --ros-args --enclave /talker_listener/talker

In another terminal, do the same to launch the ``listener`` node.
The environment variables in this terminal must be properly set as described in step 4 above.

.. code-block:: bash

  ros2 run demo_nodes_py listener --ros-args --enclave /talker_listener/listener

These nodes will be communicating using authentication and encryption!
If you look at the packet contents (for example, using ``tcpdump`` or ``Wireshark`` as covered in another tutorial), you can see that the messages are encrypted.

Note: You can switch between the C++ (demo_nodes_cpp) and Python (demo_nodes_py) packages arbitrarily.

These nodes are able to communicate because we have created the appropriate keys and certificates for them.

Leave both nodes running as you answer the questions below.


Take the Quiz!
--------------

.. tabs::

  .. group-tab:: Question 1

    Open another terminal session, but **do not** set the environment variables so that security is not enabled.
    Start the listener.
    What do you expect to happen?

  .. group-tab:: Answer 1

    The listener launches but does not receive any messages.
    All traffic is encrypted, and without security enabled the listener does not receive anything.


.. tabs::

  .. group-tab:: Question 2

    Stop the listener, set the environment variable ``ROS_SECURITY_ENABLE`` to ``true`` and start the listener again.
    What results do you expect this time?

  .. group-tab:: Answer 2

    The listener still launches but does not receive messages.
    Although security has now been enabled, it is not been configured properly since ROS is unable to locate the key files.
    The listener launches, but in non-secure mode since security is not enforced, which means that although the properly configured talker is sending encrypted messages, this listener is unable to decrypt them.

.. tabs::

  .. group-tab:: Question 3

    Stop the listener and set ``ROS_SECURITY_STRATEGY`` to ``Enforce``.
    What happens now?

  .. group-tab:: Answer 3

    The listener fails to launch.
    Security has been enabled and is being enforced.
    Since it still is not properly configured, an error is thrown rather than launching in non-secure mode.


Learn More!
-----------

Are you ready to go further with ROS Security?
Take a look at the `Secure Turtlebot2 Demo <https://github.com/ros-swg/turtlebot3_demo>`_.
You'll find a functioning and complex implementation of ROS 2 security, ready to try out your own custom scenarios.
Be sure to create pull requests and issues here so we can continue improving security support in ROS!
",What happens when the ROS listener is started without setting the environment variables for security?
".. redirect-from::

    Tutorials/Security/Access-Controls

.. _Access-Controls:

Setting access controls
=======================

**Goal:** Limit the topics a node can use.

**Tutorial level:** Advanced

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:


Background
----------

Before proceeding ensure you have completed the :doc:`Introducing-ros2-security` tutorial.

Permissions are quite flexible and can be used to control many behaviors within the ROS graph.

For this tutorial, we demonstrate a policy which only allows publishing messages on the default ``chatter`` topic.
This would prevent, for instance, remapping the topic when launching the listener or using the same security enclaves for another purpose.

In order to enforce this policy, we need to update the ``permissions.xml`` file and re-sign it before launching the node.
This can be done by modifying the permissions file by hand, or by using XML templates.


Modify ``permissions.xml``
^^^^^^^^^^^^^^^^^^^^^^^^^^

Begin by making a backup of your permissions files, and open ``permissions.xml`` for editing:

.. code-block:: bash

  cd ~/sros2_demo/demo_keystore/enclaves/talker_listener/talker
  mv permissions.p7s permissions.p7s~
  mv permissions.xml permissions.xml~
  vi permissions.xml

We will be modifying the ``<allow_rule>`` for ``<publish>`` and ``<subscribe>``.
The topics in this XML file use the DDS naming format, not the ROS name.
Find details on mapping topic names between ROS and DDS in the `Topic and Service Names design document <https://design.ros2.org/articles/topic_and_service_names.html#mapping-of-ros-2-topic-and-service-names-to-dds-concepts>`_.

Paste the following XML content into ``permission.xml``, save the file and exit the text editor.
This shows the ``chatter`` and ``rosout`` ROS topics renamed to the DDS ``rt/chatter`` and ``rt/rosout`` topics, respectively:

.. code-block:: xml
  :emphasize-lines: 15,16,17,18,23,24

  <dds xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:noNamespaceSchemaLocation=""http://www.omg.org/spec/DDS-SECURITY/20170901/omg_shared_ca_permissions.xsd"">
    <permissions>
      <grant name=""/talker_listener/talker"">
        <subject_name>CN=/talker_listener/talker</subject_name>
        <validity>
          <not_before>2021-06-01T16:57:53</not_before>
          <not_after>2031-05-31T16:57:53</not_after>
        </validity>
        <allow_rule>
          <domains>
            <id>0</id>
          </domains>
          <publish>
            <topics>
              <topic>rt/chatter</topic>
              <topic>rt/rosout</topic>
              <topic>rt/parameter_events</topic>
              <topic>*/talker/*</topic>
            </topics>
          </publish>
          <subscribe>
            <topics>
              <topic>rt/parameter_events</topic>
              <topic>*/talker/*</topic>
            </topics>
          </subscribe>
        </allow_rule>
        <allow_rule>
          <domains>
            <id>0</id>
          </domains>
          <publish>
            <topics>
              <topic>ros_discovery_info</topic>
            </topics>
          </publish>
          <subscribe>
            <topics>
              <topic>ros_discovery_info</topic>
            </topics>
          </subscribe>
        </allow_rule>
        <default>DENY</default>
      </grant>
    </permissions>
  </dds>

This policy allows the talker to publish on the ``chatter`` and the ``rosout`` topics.
It also allows includes publish and subscribe permissions needed for the talker node to manage parameters (a requirement for all nodes).
Discovery permissions remain unchanged from the original template.


Sign the policy file
^^^^^^^^^^^^^^^^^^^^

This next command creates the new S/MIME signed policy file ``permissions.p7s`` from the updated XML file ``permissions.xml``.
The file must be signed with the Permissions CA certificate, **which requires access to the Permission CA private key**.
If the private key has been protected, additional steps may be required to unlock and use it accoring to your security plan.

.. code-block:: bash

  openssl smime -sign -text -in permissions.xml -out permissions.p7s \
    --signer permissions_ca.cert.pem \
    -inkey ~/sros2_demo/demo_keystore/private/permissions_ca.key.pem


Launch the node
^^^^^^^^^^^^^^^

With the updated permissions in place, we can launch the node successfully using the same command used in prior tutorials:

.. code-block:: bash

  ros2 run demo_nodes_cpp talker --ros-args --enclave /talker_listener/talker

However, attempting to remap the ``chatter`` topic prevents the node from launching (note that this requires the ``ROS_SECURITY_STRATEGY`` set to ``Enforce``).

.. code-block:: bash

  ros2 run demo_nodes_cpp talker --ros-args --enclave /talker_listener/talker \
    --remap chatter:=not_chatter


Use the templates
^^^^^^^^^^^^^^^^^

Security policies can quickly become confusing, so the ``sros2`` utilities add the ability to create policies from templates.
Do this by using the `sample policy file <https://github.com/ros2/sros2/blob/{REPOS_FILE_BRANCH}/sros2/test/policies/sample.policy.xml#L1>`_ provided in the ``sros2`` repository.
Let's creates a policy for both the ``talker`` and the ``listener`` to only use the ``chatter`` topic.

Begin by downloading the ``sros2`` repository with the sample policy files:

.. code-block:: bash

  git clone https://github.com/ros2/sros2.git /tmp/sros2

Then use the ``create_permission`` verb while pointing to the sample policy to generate the XML permission files:

.. code-block:: bash

  ros2 security create_permission demo_keystore \
    /talker_listener/talker \
    /tmp/sros2/sros2/test/policies/sample.policy.xml
  ros2 security create_permission demo_keystore \
    /talker_listener/listener \
    /tmp/sros2/sros2/test/policies/sample.policy.xml

These permission files allow nodes to only publish or subscribe to the ``chatter`` topic, and enable communications required for parameters.

In one terminal with security enabled as in previous security tutorials, run the ``talker`` demo program:

.. code-block:: bash

  ros2 run demo_nodes_cpp talker --ros-args -e /talker_listener/talker

In another terminal do the same with the ``listener`` program:

.. code-block:: bash

  ros2 run demo_nodes_py listener --ros-args -e /talker_listener/listener

At this point, your ``talker`` and ``listener`` nodes will be communicating securely using explicit access control lists.
However, the following attempt for the ``listener`` node to subscribe to a topic other than ``chatter`` will fail:

.. code-block:: bash

  ros2 run demo_nodes_py listener --ros-args --enclave /talker_listener/listener \
    --remap chatter:=not_chatter
",Question: What are the steps involved in modifying and enforcing access controls for the ROS nodes in this tutorial?
".. redirect-from::

    Discovery-Server
    Tutorials/Discovery-Server/Discovery-Server

Using Fast DDS Discovery Server as discovery protocol [community-contributed]
=============================================================================

**Goal:** This tutorial will show how to launch ROS 2 Nodes using the **Fast DDS Discovery Server** discovery protocol.

**Tutorial level:** Advanced

**Time:** 20 minutes

.. contents:: Table of Contents
   :depth: 2
   :local:

Background
----------

Starting from ROS 2 Eloquent Elusor, the **Fast DDS Discovery Server** protocol is a feature that offers a centralized dynamic discovery mechanism, as opposed to the distributed mechanism used in DDS by default.
This tutorial explains how to run some ROS 2 examples using the Fast DDS Discovery Server feature as discovery communication.

In order to get more information about the available discovery configuration, please check the `following documentation <https://fast-dds.docs.eprosima.com/en/v2.1.0/fastdds/discovery/discovery.html>`_ or read the `Fast DDS Discovery Server specific documentation <https://fast-dds.docs.eprosima.com/en/v2.1.0/fastdds/discovery/discovery_server.html#discovery-server>`__.

The `Simple Discovery Protocol <https://fast-dds.docs.eprosima.com/en/v2.1.0/fastdds/discovery/simple.html>`__ is the standard protocol defined in the `DDS standard <https://www.omg.org/omg-dds-portal/>`__.
However, it has known disadvantages in some scenarios.

* It does not **Scale** efficiently, as the number of exchanged packets increases significantly as new nodes are added.
* It requires **multicasting** capabilities that may not work reliably in some scenarios, e.g. WiFi.

The **Fast DDS Discovery Server** provides a Client-Server Architecture that allows nodes to connect with each other using an intermediate server.
Each node functions as a *discovery client*, sharing its info with one or more *discovery servers* and receiving discovery information from it.
This reduces discovery-related network traffic and it does not require multicasting capabilities.

.. image:: figures/ds_explanation.svg
    :align: center

These discovery servers can be independent, duplicated or connected with each other in order to create redundancy over the network and avoid having a single point of failure.

Fast DDS Discovery Server v2
----------------------------

The latest ROS 2 Foxy Fitzroy release (December 2020) included a new version, version 2 of the Fast DDS Discovery Server.
This version includes a new filter feature that further reduces the number of discovery messages sent.
This version uses the topic of the different nodes to decide if two nodes wish to communicate, or if they can be left unmatched (i.e. not discovering each other).
The following figure shows the decrease in discovery messages:

.. image:: figures/ds1vs2.svg
    :align: center

This architecture reduces the number of messages sent between the server and clients dramatically.
In the following graph, the reduction in network traffic over the discovery phase for the `RMF Clinic demonstration <https://github.com/open-rmf/rmf_demos#Clinic-World>`__ is shown:

.. image:: figures/discovery_server_v2_performance.svg
    :align: center


In order to use this functionality, the discovery server can be configured using the `XML configuration for Participants <https://fast-dds.docs.eprosima.com/en/v2.1.0/fastdds/discovery/discovery_server.html#discovery-server>`__.
It is also possible to configure the discovery server using the ``fastdds`` `tool <https://fast-dds.docs.eprosima.com/en/v2.1.0/fastddscli/cli/cli.html#discovery>`__ and an `environment variable <https://fast-dds.docs.eprosima.com/en/v2.1.0/fastdds/env_vars/env_vars.html>`__, which is the approach used in this tutorial.
For a more detailed explanation about the configuration of the discovery server, visit `the Fast DDS Discovery Server documentation <https://fast-dds.docs.eprosima.com/en/v2.1.0/fastdds/discovery/discovery_server.html#discovery-server>`__.


Prerequisites
-------------

This tutorial assumes you have a ROS 2 Foxy (or newer) :doc:`installation <../../../Installation>`.
If your installation is using a ROS 2 version lower than Foxy, you cannot use the ``fastdds`` tool.
Thus, in order to use the Discovery Server, you can update your repository to use a different Fast DDS version, or configure the discovery server using the `Fast DDS XML QoS configuration <https://fast-dds.docs.eprosima.com/en/v2.1.0/fastdds/discovery/discovery_server.html#discovery-server>`__.


Run this tutorial
-----------------

The ``talker-listener`` ROS 2 demo creates a ``talker`` node that publishes a ""hello world"" message every second, and a ``listener`` node that listens to these messages.

By :doc:`sourcing ROS 2 <../../Beginner-CLI-Tools/Configuring-ROS2-Environment>` you will get access to the CLI tool ``fastdds``.
This tool gives access to the `discovery tool <https://fast-dds.docs.eprosima.com/en/v2.1.0/fastddscli/cli/cli.html#discovery>`__, which can be used to launch a discovery server. This server will manage the discovery process for the nodes that connect to it.

.. important::

    Do not forget to :doc:`source ROS 2 <../../Beginner-CLI-Tools/Configuring-ROS2-Environment>` in every new terminal opened.


Setup Discovery Server
^^^^^^^^^^^^^^^^^^^^^^

Start by launching a discovery server with id 0, port 11811 (default port) and listening on all available interfaces.

Open a new terminal and run:

.. code-block:: console

    fastdds discovery --server-id 0


Launch listener node
^^^^^^^^^^^^^^^^^^^^

Execute the listener demo, to listen to the ``/chatter`` topic.

In a new terminal, set the environment variable ``ROS_DISCOVERY_SERVER`` to the location of the discovery server.
(Do not forget to source ROS 2 in every new terminal)

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=127.0.0.1:11811

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=127.0.0.1:11811

Launch the listener node. Use the argument ``--remap __node:=listener_discovery_server`` to change the node's name for this tutorial.

.. code-block:: console

    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener_discovery_server

This will create a ROS 2 node, that will automatically create a client for the discovery server and connect to the server created previously to perform discovery, rather than using multicast.


Launch talker node
^^^^^^^^^^^^^^^^^^

Open a new terminal and set the ``ROS_DISCOVERY_SERVER`` environment variable as before so that the node starts a discovery client.

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=127.0.0.1:11811

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=127.0.0.1:11811

.. code-block:: console

    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker_discovery_server

You should now see the talker publishing ""hello world"" messages, and the listener receiving these messages.


Demonstrate Discovery Server execution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So far, there is no evidence that this example and the standard talker-listener example are running differently.
To clearly demonstrate this, run another node that is not connected to the discovery server.
Run a new listener (listening in ``/chatter`` topic by default) in a new terminal and check that it is not connected to the talker already running.

.. code-block:: console

    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=simple_listener

The new listener node should not be receiving the ""hello world"" messages.

To finally verify that everything is running correctly, a new talker can be created using the simple discovery protocol (the default DDS distributed discovery mechanism) for discovery.

.. code-block:: console

    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=simple_talker

Now you should see the ``simple_listener`` node receiving the ""hello world"" messages from ``simple_talker`` but not the other messages from ``talker_discovery_server``.


Visualization tool ``rqt_graph``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``rqt_graph`` tool can be used to verify the nodes and structure of this example.
Remember, in order to use ``rqt_graph`` with the discovery server protocol (i.e., to see the ``listener_discovery_server`` and ``talker_discovery_server`` nodes) the ``ROS_DISCOVERY_SERVER`` environment variable must be set before launching it.


Advance use cases
-----------------

The following sections show different features of the discovery server that allow you to build a robust discovery server over the network.

Server Redundancy
^^^^^^^^^^^^^^^^^

By using ``fastdds`` tool, multiple discovery servers can be created.
Discovery clients (ROS nodes) can connect to as many servers as desired.
This allows to have a redundant network that will work even if some servers or nodes shut down unexpectedly.
The figure below shows a simple architecture that provides server redundancy.

.. image:: figures/ds_redundancy_example.svg
    :align: center

In several terminals, run the following code to establish a communication with redundant servers.

.. code-block:: console

    fastdds discovery --server-id 0 --ip-address 127.0.0.1 --port 11811

.. code-block:: console

    fastdds discovery --server-id 1 --ip-address 127.0.0.1 --port 11888

``--server-id N`` means server with id N. When referencing the servers with ``ROS_DISCOVERY_SERVER``, server ``0`` must be in first place and server ``1`` in second place.

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811;127.0.0.1:11888""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811;127.0.0.1:11888""

.. code-block:: console

    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811;127.0.0.1:11888""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811;127.0.0.1:11888""

.. code-block:: console

    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener

Now, if one of these servers fails, there will still be discovery capability available and nodes will still discover each other.


Backup Server
^^^^^^^^^^^^^

The Fast DDS Discovery Server allows creating a server with backup functionality.
This allows the server to restore the last state it saved in case of a shutdown.

.. image:: figures/ds_backup_example.svg
    :align: center

In different terminals, run the following code to establish a communication with a backed-up server.

.. code-block:: console

    fastdds discovery --server-id 0 --ip-address 127.0.0.1 --port 11811 --backup

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

.. code-block:: console

    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

.. code-block:: console

    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener

Several backup files are created in the discovery server's working directory (the directory it was launched in).
The two ``SQLite`` files and two ``json`` files contain the information required to start a new server and restore the failed server's state in case of failure, avoiding the need for the discovery process to happen again, and without losing information.


Discovery partitions
^^^^^^^^^^^^^^^^^^^^

Communication with discovery servers can be split to create virtual partitions in the discovery information.
This means that two endpoints will only know about each other if there is a shared discovery server or a network of discovery servers between them.
We are going to execute an example with two independent servers.
The following figure shows the architecture.

.. image:: figures/ds_partition_example.svg
    :align: center

With this schema ``Listener 1`` will be connected to ``Talker 1`` and ``Talker 2``, as they share ``Server 1``.
``Listener 2`` will connect with ``Talker 1`` as they share ``Server 2``.
But ``Listener 2`` will not hear the messages from ``Talker 2`` because they do not share any discovery server or discovery servers, including indirectly via connections between redundant discovery servers.

Run the first server listening on localhost with the default port of 11811.

.. code-block:: console

    fastdds discovery --server-id 0 --ip-address 127.0.0.1 --port 11811

In another terminal run the second server listening on localhost using another port, in this case port 11888.

.. code-block:: console

    fastdds discovery --server-id 1 --ip-address 127.0.0.1 --port 11888

Now, run each node in a different terminal. Use ``ROS_DISCOVERY_SERVER`` environment variable to decide which server they are connected to. Be aware that the `ids must match <https://fast-dds.docs.eprosima.com/en/v2.1.0/fastdds/env_vars/env_vars.html>`__.

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811;127.0.0.1:11888""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811;127.0.0.1:11888""

.. code-block:: console

    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker_1

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811;127.0.0.1:11888""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811;127.0.0.1:11888""

.. code-block:: console

    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener_1

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

.. code-block:: console

    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker_2

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER="";127.0.0.1:11888""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER="";127.0.0.1:11888""

.. code-block:: console

    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener_2

We should see how ``Listener 1`` is receiving messages from both talker nodes, while ``Listener 2`` is in a different partition from ``Talker 2`` and so does not receive messages from it.

.. note::

    Once two endpoints (ROS nodes) have discovered each other, they do not need the discovery server network between them to listen to each other's messages.



ROS 2 Introspection
-------------------

The `ROS 2 Command Line Interface <https://github.com/ros2/ros2cli>`__ supports several introspection tools to analyze the behavior of a ROS 2 network.
These tools (i.e. ``ros2 bag record``, ``ros2 topic list``, etc.) are very helpful to understand a ROS 2 working network.

Most of these tools use DDS simple discovery to exchange topic information with every existing participant (using simple discovery, every participant in the network is connected with each other).
However, the new Discovery Server v2 implements a network traffic reduction scheme that limits the discovery data between participants that do not share a topic.
This means that nodes will only receive topic's discovery data if it has a writer or a reader for that topic.
As most ROS 2 CLIs need a node in the network (some of them rely on a running ROS 2 daemon, and some create their own nodes), using the Discovery Server v2 these nodes will not have all the network information, and thus their functionality will be limited.

The Discovery Server v2 functionality allows every Participant to run as a **Super Client**, a kind of **Client** that connects to a **Server**, from which it receives all the available discovery information (instead of just what it needs).
In this sense, ROS 2 introspection tools can be configured as **Super Client**, thus being able to discover every entity that is using the Discovery Server protocol within the network.

.. note::

    In this section we use the term *Participant* as a DDS entity. Each DDS *Participant* corresponds with a ROS 2 *Context*, a ROS 2 abstraction over DDS.
    `Nodes <ROS2Nodes>` are ROS 2 entities that rely on DDS communication interfaces: ``DataWriter`` and ``DataReader``.
    Each *Participant* can hold multiple ROS 2 Nodes.
    For further details about these concepts, please visit the `Node to Participant mapping design document <http://design.ros2.org/articles/Node_to_Participant_mapping.html>`__


Daemon's related tools
^^^^^^^^^^^^^^^^^^^^^^

The ROS 2 Daemon is used in several ROS 2 CLI introspection tools.
It creates its own Participant to add a ROS 2 Node to the network graph, in order to receive all the data sent.
In order for the ROS 2 CLI to work when using Discovery Server mechanism, the ROS 2 Daemon needs to be
configured as **Super Client**.
Therefore, this section is devoted to explain how to use ROS 2 CLI with ROS 2 Daemon running as a **Super Client**.
This will allow the Daemon to discover the entire Node graph, and to receive all topic and endpoint information.
To do so, a Fast DDS XML configuration file is used to configure the ROS 2 Daemon and CLI tools.

Below you can find a XML configuration profile, which for this tutorial should be saved in the working directory as ```super_client_configuration_file.xml``` file.
This file will configure every new participant using it, as a **Super Client**.

.. code-block:: xml

   <?xml version=""1.0"" encoding=""UTF-8"" ?>
    <dds>
        <profiles xmlns=""http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles"">
            <participant profile_name=""super_client_profile"" is_default_profile=""true"">
                <rtps>
                    <builtin>
                        <discovery_config>
                            <discoveryProtocol>SUPER_CLIENT</discoveryProtocol>
                            <discoveryServersList>
                                <RemoteServer prefix=""44.53.00.5f.45.50.52.4f.53.49.4d.41"">
                                    <metatrafficUnicastLocatorList>
                                        <locator>
                                            <udpv4>
                                                <address>127.0.0.1</address>
                                                <port>11811</port>
                                            </udpv4>
                                        </locator>
                                    </metatrafficUnicastLocatorList>
                                </RemoteServer>
                            </discoveryServersList>
                        </discovery_config>
                    </builtin>
                </rtps>
            </participant>
        </profiles>
    </dds>


.. note::

    Under the *RemoteServer* tag, the *prefix* attribute value should be updated according to the server ID passed on the CLI (see `Fast DDS CLI <https://fast-dds.docs.eprosima.com/en/latest/fastddscli/cli/cli.html#discovery>`__).
    The value specified in the shown XML snippet corresponds to an ID of value 0.

First of all, instantiate a Discovery Server using `Fast DDS CLI <https://fast-dds.docs.eprosima.com/en/latest/fastddscli/cli/cli.html#discovery>`__ specifying an ID of value 0.

.. code-block:: console

    fastdds discovery -i 0 -l 127.0.0.1 -p 11811

Run a talker and a listener that will discover each other through the Server (notice that ``ROS_DISCOVERY_SERVER`` configuration is the same as the one in ``super_client_configuration_file.xml``).

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

.. code-block:: console

    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

.. code-block:: console

    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker

Then, instantiate a ROS 2 Daemon using the **Super Client** configuration (remember to source ROS 2 installation in every new terminal).

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export FASTRTPS_DEFAULT_PROFILES_FILE=super_client_configuration_file.xml

    .. group-tab:: Windows

        .. code-block:: console

            set FASTRTPS_DEFAULT_PROFILES_FILE=super_client_configuration_file.xml

.. code-block:: console

    ros2 daemon stop
    ros2 daemon start
    ros2 topic list
    ros2 node info /talker
    ros2 topic info /chatter
    ros2 topic echo /chatter

We can also see the Node's Graph using the ROS 2 tool ``rqt_graph`` as follows (you may need to press the refresh button):

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export FASTRTPS_DEFAULT_PROFILES_FILE=super_client_configuration_file.xml

    .. group-tab:: Windows

        .. code-block:: console

            set FASTRTPS_DEFAULT_PROFILES_FILE=super_client_configuration_file.xml

.. code-block:: console

    rqt_graph


No Daemon tools
^^^^^^^^^^^^^^^

Some ROS 2 CLI tools do not use the ROS 2 Daemon.
In order for these tools to connect with a Discovery Server and receive all the topics information they need to be instantiated as a **Super Client** that connects to the **Server**.

Following the previous configuration, build a simple system with a talker and a listener.
First, run a **Server**:

.. code-block:: console

    fastdds discovery -i 0 -l 127.0.0.1 -p 11811

Then, run the talker and listener in separate terminals:

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

.. code-block:: console

    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

    .. group-tab:: Windows

        .. code-block:: console

            set ROS_DISCOVERY_SERVER=""127.0.0.1:11811""

.. code-block:: console

    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker

Continue using the ROS 2 CLI with ``--no-daemon`` option with the new configuration.
New nodes will connect with the existing Server and will know every topic.
Exporting ``ROS_DISCOVERY_SERVER`` is not needed as the ROS 2 tools will be configured through the ``FASTRTPS_DEFAULT_PROFILES_FILE``.

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            export FASTRTPS_DEFAULT_PROFILES_FILE=super_client_configuration_file.xml

    .. group-tab:: Windows

        .. code-block:: console

            set FASTRTPS_DEFAULT_PROFILES_FILE=super_client_configuration_file.xml

.. code-block:: console

    ros2 topic list --no-daemon
    ros2 node info /talker --no-daemon --spin-time 2

Compare Fast DDS Discovery Server with Simple Discovery Protocol
----------------------------------------------------------------

In order to compare executing nodes using the *Simple Discovery* Protocol (the default DDS mechanism for distributed discovery) or the *Discovery Server*, two scripts that execute a talker and many listeners and analyze the network traffic during this time are provided.
For this experiment, ``tshark`` is required to be installed on your system.
The configuration file is mandatory in order to avoid using intraprocess mode.

.. note::

    These scripts are only supported on Linux, and require a discovery server closure feature that is only available from versions newer than the version provided in ROS 2 Foxy.
    In order to use this functionality, compile ROS 2 with Fast DDS v2.1.0 or higher.

These scripts' features are references for advanced purposes and their study is left to the user.

* :download:`bash network traffic generator <scripts/generate_discovery_packages.bash>`

* :download:`python3 graph generator <scripts/discovery_packets.py>`

* :download:`XML configuration <scripts/no_intraprocess_configuration.xml>`

Run the bash script with the path to ``setup.bash`` file to source ROS 2 as an argument.
This will generate the traffic trace for simple discovery.
Execute the same script with second argument ``SERVER``.
It will generate the trace for using the discovery server.

.. note::

    Depending on your configuration of ``tcpdump``, this script may require ``sudo`` privileges to read traffic across your network device.

After both executions are done, run the Python script to generate a graph similar to the one below.

.. code-block:: console

    $ export FASTRTPS_DEFAULT_PROFILES_FILE=""no_intraprocess_configuration.xml""
    $ sudo bash generate_discovery_packages.bash ~/ros2/install/local_setup.bash
    $ sudo bash generate_discovery_packages.bash ~/ros2/install/local_setup.bash SERVER
    $ python3 discovery_packets.py

.. image:: figures/discovery_packets.svg
    :align: center

This graph is the result of a specific run of the experiment.
The reader can execute the scripts and generate their own results for comparison.
It can easily be seen that network traffic is reduced when using discovery service.

The reduction in traffic is a result of avoiding every node announcing itself and waiting a response from every other node on the network.
This creates a huge amount of traffic in large architectures.
The reduction from this method increases with the number of nodes, making this architecture more scalable than the Simple Discovery Protocol approach.

The new Fast DDS Discovery Server v2 is available since *Fast DDS* v2.0.2, replacing the old discovery server.
In this new version, those nodes that do not share topics will automatically not discover each other, saving the whole discovery data required to connect them and their endpoints.
The experiment above does not show this case, but even so the massive reduction in traffic can be appreciated due to the hidden infrastructure topics of ROS 2 nodes.
","What are the advantages of using the Fast DDS Discovery Server protocol over the Simple Discovery Protocol, especially in terms of network traffic efficiency and scalability?"
".. redirect-from::

    Tutorials/Simulators/Simulation-Main

.. _SimulationMain:

Simulators
==========

Several advanced robot simulators can be used with ROS 2, such as Gazebo, Webots, etc.
Unlike turtlesim, they provide fairly realistic results relying on physics-based models for robots, sensors, actuators and objects.
Hence, what you observe in simulation is very close to what you will get when transferring your ROS 2 controllers to a real robot.

This set of tutorials will teach you how to configure different simulators with ROS 2.

.. contents:: Contents
   :depth: 2
   :local:

.. toctree::
   :maxdepth: 1

   Webots/Simulation-Webots
   Gazebo/Simulation-Gazebo
",What are some advanced robot simulators that can be used with ROS 2?
"Gazebo
======

This set of tutorials will teach you how to configure the Gazebo simulator with ROS 2.

.. contents:: Contents
   :depth: 2
   :local:

.. toctree::
   :maxdepth: 1

   Gazebo
",What is the focus of the tutorials mentioned in the text document regarding the Gazebo simulator and ROS 2?
".. redirect-from::

    Tutorials/Simulators/Ignition/Setting-up-a-Robot-Simulation-Ignition
    Tutorials/Advanced/Simulators/Ignition
    Tutorials/Advanced/Simulators/Gazebo

Setting up a robot simulation (Gazebo)
======================================

**Goal:** Launch a Simulation with Gazebo and ROS 2

**Tutorial level:** Advanced

**Time:** 5 minutes

.. contents:: Contents
   :depth: 2
   :local:


.. note::

   These instructions are about the current `Gazebo <https://gazebosim.org/>`__ (previously known as Ignition), not  `Gazebo Classic <https://classic.gazebosim.org/>`__.

Prerequisites
-------------

You'll need to install both ROS 2 and Gazebo.

ROS 2
^^^^^

For ROS 2 you should follow the :doc:`ROS 2 install instructions <../../../../Installation>`.

Gazebo
^^^^^^

Gazebo and ROS support different combinations of versions.

All supported combinations can be seen `here <https://gazebosim.org/docs/harmonic/ros_installation#summary-of-compatible-ros-and-gazebo-combinations>`__.

`ROS REP-2000 <https://www.ros.org/reps/rep-2000.html>`__ standardizes what the default version of Gazebo is for each ROS distribution.

If you haven't installed a version of Gazebo on your system yet, you can install Gazebo by following the `installation instructions <https://gazebosim.org/docs/harmonic/ros_installation>`__.

Quick Check
-----------

To verify your Gazebo installation is correct, check you can run it:

.. code-block:: console

   gz sim

Further Resources
-----------------

Once Gazebo is installed and is all clear on the last quick test, you can move to the `Gazebo tutorials <https://gazebosim.org/docs/harmonic/tutorials>`__ to try out building your own robot!

If you use a different version of Gazebo than the recommended version, make sure to use the dropdown to select the correct version of documentation.

Summary
-------

In this tutorial, you have installed Gazebo and set-up your workspace to start with the `Gazebo tutorials <https://gazebosim.org/docs/harmonic/tutorials>`__.
",What are the prerequisites for setting up a robot simulation with Gazebo and ROS 2?
"Webots
======

This set of tutorials will teach you how to configure the Webots simulator with ROS 2.

.. contents:: Contents
   :depth: 2
   :local:

.. toctree::
   :maxdepth: 1

   Installation-Ubuntu
   Installation-Windows
   Installation-MacOS
   Setting-Up-Simulation-Webots-Basic
   Setting-Up-Simulation-Webots-Advanced
   Simulation-Reset-Handler
   Simulation-Supervisor
",What tutorials are included in the Webots simulator configuration with ROS 2 guide?
".. redirect-from::

    Tutorials/Simulators/Webots/Setting-up-a-Robot-Simulation-Webots
    Tutorials/Advanced/Simulators/Webots

Setting up a robot simulation (Basic)
======================================

**Goal:** Setup a robot simulation and control it from ROS 2.

**Tutorial level:** Advanced

**Time:** 30 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In this tutorial, you are going to use the Webots robot simulator to set-up and run a very simple ROS 2 simulation scenario.

The ``webots_ros2`` package provides an interface between ROS 2 and Webots.
It includes several sub-packages, but in this tutorial, you are going to use only the ``webots_ros2_driver`` sub-package to implement a Python or C++ plugin controlling a simulated robot.
Some other sub-packages contain demos with different robots such as the TurtleBot3.
They are documented in the `Webots ROS 2 examples <https://github.com/cyberbotics/webots_ros2/wiki/Examples>`_ page.

Prerequisites
-------------

It is recommended to understand basic ROS principles covered in the beginner :doc:`../../../../Tutorials`.
In particular, :doc:`../../../Beginner-CLI-Tools/Introducing-Turtlesim/Introducing-Turtlesim`, :doc:`../../../Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics`, :doc:`../../../Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace`, :doc:`../../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package` and :doc:`../../../Intermediate/Launch/Creating-Launch-Files` are useful prerequisites.

.. tabs::

    .. group-tab:: Linux

        The Linux and ROS commands of this tutorial can be run in a standard Linux terminal.
        The following page :doc:`./Installation-Ubuntu` explains how to install the ``webots_ros2`` package on Linux.

    .. group-tab:: Windows

        The Linux and ROS commands of this tutorial must be run in a WSL (Windows Subsystem for Linux) environment.
        The following page :doc:`./Installation-Windows` explains how to install the ``webots_ros2`` package on Windows.

    .. group-tab:: macOS

        The Linux and ROS commands of this tutorial must be run in a pre-configured Linux Virtual Machine (VM).
        The following page :doc:`./Installation-MacOS` explains how to install the ``webots_ros2`` package on macOS.

This tutorial is compatible with version 2023.1.0 of ``webots_ros2`` and Webots R2023b, as well as upcoming versions.

Tasks
-----

1 Create the package structure
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's organize the code in a custom ROS 2 package.
Create a new package named ``my_package`` from the ``src`` folder of your ROS 2 workspace.
Change the current directory of your terminal to ``ros2_ws/src`` and run:

.. tabs::

    .. group-tab:: Python

        .. code-block:: console

            ros2 pkg create --build-type ament_python --license Apache-2.0 --node-name my_robot_driver my_package --dependencies rclpy geometry_msgs webots_ros2_driver

        The ``--node-name my_robot_driver`` option will create a ``my_robot_driver.py`` template Python plugin in the ``my_package`` subfolder that you will modify later.
        The ``--dependencies rclpy geometry_msgs webots_ros2_driver`` option specifies the packages needed by the ``my_robot_driver.py`` plugin in the ``package.xml`` file.

        Let's add a ``launch`` and a ``worlds`` folder inside the ``my_package`` folder.

        .. code-block:: console

                cd my_package
                mkdir launch
                mkdir worlds

        You should end up with the following folder structure:

        .. code-block:: console

            src/
            └── my_package/
                ├── launch/
                ├── my_package/
                │   ├── __init__.py
                │   └── my_robot_driver.py
                ├── resource/
                │   └── my_package
                ├── test/
                │   ├── test_copyright.py
                │   ├── test_flake8.py
                │   └── test_pep257.py
                ├── worlds/
                ├── package.xml
                ├── setup.cfg
                └── setup.py

    .. group-tab:: C++

        .. code-block:: console

            ros2 pkg create --build-type ament_cmake --license Apache-2.0 --node-name MyRobotDriver my_package --dependencies rclcpp geometry_msgs webots_ros2_driver pluginlib

        The ``--node-name MyRobotDriver`` option will create a ``MyRobotDriver.cpp`` template C++ plugin in the ``my_package/src`` subfolder that you will modify later.
        The ``--dependencies rclcpp geometry_msgs webots_ros2_driver pluginlib`` option specifies the packages needed by the ``MyRobotDriver`` plugin in the ``package.xml`` file.


        Let's add a ``launch``, a ``worlds`` and a ``resource`` folder inside the ``my_package`` folder.

        .. code-block:: console

            cd my_package
            mkdir launch
            mkdir worlds
            mkdir resource

        Two additional files must be created: the header file for ``MyRobotDriver`` and the ``my_robot_driver.xml`` pluginlib description file.

        .. code-block:: console

            touch my_robot_driver.xml
            touch include/my_package/MyRobotDriver.hpp

        You should end up with the following folder structure:

        .. code-block:: console

            src/
            └── my_package/
                ├── include/
                │   └── my_package/
                │       └── MyRobotDriver.hpp
                ├── launch/
                ├── resource/
                ├── src/
                │   └── MyRobotDriver.cpp
                ├── worlds/
                ├── CMakeList.txt
                ├── my_robot_driver.xml
                └── package.xml

2 Setup the simulation world
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You will need a world file containing a robot to launch your simulation.
:download:`Download this world file <Code/my_world.wbt>` and move it inside ``my_package/worlds/``.

This is actually a fairly simple text file you can visualize in a text editor.
A simple robot is already included in this ``my_world.wbt`` world file.

.. note::

    In case you want to learn how to create your own robot model in Webots, you can check this `tutorial <https://cyberbotics.com/doc/guide/tutorial-6-4-wheels-robot>`_.

3 Edit the ``my_robot_driver`` plugin
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``webots_ros2_driver`` sub-package automatically creates a ROS 2 interface for most sensors.
More details on existing device interfaces and how to configure them is given in the second part of the tutorial: :doc:`./Setting-Up-Simulation-Webots-Advanced`.
In this task, you will extend this interface by creating your own custom plugin.
This custom plugin is a ROS node equivalent to a robot controller.
You can use it to access the `Webots robot API  <https://cyberbotics.com/doc/reference/robot?tab-language=python>`_ and create your own topics and services to control your robot.

.. note::

    The purpose of this tutorial is to show a basic example with a minimum number of dependencies.
    However, you could avoid the use of this plugin by using another ``webots_ros2`` sub-package named ``webots_ros2_control``, introducing a new dependency.
    This other sub-package creates an interface with the ``ros2_control`` package that facilitates the control of a differential wheeled robot.


.. tabs::

    .. group-tab:: Python

        Open ``my_package/my_package/my_robot_driver.py`` in your favorite editor and replace its contents with the following:

        .. literalinclude:: Code/my_robot_driver.py
            :language: python

        As you can see, the ``MyRobotDriver`` class implements three methods.

        The first method, named ``init(self, ...)``, is actually the ROS node counterpart of the Python ``__init__(self, ...)`` constructor.
        The ``init`` method always takes two arguments:

        - The ``webots_node`` argument contains a reference on the Webots instance.
        - The ``properties`` argument is a dictionary created from the XML tags given in the URDF files (:ref:`4 Create the my_robot.urdf file`) and allows you to pass parameters to the controller.

        The robot instance from the simulation ``self.__robot`` can be used to access the `Webots robot API <https://cyberbotics.com/doc/reference/robot?tab-language=python>`_.
        Then, it gets the two motor instances and initializes them with a target position and a target velocity.
        Finally a ROS node is created and a callback method is registered for a ROS topic named ``/cmd_vel`` that will handle ``Twist`` messages.

        .. literalinclude:: Code/my_robot_driver.py
            :language: python
            :dedent: 4
            :lines: 8-24

        Then comes the implementation of the ``__cmd_vel_callback(self, twist)`` callback private method that will be called for each ``Twist`` message received on the ``/cmd_vel`` topic and will save it in the ``self.__target_twist`` member variable.

        .. literalinclude:: Code/my_robot_driver.py
            :language: python
            :dedent: 4
            :lines: 26-27

        Finally, the ``step(self)`` method is called at every time step of the simulation.
        The call to ``rclpy.spin_once()`` is needed to keep the ROS node running smoothly.
        At each time step, the method will retrieve the desired ``forward_speed`` and ``angular_speed`` from ``self.__target_twist``.
        As the motors are controlled with angular velocities, the method will then convert the ``forward_speed`` and ``angular_speed`` into individual commands for each wheel.
        This conversion depends on the structure of the robot, more specifically on the radius of the wheel and the distance between them.

        .. literalinclude:: Code/my_robot_driver.py
            :language: python
            :dedent: 4
            :lines: 29-39

    .. group-tab:: C++

        Open ``my_package/include/my_package/MyRobotDriver.hpp`` in your favorite editor and replace its contents with the following:

        .. literalinclude:: Code/MyRobotDriver.hpp
            :language: cpp

        The class ``MyRobotDriver`` is defined, which inherits from the ``webots_ros2_driver::PluginInterface`` class.
        The plugin has to override ``step(...)`` and ``init(...)`` functions.
        More details are given in the ``MyRobotDriver.cpp`` file.
        Several helper methods, callbacks and member variables that will be used internally by the plugin are declared privately.

        Then, open ``my_package/src/MyRobotDriver.cpp`` in your favorite editor and replace its contents with the following:

        .. literalinclude:: Code/MyRobotDriver.cpp
            :language: cpp

        The ``MyRobotDriver::init`` method is executed once the plugin is loaded by the ``webots_ros2_driver`` package.
        It takes two arguments:

        * A pointer to the ``WebotsNode`` defined by ``webots_ros2_driver``, which allows to access the ROS 2 node functions.
        * The ``parameters`` argument is an unordered map of strings, created from the XML tags given in the URDF files (:ref:`4 Create the my_robot.urdf file`) and allows to pass parameters to the controller. It is not used in this example.

        It initializes the plugin by setting up the robot motors, setting their positions and velocities, and subscribing to the ``/cmd_vel`` topic.

        .. literalinclude:: Code/MyRobotDriver.cpp
            :language: cpp
            :lines: 13-33

        The subscription callback is declared as a lambda function, that will be called for each Twist message received on the ``/cmd_vel`` topic and will save it in the ``cmd_vel_msg`` member variable.

        .. literalinclude:: Code/MyRobotDriver.cpp
            :language: cpp
            :lines: 28-31

        The ``step()`` method is called at every time step of the simulation.
        At each time step, the method will retrieve the desired ``forward_speed`` and ``angular_speed`` from ``cmd_vel_msg``.
        As the motors are controlled with angular velocities, the method will then convert the ``forward_speed`` and ``angular_speed`` into individual commands for each wheel.
        This conversion depends on the structure of the robot, more specifically on the radius of the wheel and the distance between them.

        .. literalinclude:: Code/MyRobotDriver.cpp
            :language: cpp
            :lines: 35-48

        The final lines of the file define the end of the ``my_robot_driver`` namespace and include a macro to export the ``MyRobotDriver`` class as a plugin using the ``PLUGINLIB_EXPORT_CLASS`` macro.
        This allows the plugin to be loaded by the Webots ROS2 driver at runtime.

        .. literalinclude:: Code/MyRobotDriver.cpp
            :language: cpp
            :lines: 51-53

        .. note::

            While the plugin is implemented in C++, the C API must be used to interact with the Webots controller library.

.. _4 Create the my_robot.urdf file:

4 Create the ``my_robot.urdf`` file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You now have to create a URDF file to declare the ``MyRobotDriver`` plugin.
This will allow the ``webots_ros2_driver`` ROS node to launch the plugin and connect it to the target robot.

In the ``my_package/resource`` folder create a text file named ``my_robot.urdf`` with this content:

.. tabs::

    .. group-tab:: Python

        .. literalinclude:: Code/my_robot_python.urdf
            :language: xml

        The ``type`` attribute specifies the path to the class given by the hierarchical structure of files.
        ``webots_ros2_driver`` is responsible for loading the class based on the specified package and modules.

    .. group-tab:: C++

        .. literalinclude:: Code/my_robot_cpp.urdf
            :language: xml

        The ``type`` attribute specifies the namespace and class name to load.
        ``pluginlib`` is responsible for loading the class based on the specified information.

.. note::

    This simple URDF file doesn't contain any link or joint information about the robot as it is not needed in this tutorial.
    However, URDF files usually contain much more information as explained in the :doc:`../../../Intermediate/URDF/URDF-Main` tutorial.

.. note::

    Here the plugin does not take any input parameter, but this can be achieved with a tag containing the parameter name.

    .. tabs::

        .. group-tab:: Python

            .. code-block:: xml

                <plugin type=""my_package.my_robot_driver.MyRobotDriver"">
                    <parameterName>someValue</parameterName>
                </plugin>

        .. group-tab:: C++

            .. code-block:: xml

                <plugin type=""my_robot_driver::MyRobotDriver"">
                    <parameterName>someValue</parameterName>
                </plugin>


    This is namely used to pass parameters to existing Webots device plugins (see :doc:`./Setting-Up-Simulation-Webots-Advanced`).

5 Create the launch file
^^^^^^^^^^^^^^^^^^^^^^^^

Let's create the launch file to easily launch the simulation and the ROS controller with a single command.
In the ``my_package/launch`` folder create a new text file named ``robot_launch.py`` with this code:

.. literalinclude:: Code/robot_launch.py
    :language: python

The ``WebotsLauncher`` object is a custom action that allows you to start a Webots simulation instance.
You have to specify in the constructor which world file the simulator will open.

.. literalinclude:: Code/robot_launch.py
    :language: python
    :dedent: 4
    :lines: 13-15

Then, the ROS node interacting with the simulated robot is created.
This node, named ``WebotsController``, is located in the ``webots_ros2_driver`` package.

.. tabs::

    .. group-tab:: Linux

        The node will be able to communicate with the simulated robot by using a custom protocol based on IPC and shared memory.

    .. group-tab:: Windows

        The node (in WSL) will be able to communicate with the simulated robot (in Webots on native Windows) through a TCP connection.

    .. group-tab:: macOS

        The node (in the docker container) will be able to communicate with the simulated robot (in Webots on native macOS) through a TCP connection.


In your case, you need to run a single instance of this node, because you have a single robot in the simulation.
But if you had more robots in the simulation, you would have to run one instance of this node per robot.
The ``robot_name`` parameter is used to define the name of the robot the driver should connect to.
The ``robot_description`` parameter holds the path to the URDF file which refers to the ``MyRobotDriver`` plugin.
You can see the ``WebotsController`` node as the interface that connects your controller plugin to the target robot.

.. literalinclude:: Code/robot_launch.py
    :language: python
    :dedent: 4
    :lines: 17-22

After that, the two nodes are set to be launched in the ``LaunchDescription`` constructor:

.. literalinclude:: Code/robot_launch.py
    :language: python
    :dedent: 4
    :lines: 24-26

Finally, an optional part is added in order to shutdown all the nodes once Webots terminates (e.g., when it gets closed from the graphical user interface).

.. literalinclude:: Code/robot_launch.py
    :language: python
    :dedent: 8
    :lines: 27-32

.. note::

    More details on ``WebotsController`` and ``WebotsLauncher`` arguments can be found `on the nodes reference page <https://github.com/cyberbotics/webots_ros2/wiki/References-Nodes>`_.

6 Edit additional files
^^^^^^^^^^^^^^^^^^^^^^^

.. tabs::

    .. group-tab:: Python

        Before you can start the launch file, you have to modify the ``setup.py`` file to include the extra files you added.
        Open ``my_package/setup.py`` and replace its contents with:

        .. literalinclude:: Code/setup.py
            :language: python

        This sets-up the package and adds in the ``data_files`` variable the newly added files: ``my_world.wbt``, ``my_robot.urdf`` and ``robot_launch.py``.

    .. group-tab:: C++

        Before you can start the launch file, you have to modify ``CMakeLists.txt`` and ``my_robot_driver.xml`` files:

        * ``CMakeLists.txt`` defines the compilation rules of your plugin.
        * ``my_robot_driver.xml`` is necessary for the pluginlib to find your Webots ROS 2 plugin.

        Open ``my_package/my_robot_driver.xml`` and replace its contents with:

        .. literalinclude:: Code/my_robot_driver.xml
            :language: xml

        Open ``my_package/CMakeLists.txt`` and replace its contents with:

        .. literalinclude:: Code/CMakeLists.txt
            :language: cmake

        The CMakeLists.txt exports the plugin configuration file with the ``pluginlib_export_plugin_description_file()``, defines a shared library of the C++ plugin ``src/MyRobotDriver.cpp``, and sets the include and library dependencies using ``ament_target_dependencies()``.

        The file then installs the library, the directories ``launch``, ``resource``, and ``worlds`` to the ``share/my_package`` directory.
        Finally, it exports the include directories and libraries using ``ament_export_include_directories()`` and ``ament_export_libraries()``, respectively, and declares the package using ``ament_package()``.


7 Test the code
^^^^^^^^^^^^^^^

.. tabs::

    .. group-tab:: Linux

        From a terminal in your ROS 2 workspace run:

        .. code-block:: console

            colcon build
            source install/local_setup.bash
            ros2 launch my_package robot_launch.py

        This will launch the simulation.
        Webots will be automatically installed on the first run in case it was not already installed.

    .. group-tab:: Windows

        From a terminal in your WSL ROS 2 workspace run:

        .. code-block:: console

            colcon build
            export WEBOTS_HOME=/mnt/c/Program\ Files/Webots
            source install/local_setup.bash
            ros2 launch my_package robot_launch.py

        Be sure to use the ``/mnt`` prefix in front of your path to the Webots installation folder to access the Windows file system from WSL.

        This will launch the simulation.
        Webots will be automatically installed on the first run in case it was not already installed.

    .. group-tab:: macOS

        On macOS, a local server must be started on the host to start Webots from the VM.
        The local server can be downloaded `on the webots-server repository <https://github.com/cyberbotics/webots-server/blob/main/local_simulation_server.py>`_.

        In a terminal of the host machine (not in the VM), specify the Webots installation folder (e.g. ``/Applications/Webots.app``) and start the server using the following commands:

        .. code-block:: console

            export WEBOTS_HOME=/Applications/Webots.app
            python3 local_simulation_server.py

        From a terminal in the Linux VM in your ROS 2 workspace, build and launch your custom package with:

        .. code-block:: console

            colcon build
            source install/local_setup.bash
            ros2 launch my_package robot_launch.py


.. note::

    If you want to install Webots manually, you can download it `here <https://github.com/cyberbotics/webots/releases/latest>`_.


Then, open a second terminal and send a command with:

.. code-block:: console

            ros2 topic pub /cmd_vel geometry_msgs/Twist  ""linear: { x: 0.1 }""

The robot is now moving forward.

.. image:: Image/Robot_moving_forward.png

At this point, the robot is able to blindly follow your motor commands.
But it will eventually bump into the wall as you order it to move forwards.

.. image:: Image/Robot_colliding_wall.png

Close the Webots window, this should also shutdown your ROS nodes started from the launcher.
Close also the topic command with ``Ctrl+C`` in the second terminal.

Summary
-------

In this tutorial, you set-up a realistic robot simulation with Webots and implemented a custom plugin to control the motors of the robot.

Next steps
----------

To improve the simulation, the robot's sensors can be used to detect obstacles and avoid them.
The second part of the tutorial shows how to implement such behaviour:

* :doc:`./Setting-Up-Simulation-Webots-Advanced`.
",What is the goal of setting up a robot simulation in this tutorial?
"Setting up a robot simulation (Advanced)
========================================

**Goal:** Extend a robot simulation with an obstacle avoider node.

**Tutorial level:** Advanced

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In this tutorial you will extend the package created in the first part of the tutorial: :doc:`./Setting-Up-Simulation-Webots-Basic`.
The aim is to implement a ROS 2 node that avoids obstacles using the robot's distance sensors.
This tutorial focuses on using robot devices with the ``webots_ros2_driver`` interface.

Prerequisites
-------------

This is a continuation of the first part of the tutorial: :doc:`./Setting-Up-Simulation-Webots-Basic`.
It is mandatory to start with the first part to set up the custom packages and necessary files.

This tutorial is compatible with version 2023.1.0 of ``webots_ros2`` and Webots R2023b, as well as upcoming versions.

Tasks
-----

1 Updating ``my_robot.urdf``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As mentioned in :doc:`./Setting-Up-Simulation-Webots-Basic`, ``webots_ros2_driver`` contains plugins to interface most of Webots devices with ROS 2 directly.
These plugins can be loaded using the ``<device>`` tag in the URDF file of the robot.
The ``reference`` attribute should match the Webots device ``name`` parameter.
The list of all existing interfaces and the corresponding parameters can be found `on the devices reference page <https://github.com/cyberbotics/webots_ros2/wiki/References-Devices>`_.
For available devices that are not configured in the URDF file, the interface will be automatically created and default values will be used for ROS parameters (e.g. ``update rate``, ``topic name``, and ``frame name``).

In ``my_robot.urdf`` replace the whole contents with:

.. tabs::

    .. group-tab:: Python

        .. literalinclude:: Code/my_robot_with_sensors_python.urdf
            :language: xml

    .. group-tab:: C++

        .. literalinclude:: Code/my_robot_with_sensors_cpp.urdf
            :language: xml


In addition to your custom plugin, the ``webots_ros2_driver`` will parse the ``<device>`` tags referring to the **DistanceSensor** nodes and use the standard parameters in the ``<ros>`` tags to enable the sensors and name their topics.

2 Creating a ROS node to avoid obstacles
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. tabs::

    .. group-tab:: Python

        The robot will use a standard ROS node to detect the wall and send motor commands to avoid it.
        In the ``my_package/my_package/`` folder, create a file named ``obstacle_avoider.py`` with this code:

        .. literalinclude:: Code/obstacle_avoider.py
            :language: python

        This node will create a publisher for the command and subscribe to the sensors topics here:

        .. literalinclude:: Code/obstacle_avoider.py
            :language: python
            :dedent: 8
            :lines: 14-17

        When a measurement is received from the left sensor it will be copied to a member field:

        .. literalinclude:: Code/obstacle_avoider.py
            :language: python
            :dedent: 4
            :lines: 19-20

        Finally, a message will be sent to the ``/cmd_vel`` topic when a measurement from the right sensor is received.
        The ``command_message`` will register at least a forward speed in ``linear.x`` in order to make the robot move when no obstacle is detected.
        If any of the two sensors detect an obstacle, ``command_message`` will also register a rotational speed in ``angular.z`` in order to make the robot turn right.

        .. literalinclude:: Code/obstacle_avoider.py
            :language: python
            :dedent: 4
            :lines: 22-32

    .. group-tab:: C++

        The robot will use a standard ROS node to detect the wall and send motor commands to avoid it.
        In the ``my_package/include/my_package`` folder, create a header file named ``ObstacleAvoider.hpp`` with this code:

        .. literalinclude:: Code/ObstacleAvoider.hpp
            :language: cpp

        In the ``my_package/src`` folder, create a source file named ``ObstacleAvoider.cpp`` with this code:

        .. literalinclude:: Code/ObstacleAvoider.cpp
            :language: cpp

        This node will create a publisher for the command and subscribe to the sensors topics here:

        .. literalinclude:: Code/ObstacleAvoider.cpp
            :language: cpp
            :lines: 6-20

        When a measurement is received from the left sensor it will be copied to a member field:

        .. literalinclude:: Code/ObstacleAvoider.cpp
            :language: cpp
            :lines: 23-26

        Finally, a message will be sent to the ``/cmd_vel`` topic when a measurement from the right sensor is received.
        The ``command_message`` will register at least a forward speed in ``linear.x`` in order to make the robot move when no obstacle is detected.
        If any of the two sensors detect an obstacle, ``command_message`` will also register a rotational speed in ``angular.z`` in order to make the robot turn right.

        .. literalinclude:: Code/ObstacleAvoider.cpp
            :language: cpp
            :lines: 28-42


3 Updating additional files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You have to modify these two other files to launch your new node.

.. tabs::

    .. group-tab:: Python

        Edit ``setup.py`` and replace ``'console_scripts'`` with:

        .. literalinclude:: Code/setup_sensor.py
            :language: python
            :dedent: 8
            :lines: 24-27

        This will add an entry point for the ``obstacle_avoider`` node.

    .. group-tab:: C++

        Edit ``CMakeLists.txt`` and add the compilation and installation of the ``obstacle_avoider``:

        .. literalinclude:: Code/CMakeLists_sensor.txt
            :language: cmake


Go to the file ``robot_launch.py`` and replace it with:

.. literalinclude:: Code/robot_launch_sensor.py
    :language: python

This will create an ``obstacle_avoider`` node that will be included in the ``LaunchDescription``.

4 Test the obstacle avoidance code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Launch the simulation from a terminal in your ROS 2 workspace:

.. tabs::

    .. group-tab:: Linux

        From a terminal in your ROS 2 workspace run:

        .. code-block:: console

            colcon build
            source install/local_setup.bash
            ros2 launch my_package robot_launch.py

    .. group-tab:: Windows

        From a terminal in your WSL ROS 2 workspace run:

        .. code-block:: console

            colcon build
            export WEBOTS_HOME=/mnt/c/Program\ Files/Webots
            source install/local_setup.bash
            ros2 launch my_package robot_launch.py

        Be sure to use the ``/mnt`` prefix in front of your path to the Webots installation folder to access the Windows file system from WSL.

    .. group-tab:: macOS

        In a terminal of the host machine (not in the VM), if not done already, specify the Webots installation folder (e.g. ``/Applications/Webots.app``) and start the server using the following commands:

        .. code-block:: console

            export WEBOTS_HOME=/Applications/Webots.app
            python3 local_simulation_server.py

        Note that the server keeps running once the ROS 2 nodes are ended.
        You don't need to restart it every time you want to launch a new simulation.
        From a terminal in the Linux VM in your ROS 2 workspace, build and launch your custom package with:

        .. code-block:: console

            cd ~/ros2_ws
            colcon build
            source install/local_setup.bash
            ros2 launch my_package robot_launch.py

Your robot should go forward and before hitting the wall it should turn clockwise.
You can press ``Ctrl+F10`` in Webots or go to the ``View`` menu, ``Optional Rendering`` and ``Show DistanceSensor Rays`` to display the range of the distance sensors of the robot.

.. image:: Image/Robot_turning_clockwise.png

Summary
-------

In this tutorial, you extended the basic simulation with a obstacle avoider ROS 2 node that publishes velocity commands based on the distance sensor values of the robot.

Next steps
----------

You might want to improve the plugin or create new nodes to change the behavior of the robot.
You can also implement a reset handler to automatically restart your ROS nodes when the simulation is reset from the Webots interface:

* :doc:`./Simulation-Reset-Handler`.
",What is the purpose of the ROS node created in this tutorial on robot simulation?
"Setting up a Reset Handler
==========================

**Goal:** Extend a robot simulation with a reset handler to restart nodes when the reset button of Webots is pressed.

**Tutorial level:** Advanced

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In this tutorial, you will learn how to implement a reset handler in a robot simulation using Webots.
The Webots reset button reverts the world to the initial state and restarts controllers.
It is convenient as it quickly resets the simulation, but in the context of ROS 2, robot controllers are not started again making the simulation stop.
The reset handler allows you to restart specific nodes or perform additional actions when the reset button in Webots is pressed.
This can be useful for scenarios where you need to reset the state of your simulation or restart specific components without completely restarting the complete ROS system.

Prerequisites
-------------

Before proceeding with this tutorial, make sure you have completed the following:

- Understanding of ROS 2 nodes and topics covered in the beginner :doc:`../../../../Tutorials`.
- Knowledge of Webots and ROS 2 and its interface package.
- Familiarity with :doc:`./Setting-Up-Simulation-Webots-Basic`.


Reset Handler for Simple Cases (Controllers Only)
-------------------------------------------------

In the launch file of your package, add the ``respawn`` parameter.

.. code-block:: python

  def generate_launch_description():
      robot_driver = WebotsController(
          robot_name='my_robot',
          parameters=[
              {'robot_description': robot_description_path}
          ],

          # Every time one resets the simulation the controller is automatically respawned
          respawn=True
      )

      # Starts Webots
      webots = WebotsLauncher(world=PathJoinSubstitution([package_dir, 'worlds', world]))

      return LaunchDescription([
          webots,
          robot_driver
      ])

On reset, Webots kills all driver nodes.
Therefore, to start them again after reset, you should set the ``respawn`` property of the driver node to ``True``.
It will ensure driver nodes are up and running after the reset.

Reset Handler for Multiple Nodes (No Shutdown Required)
-------------------------------------------------------

If you have some other nodes that have to be started along with the driver node (e.g. ``ros2_control`` nodes), then you can use the ``OnProcessExit`` event handler:

.. code-block:: python

  def get_ros2_control_spawners(*args):
      # Declare here all nodes that must be restarted at simulation reset
      ros_control_node = Node(
          package='controller_manager',
          executable='spawner',
          arguments=['diffdrive_controller']
      )
      return [
          ros_control_node
      ]

  def generate_launch_description():
      robot_driver = WebotsController(
          robot_name='my_robot',
          parameters=[
              {'robot_description': robot_description_path}
          ],

          # Every time one resets the simulation the controller is automatically respawned
          respawn=True
      )

      # Starts Webots
      webots = WebotsLauncher(world=PathJoinSubstitution([package_dir, 'worlds', world]))

      # Declare the reset handler that respawns nodes when robot_driver exits
      reset_handler = launch.actions.RegisterEventHandler(
          event_handler=launch.event_handlers.OnProcessExit(
              target_action=robot_driver,
              on_exit=get_ros2_control_spawners,
          )
      )

      return LaunchDescription([
          webots,
          robot_driver,
          reset_handler
      ] + get_ros2_control_spawners())

It is not possible to use the ``respawn`` property on the ``ros2_control`` node, as the spawner exits during launch time and not when the simulation is reset.
Instead we should declare a list of nodes in a function (e.g. ``get_ros2_control_spawners``).
The nodes of this list are started along other nodes when executing the launch file.
With the ``reset_handler``, the function is also declared as action to start when the ``robot_driver`` node exits, which corresponds to the moment when the simulation is reset in the Webots interface.
The ``robot_driver`` node still has the ``respawn`` property set to ``True``, so that it gets restarted along with ``ros2_control`` nodes.

Reset Handler Requiring Node Shutdown
-------------------------------------

With the current ROS 2 launch API, there is no way to make the reset work in launch files where nodes need to be shutdown before the restart (e.g. ``Nav2`` or ``RViz``).
The reason is that currently, ROS 2 doesn't allow to shutdown specific nodes from a launch file.
There is a solution, but it requires to manually restart nodes after pushing the reset button.

Webots needs to be started in a specific launch file without other nodes.

.. code-block:: python

  def generate_launch_description():
      # Starts Webots
      webots = WebotsLauncher(world=PathJoinSubstitution([package_dir, 'worlds', world]))

      return LaunchDescription([
          webots
      ])


A second launch file must be started from another process.
This launch file contains all other nodes, including robot controllers/plugins, Navigation2 nodes, RViz, state publishers, etc.

.. code-block:: python

  def generate_launch_description():
      robot_driver = WebotsController(
          robot_name='my_robot',
          parameters=[
              {'robot_description': robot_description_path}
          ]
      )

      ros_control_node = Node(
          package='controller_manager',
          executable='spawner',
          arguments=['diffdrive_controller']
      )

      nav2_node = IncludeLaunchDescription(
          PythonLaunchDescriptionSource(os.path.join(
              get_package_share_directory('nav2_bringup'), 'launch', 'bringup_launch.py')),
          launch_arguments=[
              ('map', nav2_map),
              ('params_file', nav2_params),
          ],
      )

      rviz = Node(
          package='rviz2',
          executable='rviz2',
          output='screen'
      )

      # Declare the handler that shuts all nodes down when robot_driver exits
      shutdown_handler = launch.actions.RegisterEventHandler(
          event_handler=launch.event_handlers.OnProcessExit(
              target_action=robot_driver,
              on_exit=[launch.actions.EmitEvent(event=launch.events.Shutdown())],
          )
      )

      return LaunchDescription([
          robot_driver,
          ros_control_node,
          nav2_node,
          rviz,
          shutdown_handler
      ])

The second launch file contains a handler that triggers a shutdown event when the driver node exits (which is the case when the simulation is reset).
This second launch file must be manually restarted from the command line after pressing the reset button.

Summary
-------

In this tutorial, you learned how to implement a reset handler in a robot simulation using Webots.
The reset handler allows you to restart specific nodes or perform additional actions when the reset button in Webots is pressed.
You explored different approaches based on the complexity of your simulation and the requirements of your nodes.
","What is the purpose of implementing a reset handler in a robot simulation using Webots, according to the text?"
"Installation (Windows)
======================================

**Goal:** Install the ``webots_ros2`` package and run simulation examples on Windows.

**Tutorial level:** Advanced

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

The ``webots_ros2`` package provides an interface between ROS 2 and Webots.
It includes several sub-packages, including ``webots_ros2_driver``, which allows ROS nodes to communicate with Webots.
Other sub-packages are mainly examples that show multiple possible implementations using the interface.
In this tutorial, you are going to install the package and learn how to run one of these examples.

Prerequisites
-------------

It is recommended to understand basic ROS principles covered in the beginner :doc:`../../../../Tutorials`.
In particular, :doc:`../../../Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace` and :doc:`../../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package` are useful prerequisites.

Webots is a prerequisite to use the ``webots_ros2`` package.
You can follow the `installation procedure <https://cyberbotics.com/doc/guide/installation-procedure>`_ or `build it from sources <https://github.com/cyberbotics/webots/wiki/Windows-installation/>`_.

Alternatively, you can also let ``webots_ros2`` download Webots automatically.
This option appears when you launch an example of the package and no Webots installation is found.

Multiple Installations of Webots
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you have more than one installation of Webots, ROS 2 will look for Webots at the following locations (in this order):

1. If the ``ROS2_WEBOTS_HOME`` environment variable is set, ROS 2 will use the Webots in this folder, regardless of its version.
2. If the ``WEBOTS_HOME`` environment variable is set, ROS 2 will use the Webots in this folder, regardless of its version.
3. If none of the previous points is set/installed ROS 2 will look for Webots in the default installation paths for a compatible version: ``C:\Program Files\Webots``.
4. If Webots couldn't be found, ``webots_ros2`` will show a window and offer automatic Webots installation of the last compatible version.

Tasks
-----

1 Install WSL2
^^^^^^^^^^^^^^^

On Windows, WSL (Windows Subsystem for Linux) improves the user experience with ROS 2 compared to native Windows installation, as it runs on a Linux platform.
Install WSL with an Ubuntu version which is compatible with your ROS distribution and upgrade to WSL2 following the `official Microsoft tutorial <https://learn.microsoft.com/en-us/windows/wsl/install>`_.

2 Install ROS 2 in WSL
^^^^^^^^^^^^^^^^^^^^^^

Install ROS 2 inside Ubuntu WSL, following :doc:`../../../../Installation/Ubuntu-Install-Debs`.

3 Install ``webots_ros2``
^^^^^^^^^^^^^^^^^^^^^^^^^
You can then either install ``webots_ros2`` from the official released package, or install it from the latest up-to-date sources from `Github <https://github.com/cyberbotics/webots_ros2>`_.

The following commands must be run inside the WSL environment.

.. tabs::

    .. group-tab:: Install ``webots_ros2`` distributed package

        Run the following command in a terminal.

        .. code-block:: console

            sudo apt-get install ros-{DISTRO}-webots-ros2

    .. group-tab:: Install ``webots_ros2`` from sources

        Create a ROS 2 workspace with its ``src`` directory.

        .. code-block:: console

            mkdir -p ~/ros2_ws/src

        Source the ROS 2 environment.

        .. code-block:: console

            source /opt/ros/{DISTRO}/setup.bash

        Retrieve the sources from Github.

        .. code-block:: console

            cd ~/ros2_ws
            git clone --recurse-submodules https://github.com/cyberbotics/webots_ros2.git src/webots_ros2

        Install the package dependencies.

        .. code-block:: console

            sudo apt install python3-pip python3-rosdep python3-colcon-common-extensions
            sudo rosdep init && rosdep update
            rosdep install --from-paths src --ignore-src --rosdistro {DISTRO}

        Build the package using ``colcon``.

        .. code-block:: console

            colcon build

        Source this workspace.

        .. code-block:: console

            source install/local_setup.bash


4 Launch the ``webots_ros2_universal_robot`` example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

WSL doesn't support hardware acceleration (yet).
Therefore, Webots should be started on Windows, while the ROS part is running inside WSL.
To do so, the following commands must be run inside the WSL environment.

First source the ROS 2 environment, if not done already.

.. code-block:: console

        source /opt/ros/{DISTRO}/setup.bash

Setting the ``WEBOTS_HOME`` environment variable allows you to start a specific Webots installation (e.g. ``C:\Program Files\Webots``).
Use the mount point ""/mnt"" to refer to a path on native Windows.

.. code-block:: console

        export WEBOTS_HOME=/mnt/c/Program\ Files/Webots

If installed from sources, source your ROS 2 workspace, if not done already.

.. code-block:: console

        cd ~/ros2_ws
        source install/local_setup.bash

Use the ROS 2 launch command to start demo packages (e.g. ``webots_ros2_universal_robot``).

.. code-block:: console

        ros2 launch webots_ros2_universal_robot multirobot_launch.py


5 RViz troubleshooting
^^^^^^^^^^^^^^^^^^^^^^

With recent versions of WSL2, RViz should work out of the box.

You can check if it works correctly by running any example that uses RViz, for example:

.. code-block:: console

        sudo apt install ros-{DISTRO}-slam-toolbox
        ros2 launch webots_ros2_tiago robot_launch.py rviz:=true slam:=true

The Tiago robot can be controlled using:

.. code-block:: console

        ros2 run teleop_twist_keyboard teleop_twist_keyboard

With older WSL versions, RViz2 may not work directly, as no display is available. To use RViz, you can either upgrade WSL or enable X11 forwarding.

.. tabs::
    .. group-tab:: Upgrade WSL

        In a Windows shell:

        .. code-block:: console

            wsl --update

    .. group-tab:: Enable X11 forwarding

        For older versions of WSL, the following steps can be followed:

        1. Install `VcXsrv <https://sourceforge.net/projects/vcxsrv/>`_.
        2. Launch VcXsrv. You can leave most of the parameters default, except the ``Extra settings`` page, where you must set ``Clipboard``, ``Primary Selection`` and ``Disable access control`` and unset ``Native opengl``.
        3. You can save the configuration for future launches.
        4. Click on ``Finish``, you will see that the X11 server is running in the icon tray.
        5. In your WSL environment, export the ``DISPLAY`` variable.

            .. code-block:: console

                export DISPLAY=$(ip route list default | awk '{print }'):0

            You can add this to your ``.bashrc``, so that it is set for every future WSL environment.

            .. code-block:: console

                echo ""export DISPLAY=$(ip route list default | awk '{print }'):0"" >> ~/.bashrc
","What are the multiple installations of Webots that ROS 2 will look for in a Windows environment, and in what order will it search for them?"
"The Ros2Supervisor Node
=======================

**Goal:** Extend the interface with a default Supervisor robot, named ``Ros2Supervisor``.

**Tutorial level:** Advanced

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In this tutorial, you will learn how to enable the ``Ros2Supervisor`` node which enhances the interface by creating additional services and topics to interact with the simulation.
You can, for example, record animations or spawn Webots nodes directly from the ROS 2 interface while the simulation is running.
These instructions list in details the current implemented features and how to use them.

Prerequisites
-------------

Before proceeding with this tutorial, make sure you have completed the following:

- Understanding of ROS 2 nodes and topics covered in the beginner :doc:`../../../../Tutorials`.
- Knowledge of Webots and ROS 2 and its interface package.
- Familiarity with :doc:`./Setting-Up-Simulation-Webots-Basic`.

The ``Ros2Supervisor``
----------------------

The ``Ros2Supervisor`` is made of two main parts:

* A Webots Robot node added to the simulation world. Its ``supervisor`` field is set to TRUE.
* A ROS 2 node that connects to the Webots Robot as an extern controller (in a similar way to your own robot plugin).

The ROS 2 node acts as a controller that calls Supervisor API functions to control or interact with the simulation world.
User interactions with the ROS 2 node are mainly performed through services and topics.

These nodes can be automatically created at the Webots launch using the ``ros2_supervisor`` parameter in the ``WebotsLauncher``.

.. code-block:: python

    webots = WebotsLauncher(
        world=PathJoinSubstitution([package_dir, 'worlds', world]),
        mode=mode,
        ros2_supervisor=True
    )

The ``webots._supervisor`` object must also be included in the ``LaunchDescription`` returned by the launch file.

.. code-block:: python

    return LaunchDescription([
        webots,
        webots._supervisor,

        # This action will kill all nodes once the Webots simulation has exited
        launch.actions.RegisterEventHandler(
            event_handler=launch.event_handlers.OnProcessExit(
                target_action=webots,
                on_exit=[
                    launch.actions.EmitEvent(event=launch.events.Shutdown())
                ],
            )
        )
    ])

More information about launch files for ``webots_ros2`` projects can be found in :doc:`./Setting-Up-Simulation-Webots-Basic`.

Clock topic
-----------

The ``Ros2Supervisor`` node is responsible to get the time of the Webots simulation and publish it to the ``/clock`` topic.
This means that it is mandatory to spawn the ``Ros2Supervisor`` if some other nodes have their ``use_sim_time`` parameter set to ``true``.
More information about the ``/clock`` topic can be found in the `ROS wiki <http://wiki.ros.org/Clock>`_.

Import a Webots node
--------------------

The ``Ros2Supervisor`` node also allows you to spawn Webots nodes from strings through a service.

The service is named ``/Ros2Supervisor/spawn_node_from_string`` and is of type ``webots_ros2_msgs/srv/SpawnNodeFromString``.
The ``SpawnNodeFromString`` type expects a ``data`` string as input and returns a ``success`` boolean.

From the given string, the Supervisor node is getting the name of the imported node and adding it to an intern list for potential later removal (see :ref:`Remove a Webots imported node`).

The node is imported using the ``importMFNodeFromString(nodeString)`` `API function <https://cyberbotics.com/doc/reference/supervisor?tab-language=python#wb_supervisor_field_import_mf_node_from_string>`_.

Here is an example to import a simple Robot named ``imported_robot``:

.. code-block:: bash

    ros2 service call /Ros2Supervisor/spawn_node_from_string webots_ros2_msgs/srv/SpawnNodeFromString ""data: Robot { name \""imported_robot\"" }""

.. note::
    If you try to import some PROTOs in the node string, their respective URLs must be declared in the .wbt world file as EXTERNPROTO or as IMPORTABLE EXTERNPROTO.

.. _Remove a Webots imported node:

Remove a Webots imported node
-----------------------------

Once a node has been imported with the ``/Ros2Supervisor/spawn_node_from_string`` service, it can also be removed.

This can be achieved by sending the name of the node to the topic named ``/Ros2Supervisor/remove_node`` of type ``std_msgs/msg/String``.

If the node is indeed in the imported list, it is removed with the ``remove()`` `API method <https://cyberbotics.com/doc/reference/supervisor?tab-language=python#wb_supervisor_node_remove>`_.

Here is an example on how to remove the ``imported_robot`` Robot:

.. code-block:: bash

    ros2 topic pub --once /Ros2Supervisor/remove_node std_msgs/msg/String ""{data: imported_robot}""

Record animations
-----------------

The ``Ros2Supervisor`` node also creates two additional services to record HTML5 animations.

The ``/Ros2Supervisor/animation_start_recording`` service is of type ``webots_ros2_msgs/srv/SetString`` and allows to start the animation.
The ``SetString`` type expects a ``value`` string as input and returns a ``success`` boolean.
The input ``value`` represents the absolute path to the directory where the animations files should be saved.

Here is an example on how to start an animation:

.. code-block:: bash

    ros2 service call /Ros2Supervisor/animation_start_recording webots_ros2_msgs/srv/SetString ""{value: ""<ABSOLUTE_PATH>/index.html""}""


The ``/Ros2Supervisor/animation_stop_recording`` service is of type ``webots_ros2_msgs/srv/GetBool`` and allows to stop the animation.

.. code-block:: bash

    ros2 service call /Ros2Supervisor/animation_stop_recording webots_ros2_msgs/srv/GetBool ""{ask: True}""


Summary
-------

In this tutorial, you learned how to enable the ``Ros2Supervisor`` and how to extend the interface with the Webots simulation.
The node creates multiple services and topics to interact with and modify the simulation.
","What are the two main parts that make up the ""Ros2Supervisor"" node in the tutorial?"
"Installation (Ubuntu)
======================================

**Goal:** Install the ``webots_ros2`` package and run simulation examples on Ubuntu.

**Tutorial level:** Advanced

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

The ``webots_ros2`` package provides an interface between ROS 2 and Webots.
It includes several sub-packages, including ``webots_ros2_driver``, which allows you to start Webots and communicate with it.
This interface is used in most of the following tutorials, so it is required to install it beforehand.
Other sub-packages are mainly examples that show multiple possible implementations using the interface.
In this tutorial, you are going to install the package and learn how to run one of these examples.

Prerequisites
-------------

It is recommended to understand basic ROS principles covered in the beginner :doc:`../../../../Tutorials`.
In particular, :doc:`../../../Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace` and :doc:`../../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package` are useful prerequisites.

The Webots software should be installed in order to use the ``webots_ros2`` interface.
You can follow the `installation procedure <https://cyberbotics.com/doc/guide/installation-procedure>`_ or `build it from sources <https://github.com/cyberbotics/webots/wiki/Linux-installation/>`_.

Alternatively, you can also let ``webots_ros2`` download and install Webots automatically.
This option appears when you launch an example of the package and no Webots installation is found.

Multiple Installations of Webots
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you have installed different versions of Webots on your computer, ``webots_ros2`` will look for Webots at the following locations (in this order):

1. If the ``ROS2_WEBOTS_HOME`` environment variable is set, ROS 2 will use the Webots in this folder, regardless of its version.
2. If the ``WEBOTS_HOME`` environment variable is set, ROS 2 will use the Webots in this folder, regardless of its version.
3. If none of these variables is set, ``webots_ros2`` will look for Webots in the default installation paths for a compatible version: ``/usr/local/webots`` and ``/snap/webots/current/usr/share/webots``.
4. If Webots couldn't be found, ``webots_ros2`` will show a window offering the automatic installation of the latest compatible version of Webots.

Tasks
-----

1 Install ``webots_ros2``
^^^^^^^^^^^^^^^^^^^^^^^^^
You can either install the official released package, or install it from the latest up-to-date sources from `Github <https://github.com/cyberbotics/webots_ros2>`_.

.. tabs::

    .. group-tab:: Install ``webots_ros2`` distributed package

        Run the following command in a terminal.

        .. code-block:: console

            sudo apt-get install ros-{DISTRO}-webots-ros2

    .. group-tab:: Install ``webots_ros2`` from sources

        Create a ROS 2 workspace with its ``src`` directory.

        .. code-block:: console

            mkdir -p ~/ros2_ws/src

        Source the ROS 2 environment.

        .. code-block:: console

            source /opt/ros/{DISTRO}/setup.bash

        Retrieve the sources from Github.

        .. code-block:: console

            cd ~/ros2_ws
            git clone --recurse-submodules https://github.com/cyberbotics/webots_ros2.git src/webots_ros2

        Install the package dependencies.

        .. code-block:: console

            sudo apt install python3-pip python3-rosdep python3-colcon-common-extensions
            sudo rosdep init && rosdep update
            rosdep install --from-paths src --ignore-src --rosdistro {DISTRO}

        Build the package using ``colcon``.

        .. code-block:: console

            colcon build

        Source this workspace.

        .. code-block:: console

            source install/local_setup.bash

2 Launch the ``webots_ros2_universal_robot`` example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following instructions explain how to start a provided example.

First source the ROS 2 environment, if not done already.

.. code-block:: console

        source /opt/ros/{DISTRO}/setup.bash

Setting the ``WEBOTS_HOME`` environment variable allows you to start a specific Webots installation.

.. code-block:: console

        export WEBOTS_HOME=/usr/local/webots

If installed from sources, source your ROS 2 workspace, if not done already.

.. code-block:: console

        cd ~/ros2_ws
        source install/local_setup.bash

Use the ROS 2 launch command to start demo packages (e.g. ``webots_ros2_universal_robot``).

.. code-block:: console

        ros2 launch webots_ros2_universal_robot multirobot_launch.py
",What are the prerequisites for installing the ``webots_ros2`` package on Ubuntu?
"Installation (macOS)
====================

**Goal:** Install the ``webots_ros2`` package and run simulation examples on macOS.

**Tutorial level:** Advanced

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

The ``webots_ros2`` package provides an interface between ROS 2 and Webots.
It includes several sub-packages, including ``webots_ros2_driver``, which allows you to start Webots and communicate with it.
Other sub-packages are mainly examples that show multiple possible implementations using the interface.
In this tutorial, you are going to install the package and learn how to run one of these examples.

Prerequisites
-------------

It is recommended to understand basic ROS principles covered in the beginner :doc:`../../../../Tutorials`.
In particular, :doc:`../../../Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace` and :doc:`../../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package` are useful prerequisites.

It is necessary to install Webots natively on the mac in order to use the ``webots_ros2`` package in the virtual machine as explained below.
You can follow the `installation procedure <https://cyberbotics.com/doc/guide/installation-procedure>`_ or `build it from sources <https://github.com/cyberbotics/webots/wiki/macOS-installation/>`_.

Tasks
-----

On macOS, a solution based on UTM virtual machines provides an improved user experience with ROS 2 compared to native macOS installation, as it runs ROS in a Linux environment.
However, Webots should be installed natively on macOS and it will be able to communicate with the ROS nodes running in the Virtual Machine (VM).
This solution allows for native 3D hardware acceleration for Webots.
The VM runs all the ROS part (including RViz) and connects to the host machine through TCP to start Webots.
A shared folder allows the script to transfer the world and other resource files from the VM to macOS where Webots is running.

The following steps explain how to create the VM image with the installation of the ``webots_ros2`` released package.
It is also possible to install it from sources.

1 Create the VM image
^^^^^^^^^^^^^^^^^^^^^^

Install UTM on your macOS machine.
The link can be found on the `official UTM website <https://mac.getutm.app/>`_.

Download the .iso image of `Ubuntu 22.04 <https://cdimage.ubuntu.com/jammy/daily-live/current/>`_ for Humble and Rolling or `Ubuntu 20.04 <https://cdimage.ubuntu.com/focal/daily-live/pending/>`_ for Foxy.
Be sure to download the image corresponding to your CPU architecture.

In the UTM software:

* Create a new image and choose ``Virtualize`` option.
* Select the ISO image you have downloaded in the ``Boot ISO Image`` field.
* Leave all hardware settings at default (including hardware acceleration disabled).
* In the ``Shared Directory`` window, select a folder that will be used by ``webots_ros2`` to transfer all the Webots assets to the host.
  In this example, the selected folder is ``/Users/username/shared``.
* Leave all the remaining parameters as default.
* Start the VM.
  Note that you can select another shared folder each time you start the VM.
* During the first launch of the VM, install Ubuntu and choose a username for your account. In this example, the username is ``ubuntu``.
* Once Ubuntu is installed, close the VM, remove the iso image from the CD/DVD field and restart the VM.

2 Configure the VM
^^^^^^^^^^^^^^^^^^
In this section, ROS 2 is installed in the VM and the shared folder is configured.
The following instructions and commands are all run inside the VM.

* Open a terminal in the started VM and install the ROS 2 distribution you need by following the instructions in :doc:`../../../../Installation/Ubuntu-Install-Debs`:
* Create a folder in the VM to use as a shared folder.
  In this example, the shared folder in the VM is ``/home/ubuntu/shared``.

  .. code-block:: console

      mkdir /home/ubuntu/shared

* To mount this folder to the host, execute the following command.
  Don't forget to modify the path to the shared folder, if it is different in your case.

  .. code-block:: console

      sudo mount -t 9p -o trans=virtio share /home/ubuntu/shared -oversion=9p2000.L

* To automatically mount this folder to the host when starting the VM, add the following line to ``/etc/fstab``.
  Don't forget to modify the path to the shared folder, if it is different in your case.

  .. code-block:: console

      share     /home/ubuntu/shared     9p      trans=virtio,version=9p2000.L,rw,_netdev,nofail 0       0

* The environment variable ``WEBOTS_SHARED_FOLDER`` must always be set in order for the package to work properly in the VM.
  This variable specifies the location of the shared folder that is used to exchange data between the host machine and the virtual machine (VM) to the ``webots_ros2`` package.
  The value to use for this variable should be in the format of ``<host shared folder>:<VM shared folder>``, where ``<host shared folder>`` is the path to the shared folder on the host machine and ``<VM shared folder>`` is the path to the same shared folder on the VM.

  In this example:

  .. code-block:: console

    export WEBOTS_SHARED_FOLDER=/Users/username/shared:/home/ubuntu/shared

  You can add this command line to the ``~/.bashrc`` file to automatically set this environment variable when starting a new terminal.

3 Install ``webots_ros2``
^^^^^^^^^^^^^^^^^^^^^^^^^

You can either install ``webots_ros2`` from the official released package, or install it from the latest up-to-date sources from `Github <https://github.com/cyberbotics/webots_ros2>`_.

.. tabs::

    .. group-tab:: Install ``webots_ros2`` distributed package

        Run the following command in the VM terminal.

        .. code-block:: console

            sudo apt-get install ros-{DISTRO}-webots-ros2

    .. group-tab:: Install ``webots_ros2`` from sources

        Install git.

        .. code-block:: console

            sudo apt-get install git

        Create a ROS 2 workspace with its ``src`` directory.

        .. code-block:: console

            mkdir -p ~/ros2_ws/src

        Source the ROS 2 environment.

        .. code-block:: console

            source /opt/ros/{DISTRO}/setup.bash

        Retrieve the sources from Github.

        .. code-block:: console

            cd ~/ros2_ws
            git clone --recurse-submodules https://github.com/cyberbotics/webots_ros2.git src/webots_ros2

        Install the package dependencies.

        .. code-block:: console

            sudo apt install python3-pip python3-rosdep python3-colcon-common-extensions
            sudo rosdep init && rosdep update
            rosdep install --from-paths src --ignore-src --rosdistro {DISTRO}

        Build the package using ``colcon``.

        .. code-block:: console

            colcon build

        Source this workspace.

        .. code-block:: console

            source install/local_setup.bash

4 Launch the ``webots_ros2_universal_robot`` example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As mentioned in previous sections, the package uses the shared folder to communicate with Webots from the VM to the host.
In order for Webots to be started on the host from the VM's ROS package, a local TCP simulation server must be run.

The server can be downloaded here: `local_simulation_server.py <https://github.com/cyberbotics/webots-server/blob/main/local_simulation_server.py>`_.
Specify the Webots installation folder in ``WEBOTS_HOME`` environment variable (e.g. ``/Applications/Webots.app``) and run the server using the following commands in a new terminal on the host (not in the VM):

.. code-block:: console

        export WEBOTS_HOME=/Applications/Webots.app
        python3 local_simulation_server.py

In the VM, open a terminal and execute the following commands to start a package:

First source the ROS 2 environment, if not done already.

.. code-block:: console

        source /opt/ros/{DISTRO}/setup.bash

If installed from sources, source your ROS 2 workspace, if not done already.

.. code-block:: console

        cd ~/ros2_ws
        source install/local_setup.bash

If not already set in ``~/.bashrc``, set ``WEBOTS_SHARED_FOLDER`` (see previous sections for details).
Be sure to change the paths according to the location of your respective directories.

.. code-block:: console

        export WEBOTS_SHARED_FOLDER=/Users/username/shared:/home/ubuntu/shared

Use the ROS 2 launch command to start demo packages (e.g. ``webots_ros2_universal_robot``).

.. code-block:: console

        ros2 launch webots_ros2_universal_robot multirobot_launch.py

If Webots is closed or the ROS 2 process is interrupted, the local server will automatically wait for a new package launch and the shared folder will be cleaned for the next run.
",What is the recommended solution for running ROS 2 on macOS in terms of improving user experience and hardware acceleration for Webots?
".. redirect-from::

    Tutorials/Getting-Started-With-Ros2doctor

.. _Ros2Doctor:

Using ``ros2doctor`` to identify issues
=======================================

**Goal:** Identify issues in your ROS 2 setup using the ``ros2doctor`` tool.

**Tutorial level:** Beginner

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

When your ROS 2 setup is not running as expected, you can check its settings with the ``ros2doctor`` tool.

``ros2doctor`` checks all aspects of ROS 2, including platform, version, network, environment, running systems and more, and warns you about possible errors and reasons for issues.

Prerequisites
-------------

``ros2doctor`` is part of the ``ros2cli`` package.
As long as you have ``ros2cli`` installed (which any normal install should have), you will be able to use ``ros2doctor``.

This tutorial uses :doc:`turtlesim <../Beginner-CLI-Tools/Introducing-Turtlesim/Introducing-Turtlesim>` to illustrate some of the examples.

Tasks
-----

1 Check your setup
^^^^^^^^^^^^^^^^^^

Let's examine your general ROS 2 setup as a whole with ``ros2doctor``.
First, source ROS 2 in a new terminal, then enter the command:

.. code-block:: console

    ros2 doctor

This will conduct checks over all your setup modules and return warnings and errors.

If your ROS 2 setup is in perfect shape, you'll see a message similar to this:

.. code-block:: console

    All <n> checks passed

However, it's not unusual to have a few warnings returned.
A ``UserWarning`` doesn't mean your setup is unusable; it's more likely just an indication that something is configured in a way that's not ideal.

If you do receive a warning, it will look something like this:

.. code-block:: console

    <path>: <line>: UserWarning: <message>

For example, ``ros2doctor`` will find this warning if you're using an unstable ROS 2 distribution:

.. code-block:: console

    UserWarning: Distribution <distro> is not fully supported or tested. To get more consistent features, download a stable version at https://index.ros.org/doc/ros2/Installation/

If ``ros2doctor`` only finds warnings in your system, you will still receive the ``All <n> checks passed`` message.

Most checks are categorized as warnings as opposed to errors.
It's mostly up to you, the user, to determine the importance of the feedback ``ros2doctor`` returns.
If it does find a rare error in your setup, indicated by ``UserWarning: ERROR:``, the check is considered failed.

You will see a message similar to the following list of issue feedback:

.. code-block:: console

  1/3 checks failed

  Failed modules:  network

An error indicates the system is missing important settings or functions that are crucial to ROS 2.
Errors should be addressed to ensure the system functions properly.

2 Check a system
^^^^^^^^^^^^^^^^

You can also examine a running ROS 2 system to identify possible causes for issues.
To see ``ros2doctor`` working on a running system, let's run turtlesim, which has nodes actively communicating with each other.

Start up the system by opening a new terminal, sourcing ROS 2, and entering the command:

.. code-block:: console

    ros2 run turtlesim turtlesim_node

Open another terminal and source ROS 2 to run the teleop controls:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

Now run ``ros2doctor`` again in its own terminal.
You will see the warnings and errors you had the last time you ran ``ros2doctor`` on your setup if you had any.
Following those will be a couple new warnings relating to the system itself:

.. code-block:: console

    UserWarning: Publisher without subscriber detected on /turtle1/color_sensor.
    UserWarning: Publisher without subscriber detected on /turtle1/pose.

It seems that the ``/turtlesim`` node publishes data to two topics that aren't being subscribed to, and ``ros2doctor`` thinks this could possibly lead to issues.

If you run commands to echo the ``/color_sensor`` and ``/pose`` topics, those warnings will disappear because the publishers will have subscribers.

You can try this by opening two new terminals while turtlesim is still running, sourcing ROS 2 in each, and running each of the following commands in their own terminal:

.. code-block:: console

    ros2 topic echo /turtle1/color_sensor

.. code-block:: console

    ros2 topic echo /turtle1/pose

Then run ``ros2doctor`` in its terminal again.
The ``publisher without subscriber`` warnings will be gone.
(Make sure to enter ``Ctrl+C`` in the terminals where you ran ``echo``).

Now try exiting either the turtlesim window or quitting the teleop and running ``ros2doctor`` again.
You'll see more warnings indicating ``publisher without subscriber`` or ``subscriber without publisher`` for different topics, now that one node in the system isn't available.

In a complex system with many nodes, ``ros2doctor`` would be invaluable for identifying possible reasons for communication issues.

3 Get a full report
^^^^^^^^^^^^^^^^^^^

While ``ros2doctor`` will let you know warnings about your network, system, etc., running it with the ``--report`` argument will give you much more detail to help you analyze issues.

You might want to use ``--report`` if you get a warning about your network setup and want to find out exactly what part of your configuration is causing the warning.

It's also very helpful when you need to open a support ticket to get help with ROS 2.
You can copy and paste the relevant parts of your report into the ticket so the people helping you can better understand your environment and provide better assistance.

To get a full report, enter the following command in the terminal:

.. code-block:: console

    ros2 doctor --report

Which will return a list of information categorized into five groups:

.. code-block:: console

  NETWORK CONFIGURATION
  ...

  PLATFORM INFORMATION
  ...

  RMW MIDDLEWARE
  ...

  ROS 2 INFORMATION
  ...

  TOPIC LIST
  ...

You can crosscheck the information here against the warnings you get when running ``ros2 doctor``.
For example, if ``ros2doctor`` returned the warning (mentioned earlier) that your distribution is “not fully supported or tested”, you might take a look at the ``ROS 2 INFORMATION`` section of the report:

.. code-block:: console

  distribution name      : <distro>
  distribution type      : ros2
  distribution status    : prerelease
  release platforms      : {'<platform>': ['<version>']}

Here you can see the ``distribution status`` is ``prerelease``, which explains why it's not fully supported.


Summary
-------

``ros2doctor`` will inform you of problems in your ROS 2 setup and running systems.
You can get a deeper look at information behind those warnings by using the ``--report`` argument.

Keep in mind, ``ros2doctor`` is not a debug tool; it won't help with errors in your code or on the implementation side of your system.


Related content
---------------

`ros2doctor's README <https://github.com/ros2/ros2cli/tree/{REPOS_FILE_BRANCH}/ros2doctor>`__ will tell you more about different arguments.
You might want to take a look around the ``ros2doctor`` repo as well, since it's fairly beginner friendly and a great place to get started with contributing.

Next steps
----------------

You've completed the beginner level tutorials!
",What command can you use to get a full report from the `ros2doctor` tool?
".. redirect-from::

    Tutorials/Writing-A-Simple-Py-Publisher-And-Subscriber

.. _PyPubSub:

Writing a simple publisher and subscriber (Python)
==================================================

**Goal:** Create and run a publisher and subscriber node using Python.

**Tutorial level:** Beginner

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In this tutorial, you will create :doc:`nodes <../Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>` that pass information in the form of string messages to each other over a :doc:`topic <../Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics>`.
The example used here is a simple ""talker"" and ""listener"" system;
one node publishes data and the other subscribes to the topic so it can receive that data.

The code used in these examples can be found `here <https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclpy/topics>`__.

Prerequisites
-------------

In previous tutorials, you learned how to :doc:`create a workspace <./Creating-A-Workspace/Creating-A-Workspace>` and :doc:`create a package <./Creating-Your-First-ROS2-Package>`.

A basic understanding of Python is recommended, but not entirely necessary.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

Open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

Navigate into the ``ros2_ws`` directory created in a :ref:`previous tutorial <new-directory>`.

Recall that packages should be created in the ``src`` directory, not the root of the workspace.
So, navigate into ``ros2_ws/src``, and run the package creation command:

.. code-block:: console

  ros2 pkg create --build-type ament_python --license Apache-2.0 py_pubsub

Your terminal will return a message verifying the creation of your package ``py_pubsub`` and all its necessary files and folders.

2 Write the publisher node
^^^^^^^^^^^^^^^^^^^^^^^^^^

Navigate into ``ros2_ws/src/py_pubsub/py_pubsub``.
Recall that this directory is a `Python package <https://docs.python.org/3/tutorial/modules.html#packages>`__ with the same name as the ROS 2 package it's nested in.

Download the example talker code by entering the following command:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        wget https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclpy/topics/minimal_publisher/examples_rclpy_minimal_publisher/publisher_member_function.py

   .. group-tab:: macOS

      .. code-block:: console

        wget https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclpy/topics/minimal_publisher/examples_rclpy_minimal_publisher/publisher_member_function.py

   .. group-tab:: Windows

      In a Windows command line prompt:

      .. code-block:: console

            curl -sk https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclpy/topics/minimal_publisher/examples_rclpy_minimal_publisher/publisher_member_function.py -o publisher_member_function.py

      Or in powershell:

      .. code-block:: console

            curl https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclpy/topics/minimal_publisher/examples_rclpy_minimal_publisher/publisher_member_function.py -o publisher_member_function.py

Now there will be a new file named ``publisher_member_function.py`` adjacent to ``__init__.py``.

Open the file using your preferred text editor.

.. code-block:: python

  import rclpy
  from rclpy.executors import ExternalShutdownException
  from rclpy.node import Node

  from std_msgs.msg import String


  class MinimalPublisher(Node):

      def __init__(self):
          super().__init__('minimal_publisher')
          self.publisher_ = self.create_publisher(String, 'topic', 10)
          timer_period = 0.5  # seconds
          self.timer = self.create_timer(timer_period, self.timer_callback)
          self.i = 0

      def timer_callback(self):
          msg = String()
          msg.data = 'Hello World: %d' % self.i
          self.publisher_.publish(msg)
          self.get_logger().info('Publishing: ""%s""' % msg.data)
          self.i += 1


  def main(args=None):
      try:
          with rclpy.init(args=args):
              minimal_publisher = MinimalPublisher()

              rclpy.spin(minimal_publisher)
      except (KeyboardInterrupt, ExternalShutdownException):
          pass


  if __name__ == '__main__':
      main()


2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

The first lines of code after the comments import ``rclpy`` so its ``Node`` class can be used.

.. code-block:: python

  import rclpy
  from rclpy.executors import ExternalShutdownException
  from rclpy.node import Node

The next statement imports the built-in string message type that the node uses to structure the data that it passes on the topic.

.. code-block:: python

  from std_msgs.msg import String

These lines represent the node's dependencies.
Recall that dependencies have to be added to ``package.xml``, which you'll do in the next section.

Next, the ``MinimalPublisher`` class is created, which inherits from (or is a subclass of) ``Node``.

.. code-block:: python

  class MinimalPublisher(Node):

Following is the definition of the class's constructor.
``super().__init__`` calls the ``Node`` class's constructor and gives it your node name, in this case ``minimal_publisher``.

``create_publisher`` declares that the node publishes messages of type ``String`` (imported from the ``std_msgs.msg`` module), over a topic named ``topic``, and that the ""queue size"" is 10.
Queue size is a required QoS (quality of service) setting that limits the amount of queued messages if a subscriber is not receiving them fast enough.

Next, a timer is created with a callback to execute every 0.5 seconds.
``self.i`` is a counter used in the callback.

.. code-block:: python

  def __init__(self):
      super().__init__('minimal_publisher')
      self.publisher_ = self.create_publisher(String, 'topic', 10)
      timer_period = 0.5  # seconds
      self.timer = self.create_timer(timer_period, self.timer_callback)
      self.i = 0

``timer_callback`` creates a message with the counter value appended, and publishes it to the console with ``get_logger().info``.

.. code-block:: python

  def timer_callback(self):
      msg = String()
      msg.data = 'Hello World: %d' % self.i
      self.publisher_.publish(msg)
      self.get_logger().info('Publishing: ""%s""' % msg.data)
      self.i += 1

Lastly, the main function is defined.

.. code-block:: python

  def main(args=None):
      try:
          with rclpy.init(args=args):
              minimal_publisher = MinimalPublisher()

              rclpy.spin(minimal_publisher)
      except (KeyboardInterrupt, ExternalShutdownException):
          pass


First the ``rclpy`` library is initialized, then the node is created, and then it ""spins"" the node so its callbacks are called.

2.2 Add dependencies
~~~~~~~~~~~~~~~~~~~~

Navigate one level back to the ``ros2_ws/src/py_pubsub`` directory, where the ``setup.py``, ``setup.cfg``, and ``package.xml`` files have been created for you.

Open ``package.xml`` with your text editor.

As mentioned in the :doc:`previous tutorial <./Creating-Your-First-ROS2-Package>`, make sure to fill in the ``<description>``, ``<maintainer>`` and ``<license>`` tags:

.. code-block:: xml

  <description>Examples of minimal publisher/subscriber using rclpy</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>

After the lines above, add the following dependencies corresponding to your node's import statements:

.. code-block:: xml

  <exec_depend>rclpy</exec_depend>
  <exec_depend>std_msgs</exec_depend>

This declares the package needs ``rclpy`` and ``std_msgs`` when its code is executed.

Make sure to save the file.

2.3 Add an entry point
~~~~~~~~~~~~~~~~~~~~~~

Open the ``setup.py`` file.
Again, match the ``maintainer``, ``maintainer_email``, ``description`` and ``license`` fields to your ``package.xml``:

.. code-block:: python

  maintainer='YourName',
  maintainer_email='you@email.com',
  description='Examples of minimal publisher/subscriber using rclpy',
  license='Apache-2.0',

Add the following line within the ``console_scripts`` brackets of the ``entry_points`` field:

.. code-block:: python

  entry_points={
          'console_scripts': [
                  'talker = py_pubsub.publisher_member_function:main',
          ],
  },

Don't forget to save.

2.4 Check setup.cfg
~~~~~~~~~~~~~~~~~~~

The contents of the ``setup.cfg`` file should be correctly populated automatically, like so:

.. code-block:: console

  [develop]
  script_dir=$base/lib/py_pubsub
  [install]
  install_scripts=$base/lib/py_pubsub

This is simply telling setuptools to put your executables in ``lib``, because ``ros2 run`` will look for them there.

You could build your package now, source the local setup files, and run it, but let's create the subscriber node first so you can see the full system at work.

3 Write the subscriber node
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Return to ``ros2_ws/src/py_pubsub/py_pubsub`` to create the next node.
Enter the following code in your terminal:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        wget https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclpy/topics/minimal_subscriber/examples_rclpy_minimal_subscriber/subscriber_member_function.py

   .. group-tab:: macOS

      .. code-block:: console

        wget https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclpy/topics/minimal_subscriber/examples_rclpy_minimal_subscriber/subscriber_member_function.py

   .. group-tab:: Windows

      In a Windows command line prompt:

      .. code-block:: console

            curl -sk https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclpy/topics/minimal_subscriber/examples_rclpy_minimal_subscriber/subscriber_member_function.py -o subscriber_member_function.py

      Or in powershell:

      .. code-block:: console

            curl https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclpy/topics/minimal_subscriber/examples_rclpy_minimal_subscriber/subscriber_member_function.py -o subscriber_member_function.py

Now the directory should have these files:

.. code-block:: console

  __init__.py  publisher_member_function.py  subscriber_member_function.py

3.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

Open the ``subscriber_member_function.py`` with your text editor.

.. code-block:: python

  import rclpy
  from rclpy.executors import ExternalShutdownException
  from rclpy.node import Node

  from std_msgs.msg import String


  class MinimalSubscriber(Node):

      def __init__(self):
          super().__init__('minimal_subscriber')
          self.subscription = self.create_subscription(
              String,
              'topic',
              self.listener_callback,
              10)
          self.subscription  # prevent unused variable warning

      def listener_callback(self, msg):
          self.get_logger().info('I heard: ""%s""' % msg.data)


  def main(args=None):
      try:
          with rclpy.init(args=args):
              minimal_subscriber = MinimalSubscriber()

              rclpy.spin(minimal_subscriber)
      except (KeyboardInterrupt, ExternalShutdownException):
          pass


  if __name__ == '__main__':
      main()

The subscriber node's code is nearly identical to the publisher's.
The constructor creates a subscriber with the same arguments as the publisher.
Recall from the :doc:`topics tutorial <../Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics>` that the topic name and message type used by the publisher and subscriber must match to allow them to communicate.

.. code-block:: python

  self.subscription = self.create_subscription(
      String,
      'topic',
      self.listener_callback,
      10)

The subscriber's constructor and callback don't include any timer definition, because it doesn't need one.
Its callback gets called as soon as it receives a message.

The callback definition simply prints an info message to the console, along with the data it received.
Recall that the publisher defines ``msg.data = 'Hello World: %d' % self.i``

.. code-block:: python

  def listener_callback(self, msg):
      self.get_logger().info('I heard: ""%s""' % msg.data)

The ``main`` definition is almost exactly the same, replacing the creation and spinning of the publisher with the subscriber.

.. code-block:: python

  minimal_subscriber = MinimalSubscriber()

  rclpy.spin(minimal_subscriber)

Since this node has the same dependencies as the publisher, there's nothing new to add to ``package.xml``.
The ``setup.cfg`` file can also remain untouched.


3.2 Add an entry point
~~~~~~~~~~~~~~~~~~~~~~

Reopen ``setup.py`` and add the entry point for the subscriber node below the publisher's entry point.
The ``entry_points`` field should now look like this:

.. code-block:: python

  entry_points={
          'console_scripts': [
                  'talker = py_pubsub.publisher_member_function:main',
                  'listener = py_pubsub.subscriber_member_function:main',
          ],
  },

Make sure to save the file, and then your pub/sub system should be ready.

4 Build and run
^^^^^^^^^^^^^^^
You likely already have the ``rclpy`` and ``std_msgs`` packages installed as part of your ROS 2 system.
It's good practice to run ``rosdep`` in the root of your workspace (``ros2_ws``) to check for missing dependencies before building:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

      rosdep only runs on Linux, so you can skip ahead to next step.

   .. group-tab:: Windows

      rosdep only runs on Linux, so you can skip ahead to next step.


Still in the root of your workspace, ``ros2_ws``, build your new package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select py_pubsub

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select py_pubsub

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select py_pubsub

Open a new terminal, navigate to ``ros2_ws``, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the talker node:

.. code-block:: console

  ros2 run py_pubsub talker

The terminal should start publishing info messages every 0.5 seconds, like so:

.. code-block:: console

  [INFO] [minimal_publisher]: Publishing: ""Hello World: 0""
  [INFO] [minimal_publisher]: Publishing: ""Hello World: 1""
  [INFO] [minimal_publisher]: Publishing: ""Hello World: 2""
  [INFO] [minimal_publisher]: Publishing: ""Hello World: 3""
  [INFO] [minimal_publisher]: Publishing: ""Hello World: 4""
  ...

Open another terminal, source the setup files from inside ``ros2_ws`` again, and then start the listener node:

.. code-block:: console

  ros2 run py_pubsub listener

The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so:

.. code-block:: console

  [INFO] [minimal_subscriber]: I heard: ""Hello World: 10""
  [INFO] [minimal_subscriber]: I heard: ""Hello World: 11""
  [INFO] [minimal_subscriber]: I heard: ""Hello World: 12""
  [INFO] [minimal_subscriber]: I heard: ""Hello World: 13""
  [INFO] [minimal_subscriber]: I heard: ""Hello World: 14""

Enter ``Ctrl+C`` in each terminal to stop the nodes from spinning.

Summary
-------

You created two nodes to publish and subscribe to data over a topic.
Before running them, you added their dependencies and entry points to the package configuration files.

Next steps
----------

Next you'll create another simple ROS 2 package using the service/client model.
Again, you can choose to write it in either :doc:`C++ <./Writing-A-Simple-Cpp-Service-And-Client>` or :doc:`Python <./Writing-A-Simple-Py-Service-And-Client>`.

Related content
---------------

There are several ways you could write a publisher and subscriber in Python; check out the ``minimal_publisher`` and ``minimal_subscriber`` packages in the `ros2/examples <https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclpy/topics>`_ repo.
",What are the main tasks involved in creating and running a publisher and subscriber node using Python?
".. redirect-from::

    Tutorials/Creating-Your-First-ROS2-Package

.. _CreatePkg:

Creating a package
==================

**Goal:** Create a new package using either CMake or Python, and run its executable.

**Tutorial level:** Beginner

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

1 What is a ROS 2 package?
^^^^^^^^^^^^^^^^^^^^^^^^^^

A package is an organizational unit for your ROS 2 code.
If you want to be able to install your code or share it with others, then you'll need it organized in a package.
With packages, you can release your ROS 2 work and allow others to build and use it easily.

Package creation in ROS 2 uses ament as its build system and colcon as its build tool.
You can create a package using either CMake or Python, which are officially supported, though other build types do exist.

2 What makes up a ROS 2 package?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ROS 2 Python and CMake packages each have their own minimum required contents:

.. tabs::

   .. group-tab:: CMake

      * ``CMakeLists.txt`` file that describes how to build the code within the package
      * ``include/<package_name>`` directory containing the public headers for the package
      * ``package.xml`` file containing meta information about the package
      * ``src`` directory containing the source code for the package

   .. group-tab:: Python

      * ``package.xml`` file containing meta information about the package
      * ``resource/<package_name>`` marker file for the package
      * ``setup.cfg`` is required when a package has executables, so ``ros2 run`` can find them
      * ``setup.py`` containing instructions for how to install the package
      * ``<package_name>`` - a directory with the same name as your package, used by ROS 2 tools to find your package, contains ``__init__.py``

The simplest possible package may have a file structure that looks like:

.. tabs::

   .. group-tab:: CMake

      .. code-block:: console

        my_package/
             CMakeLists.txt
             include/my_package/
             package.xml
             src/

   .. group-tab:: Python

      .. code-block:: console

        my_package/
              package.xml
              resource/my_package
              setup.cfg
              setup.py
              my_package/


3 Packages in a workspace
^^^^^^^^^^^^^^^^^^^^^^^^^

A single workspace can contain as many packages as you want, each in their own folder.
You can also have packages of different build types in one workspace (CMake, Python, etc.).
You cannot have nested packages.

Best practice is to have a ``src`` folder within your workspace, and to create your packages in there.
This keeps the top level of the workspace “clean”.

A trivial workspace might look like:

.. code-block:: console

  workspace_folder/
      src/
        cpp_package_1/
            CMakeLists.txt
            include/cpp_package_1/
            package.xml
            src/

        py_package_1/
            package.xml
            resource/py_package_1
            setup.cfg
            setup.py
            py_package_1/
        ...
        cpp_package_n/
            CMakeLists.txt
            include/cpp_package_n/
            package.xml
            src/


Prerequisites
-------------

You should have a ROS 2 workspace after following the instructions in the :doc:`previous tutorial <./Creating-A-Workspace/Creating-A-Workspace>`.
You will create your package in this workspace.


Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

First, :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>`.

Let's use the workspace you created in the :ref:`previous tutorial <new-directory>`, ``ros2_ws``, for your new package.

Make sure you are in the ``src`` folder before running the package creation command.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        cd ~/ros2_ws/src

   .. group-tab:: macOS

     .. code-block:: console

       cd ~/ros2_ws/src

   .. group-tab:: Windows

     .. code-block:: console

       cd \ros2_ws\src

The command syntax for creating a new package in ROS 2 is:

.. tabs::

   .. group-tab:: CMake

      .. code-block:: console

        ros2 pkg create --build-type ament_cmake --license Apache-2.0 <package_name>

   .. group-tab:: Python

      .. code-block:: console

        ros2 pkg create --build-type ament_python --license Apache-2.0 <package_name>

For this tutorial, you will use the optional arguments ``--node-name`` and ``--license``.
``--node-name`` option creates a simple Hello World type executable in the package, and ``--license`` declares the license information for the package.

Enter the following command in your terminal:

.. tabs::

   .. group-tab:: CMake

      .. code-block:: console

        ros2 pkg create --build-type ament_cmake --license Apache-2.0 --node-name my_node my_package

   .. group-tab:: Python

      .. code-block:: console

        ros2 pkg create --build-type ament_python --license Apache-2.0 --node-name my_node my_package

You will now have a new folder within your workspace's ``src`` directory called ``my_package``.

After running the command, your terminal will return the message:

.. tabs::

   .. group-tab:: CMake

      .. code-block:: console

        going to create a new package
        package name: my_package
        destination directory: /home/user/ros2_ws/src
        package format: 3
        version: 0.0.0
        description: TODO: Package description
        maintainer: ['<name> <email>']
        licenses: ['Apache-2.0']
        build type: ament_cmake
        dependencies: []
        node_name: my_node
        creating folder ./my_package
        creating ./my_package/package.xml
        creating source and include folder
        creating folder ./my_package/src
        creating folder ./my_package/include/my_package
        creating ./my_package/CMakeLists.txt
        creating ./my_package/src/my_node.cpp

   .. group-tab:: Python

      .. code-block:: console

        going to create a new package
        package name: my_package
        destination directory: /home/user/ros2_ws/src
        package format: 3
        version: 0.0.0
        description: TODO: Package description
        maintainer: ['<name> <email>']
        licenses: ['Apache-2.0']
        build type: ament_python
        dependencies: []
        node_name: my_node
        creating folder ./my_package
        creating ./my_package/package.xml
        creating source folder
        creating folder ./my_package/my_package
        creating ./my_package/setup.py
        creating ./my_package/setup.cfg
        creating folder ./my_package/resource
        creating ./my_package/resource/my_package
        creating ./my_package/my_package/__init__.py
        creating folder ./my_package/test
        creating ./my_package/test/test_copyright.py
        creating ./my_package/test/test_flake8.py
        creating ./my_package/test/test_pep257.py
        creating ./my_package/my_package/my_node.py

You can see the automatically generated files for the new package.

2 Build a package
^^^^^^^^^^^^^^^^^

Putting packages in a workspace is especially valuable because you can build many packages at once by running ``colcon build`` in the workspace root.
Otherwise, you would have to build each package individually.

Return to the root of your workspace:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        cd ~/ros2_ws

   .. group-tab:: macOS

      .. code-block:: console

        cd ~/ros2_ws

   .. group-tab:: Windows

     .. code-block:: console

       cd \ros2_ws

Now you can build your packages:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build

  .. group-tab:: macOS

    .. code-block:: console

      colcon build

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install

    Windows doesn't allow long paths, so ``merge-install`` will combine all the paths into the ``install`` directory.

Recall from the last tutorial that you also have the ``ros_tutorials`` packages in your ``ros2_ws``.
You might have noticed that running ``colcon build`` also built the ``turtlesim`` package.
That's fine when you only have a few packages in your workspace, but when there are many packages, ``colcon build`` can take a long time.

To build only the ``my_package`` package next time, you can run:

.. code-block:: console

    colcon build --packages-select my_package

3 Source the setup file
^^^^^^^^^^^^^^^^^^^^^^^

To use your new package and executable, first open a new terminal and source your main ROS 2 installation.

Then, from inside the ``ros2_ws`` directory, run the following command to source your workspace:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/local_setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/local_setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/local_setup.bat

Now that your workspace has been added to your path, you will be able to use your new package's executables.

4 Use the package
^^^^^^^^^^^^^^^^^

To run the executable you created using the ``--node-name`` argument during package creation, enter the command:

.. code-block:: console

  ros2 run my_package my_node

Which will return a message to your terminal:

.. tabs::

   .. group-tab:: CMake

      .. code-block:: console

        hello world my_package package

   .. group-tab:: Python

      .. code-block:: console

        Hi from my_package.

5 Examine package contents
^^^^^^^^^^^^^^^^^^^^^^^^^^

Inside ``ros2_ws/src/my_package``, you will see the files and folders that ``ros2 pkg create`` automatically generated:

.. tabs::

   .. group-tab:: CMake

      .. code-block:: console

        CMakeLists.txt  include  package.xml  src

      ``my_node.cpp`` is inside the ``src`` directory.
      This is where all your custom C++ nodes will go in the future.

   .. group-tab:: Python

      .. code-block:: console

        my_package  package.xml  resource  setup.cfg  setup.py  test

      ``my_node.py`` is inside the ``my_package`` directory.
      This is where all your custom Python nodes will go in the future.

6 Customize package.xml
^^^^^^^^^^^^^^^^^^^^^^^

You may have noticed in the return message after creating your package that the fields ``description`` and ``license`` contain ``TODO`` notes.
That's because the package description and license declaration are not automatically set, but are required if you ever want to release your package.
The ``maintainer`` field may also need to be filled in.

From ``ros2_ws/src/my_package``, open ``package.xml`` using your preferred text editor:

.. tabs::

   .. group-tab:: CMake

    .. code-block:: xml

     <?xml version=""1.0""?>
     <?xml-model
        href=""http://download.ros.org/schema/package_format3.xsd""
        schematypens=""http://www.w3.org/2001/XMLSchema""?>
     <package format=""3"">
      <name>my_package</name>
      <version>0.0.0</version>
      <description>TODO: Package description</description>
      <maintainer email=""user@todo.todo"">user</maintainer>
      <license>TODO: License declaration</license>

      <buildtool_depend>ament_cmake</buildtool_depend>

      <test_depend>ament_lint_auto</test_depend>
      <test_depend>ament_lint_common</test_depend>

      <export>
        <build_type>ament_cmake</build_type>
      </export>
     </package>

   .. group-tab:: Python

    .. code-block:: xml

     <?xml version=""1.0""?>
     <?xml-model
        href=""http://download.ros.org/schema/package_format3.xsd""
        schematypens=""http://www.w3.org/2001/XMLSchema""?>
     <package format=""3"">
      <name>my_package</name>
      <version>0.0.0</version>
      <description>TODO: Package description</description>
      <maintainer email=""user@todo.todo"">user</maintainer>
      <license>TODO: License declaration</license>

      <test_depend>ament_copyright</test_depend>
      <test_depend>ament_flake8</test_depend>
      <test_depend>ament_pep257</test_depend>
      <test_depend>python3-pytest</test_depend>

      <export>
        <build_type>ament_python</build_type>
      </export>
     </package>

Input your name and email on the ``maintainer`` line if it hasn't been automatically populated for you.
Then, edit the ``description`` line to summarize the package:

.. code-block:: xml

  <description>Beginner client libraries tutorials practice package</description>

Then, update the ``license`` line.
You can read more about open source licenses `here <https://opensource.org/licenses/alphabetical>`__.
Since this package is only for practice, it's safe to use any license.
We'll use ``Apache-2.0``:

.. code-block:: xml

  <license>Apache-2.0</license>

Don't forget to save once you're done editing.

Below the license tag, you will see some tag names ending with ``_depend``.
This is where your ``package.xml`` would list its dependencies on other packages, for colcon to search for.
``my_package`` is simple and doesn't have any dependencies, but you will see this space being utilized in upcoming tutorials.

.. tabs::

   .. group-tab:: CMake

      You're all done for now!

   .. group-tab:: Python

      The ``setup.py`` file contains the same description, maintainer and license fields as ``package.xml``, so you need to set those as well.
      They need to match exactly in both files.
      The version and name (``package_name``) also need to match exactly, and should be automatically populated in both files.

      Open ``setup.py`` with your preferred text editor.

      .. code-block:: python

       from setuptools import find_packages, setup

       package_name = 'my_py_pkg'

       setup(
        name=package_name,
        version='0.0.0',
        packages=find_packages(exclude=['test']),
        data_files=[
            ('share/ament_index/resource_index/packages',
                    ['resource/' + package_name]),
            ('share/' + package_name, ['package.xml']),
          ],
        install_requires=['setuptools'],
        zip_safe=True,
        maintainer='TODO',
        maintainer_email='TODO',
        description='TODO: Package description',
        license='TODO: License declaration',
        tests_require=['pytest'],
        entry_points={
            'console_scripts': [
                    'my_node = my_py_pkg.my_node:main'
            ],
          },
       )

      Edit the ``maintainer``, ``maintainer_email``, and ``description`` lines to match ``package.xml``.

      Don't forget to save the file.


Summary
-------

You've created a package to organize your code and make it easy to use for others.

Your package was automatically populated with the necessary files, and then you used colcon to build it so you can use its executables in your local environment.

Next steps
----------

Next, let's add something meaningful to a package.
You'll start with a simple publisher/subscriber system, which you can choose to write in either :doc:`C++ <./Writing-A-Simple-Cpp-Publisher-And-Subscriber>` or :doc:`Python <./Writing-A-Simple-Py-Publisher-And-Subscriber>`.
",What are the minimum required contents for a CMake package in ROS 2?
".. redirect-from::

    Tutorials/Writing-A-Simple-Cpp-Publisher-And-Subscriber

.. _CppPubSub:

Writing a simple publisher and subscriber (C++)
===============================================

**Goal:** Create and run a publisher and subscriber node using C++.

**Tutorial level:** Beginner

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

:doc:`Nodes <../Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>` are executable processes that communicate over the ROS graph.
In this tutorial, the nodes will pass information in the form of string messages to each other over a :doc:`topic <../Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics>`.
The example used here is a simple ""talker"" and ""listener"" system; one node publishes data and the other subscribes to the topic so it can receive that data.

The code used in these examples can be found `here <https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclcpp/topics>`__.

Prerequisites
-------------

In previous tutorials, you learned how to :doc:`create a workspace <./Creating-A-Workspace/Creating-A-Workspace>` and :doc:`create a package <./Creating-Your-First-ROS2-Package>`.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

Open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

Navigate into the ``ros2_ws`` directory created in a :ref:`previous tutorial <new-directory>`.

Recall that packages should be created in the ``src`` directory, not the root of the workspace.
So, navigate into ``ros2_ws/src``, and run the package creation command:

.. code-block:: console

    ros2 pkg create --build-type ament_cmake --license Apache-2.0 cpp_pubsub

Your terminal will return a message verifying the creation of your package ``cpp_pubsub`` and all its necessary files and folders.

Navigate into ``ros2_ws/src/cpp_pubsub/src``.
Recall that this is the directory in any CMake package where the source files containing executables belong.


2 Write the publisher node
^^^^^^^^^^^^^^^^^^^^^^^^^^

Download the example talker code by entering the following command:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

            wget -O publisher_lambda_function.cpp https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_publisher/lambda.cpp

   .. group-tab:: macOS

      .. code-block:: console

            wget -O publisher_lambda_function.cpp https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_publisher/lambda.cpp

   .. group-tab:: Windows

      In a Windows command line prompt:

      .. code-block:: console

            curl -sk https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_publisher/lambda.cpp -o publisher_lambda_function.cpp

      Or in powershell:

      .. code-block:: console

            curl https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_publisher/lambda.cpp -o publisher_lambda_function.cpp

Now there will be a new file named ``publisher_lambda_function.cpp``.
Open the file using your preferred text editor.

.. code-block:: C++

    #include <chrono>
    #include <memory>
    #include <string>

    #include ""rclcpp/rclcpp.hpp""
    #include ""std_msgs/msg/string.hpp""

    using namespace std::chrono_literals;

    /* This example creates a subclass of Node and uses a fancy C++11 lambda
    * function to shorten the callback syntax, at the expense of making the
    * code somewhat more difficult to understand at first glance. */

    class MinimalPublisher : public rclcpp::Node
    {
    public:
      MinimalPublisher()
      : Node(""minimal_publisher""), count_(0)
      {
        publisher_ = this->create_publisher<std_msgs::msg::String>(""topic"", 10);
        auto timer_callback =
          [this]() -> void {
            auto message = std_msgs::msg::String();
            message.data = ""Hello, world! "" + std::to_string(this->count_++);
            RCLCPP_INFO(this->get_logger(), ""Publishing: '%s'"", message.data.c_str());
            this->publisher_->publish(message);
          };
        timer_ = this->create_wall_timer(500ms, timer_callback);
      }

    private:
      rclcpp::TimerBase::SharedPtr timer_;
      rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
      size_t count_;
    };

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<MinimalPublisher>());
      rclcpp::shutdown();
      return 0;
    }

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

The top of the code includes the standard C++ headers you will be using.
After the standard C++ headers is the ``rclcpp/rclcpp.hpp`` include which allows you to use the most common pieces of the ROS 2 system.
Last is ``std_msgs/msg/string.hpp``, which includes the built-in message type you will use to publish data.

.. code-block:: C++

    #include <chrono>
    #include <memory>
    #include <string>

    #include ""rclcpp/rclcpp.hpp""
    #include ""std_msgs/msg/string.hpp""

    using namespace std::chrono_literals;

These lines represent the node's dependencies.
Recall that dependencies have to be added to ``package.xml`` and ``CMakeLists.txt``, which you'll do in the next section.

The next line creates the node class ``MinimalPublisher`` by inheriting from ``rclcpp::Node``.
Every ``this`` in the code is referring to the node.

.. code-block:: C++

    class MinimalPublisher : public rclcpp::Node

The public constructor names the node ``minimal_publisher`` and initializes ``count_`` to 0.
Inside the constructor, the publisher is initialized with the ``String`` message type, the topic name ``topic``, and the required queue size to limit messages in the event of a backup.
Next, a `lambda function <https://en.cppreference.com/w/cpp/language/lambda>`_ called ``timer_callback`` is declared.
It performs a by-reference capture of the current object ``this``, takes no input arguments and returns void.
The ``timer_callback`` function creates a new message of type ``String``, sets its data with the desired string and publishes it.
The ``RCLCPP_INFO`` macro ensures every published message is printed to the console.
At last, ``timer_`` is initialized, which causes the ``timer_callback`` function to be executed twice a second.

.. code-block:: C++

    public:
      MinimalPublisher()
      : Node(""minimal_publisher""), count_(0)
      {
        publisher_ = this->create_publisher<std_msgs::msg::String>(""topic"", 10);
        auto timer_callback =
          [this]() -> void {
            auto message = std_msgs::msg::String();
            message.data = ""Hello, world! "" + std::to_string(this->count_++);
            RCLCPP_INFO(this->get_logger(), ""Publishing: '%s'"", message.data.c_str());
            this->publisher_->publish(message);
          };
        timer_ = this->create_wall_timer(500ms, timer_callback);
      }

In the bottom of the class is the declaration of the timer, publisher, and counter fields.

.. code-block:: C++

    private:
      rclcpp::TimerBase::SharedPtr timer_;
      rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
      size_t count_;

Following the ``MinimalPublisher`` class is ``main``, where the node actually executes.
``rclcpp::init`` initializes ROS 2, and ``rclcpp::spin`` starts processing data from the node, including callbacks from the timer.

.. code-block:: C++

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<MinimalPublisher>());
      rclcpp::shutdown();
      return 0;
    }

2.2 Add dependencies
~~~~~~~~~~~~~~~~~~~~

Navigate one level back to the ``ros2_ws/src/cpp_pubsub`` directory, where the ``CMakeLists.txt`` and ``package.xml`` files have been created for you.

Open ``package.xml`` with your text editor.

As mentioned in the :doc:`previous tutorial <./Creating-Your-First-ROS2-Package>`, make sure to fill in the ``<description>``, ``<maintainer>`` and ``<license>`` tags:

.. code-block:: xml

      <description>Examples of minimal publisher/subscriber using rclcpp</description>
      <maintainer email=""you@email.com"">Your Name</maintainer>
      <license>Apache-2.0</license>

Add a new line after the ``ament_cmake`` buildtool dependency and paste the following dependencies corresponding to your node's include statements:

.. code-block:: xml

    <depend>rclcpp</depend>
    <depend>std_msgs</depend>

This declares the package needs ``rclcpp`` and ``std_msgs`` when its code is built and executed.

Make sure to save the file.

2.3 CMakeLists.txt
~~~~~~~~~~~~~~~~~~

Now open the ``CMakeLists.txt`` file.
Below the existing dependency ``find_package(ament_cmake REQUIRED)``, add the lines:

.. code-block:: console

    find_package(rclcpp REQUIRED)
    find_package(std_msgs REQUIRED)

After that, add the executable and name it ``talker`` so you can run your node using ``ros2 run``:

.. code-block:: console

    add_executable(talker src/publisher_lambda_function.cpp)
    ament_target_dependencies(talker rclcpp std_msgs)

Finally, add the ``install(TARGETS...)`` section so ``ros2 run`` can find your executable:

.. code-block:: console

  install(TARGETS
    talker
    DESTINATION lib/${PROJECT_NAME})

You can clean up your ``CMakeLists.txt`` by removing some unnecessary sections and comments, so it looks like this:

.. code-block:: console

  cmake_minimum_required(VERSION 3.5)
  project(cpp_pubsub)

  # Default to C++14
  if(NOT CMAKE_CXX_STANDARD)
    set(CMAKE_CXX_STANDARD 14)
  endif()

  if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES ""Clang"")
    add_compile_options(-Wall -Wextra -Wpedantic)
  endif()

  find_package(ament_cmake REQUIRED)
  find_package(rclcpp REQUIRED)
  find_package(std_msgs REQUIRED)

  add_executable(talker src/publisher_lambda_function.cpp)
  ament_target_dependencies(talker rclcpp std_msgs)

  install(TARGETS
    talker
    DESTINATION lib/${PROJECT_NAME})

  ament_package()

You could build your package now, source the local setup files, and run it, but let's create the subscriber node first so you can see the full system at work.

3 Write the subscriber node
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Return to ``ros2_ws/src/cpp_pubsub/src`` to create the next node.
Enter the following code in your terminal:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

            wget -O subscriber_lambda_function.cpp https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_subscriber/lambda.cpp

   .. group-tab:: macOS

      .. code-block:: console

            wget -O subscriber_lambda_function.cpp https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_subscriber/lambda.cpp

   .. group-tab:: Windows

      In a Windows command line prompt:

      .. code-block:: console

            curl -sk https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_subscriber/lambda.cpp -o subscriber_lambda_function.cpp

      Or in powershell:

      .. code-block:: console

            curl https://raw.githubusercontent.com/ros2/examples/{REPOS_FILE_BRANCH}/rclcpp/topics/minimal_subscriber/lambda.cpp -o subscriber_lambda_function.cpp

Check to ensure that these files exist:

.. code-block:: console

    publisher_lambda_function.cpp  subscriber_lambda_function.cpp

Open the ``subscriber_lambda_function.cpp`` with your text editor.

.. code-block:: C++

    #include <memory>

    #include ""rclcpp/rclcpp.hpp""
    #include ""std_msgs/msg/string.hpp""

    class MinimalSubscriber : public rclcpp::Node
    {
    public:
      MinimalSubscriber()
      : Node(""minimal_subscriber"")
      {
        auto topic_callback =
          [this](std_msgs::msg::String::UniquePtr msg) -> void {
            RCLCPP_INFO(this->get_logger(), ""I heard: '%s'"", msg->data.c_str());
          };
        subscription_ =
          this->create_subscription<std_msgs::msg::String>(""topic"", 10, topic_callback);
      }

    private:
      rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
    };

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<MinimalSubscriber>());
      rclcpp::shutdown();
      return 0;
    }

3.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

The subscriber node's code is nearly identical to the publisher's.
Now the node is named ``minimal_subscriber``, and the constructor uses the node's ``create_subscription`` function to execute the callback.

There is no timer because the subscriber simply responds whenever data is published to the ``topic`` topic.

The ``topic_callback`` function receives the string message data published over the topic, and simply writes it to the console using the ``RCLCPP_INFO`` macro.

Recall from the :doc:`topic tutorial <../Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics>` that the topic name and message type used by the publisher and subscriber must match to allow them to communicate.

.. code-block:: C++

    public:
      MinimalSubscriber()
      : Node(""minimal_subscriber"")
      {
        auto topic_callback =
          [this](std_msgs::msg::String::UniquePtr msg) -> void {
            RCLCPP_INFO(this->get_logger(), ""I heard: '%s'"", msg->data.c_str());
          };
        subscription_ =
          this->create_subscription<std_msgs::msg::String>(""topic"", 10, topic_callback);
      }

The only field declaration in this class is the subscription.

.. code-block:: C++

    private:
      rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;

The ``main`` function is exactly the same, except now it spins the ``MinimalSubscriber`` node.
For the publisher node, spinning meant starting the timer, but for the subscriber it simply means preparing to receive messages whenever they come.

Since this node has the same dependencies as the publisher node, there's nothing new to add to ``package.xml``.

3.2 CMakeLists.txt
~~~~~~~~~~~~~~~~~~

Reopen ``CMakeLists.txt`` and add the executable and target for the subscriber node below the publisher's entries.

.. code-block:: cmake

  add_executable(listener src/subscriber_lambda_function.cpp)
  ament_target_dependencies(listener rclcpp std_msgs)

  install(TARGETS
    talker
    listener
    DESTINATION lib/${PROJECT_NAME})

Make sure to save the file, and then your pub/sub system should be ready.

.. _cpppubsub-build-and-run:

4 Build and run
^^^^^^^^^^^^^^^
You likely already have the ``rclcpp`` and ``std_msgs`` packages installed as part of your ROS 2 system.
It's good practice to run ``rosdep`` in the root of your workspace (``ros2_ws``) to check for missing dependencies before building:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

            rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

      rosdep only runs on Linux, so you can skip ahead to next step.

   .. group-tab:: Windows

      rosdep only runs on Linux, so you can skip ahead to next step.


Still in the root of your workspace, ``ros2_ws``, build your new package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select cpp_pubsub

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select cpp_pubsub

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select cpp_pubsub

Open a new terminal, navigate to ``ros2_ws``, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the talker node:

.. code-block:: console

     ros2 run cpp_pubsub talker

The terminal should start publishing info messages every 0.5 seconds, like so:

.. code-block:: console

    [INFO] [minimal_publisher]: Publishing: ""Hello World: 0""
    [INFO] [minimal_publisher]: Publishing: ""Hello World: 1""
    [INFO] [minimal_publisher]: Publishing: ""Hello World: 2""
    [INFO] [minimal_publisher]: Publishing: ""Hello World: 3""
    [INFO] [minimal_publisher]: Publishing: ""Hello World: 4""

Open another terminal, source the setup files from inside ``ros2_ws`` again, and then start the listener node:

.. code-block:: console

     ros2 run cpp_pubsub listener

The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so:

.. code-block:: console

  [INFO] [minimal_subscriber]: I heard: ""Hello World: 10""
  [INFO] [minimal_subscriber]: I heard: ""Hello World: 11""
  [INFO] [minimal_subscriber]: I heard: ""Hello World: 12""
  [INFO] [minimal_subscriber]: I heard: ""Hello World: 13""
  [INFO] [minimal_subscriber]: I heard: ""Hello World: 14""

Enter ``Ctrl+C`` in each terminal to stop the nodes from spinning.

Summary
-------

You created two nodes to publish and subscribe to data over a topic.
Before compiling and running them, you added their dependencies and executables to the package configuration files.

Next steps
----------

Next you'll create another simple ROS 2 package using the service/client model.
Again, you can choose to write it in either :doc:`C++ <./Writing-A-Simple-Cpp-Service-And-Client>` or :doc:`Python <./Writing-A-Simple-Py-Service-And-Client>`.

Related content
---------------

There are several ways you could write a publisher and subscriber in C++; check out the ``minimal_publisher`` and ``minimal_subscriber`` packages in the `ros2/examples <https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclcpp/topics>`_ repo.
",What is the purpose of creating publisher and subscriber nodes using C++ in the provided text document?
".. _SinglePkgInterface:

.. redirect-from::

    Rosidl-Tutorial
    Tutorials/Single-Package-Define-And-Use-Interface

Implementing custom interfaces
==============================

**Goal:** Learn more ways to implement custom interfaces in ROS 2.

**Tutorial level:** Beginner

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In a :doc:`previous tutorial <./Custom-ROS2-Interfaces>`, you learned how to create custom msg and srv interfaces.

While best practice is to declare interfaces in dedicated interface packages, sometimes it can be convenient to declare, create and use an interface all in one package.

Recall that interfaces can currently only be defined in CMake packages.
It is possible, however, to have Python libraries and nodes in CMake packages (using `ament_cmake_python <https://github.com/ament/ament_cmake/tree/{REPOS_FILE_BRANCH}/ament_cmake_python>`_), so you could define interfaces and Python nodes together in one package.
We'll use a CMake package and C++ nodes here for the sake of simplicity.

This tutorial will focus on the msg interface type, but the steps here are applicable to all interface types.

Prerequisites
-------------

We assume you've reviewed the basics in the :doc:`./Custom-ROS2-Interfaces` tutorial before working through this one.

You should have :doc:`ROS 2 installed <../../Installation>`, a :doc:`workspace <./Creating-A-Workspace/Creating-A-Workspace>`, and an understanding of :doc:`creating packages <./Creating-Your-First-ROS2-Package>`.

As always, don't forget to :doc:`source ROS 2 <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` in every new terminal you open.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

In your workspace ``src`` directory, create a package ``more_interfaces`` and make a directory within it for msg files:

.. code-block:: console

  ros2 pkg create --build-type ament_cmake --license Apache-2.0 more_interfaces
  mkdir more_interfaces/msg

2 Create a msg file
^^^^^^^^^^^^^^^^^^^

Inside ``more_interfaces/msg``, create a new file ``AddressBook.msg``, and paste the following code to create a message meant to carry information about an individual:

::

   uint8 PHONE_TYPE_HOME=0
   uint8 PHONE_TYPE_WORK=1
   uint8 PHONE_TYPE_MOBILE=2

   string first_name
   string last_name
   string phone_number
   uint8 phone_type

This message is composed of these fields:

* first_name: of type string
* last_name: of type string
* phone_number: of type string
* phone_type: of type uint8, with several named constant values defined

Note that it's possible to set default values for fields within a message definition.
See :doc:`../../Concepts/Basic/About-Interfaces` for more ways you can customize interfaces.

Next, we need to make sure that the msg file is turned into source code for C++, Python, and other languages.

2.1 Build a msg file
~~~~~~~~~~~~~~~~~~~~

Open ``package.xml`` and add the following lines:

.. code-block:: xml

     <buildtool_depend>rosidl_default_generators</buildtool_depend>

     <exec_depend>rosidl_default_runtime</exec_depend>

     <member_of_group>rosidl_interface_packages</member_of_group>

Note that at build time, we need ``rosidl_default_generators``, while at runtime, we only need ``rosidl_default_runtime``.

Open ``CMakeLists.txt`` and add the following lines:

Find the package that generates message code from msg/srv files:

.. code-block:: cmake

   find_package(rosidl_default_generators REQUIRED)

Declare the list of messages you want to generate:

.. code-block:: cmake

   set(msg_files
     ""msg/AddressBook.msg""
   )

By adding the .msg files manually, we make sure that CMake knows when it has to reconfigure the project after you add other .msg files.

Generate the messages:

.. code-block:: cmake

   rosidl_generate_interfaces(${PROJECT_NAME}
     ${msg_files}
   )

Also make sure you export the message runtime dependency:

.. code-block:: cmake

   ament_export_dependencies(rosidl_default_runtime)

Now you're ready to generate source files from your msg definition.
We'll skip the compile step for now as we'll do it all together below in step 4.

3 Use an interface from the same package
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now we can start writing code that uses this message.

In ``more_interfaces/src`` create a file called ``publish_address_book.cpp`` and paste the following code:

.. code-block:: c++

  #include <chrono>
  #include <memory>

  #include ""rclcpp/rclcpp.hpp""
  #include ""more_interfaces/msg/address_book.hpp""

  using namespace std::chrono_literals;

  class AddressBookPublisher : public rclcpp::Node
  {
  public:
    AddressBookPublisher()
    : Node(""address_book_publisher"")
    {
      address_book_publisher_ =
        this->create_publisher<more_interfaces::msg::AddressBook>(""address_book"", 10);

      auto publish_msg = [this]() -> void {
          auto message = more_interfaces::msg::AddressBook();

          message.first_name = ""John"";
          message.last_name = ""Doe"";
          message.phone_number = ""1234567890"";
          message.phone_type = message.PHONE_TYPE_MOBILE;

          std::cout << ""Publishing Contact\nFirst:"" << message.first_name <<
            ""  Last:"" << message.last_name << std::endl;

          this->address_book_publisher_->publish(message);
        };
      timer_ = this->create_wall_timer(1s, publish_msg);
    }

  private:
    rclcpp::Publisher<more_interfaces::msg::AddressBook>::SharedPtr address_book_publisher_;
    rclcpp::TimerBase::SharedPtr timer_;
  };


  int main(int argc, char * argv[])
  {
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<AddressBookPublisher>());
    rclcpp::shutdown();

    return 0;
  }

3.1 The code explained
~~~~~~~~~~~~~~~~~~~~~~

Include the header of our newly created ``AddressBook.msg``.

.. code-block:: c++

   #include ""more_interfaces/msg/address_book.hpp""

Create a node and an ``AddressBook`` publisher.

.. code-block:: c++

   using namespace std::chrono_literals;

   class AddressBookPublisher : public rclcpp::Node
   {
   public:
     AddressBookPublisher()
     : Node(""address_book_publisher"")
     {
       address_book_publisher_ =
         this->create_publisher<more_interfaces::msg::AddressBook>(""address_book"");

Create a callback to publish the messages periodically.

.. code-block:: c++

    auto publish_msg = [this]() -> void {

Create an ``AddressBook`` message instance that we will later publish.

.. code-block:: c++

    auto message = more_interfaces::msg::AddressBook();

Populate ``AddressBook`` fields.

.. code-block:: c++

    message.first_name = ""John"";
    message.last_name = ""Doe"";
    message.phone_number = ""1234567890"";
    message.phone_type = message.PHONE_TYPE_MOBILE;

Finally send the message periodically.

.. code-block:: c++

    std::cout << ""Publishing Contact\nFirst:"" << message.first_name <<
      ""  Last:"" << message.last_name << std::endl;

    this->address_book_publisher_->publish(message);

Create a 1 second timer to call our ``publish_msg`` function every second.

.. code-block:: c++

       timer_ = this->create_wall_timer(1s, publish_msg);

3.2 Build the publisher
~~~~~~~~~~~~~~~~~~~~~~~

We need to create a new target for this node in the ``CMakeLists.txt``:

.. code-block:: cmake

   find_package(rclcpp REQUIRED)

   add_executable(publish_address_book src/publish_address_book.cpp)
   ament_target_dependencies(publish_address_book rclcpp)

   install(TARGETS
       publish_address_book
     DESTINATION lib/${PROJECT_NAME})

3.3 Link against the interface
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to use the messages generated in the same package we need to use the following CMake code:

.. code-block:: cmake

  rosidl_get_typesupport_target(cpp_typesupport_target
    ${PROJECT_NAME} rosidl_typesupport_cpp)

  target_link_libraries(publish_address_book ""${cpp_typesupport_target}"")

This finds the relevant generated C++ code from ``AddressBook.msg`` and allows your target to link against it.

You may have noticed that this step was not necessary when the interfaces being used were from a different package that was built independently.
This CMake code is only required when you want to use interfaces in the same package as the one in which they are defined.

4 Try it out
^^^^^^^^^^^^

Return to the root of the workspace to build the package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      cd ~/ros2_ws
      colcon build --packages-up-to more_interfaces

  .. group-tab:: macOS

    .. code-block:: console

      cd ~/ros2_ws
      colcon build --packages-up-to more_interfaces

  .. group-tab:: Windows

    .. code-block:: console

      cd /ros2_ws
      colcon build --merge-install --packages-up-to more_interfaces

Then source the workspace and run the publisher:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/local_setup.bash
      ros2 run more_interfaces publish_address_book

  .. group-tab:: macOS

    .. code-block:: console

      . install/local_setup.bash
      ros2 run more_interfaces publish_address_book

  .. group-tab:: Windows

    .. code-block:: console

      call install/local_setup.bat
      ros2 run more_interfaces publish_address_book

    Or using Powershell:

    .. code-block:: console

      install/local_setup.ps1
      ros2 run more_interfaces publish_address_book

You should see the publisher relaying the msg you defined, including the values you set in ``publish_address_book.cpp``.

To confirm the message is being published on the ``address_book`` topic, open another terminal, source the workspace, and call ``topic echo``:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash
      ros2 topic echo /address_book

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash
      ros2 topic echo /address_book

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat
      ros2 topic echo /address_book

    Or using Powershell:

    .. code-block:: console

      install/setup.ps1
      ros2 topic echo /address_book

We won't create a subscriber in this tutorial, but you can try to write one yourself for practice (use :doc:`./Writing-A-Simple-Cpp-Publisher-And-Subscriber` to help).

5 (Extra) Use an existing interface definition
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. note::

  You can use an existing interface definition in a new interface definition.
  For example, let's say there is a message named ``Contact.msg`` that belongs to an existing ROS 2 package named ``rosidl_tutorials_msgs``.
  Assume that its definition is identical to our custom-made ``AddressBook.msg`` interface from earlier.

  In that case you could have defined ``AddressBook.msg`` (an interface in the package *with* your nodes) as type ``Contact`` (an interface in a *separate* package).
  You could even define ``AddressBook.msg`` as an *array* of type ``Contact``, like so:

  ::

     rosidl_tutorials_msgs/Contact[] address_book

  To generate this message you would need to declare a dependency on ``Contact.msg's`` package, ``rosidl_tutorials_msgs``, in ``package.xml``:

  .. code-block:: xml

       <build_depend>rosidl_tutorials_msgs</build_depend>

       <exec_depend>rosidl_tutorials_msgs</exec_depend>

  And in ``CMakeLists.txt``:

  .. code-block:: cmake

     find_package(rosidl_tutorials_msgs REQUIRED)

     rosidl_generate_interfaces(${PROJECT_NAME}
       ${msg_files}
       DEPENDENCIES rosidl_tutorials_msgs
     )

  You would also need to include the header of ``Contact.msg`` in your publisher node in order to be able to add ``contacts`` to your ``address_book``.

  .. code-block:: c++

     #include ""rosidl_tutorials_msgs/msg/contact.hpp""

  You could change the callback to something like this:

  .. code-block:: c++

    auto publish_msg = [this]() -> void {
       auto msg = std::make_shared<more_interfaces::msg::AddressBook>();
       {
         rosidl_tutorials_msgs::msg::Contact contact;
         contact.first_name = ""John"";
         contact.last_name = ""Doe"";
         contact.phone_number = ""1234567890"";
         contact.phone_type = message.PHONE_TYPE_MOBILE;
         msg->address_book.push_back(contact);
       }
       {
         rosidl_tutorials_msgs::msg::Contact contact;
         contact.first_name = ""Jane"";
         contact.last_name = ""Doe"";
         contact.phone_number = ""4254242424"";
         contact.phone_type = message.PHONE_TYPE_HOME;
         msg->address_book.push_back(contact);
       }

       std::cout << ""Publishing address book:"" << std::endl;
       for (auto contact : msg->address_book) {
         std::cout << ""First:"" << contact.first_name << ""  Last:"" << contact.last_name <<
           std::endl;
       }

       address_book_publisher_->publish(*msg);
     };

  Building and running these changes would show the msg defined as expected, as well as the array of msgs defined above.

Summary
-------

In this tutorial, you tried out different field types for defining interfaces, then built an interface in the same package where it's being used.

You also learned how to use another interface as a field type, as well as the ``package.xml``, ``CMakeLists.txt``, and ``#include`` statements necessary for utilizing that feature.

Next steps
----------

Next you will create a simple ROS 2 package with a custom parameter that you will learn to set from a launch file.
Again, you can choose to write it in either :doc:`C++ <./Using-Parameters-In-A-Class-CPP>` or :doc:`Python <./Using-Parameters-In-A-Class-Python>`.

Related content
---------------

There are `several design articles <https://design.ros2.org/#interfaces>`_ on ROS 2 interfaces and the IDL (interface definition language).
",What steps are involved in creating and using a custom message interface in a ROS 2 package?
".. _Colcon:

.. redirect-from::

    Colcon-Tutorial
    Tutorials/Colcon-Tutorial

Using ``colcon`` to build packages
==================================

.. contents:: Table of Contents
   :depth: 2
   :local:

**Goal:** Build a ROS 2 workspace with ``colcon``.

**Tutorial level:** Beginner

**Time:** 20 minutes

This is a brief tutorial on how to create and build a ROS 2 workspace with ``colcon``.
It is a practical tutorial and not designed to replace the core documentation.

Background
----------

``colcon`` is an iteration on the ROS build tools ``catkin_make``, ``catkin_make_isolated``, ``catkin_tools`` and ``ament_tools``.
For more information on the design of colcon see `this document <https://design.ros2.org/articles/build_tool.html>`__.

The source code can be found in the `colcon GitHub organization <https://github.com/colcon>`__.

Prerequisites
-------------

Install colcon
^^^^^^^^^^^^^^

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

        sudo apt install python3-colcon-common-extensions

  .. group-tab:: macOS

    .. code-block:: bash

        python3 -m pip install colcon-common-extensions

  .. group-tab:: Windows

    .. code-block:: bash

        pip install -U colcon-common-extensions


Install ROS 2
^^^^^^^^^^^^^

To build the samples, you will need to install ROS 2.

Follow the :doc:`installation instructions <../../Installation>`.

.. attention:: If installing from deb packages, this tutorial requires the :ref:`desktop installation <linux-install-debs-install-ros-2-packages>`.

Basics
------

A ROS workspace is a directory with a particular structure.
Commonly there is a ``src`` subdirectory.
Inside that subdirectory is where the source code of ROS packages will be located.
Typically the directory starts otherwise empty.

colcon does out of source builds.
By default it will create the following directories as peers of the ``src`` directory:

* The ``build`` directory will be where intermediate files are stored.
  For each package a subfolder will be created in which e.g. CMake is being invoked.
* The ``install`` directory is where each package will be installed to.
  By default each package will be installed into a separate subdirectory.
* The ``log`` directory contains various logging information about each colcon invocation.

.. note:: Compared to catkin there is no ``devel`` directory.

Create a workspace
^^^^^^^^^^^^^^^^^^

First, create a directory (``ros2_ws``) to contain our workspace:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

       mkdir -p ~/ros2_ws/src
       cd ~/ros2_ws

  .. group-tab:: macOS

    .. code-block:: bash

       mkdir -p ~/ros2_ws/src
       cd ~/ros2_ws

  .. group-tab:: Windows

    .. code-block:: bash

       md \dev\ros2_ws\src
       cd \dev\ros2_ws

At this point the workspace contains a single empty directory ``src``:

.. code-block:: bash

    .
    └── src

    1 directory, 0 files

Add some sources
^^^^^^^^^^^^^^^^

Let's clone the `examples <https://github.com/ros2/examples>`__ repository into the ``src`` directory of the workspace:

.. code-block:: bash

    git clone https://github.com/ros2/examples src/examples -b {REPOS_FILE_BRANCH}

Now the workspace should have the source code to the ROS 2 examples:

.. code-block:: bash

    .
    └── src
        └── examples
            ├── CONTRIBUTING.md
            ├── LICENSE
            ├── rclcpp
            ├── rclpy
            └── README.md

    4 directories, 3 files

Source an underlay
^^^^^^^^^^^^^^^^^^

It is important that we have sourced the environment for an existing ROS 2 installation that will provide our workspace with the necessary build dependencies for the example packages.
This is achieved by sourcing the setup script provided by a binary installation or a source installation, ie. another colcon workspace (see :doc:`Installation <../../Installation>`).
We call this environment an **underlay**.

Our workspace, ``ros2_ws``, will be an **overlay** on top of the existing ROS 2 installation.
In general, it is recommended to use an overlay when you plan to iterate on a small number of packages, rather than putting all of your packages into the same workspace.

Build the workspace
^^^^^^^^^^^^^^^^^^^

.. attention::

   To build packages on Windows you need to be in a Visual Studio environment, see :ref:`Building the ROS 2 Code <windows-dev-build-ros2>` for more details.

In the root of the workspace, run ``colcon build``.
Since build types such as ``ament_cmake`` do not support the concept of the ``devel`` space and require the package to be installed, colcon supports the option ``--symlink-install``.
This allows the installed files to be changed by changing the files in the ``source`` space (e.g. Python files or other non-compiled resources) for faster iteration.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --symlink-install

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --symlink-install

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --symlink-install --merge-install

    Windows doesn't allow long paths, so ``merge-install`` will combine all the paths into the ``install`` directory.

After the build is finished, we should see the ``build``, ``install``, and ``log`` directories:

.. code-block:: bash

    .
    ├── build
    ├── install
    ├── log
    └── src

    4 directories, 0 files

.. _colcon-run-the-tests:

Run tests
^^^^^^^^^

To run tests for the packages we just built, run the following:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon test

  .. group-tab:: macOS

    .. code-block:: console

      colcon test

  .. group-tab:: Windows

    Remember to use a ``x64 Native Tools Command Prompt for VS 2019`` for executing the following command, as we are going to build a workspace.

    .. code-block:: console

      colcon test --merge-install

    You also need to specify ``--merge-install`` here since we used it for building above.

.. _colcon-tutorial-source-the-environment:

Source the environment
^^^^^^^^^^^^^^^^^^^^^^

When colcon has completed building successfully, the output will be in the ``install`` directory.
Before you can use any of the installed executables or libraries, you will need to add them to your path and library paths.
colcon will have generated bash/bat files in the ``install`` directory to help set up the environment.
These files will add all of the required elements to your path and library paths as well as provide any bash or shell commands exported by packages.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

       source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: bash

       . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: bash

       call install\setup.bat

    Or with Powershell:

    .. code-block:: bash

       install\setup.ps1

Try a demo
^^^^^^^^^^

With the environment sourced, we can run executables built by colcon.
Let's run a subscriber node from the examples:

.. code-block:: bash

    ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function

In another terminal, let's run a publisher node (don't forget to source the setup script):

.. code-block:: bash

    ros2 run examples_rclcpp_minimal_publisher publisher_member_function

You should see messages from the publisher and subscriber with numbers incrementing.

Create your own package
-----------------------

colcon uses the ``package.xml`` specification defined in `REP 149 <https://www.ros.org/reps/rep-0149.html>`__ (`format 2 <https://www.ros.org/reps/rep-0140.html>`__ is also supported).

colcon supports multiple build types.
The recommended build types are ``ament_cmake`` and ``ament_python``.
Also supported are pure ``cmake`` packages.

An example of an ``ament_python`` build is the `ament_index_python package <https://github.com/ament/ament_index/tree/{REPOS_FILE_BRANCH}/ament_index_python>`__ , where the setup.py is the primary entry point for building.

A package such as `demo_nodes_cpp <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/demo_nodes_cpp>`__ uses the ``ament_cmake`` build type, and uses CMake as the build tool.

For convenience, you can use the tool ``ros2 pkg create`` to create a new package based on a template.

.. note:: For ``catkin`` users, this is the equivalent of ``catkin_create_package``.

Setup ``colcon_cd``
-------------------

The command ``colcon_cd`` allows you to quickly change the current working directory of your shell to the directory of a package.
As an example ``colcon_cd some_ros_package`` would quickly bring you to the directory ``~/ros2_ws/src/some_ros_package``.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        echo ""source /usr/share/colcon_cd/function/colcon_cd.sh"" >> ~/.bashrc
        echo ""export _colcon_cd_root=/opt/ros/{DISTRO}/"" >> ~/.bashrc

   .. group-tab:: macOS

      .. code-block:: console

        echo ""source /usr/local/share/colcon_cd/function/colcon_cd.sh"" >> ~/.bashrc
        echo ""export _colcon_cd_root=~/ros2_install"" >> ~/.bashrc

   .. group-tab:: Windows

      Not yet available

Depending on the way you installed ``colcon_cd`` and where your workspace is, the instructions above may vary, please refer to `the documentation <https://colcon.readthedocs.io/en/released/user/installation.html#quick-directory-changes>`__ for more details.
To undo this in Linux and macOS, locate your system's shell startup script and remove the appended source and export commands.

Setup ``colcon`` tab completion
-------------------------------

The ``colcon`` command supports command completion for bash and bash-like shells.
The ``colcon-argcomplete`` package must be installed, and `some setup may be required <https://colcon.readthedocs.io/en/released/user/installation.html#enable-completion>`__ to make it work.

Tips
----

* If you do not want to build a specific package place an empty file named ``COLCON_IGNORE`` in the directory and it will not be indexed.

* If you want to avoid configuring and building tests in CMake packages you can pass: ``--cmake-args -DBUILD_TESTING=0``.

* If you want to run a single particular test from a package:

  .. code-block:: bash

     colcon test --packages-select YOUR_PKG_NAME --ctest-args -R YOUR_TEST_IN_PKG

Setup ``colcon`` mixins
-----------------------

Various command line options are tedious to write and/or difficult to remember.

For example, to change the CMake build type to debug, you normally use:

.. code-block:: console

    colcon build --cmake-args -DCMAKE_BUILD_TYPE=Debug

To make common command line options easier to invoke this repository makes these ""shortcuts"" available.

To install the default colcon mixins, run the following:

.. code-block:: console

    colcon mixin add default https://raw.githubusercontent.com/colcon/colcon-mixin-repository/master/index.yaml
    colcon mixin update default

Then, try out using the ``debug`` mixin:

.. code-block:: console

    colcon build --mixin debug

For more details, see  the `colcon mixin repository <https://github.com/colcon/colcon-mixin-repository>`__.
","What is a recommended build type supported by colcon, according to the text?"
".. redirect-from::

    Tutorials/Writing-A-Simple-Py-Service-And-Client

.. _PySrvCli:

Writing a simple service and client (Python)
============================================

**Goal:** Create and run service and client nodes using Python.

**Tutorial level:** Beginner

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

When :doc:`nodes <../Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>` communicate using :doc:`services <../Beginner-CLI-Tools/Understanding-ROS2-Services/Understanding-ROS2-Services>`, the node that sends a request for data is called the client node, and the one that responds to the request is the service node.
The structure of the request and response is determined by a ``.srv`` file.

The example used here is a simple integer addition system; one node requests the sum of two integers, and the other responds with the result.

Prerequisites
-------------

In previous tutorials, you learned how to :doc:`create a workspace <./Creating-A-Workspace/Creating-A-Workspace>` and :doc:`create a package <./Creating-Your-First-ROS2-Package>`.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

Open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

Navigate into the ``ros2_ws`` directory created in a :ref:`previous tutorial <new-directory>`.

Recall that packages should be created in the ``src`` directory, not the root of the workspace.
Navigate into ``ros2_ws/src`` and create a new package:

.. code-block:: console

  ros2 pkg create --build-type ament_python --license Apache-2.0 py_srvcli --dependencies rclpy example_interfaces

Your terminal will return a message verifying the creation of your package ``py_srvcli`` and all its necessary files and folders.

The ``--dependencies`` argument will automatically add the necessary dependency lines to ``package.xml``.
``example_interfaces`` is the package that includes `the .srv file <https://github.com/ros2/example_interfaces/blob/{REPOS_FILE_BRANCH}/srv/AddTwoInts.srv>`__ you will need to structure your requests and responses:

.. code-block:: console

    int64 a
    int64 b
    ---
    int64 sum

The first two lines are the parameters of the request, and below the dashes is the response.

1.1 Update ``package.xml``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Because you used the ``--dependencies`` option during package creation, you don't have to manually add dependencies to ``package.xml``.

As always, though, make sure to add the description, maintainer email and name, and license information to ``package.xml``.

.. code-block:: xml

  <description>Python client server tutorial</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>

1.2 Update ``setup.py``
~~~~~~~~~~~~~~~~~~~~~~~

Add the same information to the ``setup.py`` file for the ``maintainer``, ``maintainer_email``, ``description`` and ``license`` fields:

.. code-block:: python

    maintainer='Your Name',
    maintainer_email='you@email.com',
    description='Python client server tutorial',
    license='Apache-2.0',

2 Write the service node
^^^^^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/py_srvcli/py_srvcli`` directory, create a new file called ``service_member_function.py`` and paste the following code within:

.. code-block:: python

  from example_interfaces.srv import AddTwoInts

  import rclpy
  from rclpy.executors import ExternalShutdownException
  from rclpy.node import Node


  class MinimalService(Node):

      def __init__(self):
          super().__init__('minimal_service')
          self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

      def add_two_ints_callback(self, request, response):
          response.sum = request.a + request.b
          self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))

          return response


  def main():
      try:
          with rclpy.init():
              minimal_service = MinimalService()

              rclpy.spin(minimal_service)
      except (KeyboardInterrupt, ExternalShutdownException):
          pass


  if __name__ == '__main__':
      main()

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

The first ``import`` statement imports the ``AddTwoInts`` service type from the ``example_interfaces`` package.
The following ``import`` statements import the necessary ROS 2 Python client library interfaces.

.. code-block:: python

  from example_interfaces.srv import AddTwoInts

  import rclpy
  from rclpy.executors import ExternalShutdownException
  from rclpy.node import Node

The ``MinimalService`` class constructor initializes the node with the name ``minimal_service``.
Then, it creates a service and defines the type, name, and callback.

.. code-block:: python

  def __init__(self):
      super().__init__('minimal_service')
      self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

The definition of the service callback receives the request data, sums it, and returns the sum as a response.

.. code-block:: python

  def add_two_ints_callback(self, request, response):
      response.sum = request.a + request.b
      self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))

      return response

Finally, the main class initializes the ROS 2 Python client library, instantiates the ``MinimalService`` class to create the service node and spins the node to handle callbacks.

2.2 Add an entry point
~~~~~~~~~~~~~~~~~~~~~~

To allow the ``ros2 run`` command to run your node, you must add the entry point to ``setup.py`` (located in the ``ros2_ws/src/py_srvcli`` directory).

Add the following line between the ``'console_scripts':`` brackets:

.. code-block:: python

  'service = py_srvcli.service_member_function:main',

3 Write the client node
^^^^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/py_srvcli/py_srvcli`` directory, create a new file called ``client_member_function.py`` and paste the following code within:

.. code-block:: python

  from example_interfaces.srv import AddTwoInts

  import rclpy
  from rclpy.executors import ExternalShutdownException
  from rclpy.node import Node


  class MinimalClientAsync(Node):

      def __init__(self):
          super().__init__('minimal_client_async')
          self.cli = self.create_client(AddTwoInts, 'add_two_ints')
          while not self.cli.wait_for_service(timeout_sec=1.0):
              self.get_logger().info('service not available, waiting again...')
          self.req = AddTwoInts.Request()

      def send_request(self):
          self.req.a = 41
          self.req.b = 1
          return self.cli.call_async(self.req)


  def main(args=None):
      try:
          with rclpy.init(args=args):
              minimal_client = MinimalClientAsync()
              future = minimal_client.send_request()
              rclpy.spin_until_future_complete(minimal_client, future)
              response = future.result()
              minimal_client.get_logger().info(
                  'Result of add_two_ints: for %d + %d = %d' %
                  (minimal_client.req.a, minimal_client.req.b, response.sum))
      except (KeyboardInterrupt, ExternalShutdownException):
          pass


  if __name__ == '__main__':
      main()


3.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

As with the service code, we first ``import`` the necessary libraries.

.. code-block:: python

  from example_interfaces.srv import AddTwoInts

  import rclpy
  from rclpy.executors import ExternalShutdownException
  from rclpy.node import Node

The ``MinimalClientAsync`` class constructor initializes the node with the name ``minimal_client_async``.
The constructor definition creates a client with the same type and name as the service node.
The type and name must match for the client and service to be able to communicate.
The ``while`` loop in the constructor checks if a service matching the type and name of the client is available once a second.
Finally it creates a new ``AddTwoInts`` request object.

.. code-block:: python

  def __init__(self):
      super().__init__('minimal_client_async')
      self.cli = self.create_client(AddTwoInts, 'add_two_ints')
      while not self.cli.wait_for_service(timeout_sec=1.0):
          self.get_logger().info('service not available, waiting again...')
      self.req = AddTwoInts.Request()

Below the constructor is the ``send_request`` method, which will send the request and spin until it receives the response or fails.

.. code-block:: python

  def send_request(self):
      self.req.a = 41
      self.req.b = 1
      return self.cli.call_async(self.req)

Finally we have the ``main`` method, which constructs a ``MinimalClientAsync`` object, sends the request using the passed-in command-line arguments, calls ``rclpy.spin_until_future_complete`` to wait for the result, and logs the results.

.. code-block:: python

  def main(args=None):
      try:
          with rclpy.init(args=args):
              minimal_client = MinimalClientAsync()
              future = minimal_client.send_request()
              rclpy.spin_until_future_complete(minimal_client, future)
              response = future.result()
              minimal_client.get_logger().info(
                  'Result of add_two_ints: for %d + %d = %d' %
                  (minimal_client.req.a, minimal_client.req.b, response.sum))
      except (KeyboardInterrupt, ExternalShutdownException):
          pass

.. warning::

  Do not use ``rclpy.spin_until_future_complete`` in a ROS 2 callback.
  For more details see the :doc:`sync deadlock article <../../../How-To-Guides/Sync-Vs-Async>`.

3.2 Add an entry point
~~~~~~~~~~~~~~~~~~~~~~

Like the service node, you also have to add an entry point to be able to run the client node.

The ``entry_points`` field of your ``setup.py`` file should look like this:

.. code-block:: python

  entry_points={
      'console_scripts': [
          'service = py_srvcli.service_member_function:main',
          'client = py_srvcli.client_member_function:main',
      ],
  },

4 Build and run
^^^^^^^^^^^^^^^

It's good practice to run ``rosdep`` in the root of your workspace (``ros2_ws``) to check for missing dependencies before building:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

            rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

      rosdep only runs on Linux, so you can skip ahead to next step.

   .. group-tab:: Windows

      rosdep only runs on Linux, so you can skip ahead to next step.


Navigate back to the root of your workspace, ``ros2_ws``, and build your new package:

.. code-block:: console

  colcon build --packages-select py_srvcli

Open a new terminal, navigate to ``ros2_ws``, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the service node:

.. code-block:: console

  ros2 run py_srvcli service

The node will wait for the client's request.

Open another terminal and source the setup files from inside ``ros2_ws`` again.
Start the client node:

.. code-block:: console

  ros2 run py_srvcli client

The client sends the request to the service, which computes the sum and returns the result.
The client should receive the following response:

.. code-block:: console

  [INFO] [minimal_client_async]: Result of add_two_ints: for 41 + 1 = 42

Return to the terminal where your service node is running.
You will see that it published log messages when it received the request:

.. code-block:: console

  [INFO] [minimal_service]: Incoming request
  a: 41 b: 1

Enter ``Ctrl+C`` in the server terminal to stop the node from spinning.


Summary
-------

You created two nodes to request and respond to data over a service.
You added their dependencies and executables to the package configuration files so that you could build and run them, allowing you to see a service/client system at work.

Next steps
----------

In the last few tutorials you've been utilizing interfaces to pass data across topics and services.
Next, you'll learn how to :doc:`create custom interfaces <./Custom-ROS2-Interfaces>`.

Related content
---------------

* There are several ways you could write a service and client in Python; check out the ``minimal_client`` and ``minimal_service`` packages in the `ros2/examples <https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclpy/services>`_ repo.

* In this tutorial, you used the ``call_async()`` API in your client node to call the service.
  There is another service call API available for Python called synchronous calls.
  We do not recommend using synchronous calls, but if you'd like to learn more about them, read the guide to :doc:`Synchronous vs. asynchronous clients <../../How-To-Guides/Sync-Vs-Async>`.
",What is the goal of creating a service and client nodes using Python as mentioned in the text document?
".. redirect-from::

    Tutorials/Custom-ROS2-Interfaces

.. _CustomInterfaces:

Creating custom msg and srv files
=================================

**Goal:** Define custom interface files (``.msg`` and ``.srv``) and use them with Python and C++ nodes.

**Tutorial level:** Beginner

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In previous tutorials you utilized message and service interfaces to learn about :doc:`topics <../Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics>`, :doc:`services <../Beginner-CLI-Tools/Understanding-ROS2-Services/Understanding-ROS2-Services>`, and simple publisher/subscriber (:doc:`C++ <./Writing-A-Simple-Cpp-Publisher-And-Subscriber>`/:doc:`Python<./Writing-A-Simple-Py-Publisher-And-Subscriber>`) and service/client (:doc:`C++ <./Writing-A-Simple-Cpp-Service-And-Client>`/:doc:`Python<./Writing-A-Simple-Py-Service-And-Client>`) nodes.
The interfaces you used were predefined in those cases.

While it's good practice to use predefined interface definitions, you will probably need to define your own messages and services sometimes as well.
This tutorial will introduce you to the simplest method of creating custom interface definitions.

Prerequisites
-------------

You should have a :doc:`ROS 2 workspace <./Creating-A-Workspace/Creating-A-Workspace>`.

This tutorial also uses the packages created in the publisher/subscriber (:doc:`C++ <./Writing-A-Simple-Cpp-Publisher-And-Subscriber>` and :doc:`Python<./Writing-A-Simple-Py-Publisher-And-Subscriber>`) and service/client  (:doc:`C++ <./Writing-A-Simple-Cpp-Service-And-Client>` and :doc:`Python<./Writing-A-Simple-Py-Service-And-Client>`) tutorials to try out the new custom messages.

Tasks
-----

1 Create a new package
^^^^^^^^^^^^^^^^^^^^^^^

For this tutorial you will be creating custom ``.msg`` and ``.srv`` files in their own package, and then utilizing them in a separate package.
Both packages should be in the same workspace.

Since we will use the pub/sub and service/client packages created in earlier tutorials, make sure you are in the same workspace as those packages (``ros2_ws/src``), and then run the following command to create a new package:

.. code-block:: console

  ros2 pkg create --build-type ament_cmake --license Apache-2.0 tutorial_interfaces

``tutorial_interfaces`` is the name of the new package.
Note that it is, and can only be, a CMake package, but this doesn't restrict in which type of packages you can use your messages and services.
You can create your own custom interfaces in a CMake package, and then use it in a C++ or Python node, which will be covered in the last section.

The ``.msg`` and ``.srv`` files are required to be placed in directories called ``msg`` and ``srv`` respectively.
Create the directories in ``ros2_ws/src/tutorial_interfaces``:

.. code-block:: console

  mkdir msg srv

2 Create custom definitions
^^^^^^^^^^^^^^^^^^^^^^^^^^^

2.1 msg definition
~~~~~~~~~~~~~~~~~~

In the ``tutorial_interfaces/msg`` directory you just created, make a new file called ``Num.msg`` with one line of code declaring its data structure:

.. code-block:: console

    int64 num

This is a custom message that transfers a single 64-bit integer called ``num``.

Also in the ``tutorial_interfaces/msg`` directory you just created, make a new file called ``Sphere.msg`` with the following content:

.. code-block:: console

    geometry_msgs/Point center
    float64 radius

This custom message uses a message from another message package (``geometry_msgs/Point`` in this case).

2.2 srv definition
~~~~~~~~~~~~~~~~~~

Back in the ``tutorial_interfaces/srv`` directory you just created, make a new file called ``AddThreeInts.srv`` with the following request and response structure:

.. code-block:: console

  int64 a
  int64 b
  int64 c
  ---
  int64 sum

This is your custom service that requests three integers named ``a``, ``b``, and ``c``, and responds with an integer called ``sum``.

3 ``CMakeLists.txt``
^^^^^^^^^^^^^^^^^^^^

To convert the interfaces you defined into language-specific code (like C++ and Python) so that they can be used in those languages, add the following lines to ``CMakeLists.txt``:

.. code-block:: cmake

  find_package(geometry_msgs REQUIRED)
  find_package(rosidl_default_generators REQUIRED)

  rosidl_generate_interfaces(${PROJECT_NAME}
    ""msg/Num.msg""
    ""msg/Sphere.msg""
    ""srv/AddThreeInts.srv""
    DEPENDENCIES geometry_msgs # Add packages that above messages depend on, in this case geometry_msgs for Sphere.msg
  )

.. note::

  The first argument (library name) in the rosidl_generate_interfaces must match ${PROJECT_NAME} (see https://github.com/ros2/rosidl/issues/441#issuecomment-591025515).

4 ``package.xml``
^^^^^^^^^^^^^^^^^

Because the interfaces rely on ``rosidl_default_generators`` for generating language-specific code, you need to declare a build tool dependency on it.
``rosidl_default_runtime`` is a runtime or execution-stage dependency, needed to be able to use the interfaces later.
The ``rosidl_interface_packages`` is the name of the dependency group that your package, ``tutorial_interfaces``, should be associated with, declared using the ``<member_of_group>`` tag.

Add the following lines within the ``<package>`` element of ``package.xml``:

.. code-block:: xml

  <depend>geometry_msgs</depend>
  <buildtool_depend>rosidl_default_generators</buildtool_depend>
  <exec_depend>rosidl_default_runtime</exec_depend>
  <member_of_group>rosidl_interface_packages</member_of_group>

5 Build the ``tutorial_interfaces`` package
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now that all the parts of your custom interfaces package are in place, you can build the package.
In the root of your workspace (``~/ros2_ws``), run the following command:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select tutorial_interfaces

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select tutorial_interfaces

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select tutorial_interfaces

Now the interfaces will be discoverable by other ROS 2 packages.

6 Confirm msg and srv creation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In a new terminal, run the following command from within your workspace (``ros2_ws``) to source it:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now you can confirm that your interface creation worked by using the ``ros2 interface show`` command:

.. code-block:: console

  ros2 interface show tutorial_interfaces/msg/Num

should return:

.. code-block:: console

    int64 num

And

.. code-block:: console

  ros2 interface show tutorial_interfaces/msg/Sphere

should return:

.. code-block:: console

    geometry_msgs/Point center
            float64 x
            float64 y
            float64 z
    float64 radius

And

.. code-block:: console

  ros2 interface show tutorial_interfaces/srv/AddThreeInts

should return:

.. code-block:: console

    int64 a
    int64 b
    int64 c
    ---
    int64 sum

7 Test the new interfaces
^^^^^^^^^^^^^^^^^^^^^^^^^

For this step you can use the packages you created in previous tutorials.
A few simple modifications to the nodes, ``CMakeLists.txt`` and ``package.xml`` files will allow you to use your new interfaces.

7.1 Testing ``Num.msg`` with pub/sub
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With a few modifications to the publisher/subscriber package created in a previous tutorial (:doc:`C++ <./Writing-A-Simple-Cpp-Publisher-And-Subscriber>` or :doc:`Python <./Writing-A-Simple-Py-Publisher-And-Subscriber>`), you can see ``Num.msg`` in action.
Since you'll be changing the standard string msg to a numerical one, the output will be slightly different.

**Publisher**

.. tabs::

  .. group-tab:: C++

    .. code-block:: c++

      #include <chrono>
      #include <memory>

      #include ""rclcpp/rclcpp.hpp""
      #include ""tutorial_interfaces/msg/num.hpp""                                            // CHANGE

      using namespace std::chrono_literals;

      class MinimalPublisher : public rclcpp::Node
      {
      public:
        MinimalPublisher()
        : Node(""minimal_publisher""), count_(0)
        {
          publisher_ = this->create_publisher<tutorial_interfaces::msg::Num>(""topic"", 10);  // CHANGE

          auto timer_callback = [this](){
            auto message = tutorial_interfaces::msg::Num();                                   // CHANGE
            message.num = this->count_++;                                                     // CHANGE
            RCLCPP_INFO_STREAM(this->get_logger(), ""Publishing: '"" << message.num << ""'"");    // CHANGE
            publisher_->publish(message);
          };
          timer_ = this->create_wall_timer(500ms, timer_callback);
        }

      private:
        rclcpp::TimerBase::SharedPtr timer_;
        rclcpp::Publisher<tutorial_interfaces::msg::Num>::SharedPtr publisher_;             // CHANGE
        size_t count_;
      };

      int main(int argc, char * argv[])
      {
        rclcpp::init(argc, argv);
        rclcpp::spin(std::make_shared<MinimalPublisher>());
        rclcpp::shutdown();
        return 0;
      }

  .. group-tab:: Python

    .. code-block:: python

      import rclpy
      from rclpy.executors import ExternalShutdownException
      from rclpy.node import Node

      from tutorial_interfaces.msg import Num                            # CHANGE


      class MinimalPublisher(Node):

          def __init__(self):
              super().__init__('minimal_publisher')
              self.publisher_ = self.create_publisher(Num, 'topic', 10)  # CHANGE
              timer_period = 0.5  # seconds
              self.timer = self.create_timer(timer_period, self.timer_callback)
              self.i = 0

          def timer_callback(self):
              msg = Num()                                                # CHANGE
              msg.num = self.i                                           # CHANGE
              self.publisher_.publish(msg)
              self.get_logger().info('Publishing: ""%d""' % msg.num)       # CHANGE
              self.i += 1


      def main(args=None):
          try:
              with rclpy.init(args=args):
                  minimal_publisher = MinimalPublisher()

                  rclpy.spin(minimal_publisher)
          except (KeyboardInterrupt, ExternalShutdownException):
              pass


      if __name__ == '__main__':
          main()


**Subscriber**

.. tabs::

  .. group-tab:: C++

    .. code-block:: c++

      #include <functional>
      #include <memory>

      #include ""rclcpp/rclcpp.hpp""
      #include ""tutorial_interfaces/msg/num.hpp""                                       // CHANGE

      using std::placeholders::_1;

      class MinimalSubscriber : public rclcpp::Node
      {
      public:
        MinimalSubscriber()
        : Node(""minimal_subscriber"")
        {
          auto topic_callback = [this](const tutorial_interfaces::msg::Num & msg){     // CHANGE
            RCLCPP_INFO_STREAM(this->get_logger(), ""I heard: '"" << msg.num << ""'"");    // CHANGE
          };
          subscription_ = this->create_subscription<tutorial_interfaces::msg::Num>(    // CHANGE
            ""topic"", 10, topic_callback);
        }

      private:
        rclcpp::Subscription<tutorial_interfaces::msg::Num>::SharedPtr subscription_;  // CHANGE
      };

      int main(int argc, char * argv[])
      {
        rclcpp::init(argc, argv);
        rclcpp::spin(std::make_shared<MinimalSubscriber>());
        rclcpp::shutdown();
        return 0;
      }

  .. group-tab:: Python

    .. code-block:: python

      import rclpy
      from rclpy.executors import ExternalShutdownException
      from rclpy.node import Node

      from tutorial_interfaces.msg import Num                        # CHANGE


      class MinimalSubscriber(Node):

          def __init__(self):
              super().__init__('minimal_subscriber')
              self.subscription = self.create_subscription(
                  Num,                                               # CHANGE
                  'topic',
                  self.listener_callback,
                  10)
              self.subscription  # prevent unused variable warning

          def listener_callback(self, msg):
              self.get_logger().info('I heard: ""%d""' % msg.num)  # CHANGE


      def main(args=None):
          try:
              with rclpy.init(args=args):
                  minimal_subscriber = MinimalSubscriber()

                  rclpy.spin(minimal_subscriber)
          except (KeyboardInterrupt, ExternalShutdownException):
              pass


      if __name__ == '__main__':
          main()


**CMakeLists.txt**

Add the following lines (C++ only):

.. code-block:: cmake

    #...

    find_package(ament_cmake REQUIRED)
    find_package(rclcpp REQUIRED)
    find_package(tutorial_interfaces REQUIRED)                      # CHANGE

    add_executable(talker src/publisher_member_function.cpp)
    ament_target_dependencies(talker rclcpp tutorial_interfaces)    # CHANGE

    add_executable(listener src/subscriber_member_function.cpp)
    ament_target_dependencies(listener rclcpp tutorial_interfaces)  # CHANGE

    install(TARGETS
      talker
      listener
      DESTINATION lib/${PROJECT_NAME})

    ament_package()


**package.xml**

Add the following line:

.. tabs::

  .. group-tab:: C++

    .. code-block:: c++

      <depend>tutorial_interfaces</depend>

  .. group-tab:: Python

    .. code-block:: python

      <exec_depend>tutorial_interfaces</exec_depend>


After making the above edits and saving all the changes, build the package:

.. tabs::

  .. group-tab:: C++

    On Linux/macOS:

    .. code-block:: console

      colcon build --packages-select cpp_pubsub

    On Windows:

    .. code-block:: console

      colcon build --merge-install --packages-select cpp_pubsub

  .. group-tab:: Python

    On Linux/macOS:

    .. code-block:: console

      colcon build --packages-select py_pubsub

    On Windows:

    .. code-block:: console

      colcon build --merge-install --packages-select py_pubsub

Then open two new terminals, source ``ros2_ws`` in each, and run:

.. tabs::

  .. group-tab:: C++

    .. code-block:: console

          ros2 run cpp_pubsub talker

    .. code-block:: console

          ros2 run cpp_pubsub listener

  .. group-tab:: Python

    .. code-block:: console

        ros2 run py_pubsub talker

    .. code-block:: console

        ros2 run py_pubsub listener

Since ``Num.msg`` relays only an integer, the talker should only be publishing integer values, as opposed to the string it published previously:

.. code-block:: console

    [INFO] [minimal_publisher]: Publishing: '0'
    [INFO] [minimal_publisher]: Publishing: '1'
    [INFO] [minimal_publisher]: Publishing: '2'


7.2 Testing ``AddThreeInts.srv`` with service/client
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With a few modifications to the service/client package created in a previous tutorial (:doc:`C++ <./Writing-A-Simple-Cpp-Service-And-Client>` or :doc:`Python <./Writing-A-Simple-Py-Service-And-Client>`), you can see ``AddThreeInts.srv`` in action.
Since you'll be changing the original two integer request srv to a three integer request srv, the output will be slightly different.

**Service**

.. tabs::

  .. group-tab:: C++

    .. code-block:: c++

      #include ""rclcpp/rclcpp.hpp""
      #include ""tutorial_interfaces/srv/add_three_ints.hpp""                                        // CHANGE

      #include <memory>

      void add(const std::shared_ptr<tutorial_interfaces::srv::AddThreeInts::Request> request,     // CHANGE
                std::shared_ptr<tutorial_interfaces::srv::AddThreeInts::Response>       response)  // CHANGE
      {
        response->sum = request->a + request->b + request->c;                                      // CHANGE
        RCLCPP_INFO(rclcpp::get_logger(""rclcpp""), ""Incoming request\na: %ld"" "" b: %ld"" "" c: %ld"",  // CHANGE
                      request->a, request->b, request->c);                                         // CHANGE
        RCLCPP_INFO(rclcpp::get_logger(""rclcpp""), ""sending back response: [%ld]"", (long int)response->sum);
      }

      int main(int argc, char **argv)
      {
        rclcpp::init(argc, argv);

        std::shared_ptr<rclcpp::Node> node = rclcpp::Node::make_shared(""add_three_ints_server"");   // CHANGE

        rclcpp::Service<tutorial_interfaces::srv::AddThreeInts>::SharedPtr service =               // CHANGE
          node->create_service<tutorial_interfaces::srv::AddThreeInts>(""add_three_ints"",  &add);   // CHANGE

        RCLCPP_INFO(rclcpp::get_logger(""rclcpp""), ""Ready to add three ints."");                     // CHANGE

        rclcpp::spin(node);
        rclcpp::shutdown();
      }

  .. group-tab:: Python

    .. code-block:: python

      from tutorial_interfaces.srv import AddThreeInts                                                           # CHANGE

      import rclpy
      from rclpy.executors import ExternalShutdownException
      from rclpy.node import Node


      class MinimalService(Node):

          def __init__(self):
              super().__init__('minimal_service')
              self.srv = self.create_service(AddThreeInts, 'add_three_ints', self.add_three_ints_callback)       # CHANGE

          def add_three_ints_callback(self, request, response):
              response.sum = request.a + request.b + request.c                                                   # CHANGE
              self.get_logger().info('Incoming request\na: %d b: %d c: %d' % (request.a, request.b, request.c))  # CHANGE

              return response

      def main(args=None):
          try:
              with rclpy.init(args=args):
                  minimal_service = MinimalService()

                  rclpy.spin(minimal_service)
          except (KeyboardInterrupt, ExternalShutdownException):
              pass


      if __name__ == '__main__':
          main()

**Client**

.. tabs::

  .. group-tab:: C++

    .. code-block:: c++

      #include ""rclcpp/rclcpp.hpp""
      #include ""tutorial_interfaces/srv/add_three_ints.hpp""                                       // CHANGE

      #include <chrono>
      #include <cstdlib>
      #include <memory>

      using namespace std::chrono_literals;

      int main(int argc, char **argv)
      {
        rclcpp::init(argc, argv);

        if (argc != 4) { // CHANGE
            RCLCPP_INFO(rclcpp::get_logger(""rclcpp""), ""usage: add_three_ints_client X Y Z"");      // CHANGE
            return 1;
        }

        std::shared_ptr<rclcpp::Node> node = rclcpp::Node::make_shared(""add_three_ints_client"");  // CHANGE
        rclcpp::Client<tutorial_interfaces::srv::AddThreeInts>::SharedPtr client =                // CHANGE
          node->create_client<tutorial_interfaces::srv::AddThreeInts>(""add_three_ints"");          // CHANGE

        auto request = std::make_shared<tutorial_interfaces::srv::AddThreeInts::Request>();       // CHANGE
        request->a = 41;
        request->b = 1;
        request->c = 1;                                                                           // CHANGE

        while (!client->wait_for_service(1s)) {
          if (!rclcpp::ok()) {
            RCLCPP_ERROR(rclcpp::get_logger(""rclcpp""), ""Interrupted while waiting for the service. Exiting."");
            return 0;
          }
          RCLCPP_INFO(rclcpp::get_logger(""rclcpp""), ""service not available, waiting again..."");
        }

        auto result = client->async_send_request(request);
        // Wait for the result.
        if (rclcpp::spin_until_future_complete(node, result) ==
          rclcpp::FutureReturnCode::SUCCESS)
        {
          RCLCPP_INFO(rclcpp::get_logger(""rclcpp""), ""Sum: %ld"", result.get()->sum);
        } else {
          RCLCPP_ERROR(rclcpp::get_logger(""rclcpp""), ""Failed to call service add_three_ints"");    // CHANGE
        }

        rclcpp::shutdown();
        return 0;
      }

  .. group-tab:: Python

    .. code-block:: python

      from tutorial_interfaces.srv import AddThreeInts                            # CHANGE

      import rclpy
      from rclpy.executors import ExternalShutdownException
      from rclpy.node import Node


      class MinimalClientAsync(Node):

          def __init__(self):
              super().__init__('minimal_client_async')
              self.cli = self.create_client(AddThreeInts, 'add_three_ints')       # CHANGE
              while not self.cli.wait_for_service(timeout_sec=1.0):
                  self.get_logger().info('service not available, waiting again...')
              self.req = AddThreeInts.Request()                                   # CHANGE

          def send_request(self):
              self.req.a = 41
              self.req.b = 1
              self.req.c = 1                                                      # CHANGE
              return self.cli.call_async(self.req)


      def main(args=None):
          try:
              with rclpy.init(args=args):
                  minimal_client = MinimalClientAsync()
                  future = minimal_client.send_request()
                  rclpy.spin_until_future_complete(minimal_client, future)
                  response = future.result()
                  minimal_client.get_logger().info(
                      'Result of add_three_ints: for %d + %d + %d = %d' %                                # CHANGE
                      (minimal_client.req.a, minimal_client.req.b, minimal_client.req.c, response.sum))  # CHANGE
          except (KeyboardInterrupt, ExternalShutdownException):
              pass


      if __name__ == '__main__':
          main()


**CMakeLists.txt**

Add the following lines (C++ only):

.. code-block:: cmake

    #...

    find_package(ament_cmake REQUIRED)
    find_package(rclcpp REQUIRED)
    find_package(tutorial_interfaces REQUIRED)         # CHANGE

    add_executable(server src/add_two_ints_server.cpp)
    ament_target_dependencies(server
      rclcpp tutorial_interfaces)                      # CHANGE

    add_executable(client src/add_two_ints_client.cpp)
    ament_target_dependencies(client
      rclcpp tutorial_interfaces)                      # CHANGE

    install(TARGETS
      server
      client
      DESTINATION lib/${PROJECT_NAME})

    ament_package()


**package.xml**

Add the following line:

.. tabs::

  .. group-tab:: C++

    .. code-block:: c++

      <depend>tutorial_interfaces</depend>

  .. group-tab:: Python

    .. code-block:: python

      <exec_depend>tutorial_interfaces</exec_depend>


After making the above edits and saving all the changes, build the package:

.. tabs::

  .. group-tab:: C++

    On Linux/macOS:

    .. code-block:: console

      colcon build --packages-select cpp_srvcli

    On Windows:

    .. code-block:: console

      colcon build --merge-install --packages-select cpp_srvcli


  .. group-tab:: Python

    On Linux/macOS:

    .. code-block:: console

      colcon build --packages-select py_srvcli

    On Windows:

    .. code-block:: console

      colcon build --merge-install --packages-select py_srvcli

Then open two new terminals, source ``ros2_ws`` in each, and run:

.. tabs::

  .. group-tab:: C++

    .. code-block:: console

          ros2 run cpp_srvcli server

    .. code-block:: console

          ros2 run cpp_srvcli client

  .. group-tab:: Python

    .. code-block:: console

        ros2 run py_srvcli service

    .. code-block:: console

        ros2 run py_srvcli client


Summary
-------

In this tutorial, you learned how to create custom interfaces in their own package and how to utilize those interfaces in other packages.

This tutorial only scratches the surface about defining custom interfaces.
You can learn more about it in :doc:`About ROS 2 interfaces <../../Concepts/Basic/About-Interfaces>`.

Next steps
----------

The :doc:`next tutorial <./Single-Package-Define-And-Use-Interface>` covers more ways to use interfaces in ROS 2.
",What is the purpose of creating custom interface files (`.msg` and `.srv`) in ROS 2 according to the given text?
".. redirect-from::

    Tutorials/Pluginlib

Creating and using plugins (C++)
================================

**Goal:** Learn to create and load a simple plugin using ``pluginlib``.

**Tutorial level:** Beginner

**Time:** 20 minutes

.. contents:: Contents
   :depth: 3
   :local:

Background
----------

This tutorial is derived from `<http://wiki.ros.org/pluginlib>`_ and `Writing and Using a Simple Plugin Tutorial <http://wiki.ros.org/pluginlib/Tutorials/Writing%20and%20Using%20a%20Simple%20Plugin>`_.

``pluginlib`` is a C++ library for loading and unloading plugins from within a ROS package.
Plugins are dynamically loadable classes that are loaded from a runtime library (i.e. shared object, dynamically linked library).
With pluginlib, you do not have to explicitly link your application against the library containing the classes -- instead ``pluginlib`` can open a library containing exported classes at any point without the application having any prior awareness of the library or the header file containing the class definition.
Plugins are useful for extending/modifying application behavior without needing the application source code.

Prerequisites
-------------

This tutorial assumes basic C++ knowledge and that you have successfully :doc:`installed ROS 2 <../../Installation>`.

Tasks
-----

In this tutorial, you will create two new packages, one that defines the base class, and another that provides the plugins.
The base class will define a generic polygon class, and then our plugins will define specific shapes.

1 Create the Base Class Package
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Create a new empty package in your ``ros2_ws/src`` folder with the following command:

.. code-block:: console

  ros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies pluginlib --node-name area_node polygon_base


Open your favorite editor, edit ``ros2_ws/src/polygon_base/include/polygon_base/regular_polygon.hpp``, and paste the following inside of it:

.. code-block:: C++

    #ifndef POLYGON_BASE_REGULAR_POLYGON_HPP
    #define POLYGON_BASE_REGULAR_POLYGON_HPP

    namespace polygon_base
    {
      class RegularPolygon
      {
        public:
          virtual void initialize(double side_length) = 0;
          virtual double area() = 0;
          virtual ~RegularPolygon(){}

        protected:
          RegularPolygon(){}
      };
    }  // namespace polygon_base

    #endif  // POLYGON_BASE_REGULAR_POLYGON_HPP

The code above creates an abstract class called ``RegularPolygon``.
One thing to notice is the presence of the initialize method.
With ``pluginlib``, a constructor without parameters is required, so if any parameters to the class are needed, we use the initialize method to pass them to the object.

We need to make this header available to other classes, so open ``ros2_ws/src/polygon_base/CMakeLists.txt`` for editing.
Add the following lines after the ``ament_target_dependencies`` command:

.. code-block:: cmake

    install(
      DIRECTORY include/
      DESTINATION include
    )

And add this command before the ``ament_package`` command:

.. code-block:: cmake

    ament_export_include_directories(
      include
    )

We will return to this package later to write our test node.

2 Create the Plugin Package
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now we're going to write two non-virtual implementations of our abstract class.
Create a second empty package in your ``ros2_ws/src`` folder with the following command:

.. code-block:: console

  ros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies polygon_base pluginlib --library-name polygon_plugins polygon_plugins

2.1 Source code for the plugins
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Open ``ros2_ws/src/polygon_plugins/src/polygon_plugins.cpp`` for editing, and paste the following inside of it:

.. code-block:: C++

    #include <polygon_base/regular_polygon.hpp>
    #include <cmath>

    namespace polygon_plugins
    {
      class Square : public polygon_base::RegularPolygon
      {
        public:
          void initialize(double side_length) override
          {
            side_length_ = side_length;
          }

          double area() override
          {
            return side_length_ * side_length_;
          }

        protected:
          double side_length_;
      };

      class Triangle : public polygon_base::RegularPolygon
      {
        public:
          void initialize(double side_length) override
          {
            side_length_ = side_length;
          }

          double area() override
          {
            return 0.5 * side_length_ * getHeight();
          }

          double getHeight()
          {
            return sqrt((side_length_ * side_length_) - ((side_length_ / 2) * (side_length_ / 2)));
          }

        protected:
          double side_length_;
      };
    }

    #include <pluginlib/class_list_macros.hpp>

    PLUGINLIB_EXPORT_CLASS(polygon_plugins::Square, polygon_base::RegularPolygon)
    PLUGINLIB_EXPORT_CLASS(polygon_plugins::Triangle, polygon_base::RegularPolygon)

The implementation of the Square and Triangle classes is fairly straightforward: save the side length, and use it to calculate the area.
The only piece that is pluginlib specific is the last three lines, which invokes some magical macros that register the classes as actual plugins.
Let's go through the arguments to the ``PLUGINLIB_EXPORT_CLASS`` macro:

1. The fully-qualified type of the plugin class, in this case, ``polygon_plugins::Square``.
2. The fully-qualified type of the base class, in this case, ``polygon_base::RegularPolygon``.

2.2 Plugin Declaration XML
~~~~~~~~~~~~~~~~~~~~~~~~~~

The steps above enable plugin instances to be created when the containing library is loaded, but the plugin loader still needs a way to find that library and to know what to reference within that library.
To this end, we'll also create an XML file that, along with a special export line in the package manifest, makes all the necessary information about our plugins available to the ROS toolchain.

Create ``ros2_ws/src/polygon_plugins/plugins.xml`` with the following code:

.. code-block:: XML

    <library path=""polygon_plugins"">
      <class type=""polygon_plugins::Square"" base_class_type=""polygon_base::RegularPolygon"">
        <description>This is a square plugin.</description>
      </class>
      <class type=""polygon_plugins::Triangle"" base_class_type=""polygon_base::RegularPolygon"">
        <description>This is a triangle plugin.</description>
      </class>
    </library>

A couple things to note:

1. The ``library`` tag gives the relative path to a library that contains the plugins that we want to export.
   In ROS 2, that is just the name of the library. In ROS 1, it contained the prefix ``lib`` or sometimes ``lib/lib`` (i.e. ``lib/libpolygon_plugins``), but here it is simpler.
2. The ``class`` tag declares a plugin that we want to export from our library.
   Let's go through its parameters:

  * ``type``: The fully qualified type of the plugin. For us, that's ``polygon_plugins::Square``.
  * ``base_class``: The fully qualified base class type for the plugin. For us, that's ``polygon_base::RegularPolygon``.
  * ``description``: A description of the plugin and what it does.

2.3 CMake Plugin Declaration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The last step is to export your plugins via ``CMakeLists.txt``.
This is a change from ROS 1, where the exporting was done via ``package.xml``.
Add the following line to your ``ros2_ws/src/polygon_plugins/CMakeLists.txt`` after the line reading ``find_package(pluginlib REQUIRED)``:

.. code-block:: cmake

    pluginlib_export_plugin_description_file(polygon_base plugins.xml)

The arguments to the ``pluginlib_export_plugin_description_file`` command are:

1. The package with the base class, i.e. ``polygon_base``.
2. The relative path to the Plugin Declaration xml, i.e. ``plugins.xml``.

3 Use the Plugins
^^^^^^^^^^^^^^^^^

Now it's time to use the plugins.
This can be done in any package, but here we're going to do it in the base package.
Edit ``ros2_ws/src/polygon_base/src/area_node.cpp`` to contain the following:

.. code-block:: C++

    #include <pluginlib/class_loader.hpp>
    #include <polygon_base/regular_polygon.hpp>

    int main(int argc, char** argv)
    {
      // To avoid unused parameter warnings
      (void) argc;
      (void) argv;

      pluginlib::ClassLoader<polygon_base::RegularPolygon> poly_loader(""polygon_base"", ""polygon_base::RegularPolygon"");

      try
      {
        std::shared_ptr<polygon_base::RegularPolygon> triangle = poly_loader.createSharedInstance(""polygon_plugins::Triangle"");
        triangle->initialize(10.0);

        std::shared_ptr<polygon_base::RegularPolygon> square = poly_loader.createSharedInstance(""polygon_plugins::Square"");
        square->initialize(10.0);

        printf(""Triangle area: %.2f\n"", triangle->area());
        printf(""Square area: %.2f\n"", square->area());
      }
      catch(pluginlib::PluginlibException& ex)
      {
        printf(""The plugin failed to load for some reason. Error: %s\n"", ex.what());
      }

      return 0;
    }

The ``ClassLoader`` is the key class to understand, defined in the ``class_loader.hpp`` `header file <https://github.com/ros/pluginlib/blob/ros2/pluginlib/include/pluginlib/class_loader.hpp>`_:

 * It is templated with the base class, i.e. ``polygon_base::RegularPolygon``.
 * The first argument is a string for the package name of the base class, i.e. ``polygon_base``.
 * The second argument is a string with the fully qualified base class type for the plugin, i.e. ``polygon_base::RegularPolygon``.

There are a number of ways to instantiate an instance of the class.
In this example, we're using shared pointers.
We just need to call ``createSharedInstance`` with the fully-qualified type of the plugin class, in this case, ``polygon_plugins::Square``.

Important note: the ``polygon_base`` package in which this node is defined does NOT depend on the ``polygon_plugins`` class.
The plugins will be loaded dynamically without any dependency needing to be declared.
Furthermore, we're instantiating the classes with hardcoded plugin names, but you can also do so dynamically with parameters, etc.

4 Build and run
^^^^^^^^^^^^^^^

Navigate back to the root of your workspace, ``ros2_ws``, and build your new packages:

.. code-block:: console

    colcon build --packages-select polygon_base polygon_plugins

From ``ros2_ws``, be sure to source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the node:

.. code-block:: console

     ros2 run polygon_base area_node

It should print:

.. code-block:: console

    Triangle area: 43.30
    Square area: 100.00

Summary
-------

Congratulations! You've just written and used your first plugins.
",What is the purpose of the `pluginlib` library in the context of creating and using plugins in C++ within a ROS package?
".. redirect-from::

    Tutorials/Writing-A-Simple-Cpp-Service-And-Client

.. _CppSrvCli:

Writing a simple service and client (C++)
=========================================

**Goal:** Create and run service and client nodes using C++.

**Tutorial level:** Beginner

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

When :doc:`nodes <../Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>` communicate using :doc:`services <../Beginner-CLI-Tools/Understanding-ROS2-Services/Understanding-ROS2-Services>`, the node that sends a request for data is called the client node, and the one that responds to the request is the service node.
The structure of the request and response is determined by a ``.srv`` file.

The example used here is a simple integer addition system; one node requests the sum of two integers, and the other responds with the result.


Prerequisites
-------------

In previous tutorials, you learned how to :doc:`create a workspace <./Creating-A-Workspace/Creating-A-Workspace>` and :doc:`create a package <./Creating-Your-First-ROS2-Package>`.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

Open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

Navigate into the ``ros2_ws`` directory created in a :ref:`previous tutorial <new-directory>`.

Recall that packages should be created in the ``src`` directory, not the root of the workspace.
Navigate into ``ros2_ws/src`` and create a new package:

.. code-block:: console

  ros2 pkg create --build-type ament_cmake --license Apache-2.0 cpp_srvcli --dependencies rclcpp example_interfaces

Your terminal will return a message verifying the creation of your package ``cpp_srvcli`` and all its necessary files and folders.

The ``--dependencies`` argument will automatically add the necessary dependency lines to ``package.xml`` and ``CMakeLists.txt``.
``example_interfaces`` is the package that includes `the .srv file <https://github.com/ros2/example_interfaces/blob/{REPOS_FILE_BRANCH}/srv/AddTwoInts.srv>`__ you will need to structure your requests and responses:

.. code-block:: console

  int64 a
  int64 b
  ---
  int64 sum

The first two lines are the parameters of the request, and below the dashes is the response.

1.1 Update ``package.xml``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Because you used the ``--dependencies`` option during package creation, you don't have to manually add dependencies to ``package.xml`` or ``CMakeLists.txt``.

As always, though, make sure to add the description, maintainer email and name, and license information to ``package.xml``.

.. code-block:: xml

  <description>C++ client server tutorial</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>


2 Write the service node
^^^^^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/cpp_srvcli/src`` directory, create a new file called ``add_two_ints_server.cpp`` and paste the following code within:

.. code-block:: C++

  #include <cinttypes>
  #include <memory>

  #include ""example_interfaces/srv/add_two_ints.hpp""
  #include ""rclcpp/rclcpp.hpp""

  using AddTwoInts = example_interfaces::srv::AddTwoInts;
  rclcpp::Node::SharedPtr g_node = nullptr;

  void handle_service(
    const std::shared_ptr<rmw_request_id_t> request_header,
    const std::shared_ptr<AddTwoInts::Request> request,
    const std::shared_ptr<AddTwoInts::Response> response)
  {
    (void)request_header;
    RCLCPP_INFO(
      g_node->get_logger(),
      ""request: %"" PRId64 "" + %"" PRId64, request->a, request->b);
    response->sum = request->a + request->b;
  }

  int main(int argc, char ** argv)
  {
    rclcpp::init(argc, argv);
    g_node = rclcpp::Node::make_shared(""minimal_service"");
    auto server = g_node->create_service<AddTwoInts>(""add_two_ints"", handle_service);
    rclcpp::spin(g_node);
    rclcpp::shutdown();
    g_node = nullptr;
    return 0;
  }

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

The first ``#include`` statements are your package dependencies.

The ``handle_service`` function adds two integers from the request and gives the sum to the response, while notifying the console of its status using logs.

.. code-block:: C++

  void handle_service(
    const std::shared_ptr<rmw_request_id_t> request_header,
    const std::shared_ptr<AddTwoInts::Request> request,
    const std::shared_ptr<AddTwoInts::Response> response)
  {
    (void)request_header;
    RCLCPP_INFO(
      g_node->get_logger(),
      ""request: %"" PRId64 "" + %"" PRId64, request->a, request->b);
    response->sum = request->a + request->b;
  }

The ``main`` function accomplishes the following, line by line:

* Initializes ROS 2 C++ client library:

  .. code-block:: C++

    rclcpp::init(argc, argv);

* Creates a node named ``minimal_service``:

  .. code-block:: C++

    g_node = rclcpp::Node::make_shared(""minimal_service"");

* Creates a service named ``add_two_ints`` for that node and automatically advertises it over the networks with the ``handle_service`` method:

  .. code-block:: C++

    auto server = g_node->create_service<AddTwoInts>(""add_two_ints"", handle_service);

* Spins the node, making the service available.

  .. code-block:: C++

    rclcpp::spin(g_node);

2.2 Add executable
~~~~~~~~~~~~~~~~~~

The ``add_executable`` macro generates an executable you can run using ``ros2 run``.
Add the following code block to ``CMakeLists.txt`` to create an executable named ``server``:

.. code-block:: console

  add_executable(server src/add_two_ints_server.cpp)
  ament_target_dependencies(server rclcpp example_interfaces)

So ``ros2 run`` can find the executable, add the following lines to the end of the file, right before ``ament_package()``:

.. code-block:: console

  install(TARGETS
      server
    DESTINATION lib/${PROJECT_NAME})

You could build your package now, source the local setup files, and run it, but let's create the client node first so you can see the full system at work.

3 Write the client node
^^^^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/cpp_srvcli/src`` directory, create a new file called ``add_two_ints_client.cpp`` and paste the following code within:

.. code-block:: C++

  #include <chrono>
  #include <cinttypes>
  #include <memory>

  #include ""example_interfaces/srv/add_two_ints.hpp""
  #include ""rclcpp/rclcpp.hpp""

  using AddTwoInts = example_interfaces::srv::AddTwoInts;

  int main(int argc, char * argv[])
  {
    rclcpp::init(argc, argv);
    auto node = rclcpp::Node::make_shared(""minimal_client"");
    auto client = node->create_client<AddTwoInts>(""add_two_ints"");
    while (!client->wait_for_service(std::chrono::seconds(1))) {
      if (!rclcpp::ok()) {
        RCLCPP_ERROR(node->get_logger(), ""client interrupted while waiting for service to appear."");
        return 1;
      }
      RCLCPP_INFO(node->get_logger(), ""waiting for service to appear..."");
    }
    auto request = std::make_shared<AddTwoInts::Request>();
    request->a = 41;
    request->b = 1;
    auto result_future = client->async_send_request(request);
    if (rclcpp::spin_until_future_complete(node, result) ==
      rclcpp::FutureReturnCode::SUCCESS)
    {
      RCLCPP_ERROR(node->get_logger(), ""service call failed :("");
      client->remove_pending_request(result_future);
      return 1;
    }
    auto result = result_future.get();
    RCLCPP_INFO(
      node->get_logger(), ""result of %"" PRId64 "" + %"" PRId64 "" = %"" PRId64,
      request->a, request->b, result->sum);
    rclcpp::shutdown();
    return 0;
  }


3.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

Similar to the service node, the following lines of code create the node and then create the client for that node:

.. code-block:: C++

  auto node = rclcpp::Node::make_shared(""minimal_client"");
  auto client = node->create_client<AddTwoInts>(""add_two_ints"");

Next, the code waits for the service to appear.
The ``while`` loop gives the client 1 second to search for service nodes in the network.
If it can't find any, it will continue waiting.
If the client is canceled (e.g. by you entering ``Ctrl+C`` into the terminal), it will return an error log message stating it was interrupted.

.. code-block:: C++

  while (!client->wait_for_service(std::chrono::seconds(1))) {
    if (!rclcpp::ok()) {
      RCLCPP_ERROR(node->get_logger(), ""client interrupted while waiting for service to appear."");
      return 1;
    }
    RCLCPP_INFO(node->get_logger(), ""waiting for service to appear..."");
  }

Next, the request is created.
Its structure is defined by the ``.srv`` file mentioned earlier.

.. code-block:: C++

  auto request = std::make_shared<example_interfaces::srv::AddTwoInts::Request>();
  request->a = 41;
  request->b = 1;


Then the client sends its request, and the node spins until it receives its response, or fails.

3.2 Add executable
~~~~~~~~~~~~~~~~~~

Return to ``CMakeLists.txt`` to add the executable and target for the new node.
After removing some unnecessary boilerplate from the automatically generated file, your ``CMakeLists.txt`` should look like this:

.. code-block:: console

  cmake_minimum_required(VERSION 3.5)
  project(cpp_srvcli)

  find_package(ament_cmake REQUIRED)
  find_package(rclcpp REQUIRED)
  find_package(example_interfaces REQUIRED)

  add_executable(server src/add_two_ints_server.cpp)
  ament_target_dependencies(server rclcpp example_interfaces)

  add_executable(client src/add_two_ints_client.cpp)
  ament_target_dependencies(client rclcpp example_interfaces)

  install(TARGETS
    server
    client
    DESTINATION lib/${PROJECT_NAME})

  ament_package()


4 Build and run
^^^^^^^^^^^^^^^

It's good practice to run ``rosdep`` in the root of your workspace (``ros2_ws``) to check for missing dependencies before building:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      rosdep install -i --from-path src --rosdistro {DISTRO} -y

  .. group-tab:: macOS

      rosdep only runs on Linux, so you can skip ahead to next step.

  .. group-tab:: Windows

      rosdep only runs on Linux, so you can skip ahead to next step.


Navigate back to the root of your workspace, ``ros2_ws``, and build your new package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select cpp_srvcli

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select cpp_srvcli

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select cpp_srvcli

Open a new terminal, navigate to ``ros2_ws``, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the service node:

.. code-block:: console

  ros2 run cpp_srvcli server

The terminal should wait for incoming requests.

Open another terminal, source the setup files from inside ``ros2_ws`` again.
Start the client node, followed by any two integers separated by a space:

.. code-block:: console

  ros2 run cpp_srvcli client

The client sends the request to the service, which computes the sum and returns the result.
The client should receive the following response:

.. code-block:: console

  [INFO] [minimal_client]: result of 41 + 1: 42

Return to the terminal where your service node is running.
You will see that it published log messages when it received the request and the data it received, and the response it sent back:

.. code-block:: console

  [INFO] [minimal_service]: request: 41 + 1

Enter ``Ctrl+C`` in the server terminal to stop the node from spinning.

Summary
-------

You created two nodes to request and respond to data over a service.
You added their dependencies and executables to the package configuration files so that you could build and run them, and see a service/client system at work.

Next steps
----------

In the last few tutorials you've been utilizing interfaces to pass data across topics and services.
Next, you'll learn how to :doc:`create custom interfaces <./Custom-ROS2-Interfaces>`.

Related content
---------------

* There are several ways you could write a service and client in C++; check out the ``minimal_service`` and ``minimal_client`` packages in the `ros2/examples <https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclcpp/services>`_ repo.
",What is the purpose of the client and service nodes in a communication setup using services in ROS 2?
".. redirect-from::

    Tutorials/Using-Parameters-In-A-Class-CPP

.. _CppParamNode:

Using parameters in a class (C++)
=================================

**Goal:** Create and run a class with ROS parameters using C++.

**Tutorial level:** Beginner

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

When making your own :doc:`nodes <../Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>` you will sometimes need to add parameters that can be set from the launch file.

This tutorial will show you how to create those parameters in a C++ class, and how to set them in a launch file.

Prerequisites
-------------

In previous tutorials, you learned how to :doc:`create a workspace <./Creating-A-Workspace/Creating-A-Workspace>` and :doc:`create a package <./Creating-Your-First-ROS2-Package>`.
You have also learned about :doc:`parameters <../Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters>` and their function in a ROS 2 system.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

Open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

Follow :ref:`these instructions <new-directory>` to create a new workspace named ``ros2_ws``.

Recall that packages should be created in the ``src`` directory, not the root of the workspace.
Navigate into ``ros2_ws/src`` and create a new package:

.. code-block:: console

  ros2 pkg create --build-type ament_cmake --license Apache-2.0 cpp_parameters --dependencies rclcpp

Your terminal will return a message verifying the creation of your package ``cpp_parameters`` and all its necessary files and folders.

The ``--dependencies`` argument will automatically add the necessary dependency lines to ``package.xml`` and ``CMakeLists.txt``.

1.1 Update ``package.xml``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Because you used the ``--dependencies`` option during package creation, you don't have to manually add dependencies to ``package.xml`` or ``CMakeLists.txt``.

As always, though, make sure to add the description, maintainer email and name, and license information to ``package.xml``.

.. code-block:: xml

  <description>C++ parameter tutorial</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>

2 Write the C++ node
^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/cpp_parameters/src`` directory, create a new file called ``cpp_parameters_node.cpp`` and paste the following code within:

.. code-block:: C++

    #include <chrono>
    #include <functional>
    #include <string>

    #include <rclcpp/rclcpp.hpp>

    using namespace std::chrono_literals;

    class MinimalParam : public rclcpp::Node
    {
    public:
      MinimalParam()
      : Node(""minimal_param_node"")
      {
        this->declare_parameter(""my_parameter"", ""world"");

        auto timer_callback = [this](){
          std::string my_param = this->get_parameter(""my_parameter"").as_string();

          RCLCPP_INFO(this->get_logger(), ""Hello %s!"", my_param.c_str());

          std::vector<rclcpp::Parameter> all_new_parameters{rclcpp::Parameter(""my_parameter"", ""world"")};
          this->set_parameters(all_new_parameters);
        };
        timer_ = this->create_wall_timer(1000ms, timer_callback);
      }

    private:
      rclcpp::TimerBase::SharedPtr timer_;
    };

    int main(int argc, char ** argv)
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<MinimalParam>());
      rclcpp::shutdown();
      return 0;
    }

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~
The ``#include`` statements at the top are the package dependencies.

The next piece of code creates the class and the constructor.
The first line of this constructor creates a parameter with the name ``my_parameter`` and a default value of ``world``.
The parameter type is inferred from the default value, so in this case it would be set to a string type.
Next, a `lambda function <https://en.cppreference.com/w/cpp/language/lambda>`_ called ``timer_callback`` is declared.
It performs a by-reference capture of the current object ``this``, takes no input arguments and returns void.
The first line of our ``timer_callback`` function gets the parameter ``my_parameter`` from the node, and stores it in ``my_param``.
Then the ``RCLCPP_INFO`` function ensures the event is logged.
The ``set_parameters`` function sets the parameter ``my_parameter`` back to the default string value ``world``.
In the case that the user changed the parameter externally, this ensures it is always reset back to the original.
In the end, ``timer_`` is initialized with a period of 1000ms, which causes the ``timer_callback`` function to be executed once a second.

.. code-block:: C++

    class MinimalParam : public rclcpp::Node
    {
    public:
      MinimalParam()
      : Node(""minimal_param_node"")
      {
        this->declare_parameter(""my_parameter"", ""world"");

        auto timer_callback = [this](){
          std::string my_param = this->get_parameter(""my_parameter"").as_string();

          RCLCPP_INFO(this->get_logger(), ""Hello %s!"", my_param.c_str());

          std::vector<rclcpp::Parameter> all_new_parameters{rclcpp::Parameter(""my_parameter"", ""world"")};
          this->set_parameters(all_new_parameters);
        };
        timer_ = this->create_wall_timer(1000ms, timer_callback);
      }

Last is the declaration of ``timer_``.

.. code-block:: C++

    private:
      rclcpp::TimerBase::SharedPtr timer_;

Following our ``MinimalParam`` is our ``main``.
Here ROS 2 is initialized, an instance of the ``MinimalParam`` class is constructed, and ``rclcpp::spin`` starts processing data from the node.

.. code-block:: C++

    int main(int argc, char ** argv)
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<MinimalParam>());
      rclcpp::shutdown();
      return 0;
    }

2.1.1 (Optional) Add ParameterDescriptor
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Optionally, you can set a descriptor for the parameter.
Descriptors allow you to specify a text description of the parameter and its constraints, like making it read-only, specifying a range, etc.
For that to work, the code in the constructor has to be changed to:

.. code-block:: C++

    // ...

    class MinimalParam : public rclcpp::Node
    {
    public:
      MinimalParam()
      : Node(""minimal_param_node"")
      {
        auto param_desc = rcl_interfaces::msg::ParameterDescriptor{};
        param_desc.description = ""This parameter is mine!"";

        this->declare_parameter(""my_parameter"", ""world"", param_desc);

        auto timer_callback = [this](){
          std::string my_param = this->get_parameter(""my_parameter"").as_string();

          RCLCPP_INFO(this->get_logger(), ""Hello %s!"", my_param.c_str());

          std::vector<rclcpp::Parameter> all_new_parameters{rclcpp::Parameter(""my_parameter"", ""world"")};
          this->set_parameters(all_new_parameters);
        };
        timer_ = this->create_wall_timer(1000ms, timer_callback);

      }

The rest of the code remains the same.
Once you run the node, you can then run ``ros2 param describe /minimal_param_node my_parameter`` to see the type and description.


2.2 Add executable
~~~~~~~~~~~~~~~~~~

Now open the ``CMakeLists.txt`` file. Below the dependency ``find_package(rclcpp REQUIRED)`` add the following lines of code.

.. code-block:: cmake

    add_executable(minimal_param_node src/cpp_parameters_node.cpp)
    ament_target_dependencies(minimal_param_node rclcpp)

    install(TARGETS
        minimal_param_node
      DESTINATION lib/${PROJECT_NAME}
    )


3 Build and run
^^^^^^^^^^^^^^^

It's good practice to run ``rosdep`` in the root of your workspace (``ros2_ws``) to check for missing dependencies before building:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

      rosdep only runs on Linux, so you can skip ahead to next step.

   .. group-tab:: Windows

      rosdep only runs on Linux, so you can skip ahead to next step.

Navigate back to the root of your workspace, ``ros2_ws``, and build your new package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select cpp_parameters

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select cpp_parameters

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select cpp_parameters

Open a new terminal, navigate to ``ros2_ws``, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the node:

.. code-block:: console

     ros2 run cpp_parameters minimal_param_node

The terminal should return the following message every second:

.. code-block:: console

    [INFO] [minimal_param_node]: Hello world!

Now you can see the default value of your parameter, but you want to be able to set it yourself.
There are two ways to accomplish this.

3.1 Change via the console
~~~~~~~~~~~~~~~~~~~~~~~~~~

This part will use the knowledge you have gained from the :doc:`tutorial about parameters <../Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters>` and apply it to the node you have just created.

Make sure the node is running:

.. code-block:: console

     ros2 run cpp_parameters minimal_param_node

Open another terminal, source the setup files from inside ``ros2_ws`` again, and enter the following line:

.. code-block:: console

    ros2 param list

There you will see the custom parameter ``my_parameter``.
To change it, simply run the following line in the console:

.. code-block:: console

    ros2 param set /minimal_param_node my_parameter earth

You know it went well if you got the output ``Set parameter successful``.
If you look at the other terminal, you should see the output change to ``[INFO] [minimal_param_node]: Hello earth!``

3.2 Change via a launch file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
You can also set the parameter in a launch file, but first you will need to add the launch directory.
Inside the ``ros2_ws/src/cpp_parameters/`` directory, create a new directory called ``launch``.
In there, create a new file called ``cpp_parameters_launch.py``


.. code-block:: Python

  from launch import LaunchDescription
  from launch_ros.actions import Node

  def generate_launch_description():
      return LaunchDescription([
          Node(
              package=""cpp_parameters"",
              executable=""minimal_param_node"",
              name=""custom_minimal_param_node"",
              output=""screen"",
              emulate_tty=True,
              parameters=[
                  {""my_parameter"": ""earth""}
              ]
          )
      ])

Here you can see that we set ``my_parameter`` to ``earth`` when we launch our node ``minimal_param_node``.
By adding the two lines below, we ensure our output is printed in our console.

.. code-block:: console

          output=""screen"",
          emulate_tty=True,

Now open the ``CMakeLists.txt`` file.
Below the lines you added earlier, add the following lines of code.

.. code-block:: console

    install(
      DIRECTORY launch
      DESTINATION share/${PROJECT_NAME}
    )

Open a console and navigate to the root of your workspace, ``ros2_ws``, and build your new package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select cpp_parameters

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select cpp_parameters

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select cpp_parameters

Then source the setup files in a new terminal:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the node using the launch file we have just created:

.. code-block:: console

     ros2 launch cpp_parameters cpp_parameters_launch.py

The terminal should return the following message the first time:

.. code-block:: console

    [INFO] [custom_minimal_param_node]: Hello earth!

Further outputs should show  ``[INFO] [minimal_param_node]: Hello world!`` every second.

Summary
-------

You created a node with a custom parameter that can be set either from a launch file or the command line.
You added the dependencies, executables, and a launch file to the package configuration files so that you could build and run them, and see the parameter in action.

Next steps
----------

Now that you have some packages and ROS 2 systems of your own, the :doc:`next tutorial <./Getting-Started-With-Ros2doctor>` will show you how to examine issues in your environment and systems in case you have problems.
",What steps are involved in creating a C++ class with ROS parameters and setting them in a launch file?
".. redirect-from::

    Tutorials/Using-Parameters-In-A-Class-Python

.. _PythonParamNode:

Using parameters in a class (Python)
====================================

**Goal:** Create and run a class with ROS parameters using Python.

**Tutorial level:** Beginner

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

When making your own :doc:`nodes <../Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes>` you will sometimes need to add parameters that can be set from the launch file.

This tutorial will show you how to create those parameters in a Python class, and how to set them in a launch file.

Prerequisites
-------------

In previous tutorials, you learned how to :doc:`create a workspace <./Creating-A-Workspace/Creating-A-Workspace>` and :doc:`create a package <./Creating-Your-First-ROS2-Package>`.
You have also learned about :doc:`parameters <../Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters>` and their function in a ROS 2 system.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

Open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

Follow :ref:`these instructions <new-directory>` to create a new workspace named ``ros2_ws``.

Recall that packages should be created in the ``src`` directory, not the root of the workspace.
Navigate into ``ros2_ws/src`` and create a new package:

.. code-block:: console

  ros2 pkg create --build-type ament_python --license Apache-2.0 python_parameters --dependencies rclpy

Your terminal will return a message verifying the creation of your package ``python_parameters`` and all its necessary files and folders.

The ``--dependencies`` argument will automatically add the necessary dependency lines to ``package.xml`` and ``CMakeLists.txt``.

1.1 Update ``package.xml``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Because you used the ``--dependencies`` option during package creation, you don't have to manually add dependencies to ``package.xml`` or ``CMakeLists.txt``.

As always, though, make sure to add the description, maintainer email and name, and license information to ``package.xml``.

.. code-block:: xml

  <description>Python parameter tutorial</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>

2 Write the Python node
^^^^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/python_parameters/python_parameters`` directory, create a new file called ``python_parameters_node.py`` and paste the following code within:

.. code-block:: Python

    import rclpy
    from rclpy.executors import ExternalShutdownException
    import rclpy.node

    class MinimalParam(rclpy.node.Node):
        def __init__(self):
            super().__init__('minimal_param_node')

            self.declare_parameter('my_parameter', 'world')

            self.timer = self.create_timer(1, self.timer_callback)

        def timer_callback(self):
            my_param = self.get_parameter('my_parameter').get_parameter_value().string_value

            self.get_logger().info('Hello %s!' % my_param)

            my_new_param = rclpy.parameter.Parameter(
                'my_parameter',
                rclpy.Parameter.Type.STRING,
                'world'
            )
            all_new_parameters = [my_new_param]
            self.set_parameters(all_new_parameters)

    def main():
        try:
            with rclpy.init():
                node = MinimalParam()
                rclpy.spin(node)
        except (KeyboardInterrupt, ExternalShutdownException):
            pass

    if __name__ == '__main__':
        main()



2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~
The ``import`` statements at the top are used to import the package dependencies.

The next piece of code creates the class and the constructor.
The line ``self.declare_parameter('my_parameter', 'world')`` of the constructor creates a parameter with the name ``my_parameter`` and a default value of ``world``.
The parameter type is inferred from the default value, so in this case it would be set to a string type.
Next the ``timer`` is initialized with a period of 1, which causes the ``timer_callback`` function to be executed once a second.

.. code-block:: Python

    class MinimalParam(rclpy.node.Node):
        def __init__(self):
            super().__init__('minimal_param_node')

            self.declare_parameter('my_parameter', 'world')

            self.timer = self.create_timer(1, self.timer_callback)

The first line of our ``timer_callback`` function gets the parameter ``my_parameter`` from the node, and stores it in ``my_param``.
Next the ``get_logger`` function ensures the event is logged.
The ``set_parameters`` function then sets the parameter ``my_parameter`` back to the default string value ``world``.
In the case that the user changed the parameter externally, this ensures it is always reset back to the original.

.. code-block:: Python

      def timer_callback(self):
          my_param = self.get_parameter('my_parameter').get_parameter_value().string_value

          self.get_logger().info('Hello %s!' % my_param)

          my_new_param = rclpy.parameter.Parameter(
              'my_parameter',
              rclpy.Parameter.Type.STRING,
              'world'
          )
          all_new_parameters = [my_new_param]
          self.set_parameters(all_new_parameters)

Following the ``timer_callback`` is our ``main``.
Here ROS 2 is initialized, an instance of the ``MinimalParam`` class is constructed, and ``rclpy.spin`` starts processing data from the node.

.. code-block:: Python

    def main():
        try:
            with rclpy.init():
                node = MinimalParam()
                rclpy.spin(node)
        except (KeyboardInterrupt, ExternalShutdownException):
            pass

    if __name__ == '__main__':
        main()


2.1.1 (Optional) Add ParameterDescriptor
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Optionally, you can set a descriptor for the parameter.
Descriptors allow you to specify a text description of the parameter and its constraints, like making it read-only, specifying a range, etc.
For that to work, the ``__init__`` code has to be changed to:

.. code-block:: Python

    # ...

    class MinimalParam(rclpy.node.Node):
        def __init__(self):
            super().__init__('minimal_param_node')

            from rcl_interfaces.msg import ParameterDescriptor
            my_parameter_descriptor = ParameterDescriptor(description='This parameter is mine!')

            self.declare_parameter('my_parameter', 'world', my_parameter_descriptor)

            self.timer = self.create_timer(1, self.timer_callback)


The rest of the code remains the same.
Once you run the node, you can then run ``ros2 param describe /minimal_param_node my_parameter`` to see the type and description.

2.2 Add an entry point
~~~~~~~~~~~~~~~~~~~~~~

Open the ``setup.py`` file.
Again, match the ``maintainer``, ``maintainer_email``, ``description`` and ``license`` fields to your ``package.xml``:

.. code-block:: python

  maintainer='YourName',
  maintainer_email='you@email.com',
  description='Python parameter tutorial',
  license='Apache-2.0',

Add the following line within the ``console_scripts`` brackets of the ``entry_points`` field:

.. code-block:: python

  entry_points={
      'console_scripts': [
          'minimal_param_node = python_parameters.python_parameters_node:main',
      ],
  },

Don't forget to save.


3 Build and run
^^^^^^^^^^^^^^^

It's good practice to run ``rosdep`` in the root of your workspace (``ros2_ws``) to check for missing dependencies before building:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

      rosdep only runs on Linux, so you can skip ahead to next step.

   .. group-tab:: Windows

      rosdep only runs on Linux, so you can skip ahead to next step.

Navigate back to the root of your workspace, ``ros2_ws``, and build your new package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select python_parameters

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select python_parameters

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select python_parameters

Open a new terminal, navigate to ``ros2_ws``, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the node:

.. code-block:: console

     ros2 run python_parameters minimal_param_node

The terminal should return the following message every second:

.. code-block:: console

    [INFO] [parameter_node]: Hello world!

Now you can see the default value of your parameter, but you want to be able to set it yourself.
There are two ways to accomplish this.

3.1 Change via the console
~~~~~~~~~~~~~~~~~~~~~~~~~~

This part will use the knowledge you have gained from the :doc:`tutoral about parameters <../Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters>` and apply it to the node you have just created.

Make sure the node is running:

.. code-block:: console

     ros2 run python_parameters minimal_param_node

Open another terminal, source the setup files from inside ``ros2_ws`` again, and enter the following line:

.. code-block:: console

    ros2 param list

There you will see the custom parameter ``my_parameter``.
To change it, simply run the following line in the console:

.. code-block:: console

    ros2 param set /minimal_param_node my_parameter earth

You know it went well if you get the output ``Set parameter successful``.
If you look at the other terminal, you should see the output change to ``[INFO] [minimal_param_node]: Hello earth!``

Since the node afterwards set the parameter back to ``world``, further outputs show  ``[INFO] [minimal_param_node]: Hello world!``

3.2 Change via a launch file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also set parameters in a launch file, but first you will need to add a launch directory.
Inside the ``ros2_ws/src/python_parameters/`` directory, create a new directory called ``launch``.
In there, create a new file called ``python_parameters_launch.py``

.. code-block:: Python

  from launch import LaunchDescription
  from launch_ros.actions import Node

  def generate_launch_description():
      return LaunchDescription([
          Node(
              package='python_parameters',
              executable='minimal_param_node',
              name='custom_minimal_param_node',
              output='screen',
              emulate_tty=True,
              parameters=[
                  {'my_parameter': 'earth'}
              ]
          )
      ])

Here you can see that we set ``my_parameter`` to ``earth`` when we launch our node ``parameter_node``.
By adding the two lines below, we ensure our output is printed in our console.

.. code-block:: console

          output=""screen"",
          emulate_tty=True,

Now open the ``setup.py`` file.
Add the ``import`` statements to the top of the file, and the other new statement to the ``data_files`` parameter to include all launch files:

.. code-block:: Python

    import os
    from glob import glob
    # ...

    setup(
      # ...
      data_files=[
          # ...
          (os.path.join('share', package_name), glob('launch/*launch.[pxy][yma]*')),
        ]
      )

Open a console and navigate to the root of your workspace, ``ros2_ws``, and build your new package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build --packages-select python_parameters

  .. group-tab:: macOS

    .. code-block:: console

      colcon build --packages-select python_parameters

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install --packages-select python_parameters

Then source the setup files in a new terminal:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the node using the launch file we have just created:

.. code-block:: console

     ros2 launch python_parameters python_parameters_launch.py

The terminal should return the following message the first time:

.. code-block:: console

    [INFO] [custom_minimal_param_node]: Hello earth!

Further outputs should show  ``[INFO] [minimal_param_node]: Hello world!`` every second.

Summary
-------

You created a node with a custom parameter that can be set either from a launch file or the command line.
You added the dependencies, executables, and a launch file to the package configuration files so that you could build and run them, and see the parameter in action.

Next steps
----------

Now that you have some packages and ROS 2 systems of your own, the :doc:`next tutorial <./Getting-Started-With-Ros2doctor>` will show you how to examine issues in your environment and systems in case you have problems.
","How can you change the value of the custom parameter ""my_parameter"" in the Python node without recreating the node itself?"
".. redirect-from::

    Tutorials/Workspace/Creating-A-Workspace

.. _ROS2Workspace:

Creating a workspace
====================

**Goal:** Create a workspace and learn how to set up an overlay for development and testing.

**Tutorial level:** Beginner

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

A workspace is a directory containing ROS 2 packages.
Before using ROS 2, it's necessary to source your ROS 2 installation workspace in the terminal you plan to work in.
This makes ROS 2's packages available for you to use in that terminal.

You also have the option of sourcing an ""overlay"" - a secondary workspace where you can add new packages without interfering with the existing ROS 2 workspace that you're extending, or ""underlay"".
Your underlay must contain the dependencies of all the packages in your overlay.
Packages in your overlay will override packages in the underlay.
It's also possible to have several layers of underlays and overlays, with each successive overlay using the packages of its parent underlays.


Prerequisites
-------------

* :doc:`ROS 2 installation <../../../Installation>`
* :doc:`colcon installation <../Colcon-Tutorial>`
* `git installation <https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>`__
* :doc:`turtlesim installation <../../Beginner-CLI-Tools/Introducing-Turtlesim/Introducing-Turtlesim>`
* Have :doc:`rosdep installed <../../Intermediate/Rosdep>`
* Understanding of basic terminal commands (`here's a guide for Linux <https://www2.cs.sfu.ca/~ggbaker/reference/unix/>`__)
* Text editor of your choice

Tasks
-----

1 Source ROS 2 environment
^^^^^^^^^^^^^^^^^^^^^^^^^^

Your main ROS 2 installation will be your underlay for this tutorial.
(Keep in mind that an underlay does not necessarily have to be the main ROS 2 installation.)

Depending on how you installed ROS 2 (from source or binaries), and which platform you're on, your exact source command will vary:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        source /opt/ros/{DISTRO}/setup.bash

   .. group-tab:: macOS

      .. code-block:: console

        . ~/ros2_install/ros2-osx/setup.bash

   .. group-tab:: Windows

      Remember to use a ``x64 Native Tools Command Prompt for VS 2019`` for executing the following commands, as we are going to build a workspace.

      .. code-block:: console

        call C:\dev\ros2\local_setup.bat

Consult the :doc:`installation guide <../../../Installation>` you followed if these commands don't work for you.

.. _new-directory:

2 Create a new directory
^^^^^^^^^^^^^^^^^^^^^^^^

Best practice is to create a new directory for every new workspace.
The name doesn't matter, but it is helpful to have it indicate the purpose of the workspace.
Let's choose the directory name ``ros2_ws``, for ""development workspace"":

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        mkdir -p ~/ros2_ws/src
        cd ~/ros2_ws/src

   .. group-tab:: macOS

      .. code-block:: console

        mkdir -p ~/ros2_ws/src
        cd ~/ros2_ws/src

   .. group-tab:: Windows

     .. code-block:: console

       md \ros2_ws\src
       cd \ros2_ws\src


Another best practice is to put any packages in your workspace into the ``src`` directory.
The above code creates a ``src`` directory inside ``ros2_ws`` and then navigates into it.


3 Clone a sample repo
^^^^^^^^^^^^^^^^^^^^^

Ensure you're still in the ``ros2_ws/src`` directory before you clone.

In the rest of the beginner developer tutorials, you will create your own packages, but for now you will practice putting a workspace together using existing packages.

If you went through the :doc:`Beginner: CLI Tools <../../Beginner-CLI-Tools>` tutorials, you'll be familiar with ``turtlesim``, one of the packages in `ros_tutorials <https://github.com/ros/ros_tutorials/>`__.

A repo can have multiple branches.
You need to check out the one that targets your installed ROS 2 distro.
When you clone this repo, add the ``-b`` argument followed by that branch.

In the ``ros2_ws/src`` directory, run the following command:

.. code-block:: console

  git clone https://github.com/ros/ros_tutorials.git -b {DISTRO}

Now ``ros_tutorials`` is cloned in your workspace.  The ``ros_tutorials`` repository contains the ``turtlesim`` package, which we'll use in the rest of this tutorial.  The other packages in this repository are not built because they contain a ``COLCON_IGNORE`` file.

So far you have populated your workspace with a sample package, but it isn't a fully-functional workspace yet.
You need to resolve the dependencies first and then build the workspace.


4 Resolve dependencies
^^^^^^^^^^^^^^^^^^^^^^

Before building the workspace, you need to resolve the package dependencies.
You may have all the dependencies already, but best practice is to check for dependencies every time you clone.
You wouldn't want a build to fail after a long wait only to realize that you have missing dependencies.

From the root of your workspace (``ros2_ws``), run the following command:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: bash

        # cd if you're still in the ``src`` directory with the ``ros_tutorials`` clone
        cd ..
        rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

      rosdep only runs on Linux, so you can skip ahead to section ""5 Build the workspace with colcon"".

   .. group-tab:: Windows

      rosdep only runs on Linux, so you can skip ahead to section ""5 Build the workspace with colcon"".

If you installed ROS 2 on Linux from source or the binary archive, you will need to use the rosdep command from their installation instructions.
Here are the :ref:`from-source rosdep section <linux-development-setup-install-dependencies-using-rosdep>` and the :ref:`binary archive rosdep section <linux-install-binary-install-missing-dependencies>`.

If you already have all your dependencies, the console will return:

.. code-block:: console

  #All required rosdeps installed successfully

Packages declare their dependencies in the package.xml file (you will learn more about packages in the next tutorial).
This command walks through those declarations and installs the ones that are missing.
You can learn more about ``rosdep`` in another tutorial (coming soon).

5 Build the workspace with colcon
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

From the root of your workspace (``ros2_ws``), you can now build your packages using the command:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      colcon build

  .. group-tab:: macOS

    .. code-block:: console

      colcon build

  .. group-tab:: Windows

    .. code-block:: console

      colcon build --merge-install

    Windows doesn't allow long paths, so ``merge-install`` will combine all the paths into the ``install`` directory.

The console will return the following message:

.. code-block:: console

  Starting >>> turtlesim
  Finished <<< turtlesim [5.49s]

  Summary: 1 package finished [5.58s]

.. note::

  Other useful arguments for ``colcon build``:

  * ``--packages-up-to`` builds the package you want, plus all its dependencies, but not the whole workspace (saves time)
  * ``--symlink-install`` saves you from having to rebuild every time you tweak python scripts
  * ``--event-handlers console_direct+`` shows console output while building (can otherwise be found in the ``log`` directory)
  * ``--executor sequential`` processes the packages one by one instead of using parallelism

Once the build is finished, enter the command in the workspace root (``~/ros2_ws``):

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        ls

   .. group-tab:: macOS

      .. code-block:: console

        ls

   .. group-tab:: Windows

      .. code-block:: console

        dir

And you will see that colcon has created new directories:

.. code-block:: console

  build  install  log  src

The ``install`` directory is where your workspace's setup files are, which you can use to source your overlay.


6 Source the overlay
^^^^^^^^^^^^^^^^^^^^

Before sourcing the overlay, it is very important that you open a new terminal, separate from the one where you built the workspace.
Sourcing an overlay in the same terminal where you built, or likewise building where an overlay is sourced, may create complex issues.

In the new terminal, source your main ROS 2 environment as the ""underlay"", so you can build the overlay ""on top of"" it:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        source /opt/ros/{DISTRO}/setup.bash

   .. group-tab:: macOS

      .. code-block:: console

        . ~/ros2_install/ros2-osx/setup.bash

   .. group-tab:: Windows

      In this case you can use a normal command prompt, as we are not going to build any workspace in this terminal.

      .. code-block:: console

        call C:\dev\ros2\local_setup.bat

Go into the root of your workspace:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        cd ~/ros2_ws

   .. group-tab:: macOS

      .. code-block:: console

        cd ~/ros2_ws

   .. group-tab:: Windows

     .. code-block:: console

       cd \ros2_ws

In the root, source your overlay:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/local_setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/local_setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install\setup.bat

.. note::

  Sourcing the ``local_setup`` of the overlay will only add the packages available in the overlay to your environment.
  ``setup`` sources the overlay as well as the underlay it was created in, allowing you to utilize both workspaces.

  So, sourcing your main ROS 2 installation's ``setup`` and then the ``ros2_ws`` overlay's ``local_setup``, like you just did,
  is the same as just sourcing ``ros2_ws``'s ``setup``, because that includes the environment of its underlay.

Now you can run the ``turtlesim`` package from the overlay:

.. code-block:: console

  ros2 run turtlesim turtlesim_node

But how can you tell that this is the overlay turtlesim running, and not your main installation's turtlesim?

Let's modify turtlesim in the overlay so you can see the effects:

* You can modify and rebuild packages in the overlay separately from the underlay.
* The overlay takes precedence over the underlay.


7 Modify the overlay
^^^^^^^^^^^^^^^^^^^^

You can modify ``turtlesim`` in your overlay by editing the title bar on the turtlesim window.
To do this, locate the ``turtle_frame.cpp`` file in ``~/ros2_ws/src/ros_tutorials/turtlesim/src``.
Open ``turtle_frame.cpp`` with your preferred text editor.

Find the function ``setWindowTitle(""TurtleSim"");``, change the value ``""TurtleSim""`` to ``""MyTurtleSim""``, and save the file.

Return to the first terminal where you ran ``colcon build`` earlier and run it again.

Return to the second terminal (where the overlay is sourced) and run turtlesim again:

.. code-block:: console

  ros2 run turtlesim turtlesim_node

You will see the title bar on the turtlesim window now says ""MyTurtleSim"".

.. image:: images/overlay.png

Even though your main ROS 2 environment was sourced in this terminal earlier, the overlay of your ``ros2_ws`` environment takes precedence over the contents of the underlay.

To see that your underlay is still intact, open a brand new terminal and source only your ROS 2 installation.
Run turtlesim again:

.. code-block:: console

  ros2 run turtlesim turtlesim_node

.. image:: images/underlay.png

You can see that modifications in the overlay did not actually affect anything in the underlay.


Summary
-------
In this tutorial, you sourced your main ROS 2 distro install as your underlay, and created an overlay by cloning and building packages in a new workspace.
The overlay gets prepended to the path, and takes precedence over the underlay, as you saw with your modified turtlesim.

Using overlays is recommended for working on a small number of packages, so you don't have to put everything in the same workspace and rebuild a huge workspace on every iteration.

Next steps
----------

Now that you understand the details behind creating, building and sourcing your own workspace, you can learn how to :doc:`create your own packages <../Creating-Your-First-ROS2-Package>`.
",What are the best practices for creating a new workspace in ROS 2?
".. redirect-from::

    Tutorials/Actions/Creating-an-Action

.. _ActionCreate:

Creating an action
==================

**Goal:** Define an action in a ROS 2 package.

**Tutorial level:** Intermediate

**Time:** 5 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

You learned about actions previously in the :doc:`../Beginner-CLI-Tools/Understanding-ROS2-Actions/Understanding-ROS2-Actions` tutorial.
Like the other communication types and their respective interfaces (topics/msg and services/srv),
you can also custom-define actions in your packages.
This tutorial shows you how to define and build an action that you can use
with the action server and action client you will write in the next tutorial.

Prerequisites
-------------

You should have :doc:`ROS 2 <../../Installation>` and `colcon <https://colcon.readthedocs.org>`__ installed.

You should know how to set up a :doc:`workspace <../Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace>` and create packages.

Remember to :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` first.

Tasks
-----

1 Creating an interface package
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      mkdir -p ~/ros2_ws/src # you can reuse an existing workspace with this naming convention
      cd ~/ros2_ws/src
      ros2 pkg create --license Apache-2.0 custom_action_interfaces

  .. group-tab:: macOS

    .. code-block:: bash

      mkdir -p ~/ros2_ws/src
      cd ~/ros2_ws/src
      ros2 pkg create --license Apache-2.0 custom_action_interfaces

  .. group-tab:: Windows

    .. code-block:: bash

      md \ros2_ws\src
      cd \ros2_ws\src
      ros2 pkg create --license Apache-2.0 custom_action_interfaces


2 Defining an action
^^^^^^^^^^^^^^^^^^^^

Actions are defined in ``.action`` files of the form:

.. code-block:: bash

    # Request
    ---
    # Result
    ---
    # Feedback

An action definition is made up of three message definitions separated by ``---``.

- A *request* message is sent from an action client to an action server initiating a new goal.
- A *result* message is sent from an action server to an action client when a goal is done.
- *Feedback* messages are periodically sent from an action server to an action client with updates about a goal.

An instance of an action is typically referred to as a *goal*.

Say we want to define a new action ""Fibonacci"" for computing the `Fibonacci sequence <https://en.wikipedia.org/wiki/Fibonacci_number>`__.

Create an ``action`` directory in our ROS 2 package ``custom_action_interfaces``:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      cd custom_action_interfaces
      mkdir action

  .. group-tab:: macOS

    .. code-block:: bash

      cd custom_action_interfaces
      mkdir action

  .. group-tab:: Windows

    .. code-block:: bash

      cd custom_action_interfaces
      md action

Within the ``action`` directory, create a file called ``Fibonacci.action`` with the following contents:

.. code-block:: console

  int32 order
  ---
  int32[] sequence
  ---
  int32[] partial_sequence

The goal request is the ``order`` of the Fibonacci sequence we want to compute, the result is the final ``sequence``, and the feedback is the ``partial_sequence`` computed so far.

3 Building an action
^^^^^^^^^^^^^^^^^^^^

Before we can use the new Fibonacci action type in our code, we must pass the definition to the rosidl code generation pipeline.

This is accomplished by adding the following lines to our ``CMakeLists.txt`` before the ``ament_package()`` line:

.. code-block:: cmake

    find_package(rosidl_default_generators REQUIRED)

    rosidl_generate_interfaces(${PROJECT_NAME}
      ""action/Fibonacci.action""
    )

We should also add the required dependencies to our ``package.xml``:

.. code-block:: xml

    <buildtool_depend>rosidl_default_generators</buildtool_depend>

    <member_of_group>rosidl_interface_packages</member_of_group>

We should now be able to build the package containing the ``Fibonacci`` action definition:

.. code-block:: bash

    # Change to the root of the workspace
    cd ~/ros2_ws
    # Build
    colcon build

We're done!

By convention, action types will be prefixed by their package name and the word ``action``.
So when we want to refer to our new action, it will have the full name ``custom_action_interfaces/action/Fibonacci``.

We can check that our action built successfully with the command line tool.
First source our workspace:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      source install/local_setup.bash

  .. group-tab:: macOS

    .. code-block:: bash

      source install/local_setup.bash

  .. group-tab:: Windows

    .. code-block:: bash

      call install\local_setup.bat

Now check that our action definition exists:

.. code-block:: bash

   ros2 interface show custom_action_interfaces/action/Fibonacci

You should see the Fibonacci action definition printed to the screen.

Summary
-------

In this tutorial, you learned the structure of an action definition.
You also learned how to correctly build a new action interface using ``CMakeLists.txt`` and ``package.xml``,
and how to verify a successful build.

Next steps
----------

Next, let's utilize your newly defined action interface by creating an action service and client (in :doc:`Python <Writing-an-Action-Server-Client/Py>` or :doc:`C++ <Writing-an-Action-Server-Client/Cpp>`).

Related content
---------------

For more detailed information about ROS actions, please refer to the `design article <http://design.ros2.org/articles/actions.html>`__.
",What are the three message definitions that make up an action definition in ROS 2?
".. redirect-from::

    Tutorials/Rosdep

Managing Dependencies with rosdep
=================================

.. contents:: Table of Contents
   :depth: 2
   :local:

**Goal:** Manage external dependencies using ``rosdep``.

**Tutorial level:** Intermediate

**Time:** 5 minutes

This tutorial will explain how to manage external dependencies using ``rosdep``.

.. warning::

   Currently rosdep only works on Linux and macOS; Windows is not supported.
   There are long-term plans to add support for Windows to https://github.com/ros-infrastructure/rosdep.

What is rosdep?
---------------

``rosdep`` is a dependency management utility that can work with packages and external libraries.
It is a command-line utility for identifying and installing dependencies to build or install a package.
``rosdep`` is *not* a package manager in its own right; it is a meta-package manager that uses its own knowledge of the system and the dependencies to find the appropriate package to install on a particular platform.
The actual installation is done using the system package manager (e.g. ``apt`` on Debian/Ubuntu, ``dnf`` on Fedora/RHEL, etc).

It is most often invoked before building a workspace, where it is used to install the dependencies of the packages within that workspace.

It has the ability to work over a single package or over a directory of packages (e.g. workspace).

.. note::

    While the name suggests it is for ROS, ``rosdep`` is semi-agnostic to ROS.
    You can utilize this powerful tool in non-ROS software projects by installing it as a standalone Python package.
    Successfully running ``rosdep`` relies on ``rosdep keys`` to be available, which can be downloaded from a public git repository with a few simple commands.

A little about package.xml files
--------------------------------

The ``package.xml`` is the file in your software where ``rosdep`` finds the set of dependencies.
It is important that the list of dependencies in the ``package.xml`` is complete and correct, which allows all of the tooling to determine the packages dependencies.
Missing or incorrect dependencies can lead to users not being able to use your package, to packages in a workspace being built out-of-order, and to packages not being able to be released.

The dependencies in the ``package.xml`` file are generally referred to as ""rosdep keys"".
These dependencies are manually populated in the ``package.xml`` file by the package's creators and should be an exhaustive list of any non-builtin libraries and packages it requires.

These are represented in the following tags (see `REP-149 <https://ros.org/reps/rep-0149.html>`__ for the full specification):

``<depend>``
^^^^^^^^^^^^

These are dependencies that should be provided at both build time and run time for your package.
For C++ packages, if in doubt, use this tag.
Pure Python packages generally don't have a build phase, so should never use this and should use ``<exec_depend>`` instead.

``<build_depend>``
^^^^^^^^^^^^^^^^^^

If you only use a particular dependency for building your package, and not at execution time, you can use the ``<build_depend>`` tag.

With this type of dependency, an installed binary of your package does not require that particular package to be installed.

However, that can create a problem if your package exports a header that includes a header from this dependency.
In that case you also need a ``<build_export_depend>``.

``<build_export_depend>``
^^^^^^^^^^^^^^^^^^^^^^^^^

If you export a header that includes a header from a dependency, it will be needed by other packages that ``<build_depend>`` on yours.
This mainly applies to headers and CMake configuration files.
Library packages referenced by libraries you export should normally specify ``<depend>``, because they are also needed at execution time.

``<exec_depend>``
^^^^^^^^^^^^^^^^^

This tag declares dependencies for shared libraries, executables, Python modules, launch scripts and other files required when running your package.

``<test_depend>``
^^^^^^^^^^^^^^^^^

This tag declares dependencies needed only by tests.
Dependencies here should *not* be duplicated with keys specified by ``<build_depend>``, ``<exec_depend>``, or ``<depend>``.

How does rosdep work?
---------------------

``rosdep`` will check for ``package.xml`` files in its path or for a specific package and find the rosdep keys stored within.
These keys are then cross-referenced against a central index to find the appropriate ROS package or software library in various package managers.
Finally, once the packages are found, they are installed and ready to go!

``rosdep`` works by retrieving the central index on to your local machine so that it doesn't have to access the network every time it runs (on Debian/Ubuntu the configuration for it is stored in ``/etc/ros/rosdep/sources.list.d/20-default.list``).

The central index is known as ``rosdistro``, which `may be found online <https://github.com/ros/rosdistro>`_.
We'll explore that more in the next section.

How do I know what keys to put in my package.xml?
-------------------------------------------------

Great question, I'm glad you asked!

* If the package you want to depend in your package is ROS-based, AND has been released into the ROS ecosystem [1]_, e.g. ``nav2_bt_navigator``, you may simply use the name of the package. You can find a list of all released ROS packages in https://github.com/ros/rosdistro at ``<distro>/distribution.yaml`` (e.g. ``humble/distribution.yaml``) for your given ROS distribution.
* If you want to depend on a non-ROS package, something often called ""system dependencies"", you will need to find the keys for a particular library. In general, there are two files of interest:

  * `rosdep/base.yaml <https://github.com/ros/rosdistro/blob/master/rosdep/base.yaml>`_ contains the ``apt`` system dependencies
  * `rosdep/python.yaml <https://github.com/ros/rosdistro/blob/master/rosdep/python.yaml>`_ contains the Python dependencies

To find a key, search for your library in these files and find the name.
This is the key to put in a ``package.xml`` file.

For example, imagine a package had a dependency on ``doxygen`` because it is a great piece of software that cares about quality documentation (hint hint).
We would search ``rosdep/base.yaml`` for ``doxygen`` and come across:

.. code-block:: yaml

  doxygen:
    arch: [doxygen]
    debian: [doxygen]
    fedora: [doxygen]
    freebsd: [doxygen]
    gentoo: [app-doc/doxygen]
    macports: [doxygen]
    nixos: [doxygen]
    openembedded: [doxygen@meta-oe]
    opensuse: [doxygen]
    rhel: [doxygen]
    ubuntu: [doxygen]

That means our rosdep key is ``doxygen``, which would resolve to those various names in different operating system's package managers for installation.

What if my library isn't in rosdistro?
--------------------------------------

If your library isn't in ``rosdistro``, you can experience the greatness that is open-source software development: you can add it yourself!
Pull requests for rosdistro are typically merged well within a week.

`Detailed instructions may be found here <https://github.com/ros/rosdistro/blob/master/CONTRIBUTING.md#rosdep-rules-contributions>`_ for how to contribute new rosdep keys.
If for some reason these may not be contributed openly, it is possible to fork rosdistro and maintain a alternate index for use.

How do I use the rosdep tool?
-----------------------------

rosdep installation
^^^^^^^^^^^^^^^^^^^

If you are using ``rosdep`` with ROS, it is conveniently packaged along with the ROS distribution.
This is the recommended way to get ``rosdep``.
You can install it with:

.. code-block:: bash

    apt-get install python3-rosdep

.. note::

    On Debian and Ubuntu, there is another, similarly named package called ``python3-rosdep2``.
    If that package is installed, make sure to remove it before installing ``python3-rosdep``.

If you are using ``rosdep`` outside of ROS, the system package may not be available.
In that case, you can install it directly from https://pypi.org:

.. code-block:: bash

    pip install rosdep

rosdep operation
^^^^^^^^^^^^^^^^

Now that we have some understanding of ``rosdep``, ``package.xml``, and ``rosdistro``, we're ready to use the utility itself!
Firstly, if this is the first time using ``rosdep``, it must be initialized via:

.. code-block:: bash

    sudo rosdep init
    rosdep update

This will initialize rosdep and ``update`` will update the locally cached rosdistro index.
It is a good idea to ``update`` rosdep on occasion to get the latest index.

Finally, we can run ``rosdep install`` to install dependencies.
Typically, this is run over a workspace with many packages in a single call to install all dependencies.
A call for that would appear as the following, if in the root of the workspace with directory ``src`` containing source code.

.. code-block:: bash

    rosdep install --from-paths src -y --ignore-src

Breaking that down:

- ``--from-paths src`` specifies the path to check for ``package.xml`` files to resolve keys for
- ``-y`` means to default yes to all prompts from the package manager to install without prompts
- ``--ignore-src`` means to ignore installing dependencies, even if a rosdep key exists, if the package itself is also in the workspace.

There are additional arguments and options available.
Use ``rosdep -h`` to see them, or look at the more complete documentation for rosdep at http://docs.ros.org/en/independent/api/rosdep/html/ .

.. [1] ""released into the ROS ecosystem"" means the package is listed in one or more of the ``<distro>/distribution.yaml`` directories in the `rosdistro database <https://github.com/ros/rosdistro>`_.
",How can one find the appropriate ROS package or software library using `rosdep`?
"Writing a Composable Node (C++)
===============================

.. contents:: Table of Contents
   :depth: 2
   :local:

Starting Place
--------------

Let's assume that you have a regular ``rclcpp::Node`` executable that you want to run in the same process as other nodes to enable more efficient communication.

We'll start from having a class that directly inherits from ``Node``, and that also has a main method defined.

.. code-block:: c++

    namespace palomino
    {
        class VincentDriver : public rclcpp::Node
        {
            // ...
        };
    }

    int main(int argc, char * argv[])
    {
        rclcpp::init(argc, argv);
        rclcpp::spin(std::make_shared<palomino::VincentDriver>());
        rclcpp::shutdown();
        return 0;
    }

This will typically be compiled as an executable in your Cmake.

.. code-block:: cmake

    # ...
    add_executable(vincent_driver src/vincent_driver.cpp)
    # ...
    install(TARGETS vincent_driver
        DESTINATION lib/${PROJECT_NAME}
    )

Code Updates
------------

Add the Package Dependency
^^^^^^^^^^^^^^^^^^^^^^^^^^

Your `package.xml <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/composition/package.xml>`__ should have a dependency on ``rclcpp_components``, a la

.. code-block:: xml

    <depend>rclcpp_components</depend>

Alternatively, you can independently add a ``build_depend/exec_depend``.

Class Definition
^^^^^^^^^^^^^^^^

The only change to your class definition that you may have to do is ensure that `the constructor for the class <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/composition/src/talker_component.cpp>`__ takes a ``NodeOptions`` argument.

.. code-block:: c++

    VincentDriver(const rclcpp::NodeOptions & options) : Node(""vincent_driver"", options)
    {
      // ...
    }

No More Main Method
^^^^^^^^^^^^^^^^^^^

Replace your main method with a ``pluginlib``-style macro invocation.

.. code-block:: c++

    #include <rclcpp_components/register_node_macro.hpp>
    RCLCPP_COMPONENTS_REGISTER_NODE(palomino::VincentDriver)

.. caution::
    If the main method you are replacing contains a ``MultiThreadedExecutor``, be sure to make note and ensure that your container node is multithreaded.
    See section below.

CMake Changes
^^^^^^^^^^^^^
First, add ``rclcpp_components`` as a dependency in your CMakeLists.txt with:

.. code-block:: cmake

    find_package(rclcpp_components REQUIRED)

Second, we're going to replace our ``add_executable`` with a ``add_library`` with a new target name.

.. code-block:: cmake

    add_library(vincent_driver_component src/vincent_driver.cpp)

Third, replace other build commands that used the old target to act on the new target.
i.e. ``ament_target_dependencies(vincent_driver ...)`` becomes ``ament_target_dependencies(vincent_driver_component ...)``

Fourth, add a new command to declare your component.

.. code-block:: cmake

    rclcpp_components_register_node(
        vincent_driver_component
        PLUGIN ""palomino::VincentDriver""
        EXECUTABLE vincent_driver
    )

Fifth and finally, change any installation commands in the CMake that operated on the old target to install the library version instead.
For instance, do not install either target into ``lib/${PROJECT_NAME}``.
Replace with the library installation.

.. code-block:: cmake

    ament_export_targets(export_vincent_driver_component)
    install(TARGETS vincent_driver_component
            EXPORT export_vincent_driver_component
            ARCHIVE DESTINATION lib
            LIBRARY DESTINATION lib
            RUNTIME DESTINATION bin
    )


Running Your Node
-----------------

See the :doc:`Composition tutorial <Composition>` for an in-depth look at composing nodes.
The quick and dirty version is that if you had the following in your Python launch file,

.. code-block:: python

    from launch_ros.actions import Node

    # ..

    ld.add_action(Node(
        package='palomino',
        executable='vincent_driver',
        # ..
    ))

you can replace it with

.. code-block:: python

    from launch_ros.actions import ComposableNodeContainer
    from launch_ros.descriptions import ComposableNode

    # ..
    ld.add_action(ComposableNodeContainer(
        name='a_buncha_nodes',
        namespace='',
        package='rclcpp_components',
        executable='component_container',
        composable_node_descriptions=[
            ComposableNode(
                package='palomino',
                plugin='palomino::VincentDriver',
                name='vincent_driver',
                # ..
                extra_arguments=[{'use_intra_process_comms': True}],
            ),
        ]
    ))

.. caution::

    If you need multi-threading, instead of setting your executable to ``component_container``, set it to ``component_container_mt``
",What change should be made to the class definition in order to enable running a Composable Node in C++ with efficient communication?
".. redirect-from::

    Composition
    Tutorials/Composition

Composing multiple nodes in a single process
============================================

.. contents:: Table of Contents
   :depth: 2
   :local:

**Goal:** Compose multiple nodes into a single process.

**Tutorial level:** Intermediate

**Time:** 20 minutes

Background
----------

See the :doc:`conceptual article <../../Concepts/Intermediate/About-Composition>`.

For information on how to write a composable node, :doc:`check out this tutorial <Writing-a-Composable-Node>`.

Prerequisites
-------------

This tutorial uses executables from the `rclcpp_components <https://github.com/ros2/rclcpp/tree/{REPOS_FILE_BRANCH}/rclcpp_components>`__, `ros2component <https://github.com/ros2/ros2cli/tree/{REPOS_FILE_BRANCH}/ros2component>`__, `composition <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/composition>`__, and `image_tools <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/image_tools>`__ packages. If you've followed the :doc:`installation instructions <../../Installation>` for your platform, these should already be installed.

Run the demos
-------------

Discover available components
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To see what components are registered and available in the workspace, execute the following in a shell:

.. code-block:: bash

   ros2 component types

The terminal will return the list of all available components:

.. code-block:: bash

   (... components of other packages here)
   composition
     composition::Talker
     composition::Listener
     composition::NodeLikeListener
     composition::Server
     composition::Client
   (... components of other packages here)


Run-time composition using ROS services with a publisher and subscriber
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the first shell, start the component container:

.. code-block:: bash

   ros2 run rclcpp_components component_container

Open the second shell and verify that the container is running via ``ros2`` command line tools:

.. code-block:: bash

   ros2 component list

You should see a name of the component:

.. code-block:: bash

   /ComponentManager

In the second shell load the talker component (see `talker <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/composition/src/talker_component.cpp>`__ source code):

.. code-block:: bash

   ros2 component load /ComponentManager composition composition::Talker

The command will return the unique ID of the loaded component as well as the node name:

.. code-block:: bash

   Loaded component 1 into '/ComponentManager' container node as '/talker'

Now the first shell should show a message that the component was loaded as well as repeated message for publishing a message.

Run another command in the second shell to load the listener component (see `listener <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/composition/src/listener_component.cpp>`__ source code):

.. code-block:: bash

   ros2 component load /ComponentManager composition composition::Listener

Terminal will return:

.. code-block:: bash

   Loaded component 2 into '/ComponentManager' container node as '/listener'

The ``ros2`` command line utility can now be used to inspect the state of the container:

.. code-block:: bash

   ros2 component list

You will see the following result:

.. code-block:: bash

   /ComponentManager
      1  /talker
      2  /listener

Now the first shell should show repeated output for each received message.

Run-time composition using ROS services with a server and client
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The example with a server and a client is very similar.

In the first shell:

.. code-block:: bash

   ros2 run rclcpp_components component_container

In the second shell (see `server <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/composition/src/server_component.cpp>`__ and `client <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/composition/src/client_component.cpp>`__ source code):

.. code-block:: bash

   ros2 component load /ComponentManager composition composition::Server
   ros2 component load /ComponentManager composition composition::Client

In this case the client sends a request to the server, the server processes the request and replies with a response, and the client prints the received response.

Compile-time composition with hardcoded nodes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This demo shows that the same shared libraries can be reused to compile a single executable running multiple components without using ROS interfaces.
The executable contains all four components from above: talker and listener as well as server and client, which is hardcoded in the main function.

In the shell call (see `source code <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/composition/src/manual_composition.cpp>`__):

.. code-block:: bash

   ros2 run composition manual_composition

This should show repeated messages from both pairs, the talker and the listener as well as the server and the client.

.. note::

   Manually-composed components will not be reflected in the ``ros2 component list`` command line tool output.

Run-time composition using dlopen
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This demo presents an alternative to run-time composition by creating a generic container process and explicitly passing the libraries to load without using ROS interfaces.
The process will open each library and create one instance of each ""rclcpp::Node"" class in the library (`source code <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/composition/src/dlopen_composition.cpp>`__).

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

       ros2 run composition dlopen_composition `ros2 pkg prefix composition`/lib/libtalker_component.so `ros2 pkg prefix composition`/lib/liblistener_component.so

  .. group-tab:: macOS

    .. code-block:: bash

       ros2 run composition dlopen_composition `ros2 pkg prefix composition`/lib/libtalker_component.dylib `ros2 pkg prefix composition`/lib/liblistener_component.dylib

  .. group-tab:: Windows

    .. code-block:: bash

       > ros2 pkg prefix composition

    to get the path to where composition is installed. Then call

    .. code-block:: bash

       > ros2 run composition dlopen_composition <path_to_composition_install>\bin\talker_component.dll <path_to_composition_install>\bin\listener_component.dll

Now the shell should show repeated output for each sent and received message.

.. note::

   dlopen-composed components will not be reflected in the ``ros2 component list`` command line tool output.


Composition using launch actions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

While the command line tools are useful for debugging and diagnosing component configurations, it is frequently more convenient to start a set of components at the same time.
To automate this action, we can use a `launch file <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/composition/launch/composition_demo_launch.py>`__:

.. code-block:: bash

   ros2 launch composition composition_demo_launch.py


Advanced Topics
---------------

Now that we have seen the basic operation of components, we can discuss a few more advanced topics.


Unloading components
^^^^^^^^^^^^^^^^^^^^

In the first shell, start the component container:

.. code-block:: bash

   ros2 run rclcpp_components component_container

Verify that the container is running via ``ros2`` command line tools:

.. code-block:: bash

   ros2 component list

You should see a name of the component:

.. code-block:: bash

   /ComponentManager

In the second shell load both the talker and listener as we have before:

.. code-block:: bash

   ros2 component load /ComponentManager composition composition::Talker
   ros2 component load /ComponentManager composition composition::Listener

Use the unique ID to unload the node from the component container.

.. code-block:: bash

   ros2 component unload /ComponentManager 1 2

The terminal should return:

.. code-block:: bash

   Unloaded component 1 from '/ComponentManager' container
   Unloaded component 2 from '/ComponentManager' container

In the first shell, verify that the repeated messages from talker and listener have stopped.


Remapping container name and namespace
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The component manager name and namespace can be remapped via standard command line arguments:

.. code-block:: bash

   ros2 run rclcpp_components component_container --ros-args -r __node:=MyContainer -r __ns:=/ns

In a second shell, components can be loaded by using the updated container name:

.. code-block:: bash

   ros2 component load /ns/MyContainer composition composition::Listener

.. note::

   Namespace remappings of the container do not affect loaded components.


Remap component names and namespaces
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Component names and namespaces may be adjusted via arguments to the load command.

In the first shell, start the component container:

.. code-block:: bash

   ros2 run rclcpp_components component_container


Some examples of how to remap names and namespaces.

Remap node name:

.. code-block:: bash

   ros2 component load /ComponentManager composition composition::Talker --node-name talker2

Remap namespace:

.. code-block:: bash

   ros2 component load /ComponentManager composition composition::Talker --node-namespace /ns

Remap both:

.. code-block:: bash

   ros2 component load /ComponentManager composition composition::Talker --node-name talker3 --node-namespace /ns2

Now use ``ros2`` command line utility:

.. code-block:: bash

   ros2 component list

In the console you should see corresponding entries:

.. code-block:: bash

   /ComponentManager
      1  /talker2
      2  /ns/talker
      3  /ns2/talker3

.. note::

   Namespace remappings of the container do not affect loaded components.

Passing parameter values into components
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``ros2 component load`` command-line supports passing arbitrary parameters to the node as it is constructed.
This functionality can be used as follows:

.. code-block:: bash

   ros2 component load /ComponentManager image_tools image_tools::Cam2Image -p burger_mode:=true

Passing additional arguments into components
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``ros2 component load`` command-line supports passing particular options to the component manager for use when constructing the node.
As of now, the only command-line option that is supported is to instantiate a node using intra-process communication.
This functionality can be used as follows:

.. code-block:: bash

   ros2 component load /ComponentManager composition composition::Talker -e use_intra_process_comms:=true

Composable nodes as shared libraries
------------------------------------

If you want to export a composable node as a shared library from a package and use that node in another package that does link-time composition, add code to the CMake file which imports the actual targets in downstream packages.

Then install the generated file and export the generated file.

A practical example can be seen here: `ROS Discourse - Ament best practice for sharing libraries <https://discourse.ros.org/t/ament-best-practice-for-sharing-libraries/3602>`__

Composing Non-Node Derived Components
-------------------------------------

In ROS 2, components allow for more efficient use of system resources and provide a powerful feature that enables you to create reusable functionality that is not tied to a specific node.

One advantage of using components is that they allow you to create non-node derived functionality as standalone executables or shared libraries that can be loaded into the ROS system as needed.

To create a component that is not derived from a node, follow these guidelines:

1. Implement a constructor that takes ``const rclcpp::NodeOptions&`` as its argument.
2. Implement the ``get_node_base_interface()`` method, which should return a ``NodeBaseInterface::SharedPtr``. You can use the ``get_node_base_interface()`` method of a node that you create in your constructor to provide this interface.

Here's an example of a component that is not derived from a node, which listens to a ROS topic: `node_like_listener_component <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/composition/src/node_like_listener_component.cpp>`__.

For more information on this topic, you can refer to this `discussion <https://github.com/ros2/rclcpp/issues/2110#issuecomment-1454228192>`__.
",What are the steps involved in composing multiple nodes into a single process using ROS services with a publisher and subscriber?
".. redirect-from::

    Tutorials/Monitoring-For-Parameter-Changes-CPP

Monitoring for parameter changes (C++)
======================================

**Goal:** Learn to use the ParameterEventHandler class to monitor and respond to parameter changes.

**Tutorial level:** Intermediate

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

Often a node needs to respond to changes to its own parameters or another node's parameters.
The ParameterEventHandler class makes it easy to listen for parameter changes so that your code can respond to them.
This tutorial will show you how to use the C++ version of the ParameterEventHandler class to monitor for changes to a node's own parameters as well as changes to another node's parameters.

Prerequisites
-------------

Before starting this tutorial, you should first complete the following tutorials:

- :doc:`../Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters`
- :doc:`../Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP`

Tasks
-----

In this tutorial, you will create a new package to contain some sample code, write some C++ code to use the ParameterEventHandler class, and test the resulting code.


1 Create a package
^^^^^^^^^^^^^^^^^^

First, open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

Follow :ref:`these instructions <new-directory>` to create a new workspace named ``ros2_ws``.

Recall that packages should be created in the ``src`` directory, not the root of the workspace.
So, navigate into ``ros2_ws/src`` and then create a new package there:

.. code-block:: console

  ros2 pkg create --build-type ament_cmake --license Apache-2.0 cpp_parameter_event_handler --dependencies rclcpp

Your terminal will return a message verifying the creation of your package ``cpp_parameter_event_handler`` and all its necessary files and folders.

The ``--dependencies`` argument will automatically add the necessary dependency lines to ``package.xml`` and ``CMakeLists.txt``.

1.1 Update ``package.xml``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Because you used the ``--dependencies`` option during package creation, you don’t have to manually add dependencies to ``package.xml`` or ``CMakeLists.txt``.
As always, though, make sure to add the description, maintainer email and name, and license information to ``package.xml``.

.. code-block:: xml

  <description>C++ parameter events client tutorial</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>

2 Write the C++ node
^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/cpp_parameter_event_handler/src`` directory, create a new file called ``parameter_event_handler.cpp`` and paste the following code within:

.. code-block:: C++

    #include <memory>

    #include ""rclcpp/rclcpp.hpp""

    class SampleNodeWithParameters : public rclcpp::Node
    {
    public:
      SampleNodeWithParameters()
      : Node(""node_with_parameters"")
      {
        this->declare_parameter(""an_int_param"", 0);

        // Create a parameter subscriber that can be used to monitor parameter changes
        // (for this node's parameters as well as other nodes' parameters)
        param_subscriber_ = std::make_shared<rclcpp::ParameterEventHandler>(this);

        // Set a callback for this node's integer parameter, ""an_int_param""
        auto cb = [this](const rclcpp::Parameter & p) {
            RCLCPP_INFO(
              this->get_logger(), ""cb: Received an update to parameter \""%s\"" of type %s: \""%ld\"""",
              p.get_name().c_str(),
              p.get_type_name().c_str(),
              p.as_int());
          };
        cb_handle_ = param_subscriber_->add_parameter_callback(""an_int_param"", cb);
      }

    private:
      std::shared_ptr<rclcpp::ParameterEventHandler> param_subscriber_;
      std::shared_ptr<rclcpp::ParameterCallbackHandle> cb_handle_;
    };

    int main(int argc, char ** argv)
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<SampleNodeWithParameters>());
      rclcpp::shutdown();

      return 0;
    }

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~
The first statement, ``#include <memory>`` is included so that the code can utilize the std::make_shared template.
The next, ``#include ""rclcpp/rclcpp.hpp""`` is included to allow the code to reference the various functionality provided by the rclcpp interface, including the ParameterEventHandler class.

After the class declaration, the code defines a class, ``SampleNodeWithParameters``.
The constructor for the class declares an integer parameter ``an_int_param``, with a default value of 0.
Next, the code creates a ``ParameterEventHandler`` that will be used to monitor changes to parameters.
Finally, the code creates a lambda function and sets it as the callback to invoke whenever ``an_int_param`` is updated.

.. note::

   It is very important to save the handle that is returned by ``add_parameter_callback``; otherwise, the callback will not be properly registered.

.. code-block:: C++

    SampleNodeWithParameters()
    : Node(""node_with_parameters"")
    {
      this->declare_parameter(""an_int_param"", 0);

      // Create a parameter subscriber that can be used to monitor parameter changes
      // (for this node's parameters as well as other nodes' parameters)
      param_subscriber_ = std::make_shared<rclcpp::ParameterEventHandler>(this);

      // Set a callback for this node's integer parameter, ""an_int_param""
      auto cb = [this](const rclcpp::Parameter & p) {
          RCLCPP_INFO(
            this->get_logger(), ""cb: Received an update to parameter \""%s\"" of type %s: \""%ld\"""",
            p.get_name().c_str(),
            p.get_type_name().c_str(),
            p.as_int());
        };
      cb_handle_ = param_subscriber_->add_parameter_callback(""an_int_param"", cb);
    }

Following the ``SampleNodeWithParameters`` is a typical ``main`` function which initializes ROS, spins the sample node so that it can send and receive messages, and then shuts down after the user enters ^C at the console.

.. code-block:: C++

    int main(int argc, char ** argv)
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<SampleNodeWithParameters>());
      rclcpp::shutdown();

      return 0;
    }


2.2 Add executable
~~~~~~~~~~~~~~~~~~

To build this code, first open the ``CMakeLists.txt`` file and add the following lines of code below the dependency ``find_package(rclcpp REQUIRED)``

.. code-block:: console

    add_executable(parameter_event_handler src/parameter_event_handler.cpp)
    ament_target_dependencies(parameter_event_handler rclcpp)

    install(TARGETS
      parameter_event_handler
      DESTINATION lib/${PROJECT_NAME}
    )

3 Build and run
^^^^^^^^^^^^^^^

It's good practice to run ``rosdep`` in the root of your workspace (``ros2_ws``) to check for missing dependencies before building:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        rosdep install -i --from-path src --rosdistro $ROS_DISTRO -y

   .. group-tab:: macOS

      rosdep only runs on Linux, so you can skip ahead to next step.

   .. group-tab:: Windows

      rosdep only runs on Linux, so you can skip ahead to next step.

Navigate back to the root of your workspace, ``ros2_ws``, and build your new package:

.. code-block:: console

    colcon build --packages-select cpp_parameter_event_handler

Open a new terminal, navigate to ``ros2_ws``, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now run the node:

.. code-block:: console

     ros2 run cpp_parameter_event_handler parameter_event_handler

The node is now active and has a single parameter and will print a message whenever this parameter is updated.
To test this, open up another terminal and source the ROS setup file as before (. install/setup.bash) and execute the following command:

.. code-block:: console

    ros2 param set node_with_parameters an_int_param 43

The terminal running the node will display a message similar to the following:

.. code-block:: console

    [INFO] [1606950498.422461764] [node_with_parameters]: cb: Received an update to parameter ""an_int_param"" of type integer: ""43""

The callback we set previously in the node has been invoked and has displayed the new updated value.
You can now terminate the running parameter_event_handler sample using ^C in the terminal.

3.1 Monitor changes to another node's parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also use the ParameterEventHandler to monitor parameter changes to another node's parameters.
Let's update the SampleNodeWithParameters class to also monitor for changes to a parameter in another node.
We will use the parameter_blackboard demo application to host a double parameter that we will monitor for updates.

First update the constructor to add the following code after the existing code:

.. code-block:: C++

    // Now, add a callback to monitor any changes to the remote node's parameter. In this
    // case, we supply the remote node name.
    auto cb2 = [this](const rclcpp::Parameter & p) {
        RCLCPP_INFO(
          this->get_logger(), ""cb2: Received an update to parameter \""%s\"" of type: %s: \""%.02lf\"""",
          p.get_name().c_str(),
          p.get_type_name().c_str(),
          p.as_double());
      };
    auto remote_node_name = std::string(""parameter_blackboard"");
    auto remote_param_name = std::string(""a_double_param"");
    cb_handle2_ = param_subscriber_->add_parameter_callback(remote_param_name, cb2, remote_node_name);


Then add another member variable, ``cb_handle2`` for the additional callback handle:

.. code-block:: C++

  private:
    std::shared_ptr<rclcpp::ParameterEventHandler> param_subscriber_;
    std::shared_ptr<rclcpp::ParameterCallbackHandle> cb_handle_;
    std::shared_ptr<rclcpp::ParameterCallbackHandle> cb_handle2_;  // Add this
  };


In a terminal, navigate back to the root of your workspace, ``ros2_ws``, and build your updated package as before:

.. code-block:: console

    colcon build --packages-select cpp_parameter_event_handler

Then source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat

Now, to test monitoring of remote parameters, first run the newly-built parameter_event_handler code:

.. code-block:: console

     ros2 run cpp_parameter_event_handler parameter_event_handler

Next, from another teminal (with ROS initialized), run the parameter_blackboard demo application, as follows:

.. code-block:: console

     ros2 run demo_nodes_cpp parameter_blackboard

Finally, from a third terminal (with ROS initialized), let's set a parameter on the parameter_blackboard node:

.. code-block:: console

     ros2 param set parameter_blackboard a_double_param 3.45

Upon executing this command, you should see output in the parameter_event_handler window, indicating that the callback function was invoked upon the parameter update:

.. code-block:: console

    [INFO] [1606952588.237531933] [node_with_parameters]: cb2: Received an update to parameter ""a_double_param"" of type: double: ""3.45""

Summary
-------

You created a node with a parameter and used the ParameterEventHandler class to set a callback to monitor changes to that parameter.
You also used the same class to monitor changes to a remote node.
The ParameterEventHandler is a convenient way to monitor for parameter changes so that you can then respond to the updated values.

Related content
---------------

To learn how to adapt ROS 1 parameter files for ROS 2, see the :doc:`Migrating YAML parameter files from ROS 1 to ROS2 <../../How-To-Guides/Migrating-from-ROS1/Migrating-Parameters>` tutorial.


",What is the purpose of using the ParameterEventHandler class in C++ for monitoring and responding to parameter changes in ROS 2 nodes?
"Monitoring for parameter changes (Python)
=========================================

**Goal:** Learn to use the ParameterEventHandler class to monitor and respond to parameter changes.

**Tutorial level:** Intermediate

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

Often a node needs to respond to changes to its own parameters or another node's parameters.
The ParameterEventHandler class makes it easy to listen for parameter changes so that your code can respond to them.
This tutorial will show you how to use the Python version of the ParameterEventHandler class to monitor for changes to a node's own parameters as well as changes to another node's parameters.

Prerequisites
-------------

Before starting this tutorial, you should first complete the following tutorials:

- :doc:`../Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters`
- :doc:`../Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python`

Tasks
-----

In this tutorial, you will create a new package to contain some sample code, write some Python code to use the ParameterEventHandler class, and test the resulting code.


1 Create a package
^^^^^^^^^^^^^^^^^^

First, open a new terminal and :doc:`source your ROS 2 installation <../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.

Follow :ref:`these instructions <new-directory>` to create a new workspace named ``ros2_ws``.

Recall that packages should be created in the ``src`` directory, not the root of the workspace.
So, navigate into ``ros2_ws/src`` and then create a new package there:

.. code-block:: console

  ros2 pkg create --build-type ament_python --license Apache-2.0 python_parameter_event_handler --dependencies rclpy

Your terminal will return a message verifying the creation of your package ``python_parameter_event_handler`` and all its necessary files and folders.

The ``--dependencies`` argument will automatically add the necessary dependency lines to ``package.xml`` and ``CMakeLists.txt``.

1.1 Update ``package.xml``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Because you used the ``--dependencies`` option during package creation, you don’t have to manually add dependencies to ``package.xml``.
As always, though, make sure to add the description, maintainer email and name, and license information to ``package.xml``.

.. code-block:: xml

  <description>Python parameter events client tutorial</description>
  <maintainer email=""you@email.com"">Your Name</maintainer>
  <license>Apache-2.0</license>

2 Write the Python node
^^^^^^^^^^^^^^^^^^^^^^^

Inside the ``ros2_ws/src/python_parameter_event_handler/python_parameter_event_handler`` directory, create a new file called ``parameter_event_handler.py`` and paste the following code within:

.. code-block:: Python

    import rclpy
    from rclpy.executors import ExternalShutdownException
    import rclpy.node
    import rclpy.parameter

    from rclpy.parameter_event_handler import ParameterEventHandler


    class SampleNodeWithParameters(rclpy.node.Node):
        def __init__(self):
            super().__init__('node_with_parameters')

            self.declare_parameter('an_int_param', 0)

            self.handler = ParameterEventHandler(self)

            self.callback_handle = self.handler.add_parameter_callback(
                parameter_name=""an_int_param"",
                node_name=""node_with_parameters"",
                callback=self.callback,
            )

        def callback(self, p: rclpy.parameter.Parameter) -> None:
            self.get_logger().info(f""Received an update to parameter: {p.name}: {rclpy.parameter.parameter_value_to_python(p.value)}"")


    def main():
        try:
            with rclpy.init():
                node = SampleNodeWithParameters()
                rclpy.spin(node)
        except (KeyboardInterrupt, ExternalShutdownException):
            pass

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

The ``import`` statements at the top are used to import the package dependencies.

.. code-block:: Python

    import rclpy
    from rclpy.executors import ExternalShutdownException
    import rclpy.node
    import rclpy.parameter

    from rclpy.parameter_event_handler import ParameterEventHandler

The next piece of code creates the class ``SampleNodeWithParameters`` and the constructor.
The constructor for the class declares an integer parameter ``an_int_param``,  with a default value of 0.
Next, the code creates a ``ParameterEventHandler`` that will be used to monitor changes to parameters.

.. code-block:: Python

    class SampleNodeWithParameters(rclpy.node.Node):
        def __init__(self):
            super().__init__('node_with_parameters')

            self.declare_parameter('an_int_param', 0)

            self.handler = ParameterEventHandler(self)


Finally, we add parameter callback and get callback handler for the new callback.

.. note::

   It is very important to save the handle that is returned by ``add_parameter_callback``; otherwise, the callback will not be properly registered.

.. code-block:: Python

            self.callback_handle = self.handler.add_parameter_callback(
                parameter_name=""an_int_param"",
                node_name=""node_with_parameters"",
                callback=self.callback,
            )

For the callback function, we use the ``callback`` method of the ``SampleNodeWithParameters`` class.

.. code-block:: Python

        def callback(self, p: rclpy.parameter.Parameter) -> None:
            self.get_logger().info(f""Received an update to parameter: {p.name}: {rclpy.parameter.parameter_value_to_python(p.value)}"")


Following the ``SampleNodeWithParameters`` is a typical ``main`` function which initializes ROS, spins the sample node so that it can send and receive messages, and then shuts down after the user enters ^C at the console.

.. code-block:: Python

    def main():
        try:
            with rclpy.init():
                node = SampleNodeWithParameters()
                rclpy.spin(node)
        except (KeyboardInterrupt, ExternalShutdownException):
            pass


2.2 Add an entry point
~~~~~~~~~~~~~~~~~~~~~~

Open the ``setup.py`` file.
Again, match the ``maintainer``, ``maintainer_email``, ``description`` and ``license`` fields to your ``package.xml``:

.. code-block:: Python

    maintainer='YourName',
    maintainer_email='you@email.com',
    description='Python parameter tutorial',
    license='Apache-2.0',

Add the following line within the ``console_scripts`` brackets of the ``entry_points`` field:

.. code-block:: Python

  entry_points={
      'console_scripts': [
          'node_with_parameters = python_parameter_event_handler.parameter_event_handler:main',
      ],
  },


3 Build and run
^^^^^^^^^^^^^^^

It's good practice to run ``rosdep`` in the root of your workspace (``ros2_ws``) to check for missing dependencies before building:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

        rosdep install -i --from-path src --rosdistro $ROS_DISTRO -y

   .. group-tab:: macOS

      rosdep only runs on Linux, so you can skip ahead to next step.

   .. group-tab:: Windows

      rosdep only runs on Linux, so you can skip ahead to next step.

Navigate back to the root of your workspace, ``ros2_ws``, and build your new package:

.. code-block:: console

    colcon build --packages-select python_parameter_event_handler

Open a new terminal, navigate to ``ros2_ws``, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install\setup.bat

Now run the node:

.. code-block:: console

     ros2 run python_parameter_event_handler node_with_parameters

The node is now active and has a single parameter and will print a message whenever this parameter is updated.
To test this, open up another terminal and source the ROS setup file as before and execute the following command:

.. code-block:: console

    ros2 param set node_with_parameters an_int_param 43

The terminal running the node will display a message similar to the following:

.. code-block:: console

    [INFO] [1698483083.315084660] [node_with_parameters]: Received an update to parameter: an_int_param: 43

The callback we set previously in the node has been invoked and has displayed the new updated value.
You can now terminate the running parameter_event_handler sample using ^C in the terminal.

3.1 Monitor changes to another node's parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also use the ParameterEventHandler to monitor parameter changes to another node's parameters.
Let's update the SampleNodeWithParameters class to monitor for changes to a parameter in another node.
We will use the parameter_blackboard demo application to host a double parameter that we will monitor for updates.

First update the constructor to add the following code after the existing code:

.. code-block:: Python

    def __init__(...):
        ...
        self.callback_handle = self.handler.add_parameter_callback(
            parameter_name=""a_double_param"",
            node_name=""parameter_blackboard"",
            callback=self.callback,
        )


In a terminal, navigate back to the root of your workspace, ``ros2_ws``, and build your updated package as before:

.. code-block:: console

    colcon build --packages-select python_parameter_event_handler

Then source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install\setup.bat

Now, to test monitoring of remote parameters, first run the newly-built parameter_event_handler code:

.. code-block:: console

     ros2 run python_parameter_event_handler node_with_parameters

Next, from another teminal (with ROS initialized), run the parameter_blackboard demo application, as follows:

.. code-block:: console

     ros2 run demo_nodes_cpp parameter_blackboard

Finally, from a third terminal (with ROS initialized), let's set a parameter on the parameter_blackboard node:

.. code-block:: console

     ros2 param set parameter_blackboard a_double_param 3.45

Upon executing this command, you should see output in the parameter_event_handler window, indicating that the callback function was invoked upon the parameter update:

.. code-block:: console

      [INFO] [1699821958.757770223] [node_with_parameters]: Received an update to parameter: a_double_param: 3.45

Summary
-------

You created a node with a parameter and used the ParameterEventHandler class to set a callback to monitor changes to that parameter.
You also used the same class to monitor changes to a remote node.
The ParameterEventHandler is a convenient way to monitor for parameter changes so that you can then respond to the updated values.

Related content
---------------

To learn how to adapt ROS 1 parameter files for ROS 2, see the :doc:`Migrating YAML parameter files from ROS 1 to ROS2 <../../How-To-Guides/Migrating-from-ROS1/Migrating-Parameters>` tutorial.
",What is the purpose of using the ParameterEventHandler class in Python for monitoring and responding to parameter changes?
".. redirect-from::

    Tutorials/URDF/Using-Xacro-to-Clean-Up-a-URDF-File

.. _URDFXacro:

Using Xacro to clean up your code
=================================

**Goal:** Learn some tricks to reduce the amount of code in a URDF file using Xacro

**Tutorial level:** Intermediate

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

By now, if you’re following all these steps at home with your own robot design, you might be sick of doing all sorts of math to get very simple robot descriptions to parse correctly.
Fortunately, you can use the `xacro <https://index.ros.org/p/xacro>`_ package to make your life simpler.
It does three things that are very helpful.

 * Constants
 * Simple Math
 * Macros

In this tutorial, we take a look at all these shortcuts to help reduce the overall size of the URDF file and make it easier to read and maintain.

Using Xacro
-----------
As its name implies, `xacro <https://index.ros.org/p/xacro>`_ is a macro language for XML.
The xacro program runs all of the macros and outputs the result.
Typical usage looks something like this:

.. code-block:: console

   xacro model.xacro > model.urdf

You can also automatically generate the urdf in a launch file.
This is convenient because it stays up to date and doesn’t use up hard drive space.
However, it does take time to generate, so be aware that your launch file might take longer to start up.

To run xacro within your launch file, you need to put the ``Command`` substitution as a parameter to the ``robot_state_publisher``.

.. code-block:: python

    path_to_urdf = get_package_share_path('turtlebot3_description') / 'urdf' / 'turtlebot3_burger.urdf'
    robot_state_publisher_node = launch_ros.actions.Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{
            'robot_description': ParameterValue(
                Command(['xacro ', str(path_to_urdf)]), value_type=str
            )
        }]
    )

An easier way to load the robot model is to use the `urdf_launch <https://github.com/ros/urdf_launch>`_ package to automatically load the xacro/urdf.

.. code-block:: python

    from launch import LaunchDescription
    from launch.actions import IncludeLaunchDescription
    from launch.substitutions import PathJoinSubstitution
    from launch_ros.substitutions import FindPackageShare


    def generate_launch_description():
        ld = LaunchDescription()

        ld.add_action(IncludeLaunchDescription(
            PathJoinSubstitution([FindPackageShare('urdf_launch'), 'launch', 'display.launch.py']),
            launch_arguments={
                'urdf_package': 'turtlebot3_description',
                'urdf_package_path': PathJoinSubstitution(['urdf', 'turtlebot3_burger.urdf'])}.items()
        ))
        return ld

At the top of the URDF file, you must specify a namespace in order for the file to parse properly.
For example, these are the first two lines of a valid xacro file:

.. code-block:: xml

    <?xml version=""1.0""?>
    <robot xmlns:xacro=""http://www.ros.org/wiki/xacro"" name=""firefighter"">

Constants
---------
Let’s take a quick look at our base_link in R2D2.

.. code-block:: xml

  <link name=""base_link"">
    <visual>
      <geometry>
        <cylinder length=""0.6"" radius=""0.2""/>
      </geometry>
      <material name=""blue""/>
    </visual>
    <collision>
      <geometry>
        <cylinder length=""0.6"" radius=""0.2""/>
      </geometry>
    </collision>
  </link>

The information here is a little redundant.
We specify the length and radius of the cylinder twice.
Worse, if we want to change that, we need to do so in two different places.

Fortunately, xacro allows you to specify properties which act as constants.
Instead, of the above code, we can write this.

.. code-block:: xml

    <xacro:property name=""width"" value=""0.2"" />
    <xacro:property name=""bodylen"" value=""0.6"" />
    <link name=""base_link"">
        <visual>
            <geometry>
                <cylinder radius=""${width}"" length=""${bodylen}""/>
            </geometry>
            <material name=""blue""/>
        </visual>
        <collision>
            <geometry>
                <cylinder radius=""${width}"" length=""${bodylen}""/>
            </geometry>
        </collision>
    </link>

* The two values are specified in the first two lines.
  They can be defined just about anywhere (assuming valid XML), at any level, before or after they are used.
  Usually they go at the top.
* Instead of specifying the actual radius in the geometry element, we use a dollar sign and curly brackets to signify the value.
* This code will generate the same code shown above.

The value of the contents of the ${} construct are then used to replace the ${}.
This means you can combine it with other text in the attribute.

.. code-block:: xml

    <xacro:property name=”robotname” value=”marvin” />
    <link name=”${robotname}s_leg” />

This will generate

.. code-block:: xml

    <link name=”marvins_leg” />

However, the contents in the ${} don’t have to only be a property, which brings us to our next point...

Math
----
You can build up arbitrarily complex expressions in the ${} construct using the four basic operations (+,-,*,/), the unary minus, and parenthesis.
Examples:

.. code-block:: xml

    <cylinder radius=""${wheeldiam/2}"" length=""0.1""/>
    <origin xyz=""${reflect*(width+.02)} 0 0.25"" />

You can also use more than the basic mathematical operations, like ``sin`` and ``cos``.

Macros
------
Here’s the biggest and most useful component to the xacro package.

Simple Macro
^^^^^^^^^^^^
Let’s take a look at a simple useless macro.

.. code-block:: xml

    <xacro:macro name=""default_origin"">
        <origin xyz=""0 0 0"" rpy=""0 0 0""/>
    </xacro:macro>
    <xacro:default_origin />

(This is useless, since if the origin is not specified, it has the same value as this.) This code will generate the following.

.. code-block:: xml

    <origin rpy=""0 0 0"" xyz=""0 0 0""/>

* The name is not technically a required element, but you need to specify it to be able to use it.
* Every instance of the ``<xacro:$NAME />`` is replaced with the contents of the ``xacro:macro`` tag.
* Note that even though its not exactly the same (the two attributes have switched order), the generated XML is equivalent.
* If the xacro with a specified name is not found, it will not be expanded and will NOT generate an error.

Parameterized Macro
^^^^^^^^^^^^^^^^^^^
You can also parameterize macros so that they don’t generate the same exact text every time.
When combined with the math functionality, this is even more powerful.

First, let’s take an example of a simple macro used in R2D2.

.. code-block:: xml

    <xacro:macro name=""default_inertial"" params=""mass"">
        <inertial>
                <mass value=""${mass}"" />
                <inertia ixx=""1e-3"" ixy=""0.0"" ixz=""0.0""
                     iyy=""1e-3"" iyz=""0.0""
                     izz=""1e-3"" />
        </inertial>
    </xacro:macro>

This can be used with the code

.. code-block:: xml

    <xacro:default_inertial mass=""10""/>

The parameters act just like properties, and you can use them in expressions

You can also use entire blocks as parameters too.

.. code-block:: xml

    <xacro:macro name=""blue_shape"" params=""name *shape"">
        <link name=""${name}"">
            <visual>
                <geometry>
                    <xacro:insert_block name=""shape"" />
                </geometry>
                <material name=""blue""/>
            </visual>
            <collision>
                <geometry>
                    <xacro:insert_block name=""shape"" />
                </geometry>
            </collision>
        </link>
    </xacro:macro>

    <xacro:blue_shape name=""base_link"">
        <cylinder radius="".42"" length="".01"" />
    </xacro:blue_shape>

* To specify a block parameter, include an asterisk before its parameter name.
* A block can be inserted using the insert_block command
* Insert the block as many times as you wish.

Practical Usage
---------------
The xacro language is rather flexible in what it allows you to do.
Here are a few useful ways that xacro is used in the `R2D2 model <https://github.com/ros/urdf_tutorial/blob/ros2/urdf/08-macroed.urdf.xacro>`_, in addition to the default inertial macro shown above.

To see the model generated by a xacro file, run the same command as with previous tutorials:

.. code-block:: console

  ros2 launch urdf_tutorial display.launch.py model:=urdf/08-macroed.urdf.xacro

(The launch file has been running the xacro command this whole time, but since there were no macros to expand, it didn't matter)

Leg macro
^^^^^^^^^
Often you want to create multiple similar looking objects in different locations.
You can use a macro and some simple math to reduce the amount of code you have to write, like we do with R2’s two legs.

.. code-block:: xml

    <xacro:macro name=""leg"" params=""prefix reflect"">
        <link name=""${prefix}_leg"">
            <visual>
                <geometry>
                    <box size=""${leglen} 0.1 0.2""/>
                </geometry>
                <origin xyz=""0 0 -${leglen/2}"" rpy=""0 ${pi/2} 0""/>
                <material name=""white""/>
            </visual>
            <collision>
                <geometry>
                    <box size=""${leglen} 0.1 0.2""/>
                </geometry>
                <origin xyz=""0 0 -${leglen/2}"" rpy=""0 ${pi/2} 0""/>
            </collision>
            <xacro:default_inertial mass=""10""/>
        </link>

        <joint name=""base_to_${prefix}_leg"" type=""fixed"">
            <parent link=""base_link""/>
            <child link=""${prefix}_leg""/>
            <origin xyz=""0 ${reflect*(width+.02)} 0.25"" />
        </joint>
        <!-- A bunch of stuff cut -->
    </xacro:macro>
    <xacro:leg prefix=""right"" reflect=""1"" />
    <xacro:leg prefix=""left"" reflect=""-1"" />

* Common Trick 1: Use a name prefix to get two similarly named objects.
* Common Trick 2: Use math to calculate joint origins.
  In the case that you change the size of your robot, changing a property with some math to calculate the joint offset will save a lot of trouble.
* Common Trick 3: Using a reflect parameter, and setting it to 1 or -1.
  See how we use the reflect parameter to put the legs on either side of the body in the base_to_${prefix}_leg origin.
",What are the three things that the Xacro package does that are very helpful?
".. redirect-from::

    Tutorials/URDF/Using-URDF-with-Robot-State-Publisher

.. _URDFPlusRSP:

Using URDF with ``robot_state_publisher``
=========================================

**Goal:** Simulate a walking robot modeled in URDF and view it in Rviz.

**Tutorial level:** Intermediate

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

This tutorial will show you how to model a walking robot, publish the state as a tf2 message and view the simulation in Rviz.
First, we create the URDF model describing the robot assembly.
Next we write a node which simulates the motion and publishes the JointState and transforms.
We then use ``robot_state_publisher`` to publish the entire robot state to ``/tf2``.

.. image:: images/r2d2_rviz_demo.gif

Prerequisites
-------------

- `rviz2 <https://index.ros.org/p/rviz2/>`__

As always, don’t forget to source ROS 2 in :doc:`every new terminal you open <../../Beginner-CLI-Tools/Configuring-ROS2-Environment>`.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^
Create the directory:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      mkdir -p second_ros2_ws/src

  .. group-tab:: macOS

    .. code-block:: console

      mkdir -p second_ros2_ws/src

  .. group-tab:: Windows

    .. code-block:: console

      md second_ros2_ws/src

Then create the package:

.. code-block:: console

    cd second_ros2_ws/src
    ros2 pkg create --build-type ament_python --license Apache-2.0 urdf_tutorial_r2d2 --dependencies rclpy
    cd urdf_tutorial_r2d2

You should now see a ``urdf_tutorial_r2d2`` folder.
Next you will make several changes to it.

2 Create the URDF File
^^^^^^^^^^^^^^^^^^^^^^

Create the directory where we will store some assets:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      mkdir -p urdf

  .. group-tab:: macOS

    .. code-block:: console

      mkdir -p urdf

  .. group-tab:: Windows

    .. code-block:: console

      md urdf

Download the :download:`URDF file <documents/r2d2.urdf.xml>` and save it as ``second_ros2_ws/src/urdf_tutorial_r2d2/urdf/r2d2.urdf.xml``.
Download the :download:`Rviz configuration file <documents/r2d2.rviz>` and save it as ``second_ros2_ws/src/urdf_tutorial_r2d2/urdf/r2d2.rviz``.

3 Publish the state
^^^^^^^^^^^^^^^^^^^

Now we need a method for specifying what state the robot is in.
To do this, we must specify all three joints and the overall odometry.

Fire up your favorite editor and paste the following code into ``second_ros2_ws/src/urdf_tutorial_r2d2/urdf_tutorial_r2d2/state_publisher.py``

.. code-block:: python

  from math import sin, cos, pi
  import rclpy
  from rclpy.executors import ExternalShutdownException
  from rclpy.node import Node
  from rclpy.qos import QoSProfile
  from geometry_msgs.msg import Quaternion
  from sensor_msgs.msg import JointState
  from tf2_ros import TransformBroadcaster, TransformStamped


  class StatePublisher(Node):

      def __init__(self):
          super().__init__('state_publisher')

          qos_profile = QoSProfile(depth=10)
          self.joint_pub = self.create_publisher(JointState, 'joint_states', qos_profile)
          self.broadcaster = TransformBroadcaster(self, qos=qos_profile)
          self.timer = self.create_timer(1/30, self.update)

          self.degree = pi / 180.0

          # robot state
          self.tilt = 0.
          self.tinc = self.degree
          self.swivel = 0.
          self.angle = 0.
          self.height = 0.
          self.hinc = 0.005

          # message declarations
          self.odom_trans = TransformStamped()
          self.odom_trans.header.frame_id = 'odom'
          self.odom_trans.child_frame_id = 'axis'
          self.joint_state = JointState()

          self.get_logger().info(""{0} started"".format(self.get_name()))

      def update(self):
          # update joint_state
          now = self.get_clock().now()
          self.joint_state.header.stamp = now.to_msg()
          self.joint_state.name = ['swivel', 'tilt', 'periscope']
          self.joint_state.position = [self.swivel, self.tilt, self.height]

          # update transform
          # (moving in a circle with radius=2)
          self.odom_trans.header.stamp = now.to_msg()
          self.odom_trans.transform.translation.x = cos(self.angle)*2
          self.odom_trans.transform.translation.y = sin(self.angle)*2
          self.odom_trans.transform.translation.z = 0.7
          self.odom_trans.transform.rotation = \
              euler_to_quaternion(0, 0, self.angle + pi/2) # roll,pitch,yaw

          # send the joint state and transform
          self.joint_pub.publish(self.joint_state)
          self.broadcaster.sendTransform(self.odom_trans)

          # Create new robot state
          self.tilt += self.tinc
          if self.tilt < -0.5 or self.tilt > 0.0:
              self.tinc *= -1
          self.height += self.hinc
          if self.height > 0.2 or self.height < 0.0:
              self.hinc *= -1
          self.swivel += self.degree
          self.angle += self.degree/4


  def euler_to_quaternion(roll, pitch, yaw):
      qx = sin(roll/2) * cos(pitch/2) * cos(yaw/2) - cos(roll/2) * sin(pitch/2) * sin(yaw/2)
      qy = cos(roll/2) * sin(pitch/2) * cos(yaw/2) + sin(roll/2) * cos(pitch/2) * sin(yaw/2)
      qz = cos(roll/2) * cos(pitch/2) * sin(yaw/2) - sin(roll/2) * sin(pitch/2) * cos(yaw/2)
      qw = cos(roll/2) * cos(pitch/2) * cos(yaw/2) + sin(roll/2) * sin(pitch/2) * sin(yaw/2)
      return Quaternion(x=qx, y=qy, z=qz, w=qw)


  def main():
      try:
          with rclpy.init():
              node = StatePublisher()
              rclpy.spin(node)
      except (KeyboardInterrupt, ExternalShutdownException):
          pass


  if __name__ == '__main__':
      main()

4 Create a launch file
^^^^^^^^^^^^^^^^^^^^^^

Create a new ``second_ros2_ws/src/urdf_tutorial_r2d2/launch`` folder.
Open your editor and paste the following code, saving it as ``second_ros2_ws/src/urdf_tutorial_r2d2/launch/demo_launch.py``

.. code-block:: python

  import os
  from ament_index_python.packages import get_package_share_directory
  from launch import LaunchDescription
  from launch.actions import DeclareLaunchArgument
  from launch.substitutions import LaunchConfiguration
  from launch_ros.actions import Node

  def generate_launch_description():

      use_sim_time = LaunchConfiguration('use_sim_time', default='false')

      urdf_file_name = 'r2d2.urdf.xml'
      urdf = os.path.join(
          get_package_share_directory('urdf_tutorial_r2d2'),
          urdf_file_name)
      with open(urdf, 'r') as infp:
          robot_desc = infp.read()

      return LaunchDescription([
          DeclareLaunchArgument(
              'use_sim_time',
              default_value='false',
              description='Use simulation (Gazebo) clock if true'),
          Node(
              package='robot_state_publisher',
              executable='robot_state_publisher',
              name='robot_state_publisher',
              output='screen',
              parameters=[{'use_sim_time': use_sim_time, 'robot_description': robot_desc}],
              arguments=[urdf]),
          Node(
              package='urdf_tutorial_r2d2',
              executable='state_publisher',
              name='state_publisher',
              output='screen'),
      ])


5 Edit the setup.py file
^^^^^^^^^^^^^^^^^^^^^^^^

You must tell the **colcon** build tool how to install your Python package.
Edit the ``second_ros2_ws/src/urdf_tutorial_r2d2/setup.py`` file as follows:

- include these import statements

.. code-block:: python

  import os
  from glob import glob
  from setuptools import setup
  from setuptools import find_packages

- append these 2 lines inside ``data_files``

.. code-block:: python

  data_files=[
    ...
    (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*launch.[pxy][yma]*'))),
    (os.path.join('share', package_name), glob('urdf/*')),
  ],

- modify the ``entry_points`` table so you can later run 'state_publisher' from a console

.. code-block:: python

        'console_scripts': [
            'state_publisher = urdf_tutorial_r2d2.state_publisher:main'
        ],

Save the ``setup.py`` file with your changes.

6 Install the package
^^^^^^^^^^^^^^^^^^^^^
.. code-block:: console

    cd second_ros2_ws
    colcon build --symlink-install --packages-select urdf_tutorial_r2d2

Source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

      source install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

      call install/setup.bat


7 View the results
^^^^^^^^^^^^^^^^^^

Launch the package

.. code-block:: console

  ros2 launch urdf_tutorial_r2d2 demo_launch.py

Open a new terminal, the run Rviz using

.. code-block:: console

  rviz2 -d second_ros2_ws/install/urdf_tutorial_r2d2/share/urdf_tutorial_r2d2/r2d2.rviz

See the `User Guide <http://wiki.ros.org/rviz/UserGuide>`__ for details on how to use Rviz.

Summary
-------

You created a ``JointState`` publisher node and coupled it with ``robot_state_publisher`` to simulate a walking robot.
The code used in these examples is originally from `here <https://github.com/benbongalon/ros2-migration/tree/master/urdf_tutorial>`__.

Credit is given to the authors of this
`ROS 1 tutorial <http://wiki.ros.org/urdf/Tutorials/Using%20urdf%20with%20robot_state_publisher>`__
from which some content was reused.
","What is the purpose of the URDF tutorial on using URDF with robot_state_publisher, and what steps are involved in achieving the goal mentioned in the tutorial?"
".. redirect-from::

    Tutorials/URDF/Building-a-Movable-Robot-Model-with-URDF

.. _MoveableURDF:

Building a movable robot model
==============================

**Goal:** Learn how to define movable joints in URDF.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

In this tutorial, we’re going to revise the R2D2 model we made in the :doc:`previous tutorial <./Building-a-Visual-Robot-Model-with-URDF-from-Scratch>` so that it has movable joints.
In the previous model, all of the joints were fixed.
Now we’ll explore three other important types of joints: continuous, revolute and prismatic.

Make sure you have installed all prerequisites before continuing.
See the :doc:`previous tutorial <./Building-a-Visual-Robot-Model-with-URDF-from-Scratch>` for information on what is required.

Again, all of the robot models mentioned in this tutorial can be found in the `urdf_tutorial <https://index.ros.org/p/urdf_tutorial>`_ package.

`Here is the new urdf <https://github.com/ros/urdf_tutorial/blob/ros2/urdf/06-flexible.urdf>`_ with flexible joints.
You can compare it to the previous version to see everything that has changed, but we’re just going to focus on three example joints.

To visualize and control this model, run the same command as the last tutorial:

.. code-block:: console

  ros2 launch urdf_tutorial display.launch.py model:=urdf/06-flexible.urdf

However now this will also pop up a GUI that allows you to control the values of all the non-fixed joints.
Play with the model some and see how it moves.
Then, we can take a look at how we accomplished this.

.. image:: https://raw.githubusercontent.com/ros/urdf_tutorial/ros2/images/flexible.png
  :width: 800
  :alt: Screenshot of Flexible Model

The Head
--------

.. code-block:: xml

  <joint name=""head_swivel"" type=""continuous"">
    <parent link=""base_link""/>
    <child link=""head""/>
    <axis xyz=""0 0 1""/>
    <origin xyz=""0 0 0.3""/>
  </joint>

The connection between the body and the head is a continuous joint, meaning that it can take on any angle from negative infinity to positive infinity.
The wheels are also modeled like this, so that they can roll in both directions forever.

The only additional information we have to add is the axis of rotation, here specified by an xyz triplet, which specifies a vector around which the head will rotate.
Since we want it to go around the z axis, we specify the vector ""0 0 1"".

The Gripper
-----------

.. code-block:: xml

  <joint name=""left_gripper_joint"" type=""revolute"">
    <axis xyz=""0 0 1""/>
    <limit effort=""1000.0"" lower=""0.0"" upper=""0.548"" velocity=""0.5""/>
    <origin rpy=""0 0 0"" xyz=""0.2 0.01 0""/>
    <parent link=""gripper_pole""/>
    <child link=""left_gripper""/>
  </joint>

Both the right and the left gripper joints are modeled as revolute joints.
This means that they rotate in the same way that the continuous joints do, but they have strict limits.
Hence, we must include the limit tag specifying the upper and lower limits of the joint (in radians).
We also must specify a maximum velocity and effort for this joint but the actual values don't matter for our purposes here.

The Gripper Arm
---------------

.. code-block:: xml

  <joint name=""gripper_extension"" type=""prismatic"">
    <parent link=""base_link""/>
    <child link=""gripper_pole""/>
    <limit effort=""1000.0"" lower=""-0.38"" upper=""0"" velocity=""0.5""/>
    <origin rpy=""0 0 0"" xyz=""0.19 0 0.2""/>
  </joint>

The gripper arm is a different kind of joint, namely a prismatic joint.
This means that it moves along an axis, not around it.
This translational movement is what allows our robot model to extend and retract its gripper arm.

The limits of the prismatic arm are specified in the same way as a revolute joint, except that the units are meters, not radians.

Other Types of Joints
---------------------

There are two other kinds of joints that move around in space.
Whereas the prismatic joint can only move along one dimension, a planar joint can move around in a plane, or two dimensions.
Furthermore, a floating joint is unconstrained, and can move around in any of the three dimensions.
These joints cannot be specified by just one number, and therefore aren’t included in this tutorial.

Specifying the Pose
-------------------

As you move the sliders around in the GUI, the model moves in Rviz.
How is this done? First the `GUI <https://index.ros.org/p/joint_state_publisher_gui>`_ parses the URDF and finds all the non-fixed joints and their limits.
Then, it uses the values of the sliders to publish `sensor_msgs/msg/JointState <https://github.com/ros2/common_interfaces/blob/eloquent/sensor_msgs/msg/JointState.msg>`_ messages.
Those are then used by `robot_state_publisher <https://index.ros.org/p/robot_state_publisher>`_ to calculate all of transforms between the different parts.
The resulting transform tree is then used to display all of the shapes in Rviz.

Next steps
----------

Now that you have a visibly functional model, you can :doc:`add in some physical properties <./Adding-Physical-and-Collision-Properties-to-a-URDF-Model>`, or :doc:`start using xacro to simplify your code <./Using-Xacro-to-Clean-Up-a-URDF-File>`.
",What are the three important types of joints explored in this tutorial on building a movable robot model using URDF?
"Generating an URDF File
=======================

**Goal:** Learn how to Export and URDF File

**Tutorial level:** Intermediate

**Time:** 5 minutes

.. contents:: Contents
   :depth: 2
   :local:

Most roboticists work in teams, and often those teams include a mechanical engineer who develops a CAD model of robot.
Instead of crafting an URDF by hand it is possible to export an URDF model from many different CAD and modeling programs.
These export tools are often developed by individuals that are familiar with the particular CAD program they use.
Below you will find a list of available URDF exporters for a variety of CAD and 3D modeling software systems.
*The ROS core maintainers do not maintain these packages. As such we make no claims about their performance or ease of use.*
However, we figured it would be helpful to produce a list of available URDF exporters.

**CAD Exporters**

 * `Blender URDF Exporter <https://github.com/dfki-ric/phobos>`_
 * `CREO Parametric URDF Exporter <https://github.com/icub-tech-iit/creo2urdf>`_
 * `FreeCAD ROS Workbench <https://github.com/galou/freecad.cross>`_
 * `RobotCAD (FreeCAD OVERCROSS) <https://github.com/drfenixion/freecad.overcross>`_
 * `Freecad to Gazebo Exporter <https://github.com/Dave-Elec/freecad_to_gazebo>`_
 * `Fusion 360 URDF Exporter <https://github.com/dheena2k2/fusion2urdf-ros2>`_
 * `FusionSDF: Fusion 360 to SDF exporter <https://github.com/andreasBihlmaier/FusionSDF>`_
 * `OnShape URDF Exporter <https://github.com/Rhoban/onshape-to-robot>`_
 * `SolidWorks URDF Exporter <https://github.com/ros/solidworks_urdf_exporter>`_
 * `ExportURDF Library (Fusion360, OnShape, Solidworks) <https://github.com/daviddorf2023/ExportURDF>`_
 * `RoboForge Project (freemium / paid tooling) <https://robofor.ge/>`_

**Other URDF Export and Conversion Tools**

 * `Gazebo SDFormat to URDF Parser <https://github.com/ros/sdformat_urdf>`_
 * `SDF to URDF Converter in Python <https://github.com/andreasBihlmaier/pysdf>`_
 * `URDF to Webots Simulator Format <https://github.com/cyberbotics/urdf2webots>`_
 * The `Blender Robotics Tools <https://github.com/robotology/blender-robotics-utils/>`_ respository includes a number of useful tools, including a tool to export `URDF files from Blender. <https://github.com/robotology/blender-robotics-utils/tree/master?tab=readme-ov-file#urdftoblender>`_
 * `CoppeliaSim URDF Exporter <https://manual.coppeliarobotics.com/en/importExport.htm#urdf>`_
 * `Isaac Sim URDF Exporter <https://docs.omniverse.nvidia.com/isaacsim/latest/advanced_tutorials/tutorial_advanced_export_urdf.html>`_

**Viewing URDF & SDF Files**
 * `Examples of Common URDF Launch Files <https://github.com/ros/urdf_launch>`_
 * Web Viewer for URDF Files: `GitHub Repo <https://github.com/gkjohnson/urdf-loaders/>`_ & `Live Website <https://gkjohnson.github.io/urdf-loaders/javascript/example/bundle/index.html>`_
 * `View SDF Models in RViz <https://github.com/Yadunund/view_sdf_rviz>`_
 * `Jupyterlab URDF Viewer <https://github.com/IsabelParedes/jupyterlab-urdf>`_

If you have an URDF tool you like please consider adding it to the list above!
",What are some examples of CAD exporters for generating URDF files?
".. redirect-from::

    Tutorials/URDF/URDF-Main

.. _URDFMain:

URDF
====

URDF (Unified Robot Description Format) is a file format for specifying the geometry and organization of robots in ROS.

.. contents:: Contents
   :depth: 0
   :local:

.. toctree::
   :maxdepth: 1

   Building-a-Visual-Robot-Model-with-URDF-from-Scratch
   Building-a-Movable-Robot-Model-with-URDF
   Adding-Physical-and-Collision-Properties-to-a-URDF-Model
   Using-Xacro-to-Clean-Up-a-URDF-File
   Using-URDF-with-Robot-State-Publisher
   Exporting-an-URDF-File
",What is URDF and what is its purpose within ROS?
".. redirect-from::

    Tutorials/URDF/Adding-Physical-and-Collision-Properties-to-a-URDF-Model

.. _URDFProperties:

Adding physical and collision properties
========================================

**Goal:** Learn how to add collision and inertial properties to links, and how to add joint dynamics to joints.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

In this tutorial, we’ll look at how to add some basic physical properties to your URDF model and how to specify its collision properties.

Collision
---------

So far, we’ve only specified our links with a single sub-element, ``visual``, which defines (not surprisingly) what the robot looks like.
However, in order to get collision detection to work or to simulate the robot, we need to define a ``collision`` element as well.
`Here is the new urdf <https://raw.githubusercontent.com/ros/urdf_tutorial/master/urdf/07-physics.urdf>`_ with collision and physical properties.

Here is the code for our new base link.

.. code-block:: xml

    <link name=""base_link"">
        <visual>
          <geometry>
            <cylinder length=""0.6"" radius=""0.2""/>
          </geometry>
          <material name=""blue"">
            <color rgba=""0 0 .8 1""/>
          </material>
        </visual>
        <collision>
          <geometry>
            <cylinder length=""0.6"" radius=""0.2""/>
          </geometry>
        </collision>
      </link>

* The collision element is a direct subelement of the link object, at the same level as the visual tag.
* The collision element defines its shape the same way the visual element does, with a geometry tag.
  The format for the geometry tag is exactly the same here as with the visual.
* You can also specify an origin in the same way as a subelement of the collision tag (as with the visual).

In many cases, you’ll want the collision geometry and origin to be exactly the same as the visual geometry and origin.
However, there are two main cases where you wouldn’t:

 * **Quicker Processing**. Doing collision detection for two meshes is a lot more computational complex than for two simple geometries.
   Hence, you may want to replace the meshes with simpler geometries in the collision element.
 * **Safe Zones**. You may want to restrict movement close to sensitive equipment.
   For instance, if we didn’t want anything to collide with R2D2’s head, we might define the collision geometry to be a cylinder encasing his head to prevent anything from getting too close to his head.

Physical Properties
-------------------
In order to get your model to simulate properly, you need to define several physical properties of your robot, i.e.
the properties that a physics engine like Gazebo would need.

Inertia
^^^^^^^
Every link element being simulated needs an inertial tag.
Here is a simple one.

.. code-block:: xml

  <link name=""base_link"">
    <visual>
      <geometry>
        <cylinder length=""0.6"" radius=""0.2""/>
      </geometry>
      <material name=""blue"">
        <color rgba=""0 0 .8 1""/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder length=""0.6"" radius=""0.2""/>
      </geometry>
    </collision>
    <inertial>
      <mass value=""10""/>
      <inertia ixx=""1e-3"" ixy=""0.0"" ixz=""0.0"" iyy=""1e-3"" iyz=""0.0"" izz=""1e-3""/>
    </inertial>
  </link>

* This element is also a subelement of the link object.
* The mass is defined in kilograms.
* The 3x3 rotational inertia matrix is specified with the inertia element.
  Since this is symmetrical, it can be represented by only 6 elements, as such.

    +---------+---------+---------+
    | **ixx** | **ixy** | **ixz** |
    +---------+---------+---------+
    |   ixy   | **iyy** | **iyz** |
    +---------+---------+---------+
    |   ixz   |   iyz   | **izz** |
    +---------+---------+---------+

* This information can be provided to you by modeling programs such as MeshLab.
  The inertia of geometric primitives (cylinder, box, sphere) can be computed using Wikipedia's `list of moment of inertia tensors <https://en.wikipedia.org/wiki/List_of_moments_of_inertia#List_of_3D_inertia_tensors>`_ (and is used in the above example).
* The inertia tensor depends on both the mass and the distribution of mass of the object.
  A good first approximation is to assume equal distribution of mass in the volume of the object and compute the inertia tensor based on the object's shape, as outlined above.
* If unsure what to put, a matrix with ixx/iyy/izz=1e-3 or smaller is often a reasonable default for a mid-sized link (it corresponds to a box of 0.1 m side length with a mass of 0.6 kg).
  The identity matrix is a particularly bad choice, since it is often much too high (it corresponds to a box of 0.1 m side length with a mass of 600 kg!).
* You can also specify an origin tag to specify the center of gravity and the inertial reference frame (relative to the link's reference frame).
* When using realtime controllers, inertia elements of zero (or almost zero) can cause the robot model to collapse without warning, and all links will appear with their origins coinciding with the world origin.

Contact Coefficients
^^^^^^^^^^^^^^^^^^^^
You can also define how the links behave when they are in contact with one another.
This is done with a subelement of the collision tag called contact_coefficients.
There are three attributes to specify:

 * mu - `Friction coefficient <https://simple.wikipedia.org/wiki/Coefficient_of_friction>`_
 * kp - `Stiffness coefficient <https://en.wikipedia.org/wiki/Stiffness>`_
 * kd - `Dampening coefficient <https://en.wikipedia.org/wiki/Damping_ratio#Damping_ratio_definition>`_

Joint Dynamics
^^^^^^^^^^^^^^
How the joint moves is defined by the dynamics tag for the joint.
There are two attributes here:

 * ``friction`` - The physical static friction.
   For prismatic joints, the units are Newtons.
   For revolving joints, the units are Newton meters.
 * ``damping`` - The physical damping value.
   For prismatic joints, the units are Newton seconds per meter.
   For revolving joints, Newton meter seconds per radian.

If not specified, these coefficients default to zero.

Other Tags
----------
In the realm of pure URDF (i.e. excluding Gazebo-specific tags), there are two remaining tags to help define the joints: calibration and safety controller.
Check out the `spec <https://wiki.ros.org/urdf/XML/joint>`_, as they are not included in this tutorial.

Next Steps
----------
Reduce the amount of code and annoying math you have to do by :doc:`using xacro <./Using-Xacro-to-Clean-Up-a-URDF-File>`.
",How can you define collision properties in a URDF model according to the provided text?
".. redirect-from::

    Tutorials/URDF/Building-a-Visual-Robot-Model-with-URDF-from-Scratch

.. _BuildingURDF:

Building a visual robot model from scratch
==========================================

**Goal:** Learn how to build a visual model of a robot that you can view in Rviz

**Tutorial level:** Intermediate

**Time:** 20 minutes

.. contents:: Contents
   :depth: 2
   :local:

.. note:: This tutorial assumes you know how to write well-formatted XML code

In this tutorial, we’re going to build a visual model of a robot that vaguely looks like R2D2.
In later tutorials, you’ll learn how to :doc:`articulate the model <./Building-a-Movable-Robot-Model-with-URDF>`, :doc:`add in some physical properties <./Adding-Physical-and-Collision-Properties-to-a-URDF-Model>`, and :doc:`generate neater code with xacro <./Using-Xacro-to-Clean-Up-a-URDF-File>`, but for now, we’re going to focus on getting the visual geometry correct.

Before continuing, make sure you have the `joint_state_publisher <https://index.ros.org/p/joint_state_publisher>`_ package installed.
If you installed `urdf_tutorial <https://index.ros.org/p/urdf_tutorial>`_ binaries, this should already be the case.
If not, please update your installation to include that package (use ``rosdep`` to check).

All of the robot models mentioned in this tutorial (and the source files) can be found in the `urdf_tutorial <https://index.ros.org/p/urdf_tutorial>`_ package.

One Shape
---------

First, we’re just going to explore one simple shape.
Here’s about as simple as a urdf as you can make.
`[Source: 01-myfirst.urdf] <https://github.com/ros/urdf_tutorial/blob/ros2/urdf/01-myfirst.urdf>`_

.. code-block:: xml

    <?xml version=""1.0""?>
    <robot name=""myfirst"">
      <link name=""base_link"">
        <visual>
          <geometry>
            <cylinder length=""0.6"" radius=""0.2""/>
          </geometry>
        </visual>
      </link>
    </robot>

To translate the XML into English, this is a robot with the name ``myfirst``, that contains only one link (a.k.a. part), whose visual component is just a cylinder 0.6 meters long with a 0.2 meter radius.
This may seem like a lot of enclosing tags for a simple “hello world” type example, but it will get more complicated, trust me.

To examine the model, launch the ``display.launch.py`` file:

.. code-block:: console

  ros2 launch urdf_tutorial display.launch.py model:=urdf/01-myfirst.urdf

This does three things:

 * Loads the specified model and saves it as a parameter for the ``robot_state_publisher`` node.
 * Runs nodes to publish `sensor_msgs/msg/JointState <https://github.com/ros2/common_interfaces/blob/{DISTRO}/sensor_msgs/msg/JointState.msg>`_ and transforms (more on these later)
 * Starts Rviz with a configuration file

After launching ``display.launch.py``, you should end up with RViz showing you the following:

.. image:: https://raw.githubusercontent.com/ros/urdf_tutorial/ros2/images/myfirst.png
  :width: 800
  :alt: my first image

Things to note:
 * The fixed frame is the transform frame where the center of the grid is located.
   Here, it’s a frame defined by our one link, base_link.
 * The visual element (the cylinder) has its origin at the center of its geometry as a default.
   Hence, half the cylinder is below the grid.

Multiple Shapes
---------------

Now let’s look at how to add multiple shapes/links.
If we just add more link elements to the urdf, the parser won’t know where to put them.
So, we have to add joints.
Joint elements can refer to both flexible and inflexible joints.
We’ll start with inflexible, or fixed joints.
`[Source: 02-multipleshapes.urdf] <https://github.com/ros/urdf_tutorial/blob/ros2/urdf/02-multipleshapes.urdf>`_

.. code-block:: xml

    <?xml version=""1.0""?>
    <robot name=""multipleshapes"">
      <link name=""base_link"">
        <visual>
          <geometry>
            <cylinder length=""0.6"" radius=""0.2""/>
          </geometry>
        </visual>
      </link>

      <link name=""right_leg"">
        <visual>
          <geometry>
            <box size=""0.6 0.1 0.2""/>
          </geometry>
        </visual>
      </link>

      <joint name=""base_to_right_leg"" type=""fixed"">
        <parent link=""base_link""/>
        <child link=""right_leg""/>
      </joint>

    </robot>

* Note how we defined a 0.6m x 0.1m x 0.2m box
* The joint is defined in terms of a parent and a child.
  URDF is ultimately a tree structure with one root link.
  This means that the leg’s position is dependent on the base_link’s position.

.. code-block:: console

  ros2 launch urdf_tutorial display.launch.py model:=urdf/02-multipleshapes.urdf

.. image:: https://raw.githubusercontent.com/ros/urdf_tutorial/ros2/images/multipleshapes.png
  :width: 800
  :alt: Multiple Shapes

Both of the shapes overlap with each other, because they share the same origin.
If we want them not to overlap we must define more origins.

Origins
-------

R2D2’s leg attaches to the top half of his torso, on the side.
So that’s where we specify the origin of the JOINT to be.
Also, it doesn’t attach to the middle of the leg, it attaches to the upper part, so we must offset the origin for the leg as well.
We also rotate the leg so it is upright.
`[Source: 03-origins.urdf] <https://github.com/ros/urdf_tutorial/blob/ros2/urdf/03-origins.urdf>`_

.. code-block:: xml

    <?xml version=""1.0""?>
    <robot name=""origins"">
      <link name=""base_link"">
        <visual>
          <geometry>
            <cylinder length=""0.6"" radius=""0.2""/>
          </geometry>
        </visual>
      </link>

      <link name=""right_leg"">
        <visual>
          <geometry>
            <box size=""0.6 0.1 0.2""/>
          </geometry>
          <origin rpy=""0 1.57075 0"" xyz=""0 0 -0.3""/>
        </visual>
      </link>

      <joint name=""base_to_right_leg"" type=""fixed"">
        <parent link=""base_link""/>
        <child link=""right_leg""/>
        <origin xyz=""0 -0.22 0.25""/>
      </joint>

    </robot>

* Let’s start by examining the joint’s origin.
  It is defined in terms of the parent’s reference frame.
  So we are -0.22 meters in the y direction (to our left, but to the right relative to the axes) and 0.25 meters in the z direction (up).
  This means that the origin for the child link will be up and to the right, regardless of the child link’s visual origin tag.
  Since we didn’t specify a rpy (roll pitch yaw) attribute, the child frame will be default have the same orientation as the parent frame.
* Now, looking at the leg’s visual origin, it has both a xyz and rpy offset.
  This defines where the center of the visual element should be, relative to its origin.
  Since we want the leg to attach at the top, we offset the origin down by setting the z offset to be -0.3 meters.
  And since we want the long part of the leg to be parallel to the z axis, we rotate the visual part PI/2 around the Y axis.

.. code-block:: console

  ros2 launch urdf_tutorial display.launch.py model:=urdf/03-origins.urdf

.. image:: https://raw.githubusercontent.com/ros/urdf_tutorial/ros2/images/origins.png
  :width: 800
  :alt: Origins Screenshot

* The launch file runs packages that will create TF frames for each link in your model based on your URDF.
  Rviz uses this information to figure out where to display each shape.
* If a TF frame does not exist for a given URDF link, then it will be placed at the origin in white (ref. `related question <http://answers.ros.org/question/207947/how-do-you-use-externally-defined-materials-in-a-urdfxacro-file/>`_).

Material Girl
-------------

“Alright,” I hear you say.
“That’s very cute, but not everyone owns a B21.
My robot and R2D2 are not red!”
That’s a good point.
Let’s take a look at the material tag.
`[Source: 04-materials.urdf] <https://github.com/ros/urdf_tutorial/blob/ros2/urdf/04-materials.urdf>`_

.. code-block:: xml

    <?xml version=""1.0""?>
    <robot name=""materials"">

      <material name=""blue"">
        <color rgba=""0 0 0.8 1""/>
      </material>

      <material name=""white"">
        <color rgba=""1 1 1 1""/>
      </material>

      <link name=""base_link"">
        <visual>
          <geometry>
            <cylinder length=""0.6"" radius=""0.2""/>
          </geometry>
          <material name=""blue""/>
        </visual>
      </link>

      <link name=""right_leg"">
        <visual>
          <geometry>
            <box size=""0.6 0.1 0.2""/>
          </geometry>
          <origin rpy=""0 1.57075 0"" xyz=""0 0 -0.3""/>
          <material name=""white""/>
        </visual>
      </link>

      <joint name=""base_to_right_leg"" type=""fixed"">
        <parent link=""base_link""/>
        <child link=""right_leg""/>
        <origin xyz=""0 -0.22 0.25""/>
      </joint>

      <link name=""left_leg"">
        <visual>
          <geometry>
            <box size=""0.6 0.1 0.2""/>
          </geometry>
          <origin rpy=""0 1.57075 0"" xyz=""0 0 -0.3""/>
          <material name=""white""/>
        </visual>
      </link>

      <joint name=""base_to_left_leg"" type=""fixed"">
        <parent link=""base_link""/>
        <child link=""left_leg""/>
        <origin xyz=""0 0.22 0.25""/>
      </joint>

    </robot>

* The body is now blue.
  We’ve defined a new material called “blue”, with the red, green, blue and alpha channels defined as 0,0,0.8 and 1 respectively.
  All of the values can be in the range [0,1].
  This material is then referenced by the base_link's visual element.
  The white material is defined similarly.
* You could also define the material tag from within the visual element, and even reference it in other links.
  No one will even complain if you redefine it though.
* You can also use a texture to specify an image file to be used for coloring the object

.. code-block:: console

  ros2 launch urdf_tutorial display.launch.py model:=urdf/04-materials.urdf

.. image:: https://raw.githubusercontent.com/ros/urdf_tutorial/ros2/images/materials.png
  :width: 800
  :alt: Materials Screenshot

Finishing the Model
-------------------

Now we finish the model off with a few more shapes: feet, wheels, and head.
Most notably, we add a sphere and a some meshes.
We’ll also add few other pieces that we’ll use later.
`[Source: 05-visual.urdf] <https://github.com/ros/urdf_tutorial/blob/ros2/urdf/05-visual.urdf>`_

.. code-block:: xml

    <?xml version=""1.0""?>
    <robot name=""visual"">

      <material name=""blue"">
        <color rgba=""0 0 0.8 1""/>
      </material>
      <material name=""black"">
        <color rgba=""0 0 0 1""/>
      </material>
      <material name=""white"">
        <color rgba=""1 1 1 1""/>
      </material>

      <link name=""base_link"">
        <visual>
          <geometry>
            <cylinder length=""0.6"" radius=""0.2""/>
          </geometry>
          <material name=""blue""/>
        </visual>
      </link>

      <link name=""right_leg"">
        <visual>
          <geometry>
            <box size=""0.6 0.1 0.2""/>
          </geometry>
          <origin rpy=""0 1.57075 0"" xyz=""0 0 -0.3""/>
          <material name=""white""/>
        </visual>
      </link>

      <joint name=""base_to_right_leg"" type=""fixed"">
        <parent link=""base_link""/>
        <child link=""right_leg""/>
        <origin xyz=""0 -0.22 0.25""/>
      </joint>

      <link name=""right_base"">
        <visual>
          <geometry>
            <box size=""0.4 0.1 0.1""/>
          </geometry>
          <material name=""white""/>
        </visual>
      </link>

      <joint name=""right_base_joint"" type=""fixed"">
        <parent link=""right_leg""/>
        <child link=""right_base""/>
        <origin xyz=""0 0 -0.6""/>
      </joint>

      <link name=""right_front_wheel"">
        <visual>
          <origin rpy=""1.57075 0 0"" xyz=""0 0 0""/>
          <geometry>
            <cylinder length=""0.1"" radius=""0.035""/>
          </geometry>
          <material name=""black""/>
        </visual>
      </link>
      <joint name=""right_front_wheel_joint"" type=""fixed"">
        <parent link=""right_base""/>
        <child link=""right_front_wheel""/>
        <origin rpy=""0 0 0"" xyz=""0.133333333333 0 -0.085""/>
      </joint>

      <link name=""right_back_wheel"">
        <visual>
          <origin rpy=""1.57075 0 0"" xyz=""0 0 0""/>
          <geometry>
            <cylinder length=""0.1"" radius=""0.035""/>
          </geometry>
          <material name=""black""/>
        </visual>
      </link>
      <joint name=""right_back_wheel_joint"" type=""fixed"">
        <parent link=""right_base""/>
        <child link=""right_back_wheel""/>
        <origin rpy=""0 0 0"" xyz=""-0.133333333333 0 -0.085""/>
      </joint>

      <link name=""left_leg"">
        <visual>
          <geometry>
            <box size=""0.6 0.1 0.2""/>
          </geometry>
          <origin rpy=""0 1.57075 0"" xyz=""0 0 -0.3""/>
          <material name=""white""/>
        </visual>
      </link>

      <joint name=""base_to_left_leg"" type=""fixed"">
        <parent link=""base_link""/>
        <child link=""left_leg""/>
        <origin xyz=""0 0.22 0.25""/>
      </joint>

      <link name=""left_base"">
        <visual>
          <geometry>
            <box size=""0.4 0.1 0.1""/>
          </geometry>
          <material name=""white""/>
        </visual>
      </link>

      <joint name=""left_base_joint"" type=""fixed"">
        <parent link=""left_leg""/>
        <child link=""left_base""/>
        <origin xyz=""0 0 -0.6""/>
      </joint>

      <link name=""left_front_wheel"">
        <visual>
          <origin rpy=""1.57075 0 0"" xyz=""0 0 0""/>
          <geometry>
            <cylinder length=""0.1"" radius=""0.035""/>
          </geometry>
          <material name=""black""/>
        </visual>
      </link>
      <joint name=""left_front_wheel_joint"" type=""fixed"">
        <parent link=""left_base""/>
        <child link=""left_front_wheel""/>
        <origin rpy=""0 0 0"" xyz=""0.133333333333 0 -0.085""/>
      </joint>

      <link name=""left_back_wheel"">
        <visual>
          <origin rpy=""1.57075 0 0"" xyz=""0 0 0""/>
          <geometry>
            <cylinder length=""0.1"" radius=""0.035""/>
          </geometry>
          <material name=""black""/>
        </visual>
      </link>
      <joint name=""left_back_wheel_joint"" type=""fixed"">
        <parent link=""left_base""/>
        <child link=""left_back_wheel""/>
        <origin rpy=""0 0 0"" xyz=""-0.133333333333 0 -0.085""/>
      </joint>

      <joint name=""gripper_extension"" type=""fixed"">
        <parent link=""base_link""/>
        <child link=""gripper_pole""/>
        <origin rpy=""0 0 0"" xyz=""0.19 0 0.2""/>
      </joint>

      <link name=""gripper_pole"">
        <visual>
          <geometry>
            <cylinder length=""0.2"" radius=""0.01""/>
          </geometry>
          <origin rpy=""0 1.57075 0 "" xyz=""0.1 0 0""/>
        </visual>
      </link>

      <joint name=""left_gripper_joint"" type=""fixed"">
        <origin rpy=""0 0 0"" xyz=""0.2 0.01 0""/>
        <parent link=""gripper_pole""/>
        <child link=""left_gripper""/>
      </joint>

      <link name=""left_gripper"">
        <visual>
          <origin rpy=""0.0 0 0"" xyz=""0 0 0""/>
          <geometry>
            <mesh filename=""package://urdf_tutorial/meshes/l_finger.dae""/>
          </geometry>
        </visual>
      </link>

      <joint name=""left_tip_joint"" type=""fixed"">
        <parent link=""left_gripper""/>
        <child link=""left_tip""/>
      </joint>

      <link name=""left_tip"">
        <visual>
          <origin rpy=""0.0 0 0"" xyz=""0.09137 0.00495 0""/>
          <geometry>
            <mesh filename=""package://urdf_tutorial/meshes/l_finger_tip.dae""/>
          </geometry>
        </visual>
      </link>
      <joint name=""right_gripper_joint"" type=""fixed"">
        <origin rpy=""0 0 0"" xyz=""0.2 -0.01 0""/>
        <parent link=""gripper_pole""/>
        <child link=""right_gripper""/>
      </joint>

      <link name=""right_gripper"">
        <visual>
          <origin rpy=""-3.1415 0 0"" xyz=""0 0 0""/>
          <geometry>
            <mesh filename=""package://urdf_tutorial/meshes/l_finger.dae""/>
          </geometry>
        </visual>
      </link>

      <joint name=""right_tip_joint"" type=""fixed"">
        <parent link=""right_gripper""/>
        <child link=""right_tip""/>
      </joint>

      <link name=""right_tip"">
        <visual>
          <origin rpy=""-3.1415 0 0"" xyz=""0.09137 0.00495 0""/>
          <geometry>
            <mesh filename=""package://urdf_tutorial/meshes/l_finger_tip.dae""/>
          </geometry>
        </visual>
      </link>

      <link name=""head"">
        <visual>
          <geometry>
            <sphere radius=""0.2""/>
          </geometry>
          <material name=""white""/>
        </visual>
      </link>
      <joint name=""head_swivel"" type=""fixed"">
        <parent link=""base_link""/>
        <child link=""head""/>
        <origin xyz=""0 0 0.3""/>
      </joint>

      <link name=""box"">
        <visual>
          <geometry>
            <box size=""0.08 0.08 0.08""/>
          </geometry>
          <material name=""blue""/>
        </visual>
      </link>

      <joint name=""tobox"" type=""fixed"">
        <parent link=""head""/>
        <child link=""box""/>
        <origin xyz=""0.1814 0 0.1414""/>
      </joint>
    </robot>

.. code-block:: console

  ros2 launch urdf_tutorial display.launch.py model:=urdf/05-visual.urdf

.. image:: https://raw.githubusercontent.com/ros/urdf_tutorial/ros2/images/visual.png
  :width: 800
  :alt: Visual Screenshot

How to add the sphere should be fairly self explanatory:

.. code-block:: xml

  <link name=""head"">
    <visual>
      <geometry>
        <sphere radius=""0.2""/>
      </geometry>
      <material name=""white""/>
    </visual>
  </link>

The meshes here were borrowed from the PR2.
They are separate files which you have to specify the path for.
You should use the ``package://NAME_OF_PACKAGE/path`` notation.
The meshes for this tutorial are located within the ``urdf_tutorial`` package, in a folder called meshes.

.. code-block:: xml

  <link name=""left_gripper"">
    <visual>
      <origin rpy=""0.0 0 0"" xyz=""0 0 0""/>
      <geometry>
        <mesh filename=""package://urdf_tutorial/meshes/l_finger.dae""/>
      </geometry>
    </visual>
  </link>

* The meshes can be imported in a number of different formats.
  STL is fairly common, but the engine also supports DAE, which can have its own color data, meaning you don’t have to specify the color/material.
  Often these are in separate files.
  These meshes reference the ``.tif`` files also in the meshes folder.
* Meshes can also be sized using relative scaling parameters or a bounding box size.
* We could have also referred to meshes in a completely different package.

There you have it.
A R2D2-like URDF model.
Now you can continue on to the next step, :doc:`making it move <./Building-a-Movable-Robot-Model-with-URDF>`.
",What is the purpose of the joint_state_publisher package mentioned in the tutorial?
".. redirect-from::

    Tutorials/Tf2/Writing-A-Tf2-Listener-Cpp

Writing a listener (C++)
========================

**Goal:** Learn how to use tf2 to get access to frame transformations.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In previous tutorials we created a tf2 broadcaster to publish the pose of a turtle to tf2.

In this tutorial we'll create a tf2 listener to start using tf2.

Prerequisites
-------------

This tutorial assumes you have completed the :doc:`tf2 static broadcaster tutorial (C++) <./Writing-A-Tf2-Static-Broadcaster-Cpp>` and the :doc:`tf2 broadcaster tutorial (C++) <./Writing-A-Tf2-Broadcaster-Cpp>`.
In the previous tutorial, we created a ``learning_tf2_cpp`` package, which is where we will continue working from.

Tasks
-----

1 Write the listener node
^^^^^^^^^^^^^^^^^^^^^^^^^

Let's first create the source files.
Go to the ``learning_tf2_cpp`` package we created in the previous tutorial.
Inside the ``src`` directory download the example listener code by entering the following command:

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_listener.cpp

    .. group-tab:: macOS

        .. code-block:: console

            wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_listener.cpp

    .. group-tab:: Windows

        In a Windows command line prompt:

        .. code-block:: console

                curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_listener.cpp -o turtle_tf2_listener.cpp

        Or in powershell:

        .. code-block:: console

                curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_listener.cpp -o turtle_tf2_listener.cpp

Open the file using your preferred text editor.

.. code-block:: C++

    #include <chrono>
    #include <functional>
    #include <memory>
    #include <string>

    #include ""geometry_msgs/msg/transform_stamped.hpp""
    #include ""geometry_msgs/msg/twist.hpp""
    #include ""rclcpp/rclcpp.hpp""
    #include ""tf2/exceptions.h""
    #include ""tf2_ros/transform_listener.h""
    #include ""tf2_ros/buffer.h""
    #include ""turtlesim_msgs/srv/spawn.hpp""

    using namespace std::chrono_literals;

    class FrameListener : public rclcpp::Node
    {
    public:
      FrameListener()
      : Node(""turtle_tf2_frame_listener""),
        turtle_spawning_service_ready_(false),
        turtle_spawned_(false)
      {
        // Declare and acquire `target_frame` parameter
        target_frame_ = this->declare_parameter<std::string>(""target_frame"", ""turtle1"");

        tf_buffer_ =
          std::make_unique<tf2_ros::Buffer>(this->get_clock());
        tf_listener_ =
          std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

        // Create a client to spawn a turtle
        spawner_ =
          this->create_client<turtlesim_msgs::srv::Spawn>(""spawn"");

        // Create turtle2 velocity publisher
        publisher_ =
          this->create_publisher<geometry_msgs::msg::Twist>(""turtle2/cmd_vel"", 1);

        // Call on_timer function every second
        timer_ = this->create_wall_timer(
          1s, [this]() {return this->on_timer();});
      }

    private:
      void on_timer()
      {
        // Store frame names in variables that will be used to
        // compute transformations
        std::string fromFrameRel = target_frame_.c_str();
        std::string toFrameRel = ""turtle2"";

        if (turtle_spawning_service_ready_) {
          if (turtle_spawned_) {
            geometry_msgs::msg::TransformStamped t;

            // Look up for the transformation between target_frame and turtle2 frames
            // and send velocity commands for turtle2 to reach target_frame
            try {
              t = tf_buffer_->lookupTransform(
                toFrameRel, fromFrameRel,
                tf2::TimePointZero);
            } catch (const tf2::TransformException & ex) {
              RCLCPP_INFO(
                this->get_logger(), ""Could not transform %s to %s: %s"",
                toFrameRel.c_str(), fromFrameRel.c_str(), ex.what());
              return;
            }

            geometry_msgs::msg::Twist msg;

            static const double scaleRotationRate = 1.0;
            msg.angular.z = scaleRotationRate * atan2(
              t.transform.translation.y,
              t.transform.translation.x);

            static const double scaleForwardSpeed = 0.5;
            msg.linear.x = scaleForwardSpeed * sqrt(
              pow(t.transform.translation.x, 2) +
              pow(t.transform.translation.y, 2));

            publisher_->publish(msg);
          } else {
            RCLCPP_INFO(this->get_logger(), ""Successfully spawned"");
            turtle_spawned_ = true;
          }
        } else {
          // Check if the service is ready
          if (spawner_->service_is_ready()) {
            // Initialize request with turtle name and coordinates
            // Note that x, y and theta are defined as floats in turtlesim_msgs/srv/Spawn
            auto request = std::make_shared<turtlesim_msgs::srv::Spawn::Request>();
            request->x = 4.0;
            request->y = 2.0;
            request->theta = 0.0;
            request->name = ""turtle2"";

            // Call request
            using ServiceResponseFuture =
              rclcpp::Client<turtlesim_msgs::srv::Spawn>::SharedFuture;
            auto response_received_callback = [this](ServiceResponseFuture future) {
                auto result = future.get();
                if (strcmp(result->name.c_str(), ""turtle2"") == 0) {
                  turtle_spawning_service_ready_ = true;
                } else {
                  RCLCPP_ERROR(this->get_logger(), ""Service callback result mismatch"");
                }
              };
            auto result = spawner_->async_send_request(request, response_received_callback);
          } else {
            RCLCPP_INFO(this->get_logger(), ""Service is not ready"");
          }
        }
      }

      // Boolean values to store the information
      // if the service for spawning turtle is available
      bool turtle_spawning_service_ready_;
      // if the turtle was successfully spawned
      bool turtle_spawned_;
      rclcpp::Client<turtlesim_msgs::srv::Spawn>::SharedPtr spawner_{nullptr};
      rclcpp::TimerBase::SharedPtr timer_{nullptr};
      rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_{nullptr};
      std::shared_ptr<tf2_ros::TransformListener> tf_listener_{nullptr};
      std::unique_ptr<tf2_ros::Buffer> tf_buffer_;
      std::string target_frame_;
    };

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<FrameListener>());
      rclcpp::shutdown();
      return 0;
    }

1.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

To understand how the service behind spawning turtle works, please refer to :doc:`writing a simple service and client (C++) <../../Beginner-Client-Libraries/Writing-A-Simple-Cpp-Service-And-Client>` tutorial.

Now, let's take a look at the code that is relevant to get access to frame transformations.
The ``tf2_ros`` contains a ``TransformListener`` class that makes the task of receiving transforms easier.

.. code-block:: C++

    #include ""tf2_ros/transform_listener.h""

Here, we create a ``TransformListener`` object.
Once the listener is created, it starts receiving tf2 transformations over the wire, and buffers them for up to 10 seconds.

.. code-block:: C++

    tf_listener_ =
      std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

Finally, we query the listener for a specific transformation.
We call ``lookup_transform`` method with following arguments:

#. Target frame

#. Source frame

#. The time at which we want to transform

Providing ``tf2::TimePointZero`` will just get us the latest available transform.
All this is wrapped in a try-catch block to handle possible exceptions.

.. code-block:: C++

    t = tf_buffer_->lookupTransform(
      toFrameRel, fromFrameRel,
      tf2::TimePointZero);

The resulting transformation represents the position and orientation of the target turtle relative to ``turtle2``.
The angle between the turtles is then used to calculate a velocity command to follow the target turtle.
For more general information about tf2 see also the :doc:`tf2 page in the Concepts section <../../../Concepts/Intermediate/About-Tf2>`.

1.2 CMakeLists.txt
~~~~~~~~~~~~~~~~~~

Navigate one level back to the ``learning_tf2_cpp`` directory, where the ``CMakeLists.txt`` and ``package.xml`` files are located.

Now open the ``CMakeLists.txt`` add the executable and name it ``turtle_tf2_listener``, which you'll use later with ``ros2 run``.

.. code-block:: console

    add_executable(turtle_tf2_listener src/turtle_tf2_listener.cpp)
    ament_target_dependencies(
        turtle_tf2_listener
        geometry_msgs
        rclcpp
        tf2
        tf2_ros
        turtlesim
    )

Finally, add the ``install(TARGETS…)`` section so ``ros2 run`` can find your executable:

.. code-block:: console

    install(TARGETS
        turtle_tf2_listener
        DESTINATION lib/${PROJECT_NAME})

2 Update the launch file
^^^^^^^^^^^^^^^^^^^^^^^^

Open the launch file called ``turtle_tf2_demo_launch.py`` in the ``src/learning_tf2_cpp/launch`` directory with your text editor, add two new nodes to the launch description, add a launch argument, and add the imports.
The resulting file should look like:

.. code-block:: python

    from launch import LaunchDescription
    from launch.actions import DeclareLaunchArgument
    from launch.substitutions import LaunchConfiguration

    from launch_ros.actions import Node


    def generate_launch_description():
        return LaunchDescription([
            Node(
                package='turtlesim',
                executable='turtlesim_node',
                name='sim'
            ),
            Node(
                package='learning_tf2_cpp',
                executable='turtle_tf2_broadcaster',
                name='broadcaster1',
                parameters=[
                    {'turtlename': 'turtle1'}
                ]
            ),
            DeclareLaunchArgument(
                'target_frame', default_value='turtle1',
                description='Target frame name.'
            ),
            Node(
                package='learning_tf2_cpp',
                executable='turtle_tf2_broadcaster',
                name='broadcaster2',
                parameters=[
                    {'turtlename': 'turtle2'}
                ]
            ),
            Node(
                package='learning_tf2_cpp',
                executable='turtle_tf2_listener',
                name='listener',
                parameters=[
                    {'target_frame': LaunchConfiguration('target_frame')}
                ]
            ),
        ])

This will declare a ``target_frame`` launch argument, start a broadcaster for the second turtle that we will spawn and a listener that will subscribe to those transformations.

3 Build
^^^^^^^

Run ``rosdep`` in the root of your workspace to check for missing dependencies.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

   .. group-tab:: Windows

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

Still in the root of your workspace, build your package:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          colcon build --packages-select learning_tf2_cpp

   .. group-tab:: macOS

      .. code-block:: console

          colcon build --packages-select learning_tf2_cpp

   .. group-tab:: Windows

      .. code-block:: console

          colcon build --merge-install --packages-select learning_tf2_cpp

Open a new terminal, navigate to the root of your workspace, and source the setup files:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          . install/setup.bash

   .. group-tab:: macOS

      .. code-block:: console

          . install/setup.bash

   .. group-tab:: Windows

      .. code-block:: console

          # CMD
          call install\setup.bat

          # Powershell
          .\install\setup.ps1

4 Run
^^^^^

Now you're ready to start your full turtle demo:

.. code-block:: console

    ros2 launch learning_tf2_cpp turtle_tf2_demo_launch.py

You should see the turtle sim with two turtles.
In the second terminal window type the following command:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

To see if things work, simply drive around the first turtle using the arrow keys (make sure your terminal window is active, not your simulator window), and you'll see the second turtle following the first one!

Summary
-------

In this tutorial you learned how to use tf2 to get access to frame transformations.
You also have finished writing your own turtlesim demo that you first tried in :doc:`Introduction to tf2 <./Introduction-To-Tf2>` tutorial.
",What is the purpose of creating a tf2 listener in C++ based on the provided text?
".. redirect-from::

    Tutorials/Tf2/Writing-A-Tf2-Broadcaster-Py

Writing a broadcaster (Python)
==============================

**Goal:** Learn how to broadcast the state of a robot to tf2.

**Tutorial level:** Intermediate

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In the next two tutorials we will write the code to reproduce the demo from the :doc:`Introduction to tf2 <./Introduction-To-Tf2>` tutorial.
After that, the following tutorials focus on extending the demo with more advanced tf2 features, including the usage of timeouts in transformation lookups and time travel.

Prerequisites
-------------

This tutorial assumes you have a working knowledge of ROS 2 and you have completed the :doc:`Introduction to tf2 tutorial <./Introduction-To-Tf2>` and :doc:`tf2 static broadcaster tutorial (Python) <./Writing-A-Tf2-Static-Broadcaster-Py>`.
We'll be reusing the ``learning_tf2_py`` package from that last tutorial.

In previous tutorials, you learned how to :doc:`create a workspace <../../Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace>` and :doc:`create a package <../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>`.

Tasks
-----

1 Write the broadcaster node
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's first create the source files.
Go to the ``learning_tf2_py`` package we created in the previous tutorial.
Inside the ``src/learning_tf2_py/learning_tf2_py`` directory download the example broadcaster code by entering the following command:

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_broadcaster.py

    .. group-tab:: macOS

        .. code-block:: console

            wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_broadcaster.py

    .. group-tab:: Windows

        In a Windows command line prompt:

        .. code-block:: console

            curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_broadcaster.py -o turtle_tf2_broadcaster.py

        Or in powershell:

        .. code-block:: console

            curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_broadcaster.py -o turtle_tf2_broadcaster.py

Now open the file called ``turtle_tf2_broadcaster.py`` using your preferred text editor.

.. code-block:: python

    import math

    from geometry_msgs.msg import TransformStamped

    import numpy as np

    import rclpy
    from rclpy.executors import ExternalShutdownException
    from rclpy.node import Node

    from tf2_ros import TransformBroadcaster

    from turtlesim.msg import Pose


    def quaternion_from_euler(ai, aj, ak):
        ai /= 2.0
        aj /= 2.0
        ak /= 2.0
        ci = math.cos(ai)
        si = math.sin(ai)
        cj = math.cos(aj)
        sj = math.sin(aj)
        ck = math.cos(ak)
        sk = math.sin(ak)
        cc = ci*ck
        cs = ci*sk
        sc = si*ck
        ss = si*sk

        q = np.empty((4, ))
        q[0] = cj*sc - sj*cs
        q[1] = cj*ss + sj*cc
        q[2] = cj*cs - sj*sc
        q[3] = cj*cc + sj*ss

        return q


    class FramePublisher(Node):

        def __init__(self):
            super().__init__('turtle_tf2_frame_publisher')

            # Declare and acquire `turtlename` parameter
            self.turtlename = self.declare_parameter(
              'turtlename', 'turtle').get_parameter_value().string_value

            # Initialize the transform broadcaster
            self.tf_broadcaster = TransformBroadcaster(self)

            # Subscribe to a turtle{1}{2}/pose topic and call handle_turtle_pose
            # callback function on each message
            self.subscription = self.create_subscription(
                Pose,
                f'/{self.turtlename}/pose',
                self.handle_turtle_pose,
                1)
            self.subscription  # prevent unused variable warning

        def handle_turtle_pose(self, msg):
            t = TransformStamped()

            # Read message content and assign it to
            # corresponding tf variables
            t.header.stamp = self.get_clock().now().to_msg()
            t.header.frame_id = 'world'
            t.child_frame_id = self.turtlename

            # Turtle only exists in 2D, thus we get x and y translation
            # coordinates from the message and set the z coordinate to 0
            t.transform.translation.x = msg.x
            t.transform.translation.y = msg.y
            t.transform.translation.z = 0.0

            # For the same reason, turtle can only rotate around one axis
            # and this why we set rotation in x and y to 0 and obtain
            # rotation in z axis from the message
            q = quaternion_from_euler(0, 0, msg.theta)
            t.transform.rotation.x = q[0]
            t.transform.rotation.y = q[1]
            t.transform.rotation.z = q[2]
            t.transform.rotation.w = q[3]

            # Send the transformation
            self.tf_broadcaster.sendTransform(t)


    def main():
        try:
            with rclpy.init():
                node = FramePublisher()
                rclpy.spin(node)
        except (KeyboardInterrupt, ExternalShutdownException):
            pass

1.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

Now, let's take a look at the code that is relevant to publishing the turtle pose to tf2.
Firstly, we define and acquire a single parameter ``turtlename``, which specifies a turtle name, e.g. ``turtle1`` or ``turtle2``.

.. code-block:: python

    self.turtlename = self.declare_parameter(
      'turtlename', 'turtle').get_parameter_value().string_value

Afterward, the node subscribes to topic ``{self.turtlename}/pose`` and runs function ``handle_turtle_pose`` on every incoming message.

.. code-block:: python

     self .subscription = self.create_subscription(
         Pose,
         f'/{self.turtlename}/pose',
         self.handle_turtle_pose,
         1)

Now, we create a ``TransformStamped`` object and give it the appropriate metadata.

#. We need to give the transform being published a timestamp, and we'll just stamp it with the current time by calling ``self.get_clock().now()``. This will return the current time used by the ``Node``.

#. Then we need to set the name of the parent frame of the link we're creating, in this case ``world``.

#. Finally, we need to set the name of the child node of the link we're creating, in this case this is the name of the turtle itself.

The handler function for the turtle pose message broadcasts this turtle's translation and rotation, and publishes it as a transform from frame ``world`` to frame ``turtleX``.

.. code-block:: python

    t = TransformStamped()

    # Read message content and assign it to
    # corresponding tf variables
    t.header.stamp = self.get_clock().now().to_msg()
    t.header.frame_id = 'world'
    t.child_frame_id = self.turtlename

Here we copy the information from the 3D turtle pose into the 3D transform.

.. code-block:: python

    # Turtle only exists in 2D, thus we get x and y translation
    # coordinates from the message and set the z coordinate to 0
    t.transform.translation.x = msg.x
    t.transform.translation.y = msg.y
    t.transform.translation.z = 0.0

    # For the same reason, turtle can only rotate around one axis
    # and this why we set rotation in x and y to 0 and obtain
    # rotation in z axis from the message
    q = quaternion_from_euler(0, 0, msg.theta)
    t.transform.rotation.x = q[0]
    t.transform.rotation.y = q[1]
    t.transform.rotation.z = q[2]
    t.transform.rotation.w = q[3]

Finally we take the transform that we constructed and pass it to the ``sendTransform`` method of the ``TransformBroadcaster`` that will take care of broadcasting.

.. code-block:: python

    # Send the transformation
    self.tf_broadcaster.sendTransform(t)

1.2 Add an entry point
~~~~~~~~~~~~~~~~~~~~~~

To allow the ``ros2 run`` command to run your node, you must add the entry point
to ``setup.py`` (located in the ``src/learning_tf2_py`` directory).

Add the following line between the ``'console_scripts':`` brackets:

.. code-block:: python

    'turtle_tf2_broadcaster = learning_tf2_py.turtle_tf2_broadcaster:main',

2 Write the launch file
^^^^^^^^^^^^^^^^^^^^^^^

Now create a launch file for this demo.
Create a ``launch`` folder in the ``src/learning_tf2_py`` directory.
With your text editor, create a new file called ``turtle_tf2_demo_launch.py`` in the ``launch`` folder, and add the following lines:

.. code-block:: python

    from launch import LaunchDescription
    from launch_ros.actions import Node


    def generate_launch_description():
        return LaunchDescription([
            Node(
                package='turtlesim',
                executable='turtlesim_node',
                name='sim'
            ),
            Node(
                package='learning_tf2_py',
                executable='turtle_tf2_broadcaster',
                name='broadcaster1',
                parameters=[
                    {'turtlename': 'turtle1'}
                ]
            ),
        ])

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

First we import required modules from the ``launch`` and ``launch_ros`` packages.
It should be noted that ``launch`` is a generic launching framework (not ROS 2 specific) and ``launch_ros`` has ROS 2 specific things, like nodes that we import here.

.. code-block:: python

    from launch import LaunchDescription
    from launch_ros.actions import Node

Now we run our nodes that start the turtlesim simulation and broadcast ``turtle1`` state to the tf2 using our ``turtle_tf2_broadcaster`` node.

.. code-block:: python

    Node(
        package='turtlesim',
        executable='turtlesim_node',
        name='sim'
    ),
    Node(
        package='learning_tf2_py',
        executable='turtle_tf2_broadcaster',
        name='broadcaster1',
        parameters=[
            {'turtlename': 'turtle1'}
        ]
    ),

2.2 Add dependencies
~~~~~~~~~~~~~~~~~~~~

Navigate one level back to the ``learning_tf2_py`` directory, where the ``setup.py``, ``setup.cfg``, and ``package.xml`` files are located.

Open ``package.xml`` with your text editor.
Add the following dependencies corresponding to your launch file's import statements:

.. code-block:: xml

    <exec_depend>launch</exec_depend>
    <exec_depend>launch_ros</exec_depend>

This declares the additional required ``launch`` and ``launch_ros`` dependencies when its code is executed.

Make sure to save the file.

2.3 Update setup.py
~~~~~~~~~~~~~~~~~~~

Reopen ``setup.py`` and add the line so that the launch files from the ``launch/`` folder will be installed.
The ``data_files`` field should now look like this:

.. code-block:: python

    data_files=[
        ...
        (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*launch.[pxy][yma]*'))),
    ],

Also add the appropriate imports at the top of the file:

.. code-block:: python

    import os
    from glob import glob

You can learn more about creating launch files in :doc:`this tutorial <../Launch/Creating-Launch-Files>`.

3 Build
^^^^^^^

Run ``rosdep`` in the root of your workspace to check for missing dependencies.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

   .. group-tab:: Windows

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

Still in the root of your workspace, build your package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        colcon build --packages-select learning_tf2_py

  .. group-tab:: macOS

    .. code-block:: console

        colcon build --packages-select learning_tf2_py

  .. group-tab:: Windows

    .. code-block:: console

        colcon build --merge-install --packages-select learning_tf2_py

Open a new terminal, navigate to the root of your workspace, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        . install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

        . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

        # CMD
        call install\setup.bat

        # Powershell
        .\install\setup.ps1

4 Run
^^^^^

Now run the launch file that will start the turtlesim simulation node and ``turtle_tf2_broadcaster`` node:

.. code-block:: console

    ros2 launch learning_tf2_py turtle_tf2_demo_launch.py

In the second terminal window type the following command:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

You will now see that the turtlesim simulation has started with one turtle that you can control.

.. image:: images/turtlesim_broadcast.png

Now, use the ``tf2_echo`` tool to check if the turtle pose is actually getting broadcast to tf2:

.. code-block:: console

    ros2 run tf2_ros tf2_echo world turtle1

This should show you the pose of the first turtle.
Drive around the turtle using the arrow keys (make sure your ``turtle_teleop_key`` terminal window is active, not your simulator window).
In your console output you will see something similar to this:

.. code-block:: console

    At time 1714913843.708748879
    - Translation: [4.541, 3.889, 0.000]
    - Rotation: in Quaternion [0.000, 0.000, 0.999, -0.035]
    - Rotation: in RPY (radian) [0.000, -0.000, -3.072]
    - Rotation: in RPY (degree) [0.000, -0.000, -176.013]
    - Matrix:
     -0.998  0.070  0.000  4.541
     -0.070 -0.998  0.000  3.889
      0.000  0.000  1.000  0.000
      0.000  0.000  0.000  1.000

If you run ``tf2_echo`` for the transform between the ``world`` and ``turtle2``, you should not see a transform, because the second turtle is not there yet.
However, as soon as we add the second turtle in the next tutorial, the pose of ``turtle2`` will be broadcast to tf2.

Summary
-------

In this tutorial you learned how to broadcast the pose of the robot (position and orientation of the turtle) to tf2 and how to use the ``tf2_echo`` tool.
To actually use the transforms broadcasted to tf2, you should move on to the next tutorial about creating a :doc:`tf2 listener <./Writing-A-Tf2-Listener-Py>`.
",What is the purpose of the `turtle_tf2_broadcaster` node in the tutorial?
".. redirect-from::

    Tutorials/Tf2/Introduction-To-Tf2

.. _IntroToTf2:

Introducing ``tf2``
===================

**Goal:** Run a turtlesim demo and see some of the power of tf2 in a multi-robot example using turtlesim.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Installing the demo
-------------------

Let's start by installing the demo package and its dependencies.

.. tabs::

   .. group-tab:: Ubuntu Packages

      .. code-block:: console

         sudo apt-get install ros-{DISTRO}-rviz2 ros-{DISTRO}-turtle-tf2-py ros-{DISTRO}-tf2-ros ros-{DISTRO}-tf2-tools ros-{DISTRO}-turtlesim

   .. group-tab:: RHEL Packages

      .. code-block:: console

         sudo dnf install ros-{DISTRO}-rviz2 ros-{DISTRO}-turtle-tf2-py ros-{DISTRO}-tf2-ros ros-{DISTRO}-tf2-tools ros-{DISTRO}-turtlesim

   .. group-tab:: From Source

      .. code-block:: console

         git clone https://github.com/ros/geometry_tutorials.git -b ros2

Running the demo
----------------

Now that we've installed the ``turtle_tf2_py`` tutorial package let's run the demo.
First, open a new terminal and :doc:`source your ROS 2 installation <../../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.
Then run the following command:

.. code-block:: console

   ros2 launch turtle_tf2_py turtle_tf2_demo.launch.py

You will see the turtlesim start with two turtles.

.. image:: images/turtlesim_follow1.png

In the second terminal window type the following command:

.. code-block:: console

   ros2 run turtlesim turtle_teleop_key

Once the turtlesim is started you can drive the central turtle around in the turtlesim using the keyboard arrow keys,
select the second terminal window so that your keystrokes will be captured to drive the turtle.

.. image:: images/turtlesim_follow2.png

You can see that one turtle continuously moves to follow the turtle you are driving around.

What is happening?
------------------

This demo is using the tf2 library to create three coordinate frames: a ``world`` frame, a ``turtle1`` frame, and a ``turtle2`` frame.
This tutorial uses a *tf2 broadcaster* to publish the turtle coordinate frames and a *tf2 listener* to compute the difference in the turtle frames and move one turtle to follow the other.

tf2 tools
---------

Now let's look at how tf2 is being used to create this demo.
We can use ``tf2_tools`` to look at what tf2 is doing behind the scenes.

1 Using view_frames
^^^^^^^^^^^^^^^^^^^

``view_frames`` creates a diagram of the frames being broadcast by tf2 over ROS.
Note that this utility only works on Linux; if you are Windows, skip to ""Using tf2_echo"" below.

.. code-block:: console

   ros2 run tf2_tools view_frames

You will see:

.. code-block:: console

   Listening to tf data during 5 seconds...
   Generating graph in frames.pdf file...

Here a tf2 listener is listening to the frames that are being broadcast over ROS and drawing a tree of how the frames are connected.
To view the tree, open the resulting ``frames.pdf`` with your favorite PDF viewer.

.. image:: images/turtlesim_frames.png

Here we can see three frames that are broadcast by tf2: ``world``, ``turtle1``, and ``turtle2``.
The ``world`` frame is the parent of the ``turtle1`` and ``turtle2`` frames.
``view_frames`` also reports some diagnostic information about when the oldest and most
recent frame transforms were received and how fast the tf2 frame is published to tf2 for debugging purposes.

2 Using tf2_echo
^^^^^^^^^^^^^^^^

``tf2_echo`` reports the transform between any two frames broadcast over ROS.

Usage:

.. code-block:: console

   ros2 run tf2_ros tf2_echo [source_frame] [target_frame]

Let's look at the transform of the ``turtle2`` frame with respect to ``turtle1`` frame which is equivalent to:

.. code-block:: console

   ros2 run tf2_ros tf2_echo turtle2 turtle1

You will see the transform displayed as the ``tf2_echo`` listener receives the frames broadcast over ROS 2.

.. code-block:: console

   At time 1683385337.850619099
   - Translation: [2.157, 0.901, 0.000]
   - Rotation: in Quaternion [0.000, 0.000, 0.172, 0.985]
   - Rotation: in RPY (radian) [0.000, -0.000, 0.345]
   - Rotation: in RPY (degree) [0.000, -0.000, 19.760]
   - Matrix:
     0.941 -0.338  0.000  2.157
     0.338  0.941  0.000  0.901
     0.000  0.000  1.000  0.000
     0.000  0.000  0.000  1.000
   At time 1683385338.841997774
   - Translation: [1.256, 0.216, 0.000]
   - Rotation: in Quaternion [0.000, 0.000, -0.016, 1.000]
   - Rotation: in RPY (radian) [0.000, 0.000, -0.032]
   - Rotation: in RPY (degree) [0.000, 0.000, -1.839]
   - Matrix:
     0.999  0.032  0.000  1.256
    -0.032  0.999 -0.000  0.216
    -0.000  0.000  1.000  0.000
     0.000  0.000  0.000  1.000

As you drive your turtle around you will see the transform change as the two turtles move relative to each other.

rviz2 and tf2
-------------

``rviz2`` is a visualization tool that is useful for examining tf2 frames.
Let's look at our turtle frames using ``rviz2`` by starting it with a configuration file using the ``-d`` option:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

      ros2 run rviz2 rviz2 -d $(ros2 pkg prefix --share turtle_tf2_py)/rviz/turtle_rviz.rviz

  .. group-tab:: Windows

    .. code-block:: console

      for /f ""usebackq tokens=*"" %a in (`ros2 pkg prefix --share turtle_tf2_py`) do rviz2 -d %a/rviz/turtle_rviz.rviz

.. image:: images/turtlesim_rviz.png

In the side bar you will see the frames broadcast by tf2.
As you drive the turtle around you will see the frames move in rviz.
",What utility is used to generate a diagram of the frames being broadcast by tf2 over ROS?
".. redirect-from::

    Tutorials/Tf2/Quaternion-Fundamentals

.. _QuaternionFundamentals:

Quaternion fundamentals
=======================

**Goal:** Learn the basics of quaternion usage in ROS 2.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

A quaternion is a 4-tuple representation of orientation, which is more concise than a rotation matrix.
Quaternions are very efficient for analyzing situations where rotations in three dimensions are involved.
Quaternions are used widely in robotics, quantum mechanics, computer vision, and 3D animation.

You can learn more about the underlying mathematical concept on `Wikipedia <https://en.wikipedia.org/wiki/Quaternion>`_.
You can also take a look at an explorable video series `Visualizing quaternions <https://eater.net/quaternions>`_ made by `3blue1brown <https://www.youtube.com/3blue1brown>`_.

In this tutorial, you will learn how quaternions and conversion methods work in ROS 2.

Prerequisites
-------------

However, this is not a hard requirement and you can stick to any other geometric transfromation library that suit you best.
You can take a look at libraries like `transforms3d <https://github.com/matthew-brett/transforms3d>`_, `scipy.spatial.transform <https://github.com/scipy/scipy/tree/master/scipy/spatial/transform>`_, `pytransform3d <https://github.com/rock-learning/pytransform3d>`_, `numpy-quaternion <https://github.com/moble/quaternion>`_ or `blender.mathutils <https://docs.blender.org/api/master/mathutils.html>`_.

Components of a quaternion
--------------------------

ROS 2 uses quaternions to track and apply rotations.
A quaternion has 4 components ``(x, y, z, w)``.
In ROS 2, ``w`` is last, but in some libraries like Eigen, ``w`` can be placed at the first position.
The commonly-used unit quaternion that yields no rotation about the x/y/z axes is ``(0, 0, 0, 1)``, and can be created in a following way:

.. code-block:: C++

   #include <tf2/LinearMath/Quaternion.h>
   ...

   tf2::Quaternion q;
   // Create a quaternion from roll/pitch/yaw in radians (0, 0, 0)
   q.setRPY(0, 0, 0);
   // Print the quaternion components (0, 0, 0, 1)
   RCLCPP_INFO(this->get_logger(), ""%f %f %f %f"",
               q.x(), q.y(), q.z(), q.w());

The magnitude of a quaternion should always be one.
If numerical errors cause a quaternion magnitude other than one, ROS 2 will print warnings.
To avoid these warnings, normalize the quaternion:

.. code-block:: C++

   q.normalize();

Quaternion types in ROS 2
-------------------------

ROS 2 uses two quaternion datatypes: ``tf2::Quaternion`` and its equivalent ``geometry_msgs::msg::Quaternion``.
To convert between them in C++, use the methods of ``tf2_geometry_msgs``.

C++

.. code-block:: C++

   #include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
   ...

   tf2::Quaternion tf2_quat, tf2_quat_from_msg;
   tf2_quat.setRPY(roll, pitch, yaw);
   // Convert tf2::Quaternion to geometry_msgs::msg::Quaternion
   geometry_msgs::msg::Quaternion msg_quat = tf2::toMsg(tf2_quat);

   // Convert geometry_msgs::msg::Quaternion to tf2::Quaternion
   tf2::convert(msg_quat, tf2_quat_from_msg);
   // or
   tf2::fromMsg(msg_quat, tf2_quat_from_msg);


Python

.. code-block:: python

   from geometry_msgs.msg import Quaternion
   ...

   # Create a list of floats, which is compatible with tf2
   # Quaternion methods
   quat_tf = [0.0, 1.0, 0.0, 0.0]

   # Convert a list to geometry_msgs.msg.Quaternion
   msg_quat = Quaternion(x=quat_tf[0], y=quat_tf[1], z=quat_tf[2], w=quat_tf[3])

Quaternion operations
---------------------

1 Think in RPY then convert to quaternion
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It's easy for us to think of rotations about axes, but hard to think in terms of quaternions.
A suggestion is to calculate target rotations in terms of roll (about an X-axis), pitch (about the Y-axis), and yaw (about the Z-axis), and then convert to a quaternion.

.. code-block:: python

   # quaternion_from_euler method is available in turtle_tf2_py/turtle_tf2_py/turtle_tf2_broadcaster.py
   q = quaternion_from_euler(1.5707, 0, -1.5707)
   print(f'The quaternion representation is x: {q[0]} y: {q[1]} z: {q[2]} w: {q[3]}.')


2 Applying a quaternion rotation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To apply the rotation of one quaternion to a pose, simply multiply the previous quaternion of the pose by the quaternion representing the desired rotation.
The order of this multiplication matters.

C++

.. code-block:: C++

   #include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
   ...

   tf2::Quaternion q_orig, q_rot, q_new;

   q_orig.setRPY(0.0, 0.0, 0.0);
   // Rotate the previous pose by 180* about X
   q_rot.setRPY(3.14159, 0.0, 0.0);
   q_new = q_rot * q_orig;
   q_new.normalize();

Python

.. code-block:: python

   q_orig = quaternion_from_euler(0, 0, 0)
   # Rotate the previous pose by 180* about X
   q_rot = quaternion_from_euler(3.14159, 0, 0)
   q_new = quaternion_multiply(q_rot, q_orig)


3 Inverting a quaternion
^^^^^^^^^^^^^^^^^^^^^^^^

An easy way to invert a quaternion is to negate the w-component:

.. code-block:: python

   q[3] = -q[3]

4 Relative rotations
^^^^^^^^^^^^^^^^^^^^

Say you have two quaternions from the same frame, ``q_1`` and ``q_2``.
You want to find the relative rotation, ``q_r``, that converts ``q_1`` to ``q_2`` in a following manner:

.. code-block:: C++

   q_2 = q_r * q_1

You can solve for ``q_r`` similarly to solving a matrix equation.
Invert ``q_1`` and right-multiply both sides. Again, the order of multiplication is important:

.. code-block:: C++

   q_r = q_2 * q_1_inverse

Here's an example to get the relative rotation from the previous robot pose to the current robot pose in python:

.. code-block:: python

  def quaternion_multiply(q0, q1):
      """"""
      Multiplies two quaternions.

      Input
      :param q0: A 4 element array containing the first quaternion (q01, q11, q21, q31)
      :param q1: A 4 element array containing the second quaternion (q02, q12, q22, q32)

      Output
      :return: A 4 element array containing the final quaternion (q03,q13,q23,q33)

      """"""
      # Extract the values from q0
      w0 = q0[0]
      x0 = q0[1]
      y0 = q0[2]
      z0 = q0[3]

      # Extract the values from q1
      w1 = q1[0]
      x1 = q1[1]
      y1 = q1[2]
      z1 = q1[3]

      # Computer the product of the two quaternions, term by term
      q0q1_w = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1
      q0q1_x = w0 * x1 + x0 * w1 + y0 * z1 - z0 * y1
      q0q1_y = w0 * y1 - x0 * z1 + y0 * w1 + z0 * x1
      q0q1_z = w0 * z1 + x0 * y1 - y0 * x1 + z0 * w1

      # Create a 4 element array containing the final quaternion
      final_quaternion = np.array([q0q1_w, q0q1_x, q0q1_y, q0q1_z])

      # Return a 4 element array containing the final quaternion (q02,q12,q22,q32)
      return final_quaternion

  q1_inv[0] = prev_pose.pose.orientation.x
  q1_inv[1] = prev_pose.pose.orientation.y
  q1_inv[2] = prev_pose.pose.orientation.z
  q1_inv[3] = -prev_pose.pose.orientation.w # Negate for inverse

  q2[0] = current_pose.pose.orientation.x
  q2[1] = current_pose.pose.orientation.y
  q2[2] = current_pose.pose.orientation.z
  q2[3] = current_pose.pose.orientation.w

  qr = quaternion_multiply(q2, q1_inv)

Summary
-------

In this tutorial, you learned about the fundamental concepts of a quaternion and its related mathematical operations, like inversion and rotation.
You also learned about its usage examples in ROS 2 and conversion methods between two separate Quaternion classes.
",What are the two quaternion datatypes used in ROS 2?
".. redirect-from::

    Tutorials/Tf2/Using-Stamped-Datatypes-With-Tf2-Ros-MessageFilter

.. _UsingStampedDatatypesWithTf2RosMessageFilter:

Using stamped datatypes with ``tf2_ros::MessageFilter``
=======================================================

**Goal:** Learn how to use ``tf2_ros::MessageFilter`` to process stamped datatypes.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 3
   :local:

Background
----------

This tutorial explains how to use sensor data with tf2.
Some real-world examples of sensor data are:

    * cameras, both mono and stereo

    * laser scans

Suppose that a new turtle named ``turtle3`` is created and it doesn't have good odometry, but there is an overhead camera tracking its position and publishing it as a ``PointStamped`` message in relation to the ``world`` frame.

``turtle1`` wants to know where ``turtle3`` is compared to itself.

To do this ``turtle1`` must listen to the topic where ``turtle3``'s pose is being published, wait until transforms into the desired frame are ready, and then do its operations.
To make this easier the ``tf2_ros::MessageFilter`` is very useful.
The ``tf2_ros::MessageFilter`` will take a subscription to any ROS 2 message with a header and cache it until it is possible to transform it into the target frame.

Tasks
-----

1 Write the broadcaster node of PointStamped messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For this tutorial we will set up a demo application which has a node (in Python) to broadcast the ``PointStamped`` position messages of ``turtle3``.

First, let's create the source file.

Go to the ``learning_tf2_py`` :doc:`package <./Writing-A-Tf2-Static-Broadcaster-Py>` we created in the previous tutorial.
Inside the ``src/learning_tf2_py/learning_tf2_py`` directory download the example sensor message broadcaster code by entering the following command:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_message_broadcaster.py

  .. group-tab:: macOS

    .. code-block:: console

        wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_message_broadcaster.py

  .. group-tab:: Windows

    In a Windows command line prompt:

    .. code-block:: console

        curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_message_broadcaster.py -o turtle_tf2_message_broadcaster.py

    Or in powershell:

    .. code-block:: console

        curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_message_broadcaster.py -o turtle_tf2_message_broadcaster.py

Open the file using your preferred text editor.

.. code-block:: python

    from geometry_msgs.msg import PointStamped
    from geometry_msgs.msg import Twist

    import rclpy
    from rclpy.executors import ExternalShutdownException
    from rclpy.node import Node

    from turtlesim.msg import Pose
    from turtlesim.srv import Spawn


    class PointPublisher(Node):

        def __init__(self):
            super().__init__('turtle_tf2_message_broadcaster')

            # Create a client to spawn a turtle
            self.spawner = self.create_client(Spawn, 'spawn')
            # Boolean values to store the information
            # if the service for spawning turtle is available
            self.turtle_spawning_service_ready = False
            # if the turtle was successfully spawned
            self.turtle_spawned = False
            # if the topics of turtle3 can be subscribed
            self.turtle_pose_cansubscribe = False

            self.timer = self.create_timer(1.0, self.on_timer)

        def on_timer(self):
            if self.turtle_spawning_service_ready:
                if self.turtle_spawned:
                    self.turtle_pose_cansubscribe = True
                else:
                    if self.result.done():
                        self.get_logger().info(
                            f'Successfully spawned {self.result.result().name}')
                        self.turtle_spawned = True
                    else:
                        self.get_logger().info('Spawn is not finished')
            else:
                if self.spawner.service_is_ready():
                    # Initialize request with turtle name and coordinates
                    # Note that x, y and theta are defined as floats in turtlesim_msgs/srv/Spawn
                    request = Spawn.Request()
                    request.name = 'turtle3'
                    request.x = 4.0
                    request.y = 2.0
                    request.theta = 0.0
                    # Call request
                    self.result = self.spawner.call_async(request)
                    self.turtle_spawning_service_ready = True
                else:
                    # Check if the service is ready
                    self.get_logger().info('Service is not ready')

            if self.turtle_pose_cansubscribe:
                self.vel_pub = self.create_publisher(Twist, 'turtle3/cmd_vel', 10)
                self.sub = self.create_subscription(Pose, 'turtle3/pose', self.handle_turtle_pose, 10)
                self.pub = self.create_publisher(PointStamped, 'turtle3/turtle_point_stamped', 10)

        def handle_turtle_pose(self, msg):
            vel_msg = Twist()
            vel_msg.linear.x = 1.0
            vel_msg.angular.z = 1.0
            self.vel_pub.publish(vel_msg)

            ps = PointStamped()
            ps.header.stamp = self.get_clock().now().to_msg()
            ps.header.frame_id = 'world'
            ps.point.x = msg.x
            ps.point.y = msg.y
            ps.point.z = 0.0
            self.pub.publish(ps)


    def main():
        try:
            with rclpy.init():
                node = PointPublisher()
                rclpy.spin(node)
        except (KeyboardInterrupt, ExternalShutdownException):
            pass


1.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

Now let's take a look at the code.
First, in the ``on_timer`` callback function, we spawn the ``turtle3`` by asynchronously calling the ``Spawn`` service of ``turtlesim``, and initialize its position at (4, 2, 0), when the turtle spawning service is ready.

.. code-block:: python

    # Initialize request with turtle name and coordinates
    # Note that x, y and theta are defined as floats in turtlesim_msgs/srv/Spawn
    request = Spawn.Request()
    request.name = 'turtle3'
    request.x = 4.0
    request.y = 2.0
    request.theta = 0.0
    # Call request
    self.result = self.spawner.call_async(request)

Afterward, the node publishes the topic ``turtle3/cmd_vel``, topic ``turtle3/turtle_point_stamped``, and subscribes to topic ``turtle3/pose`` and runs callback function ``handle_turtle_pose`` on every incoming message.

.. code-block:: python

    self.vel_pub = self.create_publisher(Twist, '/turtle3/cmd_vel', 10)
    self.sub = self.create_subscription(Pose, '/turtle3/pose', self.handle_turtle_pose, 10)
    self.pub = self.create_publisher(PointStamped, '/turtle3/turtle_point_stamped', 10)

Finally, in the callback function ``handle_turtle_pose``, we initialize the ``Twist`` messages of ``turtle3`` and publish them, which will make the ``turtle3`` move along a circle.
Then we fill up the ``PointStamped`` messages of ``turtle3`` with incoming ``Pose`` messages and publish them.

.. code-block:: python

    vel_msg = Twist()
    vel_msg.linear.x = 1.0
    vel_msg.angular.z = 1.0
    self.vel_pub.publish(vel_msg)

    ps = PointStamped()
    ps.header.stamp = self.get_clock().now().to_msg()
    ps.header.frame_id = 'world'
    ps.point.x = msg.x
    ps.point.y = msg.y
    ps.point.z = 0.0
    self.pub.publish(ps)

1.2 Write the launch file
~~~~~~~~~~~~~~~~~~~~~~~~~

In order to run this demo, we need to create a launch file ``turtle_tf2_sensor_message_launch.py`` in the ``launch`` subdirectory of package ``learning_tf2_py``:

.. code-block:: python

    from launch import LaunchDescription
    from launch.actions import DeclareLaunchArgument
    from launch_ros.actions import Node


    def generate_launch_description():
        return LaunchDescription([
            DeclareLaunchArgument(
                'target_frame', default_value='turtle1',
                description='Target frame name.'
            ),
            Node(
                package='turtlesim',
                executable='turtlesim_node',
                name='sim',
                output='screen'
            ),
            Node(
                package='turtle_tf2_py',
                executable='turtle_tf2_broadcaster',
                name='broadcaster1',
                parameters=[
                    {'turtlename': 'turtle1'}
                ]
            ),
            Node(
                package='turtle_tf2_py',
                executable='turtle_tf2_broadcaster',
                name='broadcaster2',
                parameters=[
                    {'turtlename': 'turtle3'}
                ]
            ),
            Node(
                package='turtle_tf2_py',
                executable='turtle_tf2_message_broadcaster',
                name='message_broadcaster',
            ),
        ])


1.3 Add an entry point
~~~~~~~~~~~~~~~~~~~~~~

To allow the ``ros2 run`` command to run your node, you must add the entry point to ``setup.py`` (located in the ``src/learning_tf2_py`` directory).

Add the following line between the ``'console_scripts':`` brackets:

.. code-block:: python

    'turtle_tf2_message_broadcaster = learning_tf2_py.turtle_tf2_message_broadcaster:main',

1.4 Build
~~~~~~~~~

Run ``rosdep`` in the root of your workspace to check for missing dependencies.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

   .. group-tab:: Windows

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

And then we can build the package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        colcon build --packages-select learning_tf2_py

  .. group-tab:: macOS

    .. code-block:: console

        colcon build --packages-select learning_tf2_py

  .. group-tab:: Windows

    .. code-block:: console

        colcon build --merge-install --packages-select learning_tf2_py


2 Writing the message filter/listener node
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now, to get the streaming ``PointStamped`` data of ``turtle3`` in the frame of ``turtle1`` reliably, we will create the source file of the message filter/listener node.

Go to the ``learning_tf2_cpp`` :doc:`package <./Writing-A-Tf2-Static-Broadcaster-Cpp>` we created in the previous tutorial.
Inside the ``src/learning_tf2_cpp/src`` directory download file ``turtle_tf2_message_filter.cpp`` by entering the following command:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_message_filter.cpp

  .. group-tab:: macOS

    .. code-block:: console

        wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_message_filter.cpp

  .. group-tab:: Windows

    In a Windows command line prompt:

    .. code-block:: console

        curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_message_filter.cpp -o turtle_tf2_message_filter.cpp

    Or in powershell:

    .. code-block:: console

        curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/turtle_tf2_message_filter.cpp -o turtle_tf2_message_filter.cpp

Open the file using your preferred text editor.

.. code-block:: C++

    #include <chrono>
    #include <memory>
    #include <string>

    #include ""geometry_msgs/msg/point_stamped.hpp""
    #include ""message_filters/subscriber.h""
    #include ""rclcpp/rclcpp.hpp""
    #include ""tf2_ros/buffer.h""
    #include ""tf2_ros/create_timer_ros.h""
    #include ""tf2_ros/message_filter.h""
    #include ""tf2_ros/transform_listener.h""
    #ifdef TF2_CPP_HEADERS
      #include ""tf2_geometry_msgs/tf2_geometry_msgs.hpp""
    #else
      #include ""tf2_geometry_msgs/tf2_geometry_msgs.h""
    #endif

    using namespace std::chrono_literals;

    class PoseDrawer : public rclcpp::Node
    {
    public:
      PoseDrawer()
      : Node(""turtle_tf2_pose_drawer"")
      {
        // Declare and acquire `target_frame` parameter
        target_frame_ = this->declare_parameter<std::string>(""target_frame"", ""turtle1"");

        std::chrono::duration<int> buffer_timeout(1);

        tf2_buffer_ = std::make_shared<tf2_ros::Buffer>(this->get_clock());
        // Create the timer interface before call to waitForTransform,
        // to avoid a tf2_ros::CreateTimerInterfaceException exception
        auto timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
          this->get_node_base_interface(),
          this->get_node_timers_interface());
        tf2_buffer_->setCreateTimerInterface(timer_interface);
        tf2_listener_ =
          std::make_shared<tf2_ros::TransformListener>(*tf2_buffer_);

        point_sub_.subscribe(this, ""/turtle3/turtle_point_stamped"");
        tf2_filter_ = std::make_shared<tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped>>(
          point_sub_, *tf2_buffer_, target_frame_, 100, this->get_node_logging_interface(),
          this->get_node_clock_interface(), buffer_timeout);
        // Register a callback with tf2_ros::MessageFilter to be called when transforms are available
        tf2_filter_->registerCallback(&PoseDrawer::msgCallback, this);
      }

    private:
      void msgCallback(const geometry_msgs::msg::PointStamped::SharedPtr point_ptr)
      {
        geometry_msgs::msg::PointStamped point_out;
        try {
          tf2_buffer_->transform(*point_ptr, point_out, target_frame_);
          RCLCPP_INFO(
            this->get_logger(), ""Point of turtle3 in frame of turtle1: x:%f y:%f z:%f\n"",
            point_out.point.x,
            point_out.point.y,
            point_out.point.z);
        } catch (const tf2::TransformException & ex) {
          RCLCPP_WARN(
            // Print exception which was caught
            this->get_logger(), ""Failure %s\n"", ex.what());
        }
      }

      std::string target_frame_;
      std::shared_ptr<tf2_ros::Buffer> tf2_buffer_;
      std::shared_ptr<tf2_ros::TransformListener> tf2_listener_;
      message_filters::Subscriber<geometry_msgs::msg::PointStamped> point_sub_;
      std::shared_ptr<tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped>> tf2_filter_;
    };

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<PoseDrawer>());
      rclcpp::shutdown();
      return 0;
    }


2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

First, you must include the ``tf2_ros::MessageFilter`` headers from the ``tf2_ros`` package, as well as the previously used ``tf2`` and ``ros2`` related headers.

.. code-block:: C++

    #include ""geometry_msgs/msg/point_stamped.hpp""
    #include ""message_filters/subscriber.h""
    #include ""rclcpp/rclcpp.hpp""
    #include ""tf2_ros/buffer.h""
    #include ""tf2_ros/create_timer_ros.h""
    #include ""tf2_ros/message_filter.h""
    #include ""tf2_ros/transform_listener.h""
    #ifdef TF2_CPP_HEADERS
      #include ""tf2_geometry_msgs/tf2_geometry_msgs.hpp""
    #else
      #include ""tf2_geometry_msgs/tf2_geometry_msgs.h""
    #endif


Second, there needs to be persistent instances of ``tf2_ros::Buffer``, ``tf2_ros::TransformListener`` and ``tf2_ros::MessageFilter``.

.. code-block:: C++

    std::string target_frame_;
    std::shared_ptr<tf2_ros::Buffer> tf2_buffer_;
    std::shared_ptr<tf2_ros::TransformListener> tf2_listener_;
    message_filters::Subscriber<geometry_msgs::msg::PointStamped> point_sub_;
    std::shared_ptr<tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped>> tf2_filter_;


Third, the ROS 2 ``message_filters::Subscriber`` must be initialized with the topic.
And the ``tf2_ros::MessageFilter`` must be initialized with that ``Subscriber`` object.
The other arguments of note in the ``MessageFilter`` constructor are the ``target_frame`` and the callback function.
The target frame is the frame into which it will make sure ``canTransform`` will succeed.
And the callback function is the function that will be called when the data is ready.

.. code-block:: C++

    PoseDrawer()
    : Node(""turtle_tf2_pose_drawer"")
    {
      // Declare and acquire `target_frame` parameter
      target_frame_ = this->declare_parameter<std::string>(""target_frame"", ""turtle1"");

      std::chrono::duration<int> buffer_timeout(1);

      tf2_buffer_ = std::make_shared<tf2_ros::Buffer>(this->get_clock());
      // Create the timer interface before call to waitForTransform,
      // to avoid a tf2_ros::CreateTimerInterfaceException exception
      auto timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
        this->get_node_base_interface(),
        this->get_node_timers_interface());
      tf2_buffer_->setCreateTimerInterface(timer_interface);
      tf2_listener_ =
        std::make_shared<tf2_ros::TransformListener>(*tf2_buffer_);

      point_sub_.subscribe(this, ""/turtle3/turtle_point_stamped"");
      tf2_filter_ = std::make_shared<tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped>>(
        point_sub_, *tf2_buffer_, target_frame_, 100, this->get_node_logging_interface(),
        this->get_node_clock_interface(), buffer_timeout);
      // Register a callback with tf2_ros::MessageFilter to be called when transforms are available
      tf2_filter_->registerCallback(&PoseDrawer::msgCallback, this);
    }


And last, the callback method will call ``tf2_buffer_->transform`` when the data is ready and print output to the console.

.. code-block:: C++

    private:
      void msgCallback(const geometry_msgs::msg::PointStamped::SharedPtr point_ptr)
      {
        geometry_msgs::msg::PointStamped point_out;
        try {
          tf2_buffer_->transform(*point_ptr, point_out, target_frame_);
          RCLCPP_INFO(
            this->get_logger(), ""Point of turtle3 in frame of turtle1: x:%f y:%f z:%f\n"",
            point_out.point.x,
            point_out.point.y,
            point_out.point.z);
        } catch (const tf2::TransformException & ex) {
          RCLCPP_WARN(
            // Print exception which was caught
            this->get_logger(), ""Failure %s\n"", ex.what());
        }
      }


2.2 Add dependencies
~~~~~~~~~~~~~~~~~~~~

Before building the package ``learning_tf2_cpp``, please add two another dependencies in the ``package.xml`` file of this package:

.. code-block:: xml

    <depend>message_filters</depend>
    <depend>tf2_geometry_msgs</depend>

2.3 CMakeLists.txt
~~~~~~~~~~~~~~~~~~

And in the ``CMakeLists.txt`` file, add two lines below the existing dependencies:

.. code-block:: console

    find_package(message_filters REQUIRED)
    find_package(tf2_geometry_msgs REQUIRED)

The lines below will deal with differences between ROS distributions:

.. code-block:: console

    if(TARGET tf2_geometry_msgs::tf2_geometry_msgs)
      get_target_property(_include_dirs tf2_geometry_msgs::tf2_geometry_msgs INTERFACE_INCLUDE_DIRECTORIES)
    else()
      set(_include_dirs ${tf2_geometry_msgs_INCLUDE_DIRS})
    endif()

    find_file(TF2_CPP_HEADERS
      NAMES tf2_geometry_msgs.hpp
      PATHS ${_include_dirs}
      NO_CACHE
      PATH_SUFFIXES tf2_geometry_msgs
    )

After that, add the executable and name it ``turtle_tf2_message_filter``, which you'll use later with ``ros2 run``.

.. code-block:: console

    add_executable(turtle_tf2_message_filter src/turtle_tf2_message_filter.cpp)
    ament_target_dependencies(
      turtle_tf2_message_filter
      geometry_msgs
      message_filters
      rclcpp
      tf2
      tf2_geometry_msgs
      tf2_ros
    )

    if(EXISTS ${TF2_CPP_HEADERS})
      target_compile_definitions(turtle_tf2_message_filter PUBLIC -DTF2_CPP_HEADERS)
    endif()

Finally, add the ``install(TARGETS…)`` section (below other existing nodes) so ``ros2 run`` can find your executable:

.. code-block:: console

    install(TARGETS
      turtle_tf2_message_filter
      DESTINATION lib/${PROJECT_NAME})

2.4 Build
~~~~~~~~~

Run ``rosdep`` in the root of your workspace to check for missing dependencies.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

   .. group-tab:: Windows

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

Now open a new terminal, navigate to the root of your workspace, and rebuild the package with command:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        colcon build --packages-select learning_tf2_cpp

  .. group-tab:: macOS

    .. code-block:: console

        colcon build --packages-select learning_tf2_cpp

  .. group-tab:: Windows

    .. code-block:: console

        colcon build --merge-install --packages-select learning_tf2_cpp

Open a new terminal, navigate to the root of your workspace, and source the setup files:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          . install/setup.bash

   .. group-tab:: macOS

      .. code-block:: console

          . install/setup.bash

   .. group-tab:: Windows

      .. code-block:: console

          # CMD
          call install\setup.bat

          # Powershell
          .\install\setup.ps1

3 Run
^^^^^

First we need to run several nodes (including the broadcaster node of PointStamped messages) by launching the launch file ``turtle_tf2_sensor_message_launch.py``:

.. code-block:: console

    ros2 launch learning_tf2_py turtle_tf2_sensor_message_launch.py

This will bring up the ``turtlesim`` window with two turtles, where ``turtle3`` is moving along a circle, while ``turtle1`` isn't moving at first.
But you can run the ``turtle_teleop_key`` node in another terminal to drive ``turtle1`` to move:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

.. image:: images/turtlesim_messagefilter.png

Now if you echo the topic ``turtle3/turtle_point_stamped``:

.. code-block:: console

    ros2 topic echo /turtle3/turtle_point_stamped

Then there will be output like this:

.. code-block:: console

    header:
      stamp:
        sec: 1629877510
        nanosec: 902607040
      frame_id: world
    point:
      x: 4.989276885986328
      y: 3.073937177658081
      z: 0.0
    ---
    header:
      stamp:
        sec: 1629877510
        nanosec: 918389395
      frame_id: world
    point:
      x: 4.987966060638428
      y: 3.089883327484131
      z: 0.0
    ---
    header:
      stamp:
        sec: 1629877510
        nanosec: 934186680
      frame_id: world
    point:
      x: 4.986400127410889
      y: 3.105806589126587
      z: 0.0
    ---

When the demo is running, open another terminal and run the message filter/listener node:

.. code-block:: console

    ros2 run learning_tf2_cpp turtle_tf2_message_filter

If it's running correctly you should see streaming data like this:

.. code-block:: console

    [INFO] [1630016162.006173900] [turtle_tf2_pose_drawer]: Point of turtle3 in frame of turtle1: x:-6.493231 y:-2.961614 z:0.000000

    [INFO] [1630016162.006291983] [turtle_tf2_pose_drawer]: Point of turtle3 in frame of turtle1: x:-6.472169 y:-3.004742 z:0.000000

    [INFO] [1630016162.006326234] [turtle_tf2_pose_drawer]: Point of turtle3 in frame of turtle1: x:-6.479420 y:-2.990479 z:0.000000

    [INFO] [1630016162.006355644] [turtle_tf2_pose_drawer]: Point of turtle3 in frame of turtle1: x:-6.486441 y:-2.976102 z:0.000000


Summary
-------

In this tutorial you learned how to use sensor data/messages in tf2.
Specifically speaking, you learned how to publish ``PointStamped`` messages on a topic, and how to listen to the topic and transform the frame of ``PointStamped`` messages with ``tf2_ros::MessageFilter``.
",What is the purpose of using the `tf2_ros::MessageFilter` in the context of sensor data processing?
".. redirect-from::

    Tutorials/Tf2/Adding-A-Frame-Cpp

Adding a frame (C++)
====================

**Goal:** Learn how to to add an extra frame to tf2.

**Tutorial level:** Intermediate

**Time:** 15 minutes

.. contents:: Contents
   :depth: 3
   :local:

Background
----------

In previous tutorials, we recreated the turtle demo by writing a :doc:`tf2 broadcaster <./Writing-A-Tf2-Broadcaster-Cpp>` and a :doc:`tf2 listener <Writing-A-Tf2-Listener-Cpp>`.
This tutorial will teach you how to add extra fixed and dynamic frames to the transformation tree.
In fact, adding a frame in tf2 is very similar to creating the tf2 broadcaster, but this example will show you some additional features of tf2.

For many tasks related to transformations, it is easier to think inside a local frame.
For example, it is easiest to reason about laser scan measurements in a frame at the center of the laser scanner.
tf2 allows you to define a local frame for each sensor, link, or joint in your system.
When transforming from one frame to another, tf2 will take care of all the hidden intermediate frame transformations that are introduced.

tf2 tree
--------

tf2 builds up a tree structure of frames and, thus, does not allow a closed loop in the frame structure.
This means that a frame only has one single parent, but it can have multiple children.
Currently, our tf2 tree contains three frames: ``world``, ``turtle1`` and ``turtle2``.
The two turtle frames are children of the ``world`` frame.
If we want to add a new frame to tf2, one of the three existing frames needs to be the parent frame, and the new one will become its child frame.

.. image:: images/turtlesim_frames.png

Tasks
-----

1 Write the fixed frame broadcaster
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In our turtle example, we'll add a new frame ``carrot1``, which will be the child of the ``turtle1``.
This frame will serve as the goal for the second turtle.

Let's first create the source files.
Go to the ``learning_tf2_cpp`` package we created in the previous tutorials.
Inside the ``src`` directory download the fixed frame broadcaster code by entering the following command:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/fixed_frame_tf2_broadcaster.cpp

   .. group-tab:: macOS

      .. code-block:: console

          wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/fixed_frame_tf2_broadcaster.cpp

   .. group-tab:: Windows

      In a Windows command line prompt:

      .. code-block:: console

          curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/fixed_frame_tf2_broadcaster.cpp -o fixed_frame_tf2_broadcaster.cpp

      Or in powershell:

      .. code-block:: console

          curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/fixed_frame_tf2_broadcaster.cpp -o fixed_frame_tf2_broadcaster.cpp

Now open the file called ``fixed_frame_tf2_broadcaster.cpp``.

.. code-block:: C++

    #include <chrono>
    #include <functional>
    #include <memory>

    #include ""geometry_msgs/msg/transform_stamped.hpp""
    #include ""rclcpp/rclcpp.hpp""
    #include ""tf2_ros/transform_broadcaster.h""

    using namespace std::chrono_literals;

    class FixedFrameBroadcaster : public rclcpp::Node
    {
    public:
      FixedFrameBroadcaster()
      : Node(""fixed_frame_tf2_broadcaster"")
      {
        tf_broadcaster_ = std::make_shared<tf2_ros::TransformBroadcaster>(this);

        auto broadcast_timer_callback = [this](){
            geometry_msgs::msg::TransformStamped t;

            t.header.stamp = this->get_clock()->now();
            t.header.frame_id = ""turtle1"";
            t.child_frame_id = ""carrot1"";
            t.transform.translation.x = 0.0;
            t.transform.translation.y = 2.0;
            t.transform.translation.z = 0.0;
            t.transform.rotation.x = 0.0;
            t.transform.rotation.y = 0.0;
            t.transform.rotation.z = 0.0;
            t.transform.rotation.w = 1.0;

            tf_broadcaster_->sendTransform(t);
        };
        timer_ = this->create_wall_timer(100ms, broadcast_timer_callback);
      }

    private:
      rclcpp::TimerBase::SharedPtr timer_;
      std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;
    };

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<FixedFrameBroadcaster>());
      rclcpp::shutdown();
      return 0;
    }

The code is very similar to the tf2 broadcaster tutorial example and the only difference is that the transform here does not change over time.

1.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

Let's take a look at the key lines in this piece of code.
Here we create a new transform, from the parent ``turtle1`` to the new child ``carrot1``.
The ``carrot1`` frame is 2 meters offset in y axis in terms of the ``turtle1`` frame.

.. code-block:: C++

    geometry_msgs::msg::TransformStamped t;

    t.header.stamp = this->get_clock()->now();
    t.header.frame_id = ""turtle1"";
    t.child_frame_id = ""carrot1"";
    t.transform.translation.x = 0.0;
    t.transform.translation.y = 2.0;
    t.transform.translation.z = 0.0;

1.2 CMakeLists.txt
~~~~~~~~~~~~~~~~~~

Navigate one level back to the ``learning_tf2_cpp`` directory, where the ``CMakeLists.txt`` and ``package.xml`` files are located.

Now open the ``CMakeLists.txt`` add the executable and name it ``fixed_frame_tf2_broadcaster``.

.. code-block:: console

    add_executable(fixed_frame_tf2_broadcaster src/fixed_frame_tf2_broadcaster.cpp)
    ament_target_dependencies(
        fixed_frame_tf2_broadcaster
        geometry_msgs
        rclcpp
        tf2_ros
    )

Finally, add the ``install(TARGETS…)`` section so ``ros2 run`` can find your executable:

.. code-block:: console

    install(TARGETS
        fixed_frame_tf2_broadcaster
        DESTINATION lib/${PROJECT_NAME})

1.3 Write the launch file
~~~~~~~~~~~~~~~~~~~~~~~~~

Now let's create a launch file for this example.
With your text editor, create a new file called ``turtle_tf2_fixed_frame_demo_launch.py`` in the ``src/learning_tf2_cpp/launch`` directory, and add the following lines:

.. code-block:: python

    import os

    from ament_index_python.packages import get_package_share_directory

    from launch import LaunchDescription
    from launch.actions import IncludeLaunchDescription
    from launch.launch_description_sources import PythonLaunchDescriptionSource

    from launch_ros.actions import Node


    def generate_launch_description():
        demo_nodes = IncludeLaunchDescription(
            PythonLaunchDescriptionSource([os.path.join(
                get_package_share_directory('learning_tf2_cpp'), 'launch'),
                '/turtle_tf2_demo_launch.py']),
            )

        return LaunchDescription([
            demo_nodes,
            Node(
                package='learning_tf2_cpp',
                executable='fixed_frame_tf2_broadcaster',
                name='fixed_broadcaster',
            ),
        ])


This launch file imports the required packages and then creates a ``demo_nodes`` variable that will store nodes that we created in the previous tutorial's launch file.

The last part of the code will add our fixed ``carrot1`` frame to the turtlesim world using our ``fixed_frame_tf2_broadcaster`` node.

.. code-block:: python

    Node(
        package='learning_tf2_cpp',
        executable='fixed_frame_tf2_broadcaster',
        name='fixed_broadcaster',
    ),

1.4 Build
~~~~~~~~~

Run ``rosdep`` in the root of your workspace to check for missing dependencies.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

   .. group-tab:: Windows

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

Still in the root of your workspace, build your package:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          colcon build --packages-select learning_tf2_cpp

   .. group-tab:: macOS

      .. code-block:: console

          colcon build --packages-select learning_tf2_cpp

   .. group-tab:: Windows

      .. code-block:: console

          colcon build --merge-install --packages-select learning_tf2_cpp

Open a new terminal, navigate to the root of your workspace, and source the setup files:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          . install/setup.bash

   .. group-tab:: macOS

      .. code-block:: console

          . install/setup.bash

   .. group-tab:: Windows

      .. code-block:: console

          # CMD
          call install\setup.bat

          # Powershell
          .\install\setup.ps1

1.5 Run
~~~~~~~

Now you can start the turtle broadcaster demo:

.. code-block:: console

    ros2 launch learning_tf2_cpp turtle_tf2_fixed_frame_demo_launch.py

You should notice that the new ``carrot1`` frame appeared in the transformation tree.

.. image:: images/turtlesim_frames_carrot.png

If you drive the first turtle around, you should notice that the behavior didn't change from the previous tutorial, even though we added a new frame.
That's because adding an extra frame does not affect the other frames and our listener is still using the previously defined frames.

Therefore if we want our second turtle to follow the carrot instead of the first turtle, we need to change value of the ``target_frame``.
This can be done two ways.
One way is to pass the ``target_frame`` argument to the launch file directly from the console:

.. code-block:: console

    ros2 launch learning_tf2_cpp turtle_tf2_fixed_frame_demo_launch.py target_frame:=carrot1

The second way is to update the launch file.
To do so, open the ``turtle_tf2_fixed_frame_demo_launch.py`` file, and add the ``'target_frame': 'carrot1'`` parameter via ``launch_arguments`` argument.

.. code-block:: python

    def generate_launch_description():
        demo_nodes = IncludeLaunchDescription(
            ...,
            launch_arguments={'target_frame': 'carrot1'}.items(),
            )

Now rebuild the package, restart the ``turtle_tf2_fixed_frame_demo_launch.py``, and you'll see the second turtle following the carrot instead of the first turtle!

.. image:: images/carrot_static.png

2 Write the dynamic frame broadcaster
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The extra frame we published in this tutorial is a fixed frame that doesn't change over time in relation to the parent frame.
However, if you want to publish a moving frame you can code the broadcaster to change the frame over time.
Let's change our ``carrot1`` frame so that it changes relative to ``turtle1`` frame over time.
Go to the ``learning_tf2_cpp`` package we created in the previous tutorial.
Inside the ``src`` directory download the dynamic frame broadcaster code by entering the following command:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/dynamic_frame_tf2_broadcaster.cpp

   .. group-tab:: macOS

      .. code-block:: console

          wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/dynamic_frame_tf2_broadcaster.cpp

   .. group-tab:: Windows

      In a Windows command line prompt:

      .. code-block:: console

          curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/dynamic_frame_tf2_broadcaster.cpp -o dynamic_frame_tf2_broadcaster.cpp

      Or in powershell:

      .. code-block:: console

          curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_cpp/src/dynamic_frame_tf2_broadcaster.cpp -o dynamic_frame_tf2_broadcaster.cpp

Now open the file called ``dynamic_frame_tf2_broadcaster.cpp``:

.. code-block:: C++

    #include <chrono>
    #include <functional>
    #include <memory>

    #include ""geometry_msgs/msg/transform_stamped.hpp""
    #include ""rclcpp/rclcpp.hpp""
    #include ""tf2_ros/transform_broadcaster.h""

    using namespace std::chrono_literals;

    const double PI = 3.141592653589793238463;

    class DynamicFrameBroadcaster : public rclcpp::Node
    {
    public:
      DynamicFrameBroadcaster()
      : Node(""dynamic_frame_tf2_broadcaster"")
      {
        tf_broadcaster_ = std::make_shared<tf2_ros::TransformBroadcaster>(this);

        auto broadcast_timer_callback = [this](){
            rclcpp::Time now = this->get_clock()->now();
            double x = now.seconds() * PI;

            geometry_msgs::msg::TransformStamped t;
            t.header.stamp = now;
            t.header.frame_id = ""turtle1"";
            t.child_frame_id = ""carrot1"";
            t.transform.translation.x = 10 * sin(x);
            t.transform.translation.y = 10 * cos(x);
            t.transform.translation.z = 0.0;
            t.transform.rotation.x = 0.0;
            t.transform.rotation.y = 0.0;
            t.transform.rotation.z = 0.0;
            t.transform.rotation.w = 1.0;

            tf_broadcaster_->sendTransform(t);
        };
        timer_ = this->create_wall_timer(100ms, broadcast_timer_callback);
      }

    private:
      rclcpp::TimerBase::SharedPtr timer_;
      std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;
    };

    int main(int argc, char * argv[])
    {
      rclcpp::init(argc, argv);
      rclcpp::spin(std::make_shared<DynamicFrameBroadcaster>());
      rclcpp::shutdown();
      return 0;
    }

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

Instead of a fixed definition of our x and y offsets, we are using the ``sin()`` and ``cos()`` functions on the current time so that the offset of ``carrot1`` is constantly changing.

.. code-block:: C++

    double x = now.seconds() * PI;
    ...
    t.transform.translation.x = 10 * sin(x);
    t.transform.translation.y = 10 * cos(x);

2.2 CMakeLists.txt
~~~~~~~~~~~~~~~~~~

Navigate one level back to the ``learning_tf2_cpp`` directory, where the ``CMakeLists.txt`` and ``package.xml`` files are located.

Now open the ``CMakeLists.txt`` add the executable and name it ``dynamic_frame_tf2_broadcaster``.

.. code-block:: console

    add_executable(dynamic_frame_tf2_broadcaster src/dynamic_frame_tf2_broadcaster.cpp)
    ament_target_dependencies(
        dynamic_frame_tf2_broadcaster
        geometry_msgs
        rclcpp
        tf2_ros
    )

Finally, add the ``install(TARGETS…)`` section so ``ros2 run`` can find your executable:

.. code-block:: console

    install(TARGETS
        dynamic_frame_tf2_broadcaster
        DESTINATION lib/${PROJECT_NAME})

2.3 Write the launch file
~~~~~~~~~~~~~~~~~~~~~~~~~

To test this code, create a new launch file ``turtle_tf2_dynamic_frame_demo_launch.py`` in the ``src/learning_tf2_cpp/launch`` directory and paste the following code:

.. code-block:: python

    import os

    from ament_index_python.packages import get_package_share_directory

    from launch import LaunchDescription
    from launch.actions import IncludeLaunchDescription
    from launch.launch_description_sources import PythonLaunchDescriptionSource

    from launch_ros.actions import Node


    def generate_launch_description():
        demo_nodes = IncludeLaunchDescription(
            PythonLaunchDescriptionSource([os.path.join(
                get_package_share_directory('learning_tf2_cpp'), 'launch'),
                '/turtle_tf2_demo_launch.py']),
            launch_arguments={'target_frame': 'carrot1'}.items(),
            )

        return LaunchDescription([
            demo_nodes,
            Node(
                package='learning_tf2_cpp',
                executable='dynamic_frame_tf2_broadcaster',
                name='dynamic_broadcaster',
            ),
        ])

2.4 Build
~~~~~~~~~

Run ``rosdep`` in the root of your workspace to check for missing dependencies.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

   .. group-tab:: Windows

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

Still in the root of your workspace, build your package:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          colcon build --packages-select learning_tf2_cpp

   .. group-tab:: macOS

      .. code-block:: console

          colcon build --packages-select learning_tf2_cpp

   .. group-tab:: Windows

      .. code-block:: console

          colcon build --merge-install --packages-select learning_tf2_cpp

Open a new terminal, navigate to the root of your workspace, and source the setup files:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          . install/setup.bash

   .. group-tab:: macOS

      .. code-block:: console

          . install/setup.bash

   .. group-tab:: Windows

      .. code-block:: console

          # CMD
          call install\setup.bat

          # Powershell
          .\install\setup.ps1

2.5 Run
~~~~~~~

Now you can start the dynamic frame demo:

.. code-block:: console

    ros2 launch learning_tf2_cpp turtle_tf2_dynamic_frame_demo_launch.py

You should see that the second turtle is following the carrot's position that is constantly changing.

.. image:: images/carrot_dynamic.png


Summary
-------

In this tutorial, you learned about the tf2 transformation tree, its structure, and its features.
You also learned that it is easiest to think inside a local frame, and learned to add extra fixed and dynamic frames for that local frame.
",What are the key differences between adding a fixed frame and a dynamic frame in tf2?
".. redirect-from::

    Tutorials/Tf2/Tf2-Main

.. _Tf2Main:

``tf2``
=======

Many of the tf2 tutorials are available for both C++ and Python.
The tutorials are streamlined to complete either the C++ track or the Python track.
If you want to learn both C++ and Python, you should go through the tutorials once for C++ and once for Python.

.. contents:: Contents
   :depth: 2
   :local:

.. toctree::
   :hidden:

   Introduction-To-Tf2
   Writing-A-Tf2-Static-Broadcaster-Py
   Writing-A-Tf2-Static-Broadcaster-Cpp
   Writing-A-Tf2-Broadcaster-Py
   Writing-A-Tf2-Broadcaster-Cpp
   Writing-A-Tf2-Listener-Py
   Writing-A-Tf2-Listener-Cpp
   Adding-A-Frame-Py
   Adding-A-Frame-Cpp
   Learning-About-Tf2-And-Time-Cpp
   Time-Travel-With-Tf2-Cpp
   Debugging-Tf2-Problems
   Quaternion-Fundamentals
   Using-Stamped-Datatypes-With-Tf2-Ros-MessageFilter

Workspace setup
---------------

If you have not yet created a workspace in which to complete the tutorials, :doc:`follow this tutorial <../../Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace>`.

Learning tf2
------------

#. :doc:`Introduction to tf2 <./Introduction-To-Tf2>`.

   This tutorial will give you a good idea of what tf2 can do for you.
   It shows off some of the tf2 power in a multi-robot example using turtlesim.
   This also introduces using ``tf2_echo``, ``view_frames``, and ``rviz``.

#. Writing a static broadcaster :doc:`(Python) <./Writing-A-Tf2-Static-Broadcaster-Py>` :doc:`(C++) <./Writing-A-Tf2-Static-Broadcaster-Cpp>`.

   This tutorial teaches you how to broadcast static coordinate frames to tf2.

#. Writing a broadcaster :doc:`(Python) <./Writing-A-Tf2-Broadcaster-Py>` :doc:`(C++) <Writing-A-Tf2-Broadcaster-Cpp>`.

   This tutorial teaches you how to broadcast the state of a robot to tf2.

#. Writing a listener :doc:`(Python) <./Writing-A-Tf2-Listener-Py>` :doc:`(C++) <./Writing-A-Tf2-Listener-Cpp>`.

   This tutorial teaches you how to use tf2 to get access to frame transformations.

#. Adding a frame :doc:`(Python) <./Adding-A-Frame-Py>` :doc:`(C++) <Adding-A-Frame-Cpp>`.

   This tutorial teaches you how to add an extra fixed frame to tf2.

#. Using time :doc:`(C++) <Learning-About-Tf2-And-Time-Cpp>`.

   This tutorial teaches you to use the timeout in ``lookup_transform`` function to
   wait for a transform to be available on the tf2 tree.

#. Traveling in time :doc:`(C++) <./Time-Travel-With-Tf2-Cpp>`.

   This tutorial teaches you about advanced time travel features of tf2.

Debugging tf2
-------------

#. :doc:`Quaternion fundamentals <./Quaternion-Fundamentals>`.

   This tutorial teaches you basics of quaternion usage in ROS 2.

#. :doc:`Debugging tf2 problems <./Debugging-Tf2-Problems>`.

   This tutorial teaches you about a systematic approach for debugging tf2 related problems.

Using sensor messages with tf2
------------------------------

#. :doc:`Using stamped datatypes with tf2_ros::MessageFilter <./Using-Stamped-Datatypes-With-Tf2-Ros-MessageFilter>`.

   This tutorial teaches you how to use ``tf2_ros::MessageFilter`` to process stamped datatypes.
",What tutorials are streamlined to complete either the C++ track or the Python track in the tf2 main document?
".. redirect-from::

    Tutorials/Tf2/Writing-A-Tf2-Static-Broadcaster-Py

Writing a static broadcaster (Python)
=====================================

**Goal:** Learn how to broadcast static coordinate frames to tf2.

**Tutorial level:** Intermediate

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

Publishing static transforms is useful to define the relationship between a robot base and its sensors or non-moving parts.
For example, it is easiest to reason about laser scan measurements in a frame at the center of the laser scanner.

This is a standalone tutorial covering the basics of static transforms, which consists of two parts.
In the first part we will write code to publish static transforms to tf2.
In the second part we will explain how to use the commandline ``static_transform_publisher`` executable tool in ``tf2_ros``.

In the next two tutorials we will write the code to reproduce the demo from the :doc:`Introduction to tf2 <./Introduction-To-Tf2>` tutorial.
After that, the following tutorials focus on extending the demo with more advanced tf2 features.

Prerequisites
-------------

In previous tutorials, you learned how to :doc:`create a workspace <../../Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace>` and :doc:`create a package <../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>`.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

First we will create a package that will be used for this tutorial and the following ones.
The package called ``learning_tf2_py`` will depend on ``geometry_msgs``, ``python3-numpy``, ``rclpy``, ``tf2_ros_py``, and ``turtlesim``.
Code for this tutorial is stored `here <https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/static_turtle_tf2_broadcaster.py>`_.

Open a new terminal and :doc:`source your ROS 2 installation <../../Beginner-CLI-Tools/Configuring-ROS2-Environment>` so that ``ros2`` commands will work.
Navigate to workspace's ``src`` folder and create a new package:

.. code-block:: console

   ros2 pkg create --build-type ament_python --license Apache-2.0 -- learning_tf2_py

Your terminal will return a message verifying the creation of your package ``learning_tf2_py`` and all its necessary files and folders.

2 Write the static broadcaster node
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's first create the source files.
Inside the ``src/learning_tf2_py/learning_tf2_py`` directory download the example static broadcaster code by entering the following command:

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/static_turtle_tf2_broadcaster.py

    .. group-tab:: macOS

        .. code-block:: console

            wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/static_turtle_tf2_broadcaster.py

    .. group-tab:: Windows

        In a Windows command line prompt:

        .. code-block:: console

                curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/static_turtle_tf2_broadcaster.py -o static_turtle_tf2_broadcaster.py

        Or in powershell:

        .. code-block:: console

                curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/static_turtle_tf2_broadcaster.py -o static_turtle_tf2_broadcaster.py

Now open the file called ``static_turtle_tf2_broadcaster.py`` using your preferred text editor.

.. code-block:: python

    import math
    import sys

    from geometry_msgs.msg import TransformStamped

    import numpy as np

    import rclpy
    from rclpy.executors import ExternalShutdownException
    from rclpy.node import Node

    from tf2_ros.static_transform_broadcaster import StaticTransformBroadcaster


    def quaternion_from_euler(ai, aj, ak):
        ai /= 2.0
        aj /= 2.0
        ak /= 2.0
        ci = math.cos(ai)
        si = math.sin(ai)
        cj = math.cos(aj)
        sj = math.sin(aj)
        ck = math.cos(ak)
        sk = math.sin(ak)
        cc = ci*ck
        cs = ci*sk
        sc = si*ck
        ss = si*sk

        q = np.empty((4, ))
        q[0] = cj*sc - sj*cs
        q[1] = cj*ss + sj*cc
        q[2] = cj*cs - sj*sc
        q[3] = cj*cc + sj*ss

        return q


    class StaticFramePublisher(Node):
        """"""
        Broadcast transforms that never change.

        This example publishes transforms from `world` to a static turtle frame.
        The transforms are only published once at startup, and are constant for all
        time.
        """"""

        def __init__(self, transformation):
            super().__init__('static_turtle_tf2_broadcaster')

            self.tf_static_broadcaster = StaticTransformBroadcaster(self)

            # Publish static transforms once at startup
            self.make_transforms(transformation)

        def make_transforms(self, transformation):
            t = TransformStamped()

            t.header.stamp = self.get_clock().now().to_msg()
            t.header.frame_id = 'world'
            t.child_frame_id = transformation[1]

            t.transform.translation.x = float(transformation[2])
            t.transform.translation.y = float(transformation[3])
            t.transform.translation.z = float(transformation[4])
            quat = quaternion_from_euler(
                float(transformation[5]), float(transformation[6]), float(transformation[7]))
            t.transform.rotation.x = quat[0]
            t.transform.rotation.y = quat[1]
            t.transform.rotation.z = quat[2]
            t.transform.rotation.w = quat[3]

            self.tf_static_broadcaster.sendTransform(t)


    def main():
        try:
            logger = rclpy.logging.get_logger('logger')

            # obtain parameters from command line arguments
            if len(sys.argv) != 8:
                logger.info('Invalid number of parameters. Usage: \n'
                            '$ ros2 run learning_tf2_py static_turtle_tf2_broadcaster'
                            'child_frame_name x y z roll pitch yaw')
                sys.exit(1)

            if sys.argv[1] == 'world':
                logger.info('Your static turtle name cannot be ""world""')
                sys.exit(2)

            # pass parameters and initialize node
            with rclpy.init():
                node = StaticFramePublisher(sys.argv)
                rclpy.spin(node)
        except (KeyboardInterrupt, ExternalShutdownException):
            pass

2.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

Now let's look at the code that is relevant to publishing the static turtle pose to tf2.
The first lines import required packages.
First we import the ``TransformStamped`` from the ``geometry_msgs``, which provides us a template for the message that we will publish to the transformation tree.

.. code-block:: python

    from geometry_msgs.msg import TransformStamped

Afterward, ``rclpy`` is imported so its ``Node`` class can be used.

.. code-block:: python

    import rclpy
    from rclpy.executors import ExternalShutdownException
    from rclpy.node import Node

The ``tf2_ros`` package provides a ``StaticTransformBroadcaster`` to make the publishing of static transforms easy.
To use the ``StaticTransformBroadcaster``, we need to import it from the ``tf2_ros`` module.

.. code-block:: python

    from tf2_ros.static_transform_broadcaster import StaticTransformBroadcaster

The ``StaticFramePublisher`` class constructor initializes the node with the name ``static_turtle_tf2_broadcaster``.
Then, ``StaticTransformBroadcaster`` is created, which will send one static transformation upon the startup.

.. code-block:: python

    self.tf_static_broadcaster = StaticTransformBroadcaster(self)
    self.make_transforms(transformation)

Here we create a ``TransformStamped`` object, which will be the message we will send over once populated.
Before passing the actual transform values we need to give it the appropriate metadata.

#. We need to give the transform being published a timestamp and we'll just stamp it with the current time, ``self.get_clock().now()``

#. Then we need to set the name of the parent frame of the link we're creating, in this case ``world``

#. Finally, we need to set the name of the child frame of the link we're creating

.. code-block:: python

    t = TransformStamped()

    t.header.stamp = self.get_clock().now().to_msg()
    t.header.frame_id = 'world'
    t.child_frame_id = transformation[1]

Here we populate the 6D pose (translation and rotation) of the turtle.

.. code-block:: python

    t.transform.translation.x = float(transformation[2])
    t.transform.translation.y = float(transformation[3])
    t.transform.translation.z = float(transformation[4])
    quat = quaternion_from_euler(
        float(transformation[5]), float(transformation[6]), float(transformation[7]))
    t.transform.rotation.x = quat[0]
    t.transform.rotation.y = quat[1]
    t.transform.rotation.z = quat[2]
    t.transform.rotation.w = quat[3]

Finally, we broadcast static transform using the ``sendTransform()`` function.

.. code-block:: python

    self.tf_static_broadcaster.sendTransform(t)

2.2 Update package.xml
~~~~~~~~~~~~~~~~~~~~~~

Navigate one level back to the ``src/learning_tf2_py`` directory, where the ``setup.py``, ``setup.cfg``, and ``package.xml`` files have been created for you.

Open ``package.xml`` with your text editor.

As mentioned in the :doc:`Create a package <../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>` tutorial, make sure to fill in the ``<description>``, ``<maintainer>`` and ``<license>`` tags:

.. code-block:: xml

    <description>Learning tf2 with rclpy</description>
    <maintainer email=""you@email.com"">Your Name</maintainer>
    <license>Apache-2.0</license>

After the lines above, add the following dependencies corresponding to your node’s import statements:

.. code-block:: xml

    <exec_depend>geometry_msgs</exec_depend>
    <exec_depend>python3-numpy</exec_depend>
    <exec_depend>rclpy</exec_depend>
    <exec_depend>tf2_ros_py</exec_depend>
    <exec_depend>turtlesim</exec_depend>

This declares the required ``geometry_msgs``, ``python3-numpy``, ``rclpy``, ``tf2_ros_py``, and ``turtlesim`` dependencies when its code is executed.

Make sure to save the file.

2.3 Add an entry point
~~~~~~~~~~~~~~~~~~~~~~

To allow the ``ros2 run`` command to run your node, you must add the entry point to ``setup.py`` (located in the ``src/learning_tf2_py`` directory).

Add the following line between the ``'console_scripts':`` brackets:

.. code-block:: python

    'static_turtle_tf2_broadcaster = learning_tf2_py.static_turtle_tf2_broadcaster:main',

3 Build
^^^^^^^

It's good practice to run ``rosdep`` in the root of your workspace to check for missing dependencies before building:

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

      rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

   .. group-tab:: Windows

      rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

Still in the root of your workspace, build your new package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        colcon build --packages-select learning_tf2_py

  .. group-tab:: macOS

    .. code-block:: console

        colcon build --packages-select learning_tf2_py

  .. group-tab:: Windows

    .. code-block:: console

        colcon build --merge-install --packages-select learning_tf2_py

Open a new terminal, navigate to the root of your workspace, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        . install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

        . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

        # CMD
        call install\setup.bat

        # Powershell
        .\install\setup.ps1

4 Run
^^^^^

Now run the ``static_turtle_tf2_broadcaster`` node:

.. code-block:: console

    ros2 run learning_tf2_py static_turtle_tf2_broadcaster mystaticturtle 0 0 1 0 0 0

This sets a turtle pose broadcast for ``mystaticturtle`` to float 1 meter above the ground.

We can now check that the static transform has been published by echoing the ``tf_static`` topic

.. code-block:: console

    ros2 topic echo /tf_static

If everything went well you should see a single static transform

.. code-block:: console

    transforms:
    - header:
       stamp:
          sec: 1622908754
          nanosec: 208515730
       frame_id: world
    child_frame_id: mystaticturtle
    transform:
       translation:
          x: 0.0
          y: 0.0
          z: 1.0
       rotation:
          x: 0.0
          y: 0.0
          z: 0.0
          w: 1.0

The proper way to publish static transforms
-------------------------------------------

This tutorial aimed to show how ``StaticTransformBroadcaster`` can be used to publish static transforms.
In your real development process you shouldn't have to write this code yourself and should use the dedicated ``tf2_ros`` tool to do so.
``tf2_ros`` provides an executable named ``static_transform_publisher`` that can be used either as a commandline tool or a node that you can add to your launchfiles.

The following command publishes a static coordinate transform to tf2 using an x/y/z offset in meters and roll/pitch/yaw in radians.
In ROS 2, roll/pitch/yaw refers to rotation about the x/y/z-axis, respectively.

.. code-block:: console

    ros2 run tf2_ros static_transform_publisher --x x --y y --z z --yaw yaw --pitch pitch --roll roll --frame-id frame_id --child-frame-id child_frame_id

The following command publishes a static coordinate transform to tf2 using an x/y/z offset in meters and roll/pitch/yaw as a quaternion.

.. code-block:: console

    ros2 run tf2_ros static_transform_publisher --x x --y y --z z --qx qx --qy qy --qz qz --qw qw --frame-id frame_id --child-frame-id child_frame_id

``static_transform_publisher`` is designed both as a command-line tool for manual use, as well as for use within ``launch`` files for setting static transforms. For example:

.. code-block:: python

    from launch import LaunchDescription
    from launch_ros.actions import Node

    def generate_launch_description():
        return LaunchDescription([
            Node(
                package='tf2_ros',
                executable='static_transform_publisher',
                arguments = ['--x', '0', '--y', '0', '--z', '1', '--yaw', '0', '--pitch', '0', '--roll', '0', '--frame-id', 'world', '--child-frame-id', 'mystaticturtle']
            ),
        ])

Note that all arguments except for ``--frame-id`` and ``--child-frame-id`` are optional; if a particular option isn't specified, then the identity will be assumed.

Summary
-------

In this tutorial you learned how static transforms are useful to define static relationships between frames, like ``mystaticturtle`` in relation to the ``world`` frame.
In addition, you learned how static transforms can be useful for understanding sensor data, such as from laser scanners, by relating the data to a common coordinate frame.
Finally, you wrote your own node to publish static transforms to tf2 and learned how to publish required static transformations using ``static_transform_publisher`` executable and launch files.
",What is the purpose of broadcasting static coordinate frames to tf2 in ROS 2?
".. redirect-from::

    Tutorials/Tf2/Debugging-Tf2-Problems

.. _DebuggingTf2Problems:

Debugging
=========

**Goal:** Learn how to use a systematic approach for debugging tf2 related problems.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

This tutorial walks you through the steps to debug a typical tf2 problem.
It will also use many of the tf2 debugging tools, such as ``tf2_echo``, ``tf2_monitor``, and ``view_frames``.
This tutorial assumes you have completed the :doc:`learning tf2 <./Tf2-Main>` tutorials.

Debugging example
-----------------

1 Setting and starting the example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For this tutorial we will set up a demo application that has a number of problems.
The goal of this tutorial is to apply a systematic approach to find and tackle these problems.
First, let's create the source file.

Go to the ``learning_tf2_cpp`` package we created in :doc:`tf2 tutorials <./Tf2-Main>`.
Inside the ``src`` directory make a copy of the source file ``turtle_tf2_listener.cpp`` and rename it to ``turtle_tf2_listener_debug.cpp``.

Open the file using your preferred text editor, and change line 65 from

.. code-block:: C++

   std::string toFrameRel = ""turtle2"";

to

.. code-block:: C++

   std::string toFrameRel = ""turtle3"";

and change ``lookupTransform()`` call in lines 73-77 from

.. code-block:: C++

    try {
      t = tf_buffer_->lookupTransform(
        toFrameRel, fromFrameRel,
        tf2::TimePointZero);
    } catch (const tf2::TransformException & ex) {

to

.. code-block:: C++

    try {
      t = tf_buffer_->lookupTransform(
        toFrameRel, fromFrameRel,
        this->now());
    } catch (const tf2::TransformException & ex) {

And save changes to the file.
In order to run this demo, we need to create a launch file ``start_tf2_debug_demo_launch.py`` in the ``launch`` subdirectory of package ``learning_tf2_cpp``:

.. code-block:: python

   from launch import LaunchDescription
   from launch.actions import DeclareLaunchArgument
   from launch.substitutions import LaunchConfiguration

   from launch_ros.actions import Node

   def generate_launch_description():
      return LaunchDescription([
         DeclareLaunchArgument(
            'target_frame', default_value='turtle1',
            description='Target frame name.'
         ),
         Node(
            package='turtlesim',
            executable='turtlesim_node',
            name='sim',
            output='screen'
         ),
         Node(
            package='learning_tf2_cpp',
            executable='turtle_tf2_broadcaster',
            name='broadcaster1',
            parameters=[
                  {'turtlename': 'turtle1'}
            ]
         ),
         Node(
            package='learning_tf2_cpp',
            executable='turtle_tf2_broadcaster',
            name='broadcaster2',
            parameters=[
                  {'turtlename': 'turtle2'}
            ]
         ),
         Node(
            package='learning_tf2_cpp',
            executable='turtle_tf2_listener_debug',
            name='listener_debug',
            parameters=[
                  {'target_frame': LaunchConfiguration('target_frame')}
            ]
         ),
      ])

Don't forget to add the ``turtle_tf2_listener_debug`` executable to the ``CMakeLists.txt`` and build the package.

Now let's run it to see what happens:

.. code-block:: console

   ros2 launch learning_tf2_cpp start_tf2_debug_demo_launch.py

You will now see that the turtlesim came up.
At the same time, if you run the ``turtle_teleop_key`` in another terminal window, you can use the arrow keys to drive the ``turtle1`` around.

.. code-block:: console

   ros2 run turtlesim turtle_teleop_key

You will also notice that there is a second turtle in the lower, left corner.
If the demo would be working correctly, this second turtle should be following the turtle you can command with the arrow keys.
However, it is not the case because we have to solve some problems first.
You should notice the following message:

.. code-block:: console

   [turtle_tf2_listener_debug-4] [INFO] [1630223454.942322623] [listener_debug]: Could not
   transform turtle3 to turtle1: ""turtle3"" passed to lookupTransform argument target_frame
   does not exist

2 Finding the tf2 request
^^^^^^^^^^^^^^^^^^^^^^^^^

Firstly, we need to find out what exactly we are asking tf2 to do.
Therefore, we go into the part of the code that is using tf2.
Open the ``src/turtle_tf2_listener_debug.cpp`` file, and take a look at line 65:

.. code-block:: C++

   std::string to_frame_rel = ""turtle3"";

and lines 73-77:

.. code-block:: C++

    try {
      t = tf_buffer_->lookupTransform(
        toFrameRel, fromFrameRel,
        this->now());
    } catch (const tf2::TransformException & ex) {

Here we do the actual request to tf2.
The three arguments tell us directly what we are asking tf2: transform from frame ``turtle3`` to frame ``turtle1`` at time ``now``.

Now, let's take a look at why this request to tf2 is failing.

3 Checking the frames
^^^^^^^^^^^^^^^^^^^^^

Firstly, to find out if tf2 knows about our transform between ``turtle3`` and ``turtle1``, we will use ``tf2_echo`` tool.

.. code-block:: console

   ros2 run tf2_ros tf2_echo turtle3 turtle1

The output tells us that frame ``turtle3`` does not exist:

.. code-block:: console

   [INFO] [1630223557.477636052] [tf2_echo]: Waiting for transform turtle3 ->  turtle1:
   Invalid frame ID ""turtle3"" passed to canTransform argument target_frame - frame does
   not exist

Then what frames do exist?
If you like to get a graphical representation of this, use ``view_frames`` tool.

.. code-block:: console

   ros2 run tf2_tools view_frames

Open the generated ``frames.pdf`` file to see the following output:

.. image:: images/turtlesim_frames.png

So obviously the problem is that we are requesting transform from frame ``turtle3``, which does not exist.
To fix this bug, just replace ``turtle3`` with ``turtle2`` in line 65.

And now stop the running demo, build it, and run it again:

.. code-block:: console

   ros2 launch turtle_tf2 start_debug_demo.launch.py

And right away we run into the next problem:

.. code-block:: console

   [turtle_tf2_listener_debug-4] [INFO] [1630223704.617382464] [listener_debug]: Could not
   transform turtle2 to turtle1: Lookup would require extrapolation into the future. Requested
   time 1630223704.617054 but the latest data is at time 1630223704.616726, when looking up
   transform from frame [turtle1] to frame [turtle2]

4 Checking the timestamp
^^^^^^^^^^^^^^^^^^^^^^^^

Now that we solved the frame name problem, it is time to look at the timestamps.
Remember, we are trying to get the transform between ``turtle2`` and ``turtle1`` at the current time (i.e., ``now``).
To get statistics on the timing, call ``tf2_monitor`` with corresponding frames.

.. code-block:: console

   ros2 run tf2_ros tf2_monitor turtle2 turtle1

The result should look something like this:

.. code-block:: console

   RESULTS: for turtle2 to turtle1
   Chain is: turtle1
   Net delay     avg = 0.00287347: max = 0.0167241

   Frames:
   Frame: turtle1, published by <no authority available>, Average Delay: 0.000295833, Max Delay: 0.000755072

   All Broadcasters:
   Node: <no authority available> 125.246 Hz, Average Delay: 0.000290237 Max Delay: 0.000786781

The key part here is the delay for the chain from ``turtle2`` to ``turtle1``.
The output shows there is an average delay of about 3 milliseconds.
This means that tf2 can only transform between the turtles after 3 milliseconds are passed.
So, if we would be asking tf2 for the transformation between the turtles 3 milliseconds ago instead of ``now``, tf2 would be able to give us an answer sometimes.
Let's test this quickly by changing lines 73-77 to:

.. code-block:: C++

    try {
      t = tf_buffer_->lookupTransform(
        toFrameRel, fromFrameRel,
        this->now() - rclcpp::Duration::from_seconds(0.1));
    } catch (const tf2::TransformException & ex) {

In the new code we are asking for the transform between the turtles 100 milliseconds ago.
It is usual to use a longer periods, just to make sure that the transform will arrive.
Stop the demo, build and run:

.. code-block:: console

   ros2 launch turtle_tf2 start_debug_demo.launch.py

And you should finally see the turtle move!

.. image:: images/turtlesim_follow1.png

That last fix we made is not really what you want to do, it was just to make sure that was our problem.
The real fix would look like this:

.. code-block:: C++

    try {
      t = tf_buffer_->lookupTransform(
        toFrameRel, fromFrameRel,
        tf2::TimePointZero);
    } catch (const tf2::TransformException & ex) {

Or like this:

.. code-block:: C++

    try {
      t = tf_buffer_->lookupTransform(
        toFrameRel, fromFrameRel,
        tf2::TimePoint());
    } catch (const tf2::TransformException & ex) {

You can learn more about timeouts in the :doc:`Using time <./Learning-About-Tf2-And-Time-Cpp>` tutorial, and use them as below:

.. code-block:: C++

    try {
      t = tf_buffer_->lookupTransform(
        toFrameRel, fromFrameRel,
        this->now(),
        rclcpp::Duration::from_seconds(0.05));
    } catch (const tf2::TransformException & ex) {

Summary
-------

In this tutorial you learned how to use a systematic approach for debugging tf2 related problems.
You also learned how to use tf2 debugging tools, such as ``tf2_echo``, ``tf2_monitor``, and ``view_frames`` to help you debug those tf2 problems.
",What are some of the tf2 debugging tools mentioned in the text?
".. redirect-from::

    Tutorials/Tf2/Time-Travel-With-Tf2-Cpp

.. _TimeTravelWithTf2Cpp:

Traveling in time (C++)
=======================

**Goal:** Learn about advanced time travel features of tf2.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In the previous tutorial, we discussed the :doc:`basics of tf2 and time <./Learning-About-Tf2-And-Time-Cpp>`.
This tutorial will take us one step further and expose a powerful tf2 trick: the time travel.
In short, one of the key features of tf2 library is that it is able to transform data in time as well as in space.

This tf2 time travel feature can be useful for various tasks, like monitoring the pose of the robot for a long period of time or building a follower robot that will follow the ""steps"" of the leader.
We will use that time travel feature to look up transforms back in time and program ``turtle2`` to follow 5 seconds behind ``carrot1``.

Time travel
-----------

First, let's go back to where we ended in the previous tutorial :doc:`Using time <./Learning-About-Tf2-And-Time-Cpp>`.
Go to your ``learning_tf2_cpp`` package.

Now, instead of making the second turtle go to where the carrot is now, we will make the second turtle go to where the first carrot was 5 seconds ago.
Edit the ``lookupTransform()`` call in ``turtle_tf2_listener.cpp`` file to

.. code-block:: C++

    rclcpp::Time when = this->get_clock()->now() - rclcpp::Duration(5, 0);
    try {
        t = tf_buffer_->lookupTransform(
            toFrameRel,
            fromFrameRel,
            when,
            50ms);
    } catch (const tf2::TransformException & ex) {

Now if you run this, during the first 5 seconds, the second turtle would not know where to go because we do not yet have a 5-second history of poses of the carrot.
But what happens after these 5 seconds? Build the package then let's just give it a try:

.. code-block:: console

    ros2 launch learning_tf2_cpp turtle_tf2_fixed_frame_demo_launch.py

.. image:: images/turtlesim_delay1.png

You should now notice that your turtle is driving around uncontrollably like in this screenshot. Let's try to understand reason behind that behavior.

#. In our code we asked tf2 the following question: ""What was the pose of ``carrot1`` 5 seconds ago, relative to ``turtle2`` 5 seconds ago?"". This means we are controlling the second turtle based on where it was 5 seconds ago as well as where the first carrot was 5 seconds ago.

#. However, what we really want to ask is: ""What was the pose of ``carrot1`` 5 seconds ago, relative to the current position of the ``turtle2``?"".

Advanced API for lookupTransform()
----------------------------------

To ask the tf2 that particular question, we will use an advanced API that gives us the power to say explicitly when to acquire the specified transformations.
This is done by calling the ``lookupTransform()`` method with additional parameters.
Your code now would look like this:

.. code-block:: C++

    rclcpp::Time now = this->get_clock()->now();
    rclcpp::Time when = now - rclcpp::Duration(5, 0);
    try {
        t = tf_buffer_->lookupTransform(
            toFrameRel,
            now,
            fromFrameRel,
            when,
            ""world"",
            50ms);
    } catch (const tf2::TransformException & ex) {

The advanced API for ``lookupTransform()`` takes six arguments:

#. Target frame

#. The time to transform to

#. Source frame

#. The time at which source frame will be evaluated

#. Frame that does not change over time, in this case the ``world`` frame

#. Time to wait for the target frame to become available

To sum up, tf2 does the following in the background.
In the past, it computes the transform from the ``carrot1`` to the ``world``.
In the ``world`` frame, tf2 time travels from the past to now.
And at the current time, tf2 computes the transform from the ``world`` to the ``turtle2``.

Checking the results
--------------------

Build the package then let's run the simulation again, this time with the advanced time-travel API:

.. code-block:: console

    ros2 launch learning_tf2_cpp turtle_tf2_fixed_frame_demo_launch.py

.. image:: images/turtlesim_delay2.png

And yes, the second turtle is directed to where the first carrot was 5 seconds ago!

Summary
-------

In this tutorial, you have seen one of the advanced features of tf2.
You learned that tf2 can transform data in time and learned how to do that with turtlesim example.
tf2 allowed you to go back in time and make frame transformations between old and current poses of turtles by using the advanced ``lookupTransform()`` API.
",What is the advanced API for the `lookupTransform()` method in tf2 and what are the six arguments it takes?
".. redirect-from::

    Tutorials/Tf2/Learning-About-Tf2-And-Time-Cpp

.. _LearningAboutTf2AndTimeCpp:

Using time (C++)
================

**Goal:** Learn how to get a transform at a specific time and wait for a transform to be available on the tf2 tree using ``lookupTransform()`` function.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In previous tutorials, we recreated the turtle demo by writing a :doc:`tf2 broadcaster <Writing-A-Tf2-Broadcaster-Cpp>` and a :doc:`tf2 listener <Writing-A-Tf2-Listener-Cpp>`.
We also learned how to :doc:`add a new frame to the transformation tree <Adding-A-Frame-Cpp>` and learned how tf2 keeps track of a tree of coordinate frames.
This tree changes over time, and tf2 stores a time snapshot for every transform (for up to 10 seconds by default).
Until now we used the ``lookupTransform()`` function to get access to the latest available transforms in that tf2 tree, without knowing at what time that transform was recorded.
This tutorial will teach you how to get a transform at a specific time.

Tasks
-----

1 Update the listener node
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's go back to where we ended in the :doc:`adding a frame tutorial <Adding-A-Frame-Cpp>`.
Go to the ``learning_tf2_cpp`` package.
Open ``turtle_tf2_listener.cpp`` and take a look at the ``lookupTransform()`` call:

.. code-block:: C++

   try {
       t = tf_buffer_->lookupTransform(
          toFrameRel,
          fromFrameRel,
          tf2::TimePointZero);
   } catch (const tf2::TransformException & ex) {

You can see that we specified a time equal to 0 by calling ``tf2::TimePointZero``.

.. note::

    The ``tf2`` package has it's own time type ``tf2::TimePoint``, which is different from ``rclcpp::Time``.
    Many APIs in the package ``tf2_ros`` automatically convert between ``rclcpp::Time`` and ``tf2::TimePoint``.

    ``rclcpp::Time(0, 0, this->get_clock()->get_clock_type())`` could have been used here, but it would have been converted to ``tf2::TimePointZero`` anyways.

For tf2, time 0 means ""the latest available"" transform in the buffer.
Now, change this line to get the transform at the current time, ``this->get_clock()->now()``:

.. code-block:: C++

   rclcpp::Time now = this->get_clock()->now();
   try {
       t = tf_buffer_->lookupTransform(
           toFrameRel, fromFrameRel,
           now);
   } catch (const tf2::TransformException & ex) {

Now build the package and try to run the launch file.

.. code-block:: console

   ros2 launch learning_tf2_cpp turtle_tf2_demo_launch.py

You will notice that it fails and outputs something similar to this:

.. code-block:: console

   [INFO] [1629873136.345688064] [listener]: Could not transform turtle2 to turtle1: Lookup would
   require extrapolation into the future.  Requested time 1629873136.345539 but the latest data
   is at time 1629873136.338804, when looking up transform from frame [turtle1] to frame [turtle2]

It tells you that the frame does not exist or that the data is in the future.

To understand why is this happening we need to understand how buffers work.
Firstly, each listener has a buffer where it stores all the coordinate transforms coming from the different tf2 broadcasters.
Secondly, when a broadcaster sends out a transform, it takes some time before that transform gets into the buffer (usually a couple of milliseconds).
As a result, when you request a frame transform at time ""now"", you should wait a few milliseconds for that information to arrive.

2 Fix the listener node
^^^^^^^^^^^^^^^^^^^^^^^

tf2 provides a nice tool that will wait until a transform becomes available.
You use this by adding a timeout parameter to ``lookupTransform()``.
To fix this, edit your code as shown below (add the last timeout parameter):

.. code-block:: C++

   rclcpp::Time now = this->get_clock()->now();
   try {
       t = tf_buffer_->lookupTransform(
           toFrameRel,
           fromFrameRel,
           now,
           50ms);
   } catch (const tf2::TransformException & ex) {

The ``lookupTransform()`` can take four arguments, where the last one is an optional timeout.
It will block for up to that duration waiting for it to timeout.

3 Check the results
^^^^^^^^^^^^^^^^^^^

You can now build the package and run the launch file.

.. code-block:: console

   ros2 launch learning_tf2_cpp turtle_tf2_demo_launch.py

You should notice that ``lookupTransform()`` will actually block until the transform between the two turtles becomes available (this will usually take a few milliseconds).
Once the timeout has been reached (fifty milliseconds in this case), an exception will be raised only if the transform is still not available.

Summary
-------

In this tutorial, you learned how to acquire a transform at a specific timestamp and how to wait for a transform to be available on the tf2 tree when using the ``lookupTransform()`` function.
",What tool can be utilized in tf2 to wait for a transform to become available by adding a timeout parameter to the `lookupTransform()` function?
".. redirect-from::

    Tutorials/Tf2/Writing-A-Tf2-Listener-Py

Writing a listener (Python)
===========================

**Goal:** Learn how to use tf2 to get access to frame transformations.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

In previous tutorials we created a tf2 broadcaster to publish the pose of a turtle to tf2.

In this tutorial we'll create a tf2 listener to start using tf2.

Prerequisites
-------------

This tutorial assumes you have completed the :doc:`tf2 static broadcaster tutorial (Python) <./Writing-A-Tf2-Static-Broadcaster-Py>` and :doc:`tf2 broadcaster tutorial (Python) <./Writing-A-Tf2-Broadcaster-Py>`.
In the previous tutorial, we created a ``learning_tf2_py`` package, which is where we will continue working from.

Tasks
-----

1 Write the listener node
^^^^^^^^^^^^^^^^^^^^^^^^^

Let's first create the source files.
Go to the ``learning_tf2_py`` package we created in the previous tutorial.
Inside the ``src/learning_tf2_py/learning_tf2_py`` directory download the example listener code by entering the following command:

.. tabs::

    .. group-tab:: Linux

        .. code-block:: console

            wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_listener.py

    .. group-tab:: macOS

        .. code-block:: console

            wget https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_listener.py

    .. group-tab:: Windows

        In a Windows command line prompt:

        .. code-block:: console

            curl -sk https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_listener.py -o turtle_tf2_listener.py

        Or in powershell:

        .. code-block:: console

            curl https://raw.githubusercontent.com/ros/geometry_tutorials/ros2/turtle_tf2_py/turtle_tf2_py/turtle_tf2_listener.py -o turtle_tf2_listener.py

Now open the file called ``turtle_tf2_listener.py`` using your preferred text editor.

.. code-block:: python

    import math

    from geometry_msgs.msg import Twist

    import rclpy
    from rclpy.executors import ExternalShutdownException
    from rclpy.node import Node

    from tf2_ros import TransformException
    from tf2_ros.buffer import Buffer
    from tf2_ros.transform_listener import TransformListener

    from turtlesim.srv import Spawn


    class FrameListener(Node):

        def __init__(self):
            super().__init__('turtle_tf2_frame_listener')

            # Declare and acquire `target_frame` parameter
            self.target_frame = self.declare_parameter(
              'target_frame', 'turtle1').get_parameter_value().string_value

            self.tf_buffer = Buffer()
            self.tf_listener = TransformListener(self.tf_buffer, self)

            # Create a client to spawn a turtle
            self.spawner = self.create_client(Spawn, 'spawn')
            # Boolean values to store the information
            # if the service for spawning turtle is available
            self.turtle_spawning_service_ready = False
            # if the turtle was successfully spawned
            self.turtle_spawned = False

            # Create turtle2 velocity publisher
            self.publisher = self.create_publisher(Twist, 'turtle2/cmd_vel', 1)

            # Call on_timer function every second
            self.timer = self.create_timer(1.0, self.on_timer)

        def on_timer(self):
            # Store frame names in variables that will be used to
            # compute transformations
            from_frame_rel = self.target_frame
            to_frame_rel = 'turtle2'

            if self.turtle_spawning_service_ready:
                if self.turtle_spawned:
                    # Look up for the transformation between target_frame and turtle2 frames
                    # and send velocity commands for turtle2 to reach target_frame
                    try:
                        t = self.tf_buffer.lookup_transform(
                            to_frame_rel,
                            from_frame_rel,
                            rclpy.time.Time())
                    except TransformException as ex:
                        self.get_logger().info(
                            f'Could not transform {to_frame_rel} to {from_frame_rel}: {ex}')
                        return

                    msg = Twist()
                    scale_rotation_rate = 1.0
                    msg.angular.z = scale_rotation_rate * math.atan2(
                        t.transform.translation.y,
                        t.transform.translation.x)

                    scale_forward_speed = 0.5
                    msg.linear.x = scale_forward_speed * math.sqrt(
                        t.transform.translation.x ** 2 +
                        t.transform.translation.y ** 2)

                    self.publisher.publish(msg)
                else:
                    if self.result.done():
                        self.get_logger().info(
                            f'Successfully spawned {self.result.result().name}')
                        self.turtle_spawned = True
                    else:
                        self.get_logger().info('Spawn is not finished')
            else:
                if self.spawner.service_is_ready():
                    # Initialize request with turtle name and coordinates
                    # Note that x, y and theta are defined as floats in turtlesim_msgs/srv/Spawn
                    request = Spawn.Request()
                    request.name = 'turtle2'
                    request.x = float(4)
                    request.y = float(2)
                    request.theta = float(0)
                    # Call request
                    self.result = self.spawner.call_async(request)
                    self.turtle_spawning_service_ready = True
                else:
                    # Check if the service is ready
                    self.get_logger().info('Service is not ready')


    def main():
        try:
            with rclpy.init():
                node = FrameListener()
                rclpy.spin(node)
        except (KeyboardInterrupt, ExternalShutdownException):
            pass

1.1 Examine the code
~~~~~~~~~~~~~~~~~~~~

To understand how the service behind spawning turtle works, please refer to :doc:`writing a simple service and client (Python) <../../Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client>` tutorial.

Now, let's take a look at the code that is relevant to get access to frame transformations.
The ``tf2_ros`` package provides an implementation of a ``TransformListener`` to help make the task of receiving transforms easier.

.. code-block:: python

    from tf2_ros.transform_listener import TransformListener

Here, we create a ``TransformListener`` object.
Once the listener is created, it starts receiving tf2 transformations over the wire, and buffers them for up to 10 seconds.

.. code-block:: python

    self.tf_listener = TransformListener(self.tf_buffer, self)

Finally, we query the listener for a specific transformation.
We call ``lookup_transform`` method with following arguments:

#. Target frame

#. Source frame

#. The time at which we want to transform

Providing ``rclpy.time.Time()`` will just get us the latest available transform.
All this is wrapped in a try-except block to handle possible exceptions.

.. code-block:: python

    t = self.tf_buffer.lookup_transform(
        to_frame_rel,
        from_frame_rel,
        rclpy.time.Time())

1.2 Add an entry point
~~~~~~~~~~~~~~~~~~~~~~

To allow the ``ros2 run`` command to run your node, you must add the entry point to ``setup.py`` (located in the ``src/learning_tf2_py`` directory).

Add the following line between the ``'console_scripts':`` brackets:

.. code-block:: python

    'turtle_tf2_listener = learning_tf2_py.turtle_tf2_listener:main',

2 Update the launch file
^^^^^^^^^^^^^^^^^^^^^^^^

Open the launch file called ``turtle_tf2_demo_launch.py`` in the ``src/learning_tf2_py/launch`` directory with your text editor, add two new nodes to the launch description, add a launch argument, and add the imports.
The resulting file should look like:

.. code-block:: python

    from launch import LaunchDescription
    from launch.actions import DeclareLaunchArgument
    from launch.substitutions import LaunchConfiguration

    from launch_ros.actions import Node


    def generate_launch_description():
        return LaunchDescription([
            Node(
                package='turtlesim',
                executable='turtlesim_node',
                name='sim'
            ),
            Node(
                package='learning_tf2_py',
                executable='turtle_tf2_broadcaster',
                name='broadcaster1',
                parameters=[
                    {'turtlename': 'turtle1'}
                ]
            ),
            DeclareLaunchArgument(
                'target_frame', default_value='turtle1',
                description='Target frame name.'
            ),
            Node(
                package='learning_tf2_py',
                executable='turtle_tf2_broadcaster',
                name='broadcaster2',
                parameters=[
                    {'turtlename': 'turtle2'}
                ]
            ),
            Node(
                package='learning_tf2_py',
                executable='turtle_tf2_listener',
                name='listener',
                parameters=[
                    {'target_frame': LaunchConfiguration('target_frame')}
                ]
            ),
        ])

This will declare a ``target_frame`` launch argument, start a broadcaster for second turtle that we will spawn and listener that will subscribe to those transformations.

3 Build
^^^^^^^

Run ``rosdep`` in the root of your workspace to check for missing dependencies.

.. tabs::

   .. group-tab:: Linux

      .. code-block:: console

          rosdep install -i --from-path src --rosdistro {DISTRO} -y

   .. group-tab:: macOS

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

   .. group-tab:: Windows

        rosdep only runs on Linux, so you will need to install ``geometry_msgs`` and ``turtlesim`` dependencies yourself

Still in the root of your workspace, build your package:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        colcon build --packages-select learning_tf2_py

  .. group-tab:: macOS

    .. code-block:: console

        colcon build --packages-select learning_tf2_py

  .. group-tab:: Windows

    .. code-block:: console

        colcon build --merge-install --packages-select learning_tf2_py

Open a new terminal, navigate to the root of your workspace, and source the setup files:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

        . install/setup.bash

  .. group-tab:: macOS

    .. code-block:: console

        . install/setup.bash

  .. group-tab:: Windows

    .. code-block:: console

        # CMD
        call install\setup.bat

        # Powershell
        .\install\setup.ps1

4 Run
^^^^^

Now you're ready to start your full turtle demo:

.. code-block:: console

    ros2 launch learning_tf2_py turtle_tf2_demo_launch.py

You should see the turtle sim with two turtles.
In the second terminal window type the following command:

.. code-block:: console

    ros2 run turtlesim turtle_teleop_key

To see if things work, simply drive around the first turtle using the arrow keys (make sure your terminal window is active, not your simulator window), and you'll see the second turtle following the first one!

Summary
-------

In this tutorial you learned how to use tf2 to get access to frame transformations.
You also have finished writing your own turtlesim demo that you first tried in :doc:`Introduction to tf2 <./Introduction-To-Tf2>` tutorial.
",What is the purpose of creating a tf2 listener in Python according to the provided text?
"RViz
====

RViz is a 3D visualizer for the Robot Operating System (ROS) framework.

.. contents:: Contents
   :depth: 0
   :local:

.. toctree::
   :maxdepth: 1

   RViz-User-Guide/RViz-User-Guide
   RViz-Custom-Display/RViz-Custom-Display
   Marker-Display-types/Marker-Display-types
",What is RViz and what framework is it designed for?
"RViz User Guide
===============

**Goal:** Understanding RViz

**Tutorial level:** Intermediate

**Time:** 25 Minutes

.. contents:: Contents
   :depth: 2
   :local:


Background
----------
RViz is a 3D visualizer for the Robot Operating System (ROS) framework.

Install or build rviz
---------------------
Follow the :doc:`installation instructions <../../../../Installation>` for your operating system to install RViz.

Startup
-------
Don't forget to source the setup file.

.. code-block:: bash

   source /opt/ros/{DISTRO}/setup.bash

Then start the visualizer

.. code-block:: bash

   ros2 run rviz2 rviz2

When RViz starts for the first time, you will see this window:

.. image:: images/initial_startup.png

The big black window in the middle is the 3D view (empty because there is nothing to see).
On the left is the Displays list, which will show any displays you have loaded.
Right now it just contains the global options and a Grid, which we'll get to later.
On the right are some of the other panels, described below.

Displays
--------
A display is something that draws something in the 3D world, and likely has some options available in the displays list.
An example is a point cloud, the robot state, etc.

Adding a new display
^^^^^^^^^^^^^^^^^^^^
To add a display, click the Add button at the bottom:

.. image:: images/add-button.png

This will pop up the new display dialog:

.. image:: images/add-display-dialog.png

The list at the top contains the display type.
The type details what kind of data this display will visualize.
The text box in the middle gives a description of the selected display type.
Finally, you must give the display a unique name.
If you have, for example, two laser scanners on your robot, you might create two ``Laser Scan`` displays named ""Laser Base"" and ""Laser Head"".

Display Properties
^^^^^^^^^^^^^^^^^^
Each display gets its own list of properties.
For example:

.. image:: images/display-properties.png

Display Status
^^^^^^^^^^^^^^
Each display gets its own status to help let you know if everything is OK or not.
The status can be one of: ``OK``, ``Warning``, ``Error``, or ``Disabled``.
The status is indicated in the display's title by the background color,
as well as in the Status category that you can see if the display is expanded:

.. image:: images/display-status.png

The ``Status`` category also expands to show specific status information.
This information is different for different displays, and the messages should be self explanatory.

Built-in Display Types
^^^^^^^^^^^^^^^^^^^^^^
.. list-table::
   :header-rows: 1
   :widths: 10 10 10

   * - Name
     - Description
     - Messages Used
   * - Axes
     - Displays a set of Axes
     -
   * - Effort
     - Shows the effort being put into each revolute joint of a robot
     - `sensor_msgs/msg/JointStates <https://github.com/ros2/common_interfaces/blob/{DISTRO}/sensor_msgs/msg/JointState.msg>`__
   * - Camera
     - Creates a new rendering window from the perspective of a camera, and overlays the image on top of it.
     - `sensor_msgs/msg/Image <https://github.com/ros2/common_interfaces/blob/{DISTRO}/sensor_msgs/msg/Image.msg>`__, `sensor_msgs/msg/CameraInfo <https://github.com/ros2/common_interfaces/blob/{DISTRO}/sensor_msgs/msg/CameraInfo.msg>`__
   * - Grid
     - Displays a 2D or 3D grid along a plane
     -
   * - Grid Cells
     - Draws cells from a grid, usually obstacles from a costmap from the `navigation <https://github.com/ros-planning/navigation2>`__ stack.
     - `nav_msgs/msg/GridCells <https://github.com/ros2/common_interfaces/blob/{DISTRO}/nav_msgs/msg/GridCells.msg>`__
   * - Image
     - Creates a new rendering window with an Image. Unlike the Camera display, this display does not use a CameraInfo
     - `sensor_msgs/msg/Image <https://github.com/ros2/common_interfaces/blob/{DISTRO}/sensor_msgs/msg/Image.msg>`__
   * - InteractiveMarker
     - Displays 3D objects from one or multiple Interactive Marker servers and allows mouse interaction with them
     - `visualization_msgs/msg/InteractiveMarker <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/InteractiveMarker.msg>`__
   * - Laser Scan
     - Shows data from a laser scan, with different options for rendering modes, accumulation, etc.
     - `sensor_msgs/msg/LaserScan <https://github.com/ros2/common_interfaces/blob/{DISTRO}/sensor_msgs/msg/LaserScan.msg>`__
   * - Map
     - Displays a map on the ground plane.
     - `nav_msgs/msg/OccupancyGrid <https://github.com/ros2/common_interfaces/blob/{DISTRO}/nav_msgs/msg/OccupancyGrid.msg>`__
   * - Markers
     - Allows programmers to display arbitrary primitive shapes through a topic
     - `visualization_msgs/msg/Marker <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/Marker.msg>`__, `visualization_msgs/msg/MarkerArray <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/MarkerArray.msg>`__
   * - Path
     - Shows a path from the `navigation <https://github.com/ros-planning/navigation2>`__ stack.
     - `nav_msgs/msg/Path <https://github.com/ros2/common_interfaces/blob/{DISTRO}/nav_msgs/msg/Path.msg>`__
   * - Point
     - Draws a point as a small sphere.
     - `geometry_msgs/msg/PointStamped <https://github.com/ros2/common_interfaces/blob/{DISTRO}/geometry_msgs/msg/PointStamped.msg>`__
   * - Pose
     - Draws a pose as either an arrow or axes.
     - `geometry_msgs/msg/PoseStamped <https://github.com/ros2/common_interfaces/blob/{DISTRO}/geometry_msgs/msg/PoseStamped.msg>`__
   * - Pose Array
     - Draws a ""cloud"" of arrows, one for each pose in a pose array
     - `geometry_msgs/msg/PoseArray <https://github.com/ros2/common_interfaces/blob/{DISTRO}/geometry_msgs/msg/PoseArray.msg>`__
   * - Point Cloud(2)
     - Shows data from a point cloud, with different options for rendering modes, accumulation, etc.
     - `sensor_msgs/msg/PointCloud <https://github.com/ros2/common_interfaces/blob/{DISTRO}/sensor_msgs/msg/PointCloud.msg>`__, `sensor_msgs/msg/PointCloud2 <https://github.com/ros2/common_interfaces/blob/{DISTRO}/sensor_msgs/msg/PointCloud2.msg>`__
   * - Polygon
     - Draws the outline of a polygon as lines.
     - `geometry_msgs/msg/Polygon <https://github.com/ros2/common_interfaces/blob/{DISTRO}/geometry_msgs/msg/Polygon.msg>`__
   * - Odometry
     - Accumulates odometry poses from over time.
     - `nav_msgs/msg/Odometry <https://github.com/ros2/common_interfaces/blob/{DISTRO}/nav_msgs/msg/Odometry.msg>`__
   * - Range
     - Displays cones representing range measurements from sonar or IR range sensors. Version: Electric+
     - `sensor_msgs/msg/Range <https://github.com/ros2/common_interfaces/blob/{DISTRO}/sensor_msgs/msg/Range.msg>`__
   * - RobotModel
     - Shows a visual representation of a robot in the correct pose (as defined by the current TF transforms).
     -
   * - TF
     - Displays the `tf2 <https://github.com/ros2/geometry2>`__ transform hierarchy.
     -
   * - Wrench
     - Draws a wrench as arrow (force) and arrow + circle (torque)
     - `geometry_msgs/msg/WrenchStamped <https://github.com/ros2/common_interfaces/blob/{DISTRO}/geometry_msgs/msg/WrenchStamped.msg>`__
   * - Twist
     - Draws a twist as arrow (linear) and arrow + circle (angular)
     - `geometry_msgs/msg/TwistStamped <https://github.com/ros2/common_interfaces/blob/{DISTRO}/geometry_msgs/msg/TwistStamped.msg>`__

Configurations
--------------
Different configurations of displays are often useful for different uses of the visualizer.
A configuration useful for a full PR2 is not necessarily useful for a test cart, for example.
To this end, the visualizer lets you load and save different configurations.

A configuration contains:

* Displays + their properties
* Tool properties
* The viewpoint and settings for the 3D visualzation

Views Panel
-----------
There are a number of different camera types available in the visualizer.

.. image:: images/camera-types.png

Camera types consist both of different ways of controlling the camera and different types of projection (Orthographic vs. Perspective).

Orbital Camera (default)
^^^^^^^^^^^^^^^^^^^^^^^^
The orbital camera simply rotates around a focal point, while always looking at that point.
The focal point is visualized as a small disc while you're moving the camera:

.. image:: images/focal-point.png

Controls:

* **Left mouse button**: Click and drag to rotate around the focal point.
* **Middle mouse button**: Click and drag to move the focal point in the plane formed by the camera's up and right vectors. The distance moved depends on the focal point -- if there is an object on the focal point, and you click on top of it, it will stay under your mouse.
* **Right mouse button**: Click and drag to zoom in/out of the focal point. Dragging up zooms in, down zooms out.
* **Scrollwheel**: Zoom in/out of the focal point

FPS (first-person) Camera
^^^^^^^^^^^^^^^^^^^^^^^^^
The FPS camera is a first-person camera, so it rotates as if you're looking with your head.

Controls:

* **Left mouse button**: Click and drag to rotate. Control-click to pick the object under the mouse and look directly at it.
* **Middle mouse button**: Click and drag to move along the plane formed by the camera's up and right vectors.
* **Right mouse button**: Click and drag to move along the camera's forward vector. Dragging up moves forward, down moves backward.
* **Scrollwheel**: Move forward/backward.

Top-down Orthographic
^^^^^^^^^^^^^^^^^^^^^
The top-down orthographic camera always looks down along the Z axis (in the robot frame),
and is an orthographic view which means things do not get smaller as they get farther away.

Controls:

* **Left mouse button**: Click and drag to rotate around the Z axis.
* **Middle mouse button**: Click and drag to move the camera along the XY plane.
* **Right mouse button**: Click and drag to zoom the image.
* **Scrollwheel**: Zoom the image.

XY Orbit
^^^^^^^^
Same as the orbital camera, with the focus point restricted to the XY plane.

Controls:

See orbital camera.

Third Person Follower
^^^^^^^^^^^^^^^^^^^^^
The camera maintains a constant viewing angle towards the target frame.
In contrast to XY Orbit the camera turns if the target frame yaws.
This could be handy if you are doing 3D mapping of a hallway with corners for example.

Controls:

See orbital camera.


Custom Views
^^^^^^^^^^^^
The views panel also lets you create different named views, which are saved and can be switched between.
A view consists of a target frame, camera type and camera pose.
You can save a view by clicking the Save button of the views panel.

.. image:: images/views.png

A view consists of:

* View controller type
* View configuration (position, orientation, etc; possibly different for each view controller type.)
* The Target Frame

Views are saved per user, not in the config files.

Coordinate Frames
-----------------
RViz uses the tf transform system for transforming data from the coordinate frame it arrives in into a global reference frame.
There are two coordinate frames that are important to know about in the visualizer, the target frame and the fixed frame.

The Fixed Frame
^^^^^^^^^^^^^^^
The more-important of the two frames is the fixed frame.
The fixed frame is the reference frame used to denote the ``world`` frame.
This is usually the ``map``, or ``world``, or something similar, but can also be, for example, your odometry frame.

If the fixed frame is erroneously set to, say, the base of the robot, then all the objects the robot has ever seen will appear in front of the robot, at the position relative to the robot at which they were detected.
For correct results, the fixed frame should not be moving relative to the world.

If you change the fixed frame, all data currently being shown is cleared rather than re-transformed.

The Target Frame
^^^^^^^^^^^^^^^^
The target frame is the reference frame for the camera view.
For example, if your target frame is the map, you'll see the robot driving around the map.
If your target frame is the base of the robot, the robot will stay in the same place while everything else moves relative to it.

Tools
-----
The visualizer has a number of tools you can use on the toolbar.
The following sections will give a short introduction into these tools.
You can find some more information under Help -> Show Help panel.

.. image:: images/tool.png

Interact
^^^^^^^^
This tool lets you interact with the visualized environment.
You can click on objects and depending on their properties simply select them, move them around and much more.

Keyboard shortcut: ``i``

Move Camera
^^^^^^^^^^^
The Move Camera tool is the default tool.
When this is selected and you click inside the 3D view, the viewpoint changes according to the options and camera type you have selected in the ``Views`` panel. See the previous section ``Views Panel`` for more information.

Keyboard shortcut: ``m``

Select
^^^^^^
The Select tool allows you to select items being displayed in the 3D view.
It supports single-point selection as well as click/drag box selection.
You can add to a selection with the Shift key, and remove from the selection with the Ctrl key.
If you want to move the camera around while selecting without switching back to the Move Camera tool you can hold down the Alt key.
The ``f`` key will focus the camera on the current selection.

.. image:: images/selection_highlight.png

.. image:: images/selection_selected.png

Keyboard shortcut: ``s``

Focus Camera
^^^^^^^^^^^^
Focus camera lets you select a location in the visualizer.
The camera will then focus that point by changing its orientation but not its position.

Keyboard shortcut: ``c``

Measure
^^^^^^^
With the measure tool you can measure the distance between to points in the visualizer.
The first click after activating the tool will set the starting point and the second one the end point of the measurement.
The resulting distance will be displayed at the bottom of the RViz window.
But notice that the measurement tool only works with actually rendered objects in the visualizer, you can not use it in empty space.

.. image:: images/measure.png

Keyboard shortcut: ``n``

2D Pose Estimate
^^^^^^^^^^^^^^^^
This tool lets you set an initial pose to seed the localization system (sent on the ``initialpose`` ROS topic).
Click on a location on the ground plane and drag to select the orientation.
The output topic can be changed in the ``Tool Properties`` panel.

.. image:: images/set_pose.png

This tool works with the `navigation <https://github.com/ros-planning/navigation2>`__ stack.

Keyboard shortcut: ``p``

2D Nav Goal
^^^^^^^^^^^
This tool lets you set a goal sent on the ``goal_pose`` ROS topic.
Click on a location on the ground plane and drag to select the orientation.
The output topic can be changed in the ``Tool Properties`` panel.

This tool works with the `navigation <https://github.com/ros-planning/navigation2>`__ stack.

Keyboard shortcut: ``g``

Publish Point
^^^^^^^^^^^^^
The publish point tool lets you select an object in the visualizer
and the tool will publish the coordinates of that point based on the frame.
The results are shown at the bottom like with the measure tool but are also published on the ``clicked_point`` topic.

Keyboard shortcut: ``u``

Time
----
The Time panel is mostly useful when running in a simulator, since it allows you to see how much ROS Time has passed, vs. how much ``Wall Clock`` (aka real) time has passed.
The time panel also lets you reset the visualizer's internal time state, which resets of all the displays as well as tf's internal cache of data.

.. image:: images/time.png

If you are not running in simulation, the time panel is mostly useless.
In most cases it can be closed and you will probably not even notice (other than having a bit more screen real estate for the rest of rviz).
","What is the purpose of the ""Fixed Frame"" in RViz and why is it important to set it correctly?"
"Building a Custom RViz Display
==============================

Background
----------
There are many types of data that have existing visualizations in RViz. However, if there is a message type that does
not yet have a plugin to display it, there are two choices to see it in RViz.

 1. Convert the message to another type, such as ``visualization_msgs/Marker``.
 2. Write a Custom RViz Display.

With the first option, there is more network traffic and limitations to how the data can be represented. It is also quick and flexible.
The latter option is explained in this tutorial. It takes a bit of work, but can lead to much richer visualizations.

All of the code for this tutorial can be found in `this repository <https://github.com/MetroRobots/rviz_plugin_tutorial>`__.
In order to see the incremental progress of the plugin written in this tutorial,
the repository has different branches (``step2``, ``step3``...) that can each be compiled and run as you go.


Point2D Message
---------------

We'll be playing with a toy message defined in the ``rviz_plugin_tutorial_msgs`` package: ``Point2D.msg``:

.. code-block::

   std_msgs/Header header
   float64 x
   float64 y

Boilerplate for Basic Plugin
----------------------------

Strap in, there's a lot of code.
You can view the full version of this code with the branch name ``step1``.

Header File
^^^^^^^^^^^

Here are the contents of ``point_display.hpp``

.. code-block:: c++

   #ifndef RVIZ_PLUGIN_TUTORIAL__POINT_DISPLAY_HPP_
   #define RVIZ_PLUGIN_TUTORIAL__POINT_DISPLAY_HPP_

   #include <rviz_common/message_filter_display.hpp>
   #include <rviz_plugin_tutorial_msgs/msg/point2_d.hpp>

   namespace rviz_plugin_tutorial
   {
   class PointDisplay
     : public rviz_common::MessageFilterDisplay<rviz_plugin_tutorial_msgs::msg::Point2D>
   {
     Q_OBJECT

   protected:
     void processMessage(const rviz_plugin_tutorial_msgs::msg::Point2D::ConstSharedPtr msg) override;
   };
   }  // namespace rviz_plugin_tutorial

   #endif  // RVIZ_PLUGIN_TUTORIAL__POINT_DISPLAY_HPP_

* We're implementing the `MessageFilterDisplay <https://github.com/ros2/rviz/blob/0ef2b56373b98b5536f0f817c11dc2b5549f391d/rviz_common/include/rviz_common/message_filter_display.hpp#L43>`__ class which can be used with any message with a ``std_msgs/Header``.
* The class is templated with our ``Point2D`` message type.
* `For reasons outside the scope of this tutorial <https://doc.qt.io/qt-5/moc.html>`__, you need the ``Q_OBJECT`` macro in there to get the QT parts of the GUI to work.
* ``processMessage`` is the only method that needs to be implemented, which we'll do in the cpp file.

Source File
^^^^^^^^^^^

``point_display.cpp``

.. code-block:: c++

   #include <rviz_plugin_tutorial/point_display.hpp>
   #include <rviz_common/logging.hpp>

   namespace rviz_plugin_tutorial
   {
   void PointDisplay::processMessage(const rviz_plugin_tutorial_msgs::msg::Point2D::ConstSharedPtr msg)
   {
     RVIZ_COMMON_LOG_INFO_STREAM(""We got a message with frame "" << msg->header.frame_id);
   }
   }  // namespace rviz_plugin_tutorial

   #include <pluginlib/class_list_macros.hpp>
   PLUGINLIB_EXPORT_CLASS(rviz_plugin_tutorial::PointDisplay, rviz_common::Display)


* The logging is not strictly necessary, but helps with debugging.
* In order for RViz to find our plugin, we need this ``PLUGINLIB`` invocation in our code (as well as other things below).

package.xml
^^^^^^^^^^^

We need the following three dependencies in our package.xml:

.. code-block:: xml

     <depend>pluginlib</depend>
     <depend>rviz_common</depend>
     <depend>rviz_plugin_tutorial_msgs</depend>

rviz_common_plugins.xml
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: xml

   <library path=""point_display"">
     <class type=""rviz_plugin_tutorial::PointDisplay"" base_class_type=""rviz_common::Display"">
       <description></description>
     </class>
   </library>


* This is standard ``pluginlib`` code.

  * The library ``path`` is the name of the library we'll assign in the CMake.
  * The class should match the ``PLUGINLIB`` invocation from above.

* We'll come back to the description later, I promise.

CMakeLists.txt
^^^^^^^^^^^^^^

Add the following lines to the top of the standard boilerplate.

.. code-block:: cmake

   find_package(ament_cmake_ros REQUIRED)
   find_package(pluginlib REQUIRED)
   find_package(rviz_common REQUIRED)
   find_package(rviz_plugin_tutorial_msgs REQUIRED)

   set(CMAKE_AUTOMOC ON)
   qt5_wrap_cpp(MOC_FILES
     include/rviz_plugin_tutorial/point_display.hpp
   )

   add_library(point_display src/point_display.cpp ${MOC_FILES})
   target_include_directories(point_display PUBLIC
     $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
     $<INSTALL_INTERFACE:include>
   )
   ament_target_dependencies(point_display
     pluginlib
     rviz_common
     rviz_plugin_tutorial_msgs
   )
   install(TARGETS point_display
           EXPORT export_rviz_plugin_tutorial
           ARCHIVE DESTINATION lib
           LIBRARY DESTINATION lib
           RUNTIME DESTINATION bin
   )
   install(DIRECTORY include/
           DESTINATION include
   )
   install(FILES rviz_common_plugins.xml
           DESTINATION share/${PROJECT_NAME}
   )
   ament_export_include_directories(include)
   ament_export_targets(export_rviz_plugin_tutorial)
   pluginlib_export_plugin_description_file(rviz_common rviz_common_plugins.xml)


* To generate the proper Qt files, we need to

  * Turn ``CMAKE_AUTOMOC`` on.
  * Wrap the headers by calling ``qt5_wrap_cpp`` with each header that has ``Q_OBJECT`` in it.
  * Include the ``MOC_FILES`` in the library alongside our other cpp files.

* Note that if you do NOT wrap your header files, you may get an error message when attempting to load the plugin at runtime, along the lines of:

  .. code-block::

     [rviz2]: PluginlibFactory: The plugin for class 'rviz_plugin_tutorial::PointDisplay' failed to load. Error: Failed to load library /home/ros/ros2_ws/install/rviz_plugin_tutorial/lib/libpoint_display.so. Make sure that you are calling the PLUGINLIB_EXPORT_CLASS macro in the library code, and that names are consistent between this macro and your XML. Error string: Could not load library LoadLibrary error: /home/ros/ros2_ws/install/rviz_plugin_tutorial/lib/libpoint_display.so: undefined symbol: _ZTVN20rviz_plugin_tutorial12PointDisplayE, at /tmp/binarydeb/ros-foxy-rcutils-1.1.4/src/shared_library.c:84

* A lot of the other code ensures that the plugin portion works.
  Namely, calling ``pluginlib_export_plugin_description_file`` is essential to getting RViz to find your new plugin.

Testing it out
^^^^^^^^^^^^^^

Compile your code and run ``rviz2``.
You should be able to add your new plugin by clicking ``Add`` in the bottom left, and then selecting your package/plugin.


.. image:: images/Step1A.png
   :target: images/Step1A.png
   :alt: screenshot of adding display


Initially, the display will be in an error state because you have yet to assign a topic.

.. image:: images/Step1B.png
   :target: images/Step1B.png
   :alt: screenshot of error state


If we put the topic ``/point`` in, it should load fine but not display anything.

.. image:: images/Step1C.png
   :target: images/Step1C.png
   :alt: screenshot of functioning empty display


You can publish messages with the following command:

.. code-block:: bash

   ros2 topic pub /point rviz_plugin_tutorial_msgs/msg/Point2D ""{header: {frame_id: map}, x: 1, y: 2}"" -r 0.5

That should result in the ""We got a message"" logging to appear in the ``stdout`` of RViz.

Actual Visualization
--------------------

You can view the full version of this step with the branch name ``step2``.

First, you need to add a dependency in ``CMakeLists.txt`` and ``package.xml`` on the package ``rviz_rendering``.

We need to add three lines to the header file:


* ``#include <rviz_rendering/objects/shape.hpp>`` - There's `lots of options in the rviz_rendering package <https://github.com/ros2/rviz/tree/ros2/rviz_rendering/include/rviz_rendering/objects>`_ for objects to build your visualization on. Here we're using a simple shape.
* In the class, we'll add a new ``protected`` virtual method: ``void onInitialize() override;``
* We also add a pointer to our shape object: ``std::unique_ptr<rviz_rendering::Shape> point_shape_;``

Then in the cpp file, we define the ``onInitialize`` method:

.. code-block:: c++

   void PointDisplay::onInitialize()
   {
     MFDClass::onInitialize();
     point_shape_ =
       std::make_unique<rviz_rendering::Shape>(rviz_rendering::Shape::Type::Cube, scene_manager_,
         scene_node_);
   }


* ``MFDClass`` is `aliased <https://github.com/ros2/rviz/blob/0ef2b56373b98b5536f0f817c11dc2b5549f391d/rviz_common/include/rviz_common/message_filter_display.hpp#L57>`_ to the templated parent class for convenience.
* The shape object must be constructed here in the ``onInitialize`` method rather than the constructor because otherwise ``scene_manager_`` and ``scene_node_`` would not be ready.

We also update our ``processMessage`` method:

.. code-block:: c++

   void PointDisplay::processMessage(const rviz_plugin_tutorial_msgs::msg::Point2D::ConstSharedPtr msg)
   {
     RVIZ_COMMON_LOG_INFO_STREAM(""We got a message with frame "" << msg->header.frame_id);

     Ogre::Vector3 position;
     Ogre::Quaternion orientation;
     if (!context_->getFrameManager()->getTransform(msg->header, position, orientation)) {
       RVIZ_COMMON_LOG_DEBUG_STREAM(""Error transforming from frame '"" << msg->header.frame_id <<
           ""' to frame '"" << qPrintable(fixed_frame_) << ""'"");
     }

     scene_node_->setPosition(position);
     scene_node_->setOrientation(orientation);

     Ogre::Vector3 point_pos;
     point_pos.x = msg->x;
     point_pos.y = msg->y;
     point_shape_->setPosition(point_pos);
   }


* We need to get the proper frame for our message and transform the ``scene_node_`` accordingly.
  This ensures that the visualization does not always appear relative to the fixed frame.
* The actual visualization that we've been building up to is in the last four lines: we set the position of the visualization to match the message's position.

The result should look like this:

.. image:: images/Step2A.png
   :target: images/Step2A.png
   :alt: screenshot of functioning display


If the box does not appear in that location, it might be because:

* You are not publishing the topic at this time
* The message hasn't been published in the last 2 seconds.
* You did not properly set the topic in RViz.

It's Nice to Have Options.
--------------------------

If you want to allow users to customize different properties of the visualization, you need to add `rviz_common::Property objects <https://github.com/ros2/rviz/tree/ros2/rviz_common/include/rviz_common/properties>`_.

You can view the full version of this step with the branch name ``step3``.

Header Updates
^^^^^^^^^^^^^^



Include the header file for color properties: ``#include <rviz_common/properties/color_property.hpp>``.
Color is but one of many properties you can set.

Add in the prototype for ``updateStyle``, which is called whenever the GUI is changed via Qt's SIGNAL/SLOT framework:

.. code-block:: c++

  private Q_SLOTS:
    void updateStyle();

Add in a new property to store the property itself: ``std::unique_ptr<rviz_common::properties::ColorProperty> color_property_;``

Cpp Updates
^^^^^^^^^^^


* ``#include <rviz_common/properties/parse_color.hpp>`` - Contains helper function to convert property to OGRE color.
* To our ``onInitialize`` we add

.. code-block:: c++

    color_property_ = std::make_unique<rviz_common::properties::ColorProperty>(
        ""Point Color"", QColor(36, 64, 142), ""Color to draw the point."", this, SLOT(updateStyle()));
    updateStyle();


* This constructs the object with its name, default value, description and the callback.
* We call ``updateStyle`` directly so that the color is set at the beginning even before the property is changed.

* Then we define the callback.

.. code-block:: c++

    void PointDisplay::updateStyle()
    {
      Ogre::ColourValue color = rviz_common::properties::qtToOgre(color_property_->getColor());
      point_shape_->setColor(color);
    }

The result should look like this:

.. image:: images/Step3A.png
   :target: images/Step3A.png
   :alt: screenshot with color property


Ooh, pink!

.. image:: images/Step3B.png
   :target: images/Step3B.png
   :alt: screenshot with changed color


Status Report
-------------

You can view the full version of this step with the branch name ``step4``.

You can also set the status of the display.
As an arbitrary example, let's make our display show a warning when the x coordinate is negative, because why not?
In ``processMessage``:

.. code-block:: c++

     if (msg->x < 0) {
       setStatus(StatusProperty::Warn, ""Message"",
           ""I will complain about points with negative x values."");
     } else {
       setStatus(StatusProperty::Ok, ""Message"", ""OK"");
     }


* We're assuming a previous ``using rviz_common::properties::StatusProperty;`` declaration.
* Think of the status as Key/Value pairs, with the key being some string (here we're using ``""Message""``\ ) and the values are the status level (error/warn/ok) and the description (some other string).


.. image:: images/Step4A.png
   :target: images/Step4A.png
   :alt: screenshot with ok status



.. image:: images/Step4B.png
   :target: images/Step4B.png
   :alt: screenshot with warning status


Cleanup
-------

Now its time to clean it up a bit.
This makes things look nicer and be a little easier to use, but aren't strictly required.
You can view the full version of this step with the branch name ``step5``.

First, we update the plugin declaration.

.. code-block:: xml

   <library path=""point_display"">
     <class name=""Point2D"" type=""rviz_plugin_tutorial::PointDisplay"" base_class_type=""rviz_common::Display"">
       <description>Tutorial to display a point</description>
       <message_type>rviz_plugin_tutorial_msgs/msg/Point2D</message_type>
     </class>
   </library>


* We add the ``name`` field to the ``class`` tag.
  This changes the name that is displayed in RViz.
  In code, it makes sense to call it a ``PointDisplay`` but in RViz, we want to simplify.
* We put actual text into the description. Don't be lazy.
* By declaring the specific message type here, when you attempt to add a Display by Topic, it will suggest this plugin for the topics of that type.

We also add an icon for the plugin at ``icons/classes/Point2D.png``.
The folder is hardcoded, and the filename should match the name from the plugin declaration (or the name of the class if not specified). `[icon source] <https://commons.wikimedia.org/wiki/File:Free_software_icon.svg>`_

We need to install the image file in the CMake.

.. code-block:: cmake

   install(FILES icons/classes/Point2D.png
           DESTINATION share/${PROJECT_NAME}/icons/classes
   )

Now when you add the display, it should show up with an icon and description.


.. image:: images/Step5A.png
   :target: images/Step5A.png
   :alt: screenshot with added icon and description


Here is the display when attempting to add by topic:


.. image:: images/Step5B.png
   :target: images/Step5B.png
   :alt: screenshot with add by topic dialog


And finally, here's the icon in the standard interface:


.. image:: images/Step5C.png
   :target: images/Step5C.png
   :alt: screenshot with icon in standard interface


Note, if you change the plugins name, previous RViz configurations will no longer work.
",What is the purpose of the `Q_OBJECT` macro in the `point_display.hpp` file?
"Marker: Display types
=====================

**Goal:** This tutorial explains the basic Marker types and how to use them.

**Tutorial level:** Intermediate

**Time:** 15 Minutes

.. contents:: Contents
   :depth: 2
   :local:


Background
----------
The Markers display allows programmatic addition of various primitive shapes to the 3D view by sending a
`visualization_msgs/msg/Marker <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/Marker.msg>`_ or
`visualization_msgs/msg/MarkerArray <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/MarkerArray.msg>`_ message.

.. image:: images/marker_overview.png

..
    This is a comment, the next line will be added to the file once the Markers-Sending-Basic-Shapes-CPP is merged to point to the start of the tutorial series.
    The :doc:`Marker: Sending Basic Shapes <../Markers-Sending-Basic-Shapes-CPP/Markers-Sending-Basic-Shapes-CPP>` that tutorial begins a series of tutorials on sending markers.

The Marker Message
------------------
1 Example Usage (C++)
^^^^^^^^^^^^^^^^^^^^^
First we will create a simple publisher node that publishes ``Marker`` messages from the ``visualization_messages`` package to the ``visualization_marker`` topic:

.. code-block:: C++

    auto marker_pub = node->create_publisher<visualization_msgs::msg::Marker>(""visualization_marker"", 1);

After that it is as simple as filling out a `visualization_msgs/msg/Marker <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/Marker.msg>`_
message and publishing it:

.. code-block:: C++

    visualization_msgs::msg::Marker marker;

    marker.header.frame_id = ""/my_frame"";
    marker.header.stamp = rclcpp::Clock().now();

    marker.ns = ""basic_shapes"";
    marker.id = 0;

    marker.type = visualization_msgs::msg::Marker::SPHERE;

    marker.action = visualization_msgs::msg::Marker::ADD;

    marker.pose.position.x = 0;
    marker.pose.position.y = 0;
    marker.pose.position.z = 0;
    marker.pose.orientation.x = 0.0;
    marker.pose.orientation.y = 0.0;
    marker.pose.orientation.z = 0.0;
    marker.pose.orientation.w = 1.0;

    marker.scale.x = 1.0;
    marker.scale.y = 1.0;
    marker.scale.z = 1.0;

    marker.color.r = 0.0f;
    marker.color.g = 1.0f;
    marker.color.b = 0.0f;
    marker.color.a = 1.0;   // Don't forget to set the alpha!

    // only if using a MESH_RESOURCE marker type:
    marker.mesh_resource = ""package://pr2_description/meshes/base_v0/base.dae"";

    marker.lifetime = rclcpp::Duration::from_nanoseconds(0);

    marker_pub->publish(marker);

There is also a `visualization_msgs/msg/MarkerArray <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/MarkerArray.msg>`_ message, which lets you publish many markers at once.

2 Message Parameters
^^^^^^^^^^^^^^^^^^^^

The Marker message type is defined in `ROS 2 Common Interfaces <https://github.com/ros2/common_interfaces/tree/{DISTRO}/visualization_msgs/msg>`_ package.
The messages in this package include comments that are helpful in understanding each of the fields in the message.

* ``ns``:

    Namespace for these markers. This plus the id form a unique identifier.

* ``id``:

    Unique id assigned to this marker. It is your responsibility to keep these unique within your namespace.

* ``type``:

    Type of marker (Arrow, Sphere, ...). The available types are specified in the message definition.

* ``action``:

    0 = add/modify, 1 = (deprecated), 2 = delete, 3 = deleteall

* ``pose``:

    Pose marker, specified as x/y/z position and x/y/z/w quaternion orientation.

* ``scale``:

    Scale of the marker. Applied before the position/orientation. A scale of [1, 1, 1] means the object will be 1m by 1m by 1m.

* ``color``:

    Color of the object, specified as r/g/b/a, with values in the range of [0, 1]. The, ``a`` or alpha value, denotes the opacity of the marker with 1 indicating opaque and 0 indicating completely transparent. The default value is 0, or completely transparent. **You must set the a value of your marker to a non-zero value or it will be transparent by default!**

* ``points``:

    Only used for markers of type ``Points``, ``Line strips``, and ``Line`` / ``Cube`` / ``Sphere`` -lists.
    It's also used for the Arrow type, if you want to specify the arrow start and end points.
    This entry represents a list of ``geometry_msgs/Point`` types for the center or each marker object you would like rendered.

* ``colors``:

    This field is only used for markers that use the points member. This field specifies per-vertex color r/g/b/ color  (no alpha yet) for each entry in ``points``.

* ``lifetime``:

    A `duration message value <https://docs.ros.org/en/ros2_packages/{DISTRO}/api/builtin_interfaces/interfaces/msg/Duration.html>`_ used to automatically delete the marker after this period of time.
    The countdown resets if another marker of the same ``namespace`` / ``id`` is received.

* ``frame_locked``:

    Without the ``frame_locked`` parameter the marker will be placed based on the current transform and will stay there even if the given transform changes later.
    Setting this parameter tells RViz to retransform the marker to the new current location of the specified frame on every update cycle.

* ``text``:

    The text string used for the ``TEXT_VIEW_FACING`` marker type

* ``mesh_resource``:

    The resource location for the ``MESH_RESOURCE`` marker type. Can be any mesh type supported by RViz (``.stl`` or Ogre ``.mesh`` in 1.0, with the addition of COLLADA in 1.1).
    The format is the URI-form used by `resource_retriever <https://github.com/ros/resource_retriever/tree/{DISTRO}>`_, including the package:// syntax.

3 Object types
^^^^^^^^^^^^^^

.. _RVizMarkerObjectTypes:

3.1 Arrow (ARROW=0)
~~~~~~~~~~~~~~~~~~~

.. image:: images/ArrowMarker.png

The arrow type provides two different ways of specifying where the arrow should begin/end:

* ``Position/Orientation``:

    Pivot point is around the tip of its tail. Identity orientation points it along the +X axis. ``scale.x`` is the arrow length, ``scale.y`` is the arrow width and ``scale.z`` is the arrow height.

* ``Start/End Points``:

    You can also specify a start/end point for the arrow, using the points member. If you put points into the points member, it will assume you want to do things this way.

    * The point at index 0 is assumed to be the start point, and the point at index 1 is assumed to be the end.
    * ``scale.x`` is the shaft diameter, and ``scale.y`` is the head diameter. If ``scale.z`` is not zero, it specifies the head length.

3.2 Cube (CUBE=1)
~~~~~~~~~~~~~~~~~

.. image:: images/CubeMarker.png

Pivot point is at the center of the cube.

3.3 Sphere (SPHERE=2)
~~~~~~~~~~~~~~~~~~~~~

.. image:: images/SphereMarker.png

Pivot point is at the center of the sphere.

``scale.x`` is diameter in x direction, ``scale.y`` in y direction, ``scale.z`` in z direction.
By setting these to different values you get an ellipsoid instead of a sphere.

3.4 Cylinder (CYLINDER=3)
~~~~~~~~~~~~~~~~~~~~~~~~~

.. image:: images/CylinderMarker.png

Pivot point is at the center of the cylinder.

``scale.x`` is diameter in x direction, ``scale.y`` in y direction, by setting these to different values you get an ellipse instead of a circle.
Use ``scale.z`` to specify the height.

3.5 Line Strip (LINE_STRIP=4)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. image:: images/LineStripMarker.png

Line strips use the points member of the `visualization_msgs/msg/Marker <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/Marker.msg>`_ message.
It will draw a line between every two consecutive points, so 0-1, 1-2, 2-3, 3-4, 4-5...

Line strips also have some special handling for scale: only ``scale.x`` is used and it controls the width of the line segments.

Note that ``pose`` is still used (the points in the line will be transformed by them), and the lines will be correct relative to the ``frame id`` specified in the header.

3.6 Line List (LINE_LIST=5)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. image:: images/LineListMarker.png

Line lists use the points member of the `visualization_msgs/msg/Marker <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/Marker.msg>`_ message. It will draw a line between each pair of points, so 0-1, 2-3, 4-5, ...

Line lists also have some special handling for scale: only ``scale.x`` is used and it controls the width of the line segments.

Note that ``pose`` is still used (the points in the line will be transformed by them), and the lines will be correct relative to the ``frame id`` specified in the header.

3.7 Cube List (CUBE_LIST=6)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. image:: images/CubeListMarker.png

A cube list is a list of cubes with all the same properties except their positions.
Using this object type instead of a `visualization_msgs/msg/MarkerArray <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/MarkerArray.msg>`_ allows RViz to batch-up rendering,
which causes them to render much faster.
The caveat is that they all must have the same scale.

The ``points`` member of the `visualization_msgs/msg/Marker <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/Marker.msg>`_ message is used for the position of each cube.

3.8 Sphere List (SPHERE_LIST=7)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. image:: images/SphereListMarker.png

A sphere list is a list of spheres with all the same properties except their positions.
Using this object type instead of a `visualization_msgs/msg/MarkerArray <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/MarkerArray.msg>`_ allows RViz to batch-up rendering,
which causes them to render much faster.
The caveat is that they all must have the same scale.

The ``points`` member of the `visualization_msgs/msg/Marker <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/Marker.msg>`_ message is used for the position of each sphere.

Note that ``pose`` is still used (the ``points`` in the line will be transformed by them), and the lines will be correct relative to the ``frame id`` specified in the header.

3.9 Points (POINTS=8)
~~~~~~~~~~~~~~~~~~~~~

.. image:: images/PointsMarker.png

Uses the ``points`` member of the `visualization_msgs/msg/Marker <https://github.com/ros2/common_interfaces/blob/{DISTRO}/visualization_msgs/msg/Marker.msg>`_ message.

``Points`` have some special handling for scale: ``scale.x`` is point width, ``scale.y`` is point height

Note that ``pose`` is still used (the ``points`` in the line will be transformed by them), and the lines will be correct relative to the ``frame id`` specified in the header.

3.10 View-Oriented Text (TEXT_VIEW_FACING=9)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. image:: images/text_view_facing_marker.png

This marker displays text in a 3D spot in the world.
The text always appears oriented correctly for the RViZ user to see the included text. Uses the ``text`` field in the marker.

Only ``scale.z`` is used. ``scale.z`` specifies the height of an uppercase ""A"".

3.11 Mesh Resource (MESH_RESOURCE=10)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. image:: images/mesh_resource_marker.png

Uses the ``mesh_resource`` field in the marker.
Can be any mesh type supported by RViz (binary ``.stl`` or Ogre ``.mesh`` in 1.0, with the addition of COLLADA (``.dae``) in 1.1).
The format is the URI-form used by `resource_retriever <https://github.com/ros/resource_retriever/tree/{DISTRO}>`_, including the ``package://`` syntax.

An example of a mesh an its use is:

.. code-block:: C++

    marker.type = visualization_msgs::Marker::MESH_RESOURCE;
    marker.mesh_resource = ""package://pr2_description/meshes/base_v0/base.dae"";

Scale on a mesh is relative.
A scale of (1.0, 1.0, 1.0) means the mesh will display as the exact size specified in the mesh file.
A scale of (1.0, 1.0, 2.0) means the mesh will show up twice as tall, but the same width/depth.

If the ``mesh_use_embedded_materials`` flag is set to true and the mesh is of a type which supports embedded materials (such as COLLADA),
the material defined in that file will be used instead of the color defined in the marker.

Since version [1.8], even when ``mesh_use_embedded_materials`` is true,
if the marker ``color`` is set to anything other than ``r=0``, ``g=0``, ``b=0``, ``a=0`` the marker ``color`` and ``alpha`` will be used to tint the mesh with the embedded material.

3.12 Triangle List (TRIANGLE_LIST=11)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. image:: images/triangle_list_marker.png

Uses the points and optionally colors members.
Every set of 3 points is treated as a triangle, so indices 0-1-2, 3-4-5, etc.

Note that ``pose`` and ``scale`` are still used (the points in the line will be transformed by them),
and the lines will be correct relative to the ``frame id`` specified in the header.

4 Rendering Complexity Notes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
A single marker is always less expensive to render than many markers.
For example, a single cube list can handle thousands of cubes, where we will not be able to render thousands of individual cube markers.
",What type of object is represented by a Marker with the type `SPHERE` according to the text document provided?
".. redirect-from::

    Tutorials/Actions/Writing-a-Py-Action-Server-Client

.. _ActionsPy:

Writing an action server and client (Python)
============================================

**Goal:** Implement an action server and client in Python.

**Tutorial level:** Intermediate

**Time:** 15 minutes

.. contents:: Contents
   :depth: 2
   :local:

Background
----------

Actions are a form of asynchronous communication in ROS 2.
*Action clients* send goal requests to *action servers*.
*Action servers* send goal feedback and results to *action clients*.

Prerequisites
-------------

You will need the ``custom_action_interfaces`` package and the ``Fibonacci.action``
interface defined in the previous tutorial, :doc:`../Creating-an-Action`.

Tasks
-----

1 Writing an action server
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's focus on writing an action server that computes the Fibonacci sequence
using the action we created in the :doc:`../Creating-an-Action` tutorial.

Until now, you've created packages and used ``ros2 run`` to run your nodes.
To keep things simple in this tutorial, however, we’ll scope the action server to a single file.
If you'd like to see what a complete package for the actions tutorials looks like, check out
`action_tutorials <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/action_tutorials>`__.

Open a new file in your home directory, let's call it ``fibonacci_action_server.py``,
and add the following code:

.. literalinclude:: scripts/server_0.py
    :language: python

Line 8 defines a class ``FibonacciActionServer`` that is a subclass of ``Node``.
The class is initialized by calling the ``Node`` constructor, naming our node ``fibonacci_action_server``:

.. literalinclude:: scripts/server_0.py
    :language: python
    :lines: 12

In the constructor we also instantiate a new action server:

.. literalinclude:: scripts/server_0.py
    :language: python
    :lines: 13-17

An action server requires four arguments:

1. A ROS 2 node to add the action client to: ``self``.
2. The type of the action: ``Fibonacci`` (imported in line 5).
3. The action name: ``'fibonacci'``.
4. A callback function for executing accepted goals: ``self.execute_callback``.
   This callback **must** return a result message for the action type.

We also define an ``execute_callback`` method in our class:

.. literalinclude:: scripts/server_0.py
    :language: python
    :lines: 19-22

This is the method that will be called to execute a goal once it is accepted.

Let's try running our action server:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      python3 fibonacci_action_server.py

  .. group-tab:: macOS

    .. code-block:: bash

      python3 fibonacci_action_server.py

  .. group-tab:: Windows

    .. code-block:: bash

      python fibonacci_action_server.py

In another terminal, we can use the command line interface to send a goal:

.. code-block:: bash

    ros2 action send_goal fibonacci custom_action_interfaces/action/Fibonacci ""{order: 5}""

In the terminal that is running the action server, you should see a logged message ""Executing goal..."" followed by a warning that the goal state was not set.
By default, if the goal handle state is not set in the execute callback it assumes the *aborted* state.

We can call ``succeed()`` on the goal handle to indicate that the goal was successful:

.. literalinclude:: scripts/server_1.py
    :language: python
    :lines: 19-23
    :emphasize-lines: 3

Now if you restart the action server and send another goal, you should see the goal finished with the status ``SUCCEEDED``.

Now let's make our goal execution actually compute and return the requested Fibonacci sequence:

.. literalinclude:: scripts/server_2.py
    :language: python
    :lines: 19-31
    :emphasize-lines: 4-7,12

After computing the sequence, we assign it to the result message field before returning.

Again, restart the action server and send another goal.
You should see the goal finish with the proper result sequence.

1.2 Publishing feedback
~~~~~~~~~~~~~~~~~~~~~~~

One of the nice things about actions is the ability to provide feedback to an action client during goal execution.
We can make our action server publish feedback for action clients by calling the goal handle's ``publish_feedback()`` method.

We'll replace the ``sequence`` variable, and use a feedback message to store the sequence instead.
After every update of the feedback message in the for-loop, we publish the feedback message and sleep for dramatic effect:

.. literalinclude:: scripts/server_3.py
    :language: python
    :emphasize-lines: 1,24,25,28-32,37

After restarting the action server, we can confirm that feedback is now published by using the command line tool with the ``--feedback`` option:

.. code-block:: bash

    ros2 action send_goal --feedback fibonacci custom_action_interfaces/action/Fibonacci ""{order: 5}""

2 Writing an action client
^^^^^^^^^^^^^^^^^^^^^^^^^^

We'll also scope the action client to a single file.
Open a new file, let's call it ``fibonacci_action_client.py``, and add the following boilerplate code:

.. literalinclude:: scripts/client_0.py
    :language: python

We've defined a class ``FibonacciActionClient`` that is a subclass of ``Node``.
The class is initialized by calling the ``Node`` constructor, naming our node ``fibonacci_action_client``:

.. literalinclude:: scripts/client_0.py
    :language: python
    :lines: 12

Also in the class constructor, we create an action client using the custom action definition from the previous tutorial on :doc:`../Creating-an-Action`:

.. literalinclude:: scripts/client_0.py
    :language: python
    :lines: 13

We create an ``ActionClient`` by passing it three arguments:

1. A ROS 2 node to add the action client to: ``self``
2. The type of the action: ``Fibonacci``
3. The action name: ``'fibonacci'``

Our action client will be able to communicate with action servers of the same action name and type.

We also define a method ``send_goal`` in the ``FibonacciActionClient`` class:

.. literalinclude:: scripts/client_0.py
    :language: python
    :lines: 15-21

This method waits for the action server to be available, then sends a goal to the server.
It returns a future that we can later wait on.

After the class definition, we define a function ``main()`` that initializes ROS 2
and creates an instance of our ``FibonacciActionClient`` node.
It then sends a goal and waits until that goal has been completed.

Finally, we call ``main()`` in the entry point of our Python program.

Let's test our action client by first running the action server built earlier:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      python3 fibonacci_action_server.py

  .. group-tab:: macOS

    .. code-block:: bash

      python3 fibonacci_action_server.py

  .. group-tab:: Windows

    .. code-block:: bash

      python fibonacci_action_server.py

In another terminal, run the action client:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      python3 fibonacci_action_client.py

  .. group-tab:: macOS

    .. code-block:: bash

      python3 fibonacci_action_client.py

  .. group-tab:: Windows

    .. code-block:: bash

      python fibonacci_action_client.py

You should see messages printed by the action server as it successfully executes the goal:

.. code-block:: bash

  [INFO] [fibonacci_action_server]: Executing goal...
  [INFO] [fibonacci_action_server]: Feedback: array('i', [0, 1, 1])
  [INFO] [fibonacci_action_server]: Feedback: array('i', [0, 1, 1, 2])
  [INFO] [fibonacci_action_server]: Feedback: array('i', [0, 1, 1, 2, 3])
  [INFO] [fibonacci_action_server]: Feedback: array('i', [0, 1, 1, 2, 3, 5])
  # etc.

The action client should start up, and then quickly finish.
At this point, we have a functioning action client, but we don't see any results or get any feedback.

2.1 Getting a result
~~~~~~~~~~~~~~~~~~~~

So we can send a goal, but how do we know when it is completed?
We can get the result information with a couple steps.
First, we need to get a goal handle for the goal we sent.
Then, we can use the goal handle to request the result.

Here's the complete code for this example:

.. literalinclude:: scripts/client_1.py
    :language: python

The ``ActionClient.send_goal_async()`` method returns a future to a goal handle.
First we register a callback for when the future is complete:

.. literalinclude:: scripts/client_1.py
    :language: python
    :lines: 23

Note that the future is completed when an action server accepts or rejects the goal request.
Let's look at the ``goal_response_callback`` in more detail.
We can check to see if the goal was rejected and return early since we know there will be no result:

.. literalinclude:: scripts/client_1.py
    :language: python
    :lines: 25-31

Now that we've got a goal handle, we can use it to request the result with the method ``get_result_async()``.
Similar to sending the goal, we will get a future that will complete when the result is ready.
Let's register a callback just like we did for the goal response:

.. literalinclude:: scripts/client_1.py
    :language: python
    :lines: 33-34

In the callback, we log the result sequence and shutdown ROS 2 for a clean exit:

.. literalinclude:: scripts/client_1.py
    :language: python
    :lines: 36-39

With an action server running in a separate terminal, go ahead and try running our Fibonacci action client!

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      python3 fibonacci_action_client.py

  .. group-tab:: macOS

    .. code-block:: bash

      python3 fibonacci_action_client.py

  .. group-tab:: Windows

    .. code-block:: bash

      python fibonacci_action_client.py

You should see logged messages for the goal being accepted and the final result.

2.2 Getting feedback
~~~~~~~~~~~~~~~~~~~~

Our action client can send goals.
Nice!
But it would be great if we could get some feedback about the goals we send from the action server.

Here's the complete code for this example:

.. literalinclude:: scripts/client_2.py
    :language: python

Here's the callback function for feedback messages:

.. literalinclude:: scripts/client_2.py
    :language: python
    :lines: 41-43

In the callback we get the feedback portion of the message and print the ``partial_sequence`` field to the screen.

We need to register the callback with the action client.
This is achieved by additionally passing the callback to the action client when we send a goal:

.. literalinclude:: scripts/client_2.py
    :language: python
    :lines: 21

We're all set. If we run our action client, you should see feedback being printed to the screen.

Summary
-------

In this tutorial, you put together a Python action server and action client line by line, and configured them to exchange goals, feedback, and results.

Related content
---------------

* There are several ways you could write an action server and client in Python; check out the ``minimal_action_server`` and ``minimal_action_client`` packages in the `ros2/examples <https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclpy/actions>`_ repo.

* For more detailed information about ROS actions, please refer to the `design article <http://design.ros2.org/articles/actions.html>`__.
","What is the goal of the tutorial ""Writing an action server and client (Python)""?"
".. TestingCpp:

Writing Basic Tests with C++ with GTest
=======================================

Starting point: we'll assume you have a :ref:`basic ament_cmake package<CreatePkg>` set up already and you want to add some tests to it.

In this tutorial, we'll be using `gtest <https://google.github.io/googletest/primer.html>`__.

Package Setup
-------------

Source Code
^^^^^^^^^^^
We'll start off with our code in a file called ``test/tutorial_test.cpp``

.. code-block:: c++

    #include <gtest/gtest.h>

    TEST(package_name, a_first_test)
    {
      ASSERT_EQ(4, 2 + 2);
    }

    int main(int argc, char ** argv)
    {
      testing::InitGoogleTest(&argc, argv);
      return RUN_ALL_TESTS();
    }


package.xml
^^^^^^^^^^^
Add the following line to ``package.xml``

.. code-block:: c++

    <test_depend>ament_cmake_gtest</test_depend>

CMakeLists.txt
^^^^^^^^^^^^^^

.. code-block:: cmake

    if(BUILD_TESTING)
      find_package(ament_cmake_gtest REQUIRED)
      ament_add_gtest(${PROJECT_NAME}_tutorial_test test/tutorial_test.cpp)
      target_include_directories(${PROJECT_NAME}_tutorial_test PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
      )
      target_link_libraries(${PROJECT_NAME}_tutorial_test name_of_local_library)
    endif()

The testing code is wrapped in the ``if/endif`` block to avoid building tests where possible. ``ament_add_gtest`` functions much like ``add_executable`` so you'll need to call ``target_include_directories``, ``ament_target_dependencies`` and ``target_link_libraries`` as you normally would.


Running Tests
-------------

See the :doc:`tutorial on how to run tests from the command line <CLI>` for more information on running the tests and inspecting the test results.
",What is the purpose of including the line `<test_depend>ament_cmake_gtest</test_depend>` in the `package.xml` file in CMake when setting up a C++ testing environment with GTest?
".. BuildFarmTesting:

Testing Your Code with the ROS Build Farm
=========================================

The `ROS 2 Build Farm <https://build.ros2.org/>`_ is incredibly powerful.
In addition to creating binaries, it will also test pull requests by compiling and running all the tests for your ROS packages before the PR is merged.

There are four prerequisites.

 * The GitHub user `@ros-pull-request-builder <https://github.com/ros-pull-request-builder>`_ must have access to the repository.
 * The GitHub repository must have the webhooks set up.
 * `Your package must be indexed in rosdistro </How-To-Guides/Releasing/Index-Your-Packages>`
 * The ``test_pull_requests`` flag must be true.


GitHub Access
-------------

You can give access to the PR Builder either at the GitHub organization level OR just to the single GitHub repository.

GitHub Organization
^^^^^^^^^^^^^^^^^^^

#. Open `https://github.com/orgs/%YOUR_ORG%/people <https://github.com/orgs/%YOUR_ORG%/people>`_
   (while replacing ``%YOUR_ORG%`` with the appropriate organization)
#. Click ``Invite Member`` and enter ``ros-pull-request-builder``


GitHub Repository
^^^^^^^^^^^^^^^^^

#. Open `https://github.com/%YOUR_ORG%/%YOUR_REPO%/settings/access <https://github.com/%YOUR_ORG%/%YOUR_REPO%/settings/access>`_
   (while replacing ``%YOUR_ORG%/%YOUR_REPO$`` with the appropriate organization/repo)
#. Click ``Add people`` and enter ``ros-pull-request-builder``
#. Select ``Admin`` or ``Write`` for their role. (see next section)


WebHooks
--------

If you grant full administrative rights to ``ros-pull-request-builder``, it will automatically setup the hooks.

Alternatively, you can avoid the need for full administrative rights by setting them up with only **write** permissions.

#. Open `https://github.com/%YOUR_ORG%/%YOUR_REPO%/settings/hooks/new <https://github.com/%YOUR_ORG%/%YOUR_REPO%/settings/hooks/new>`_)
#. Enter ``""https://build.ros2.org/ghprbhook/`` as the Payload URL
#. Check the following options:
    * Let me select individual events.
    * Issue comments
    * Pull requests


test_pull_requests
------------------

For each ROS distro that you want pull request testing for, you must enable the ``test_pull_requests`` flag in the appropriate section of the `rosdistro <https://github.com/ros/rosdistro/>`_.

 * **Option 1** - You have the option when running `bloom </How-To-Guides/Releasing/Releasing-a-Package>` to turn on pull request testing.
 * **Option 2** - You can **carefully** manually edit the appropriate file in the rosdistro repo, and make a new pull request.
   `Example <https://github.com/ros/rosdistro/blob/3c295f76b0755989e9ed526c0b5f28a5f6a94da3/rolling/distribution.yaml#L4708>`_.
   `Documented in REP 143 <http://docs.ros.org/en/independent/api/rep/html/rep-0143.html#distribution-file>`_.

Note that after the pull request has been added, the job will usually not be created until the nightly Jenkins reconfiguration.
",How can you enable pull request testing for your ROS packages using the ROS 2 Build Farm with the required prerequisites?
".. TestingPython:

Writing Basic Tests with Python
===============================

Starting point: we'll assume you have a :ref:`basic ament_python package<CreatePkg>` set up already and you want to add some tests to it.

If you are using ament_cmake_python, refer to the the :doc:`ament_cmake_python docs<../../../How-To-Guides/Ament-CMake-Python-Documentation>` for how to make tests dicoverable.
The test contents and invocation with ``colcon`` remain the same.

Package Setup
-------------

setup.py
^^^^^^^^

Your ``setup.py`` must have a test dependency on ``pytest`` within the call to ``setup(...)``:

.. code-block:: python

    tests_require=['pytest'],

Test Files and Folders
^^^^^^^^^^^^^^^^^^^^^^

Your test code needs to go in a folder named ``tests`` in the root of your package.

Any file that contains tests that you want to run must have the pattern ``test_FOO.py`` where ``FOO`` can be replaced with anything.

Example package layout:
""""""""""""""""""""""""""""""""""""""""""""""

.. code-block::

  awesome_ros_package/
    awesome_ros_package/
        __init__.py
        fozzie.py
    package.xml
    setup.cfg
    setup.py
    tests/
        test_init.py
        test_copyright.py
        test_fozzie.py


Test Contents
-------------

You can now write tests to your heart's content. There are `plenty of resources on pytest <https://docs.pytest.org>`__, but in short, you can write functions with the ``test_`` prefix and include whatever assert statements you'd like.


.. code-block:: python

  def test_math():
      assert 2 + 2 == 5   # This should fail for most mathematical systems

Running Tests
-------------

See the :doc:`tutorial on how to run tests from the command line <CLI>` for more information on running the tests and inspecting the test results.

Special Commands
----------------

Beyond the :doc:`standard colcon testing commands <CLI>` you can also specify arguments to the ``pytest`` framework from the command line with the ``--pytest-args`` flag.
For example, you can specify the name of the function to run with


.. code-block:: console

  colcon test --packages-select <name-of-pkg> --pytest-args -k name_of_the_test_function

To see the pytest output while running the tests, use these flags:

.. code-block:: console

  colcon test --event-handlers console_cohesion+
",What must your ``setup.py`` include in order to have a test dependency on ``pytest``?
".. _TestingMain:

Testing
=======

Why automatic tests?
--------------------

Here are some of the many good reasons why should we have automated tests:

* You can make incremental updates to your code more quickly. ROS has hundreds of packages with many interdependencies, so it can be hard to anticipate the problems a small change might cause. If your change passes the unit tests, you can be more confident that you haven't introduced problems — or at least the problems aren't your fault.
* You can refactor your code with greater confidence. Passing the unit tests verifies that you haven't introduced any bugs while refactoring. This gives you this wonderful freedom from change fear!
* It leads to better designed code. Unit tests force you to write your code so that it can be more easily tested. This often means keeping your underlying functions and framework separate, which is one of our design goals with ROS code.
* They prevent recurring bugs (bug regressions). It's a good practice to write a unit test for every bug you fix. In fact, write the unit test before you fix the bug. This will help you to precisely, or even deterministically, reproduce the bug, and much more precisely understand what the problem is. As a result, you will also create a better patch, which you can then test with your regression test to verify that the bug is fixed. That way the bug won't accidentally get reintroduced if the code gets modified later on. It also means that it will be easier to convince the reviewer of the patch that the problem is solved, and the contribution is of high quality.
* Other people can work on your code more easily (an automatic form of documentation). It can be hard to figure out whether or not you've broken someone else's code when you make a change. The unit tests are a tool for other developers to validate their changes. Automatic tests document your coding decisions, and communicate to other developers automatically about their violation. Thus tests become documentation for your code — a documentation that does not need to be read for the most time, and when it does need to be inspected the test system will precisely indicate what to read (which tests fail). By writing automatic tests you make other contributors faster. This improves the entire ROS project.
* It is much easier to become a contributor to ROS if we have automated unit tests. It is very difficult for new external developers to contribute to your components. When they make changes to code, they are often doing it in the blind, driven by a lot of guesswork. By providing a harness of automated tests, you help them in the task. They get immediate feedback for their changes. It becomes easier to contribute to a project, and new contributors to join more easily. Also their first contributions are of higher quality, which decreases the workload on maintainers. A win-win!
* Automatic tests simplify maintainership. Especially for mature packages, which change more slowly, and mostly need to be updated to new dependencies, an automatic test suite helps to very quickly establish whether the package still works. This makes it much easier to decide whether the package is still supported or not.
* Automatic tests amplify the value of Continuous Integration. Regression tests, along with normal scenario-based requirements tests, contribute to overall body of automated tests for your component. Your component is better tested against evolution of other APIs that it depends on (CI servers will tell you better and more precisely what problems develop in your code).

Perhaps the most important benefit of writing tests is that tests make you a good citizen.
Tests influence quality in the long term.
It is a well accepted practice in many open-source projects.
By writing regressions tests, you are contributing to long term quality of the ROS ecosystem.

Is this all coming for free?
----------------------------

Of course, there is never free lunch.
To get the benefits of testing, some investment is necessary.

* You need to develop a test, which sometimes may be difficult or costly. Sometimes it might also be nontrivial, as the test should be automatic. Things get particularly hairy if your tests should involve special hardware (they should not: try to use simulation, mock the hardware, or narrow down the test to a smaller software problem) or require external environment, for instance human operators.
* Regression tests and other automatic tests need to be maintained. When the design of the component changes, a lot of tests become invalidated (for instance they no longer compile, or throw runtime exceptions related to the API design). These tests fail not only because the redesign re-introduced bugs but also because they need to be updated to the new design. Occasionally, with bigger redesigns, old regression tests should be dropped.
* Large bodies of tests can take a long time to run, which can increase Continuous Integration server costs.

Available Tutorials:
--------------------

.. toctree::
   :maxdepth: 1

   CLI
   Cpp
   Python
   BuildFarmTesting
",What are some of the reasons highlighted in the text for having automated tests in the context of ROS?
".. TestingCLI:

Running Tests in ROS 2 from the Command Line
============================================

Build and run your tests
^^^^^^^^^^^^^^^^^^^^^^^^

To compile and run the tests, simply run the `test <https://colcon.readthedocs.io/en/released/reference/verb/test.html>`__ verb from ``colcon``.

.. code-block:: console

  colcon test --ctest-args tests [package_selection_args]

(where ``package_selection_args`` are optional package selection arguments for ``colcon`` to limit which packages are built and run)

:ref:`Sourcing the workspace <colcon-tutorial-source-the-environment>` before testing should not be necessary.
``colcon test`` makes sure that the tests run with the right environment, have access to their dependencies, etc.

Examine Test Results
^^^^^^^^^^^^^^^^^^^^

To see the results, simply run the `test-result <https://colcon.readthedocs.io/en/released/reference/verb/test-result.html>`__ verb from ``colcon``.

.. code-block:: console

  colcon test-result --all

To see the exact test cases which fail, use the ``--verbose`` flag:

.. code-block:: console

  colcon test-result --all --verbose

Debugging tests with GDB
^^^^^^^^^^^^^^^^^^^^^^^^

For detailed guidance on debugging tests using GDB, refer to the :doc:`GDB Tutorial <../../../How-To-Guides/Getting-Backtraces-in-ROS-2>`.
",What command should you run to see the exact test cases that fail with detailed information using `colcon` for ROS 2 testing?
".. redirect-from::

    Tutorials/Launch-Files/Launch-Main
    Tutorials/Launch/Launch-Main

.. _LaunchFilesMain:

Launch
======

ROS 2 Launch files allow you to start up and configure a number of executables containing ROS 2 nodes simultaneously.

.. toctree::
   :hidden:

   Creating-Launch-Files
   Launch-system
   Using-Substitutions
   Using-Event-Handlers
   Using-ROS2-Launch-For-Large-Projects

#. :doc:`Creating a launch file <./Creating-Launch-Files>`.

   Learn how to create a launch file that will start up nodes and their configurations all at once.

#. :doc:`Launching and monitoring multiple nodes <./Launch-system>`.

   Get a more advanced overview of how launch files work.

#. :doc:`Using substitutions <./Using-Substitutions>`.

   Use substitutions to provide more flexibility when describing reusable launch files.

#. :doc:`Using event handlers <./Using-Event-Handlers>`.

   Use event handlers to monitor the state of processes or to define a complex set of rules that can be used to dynamically modify the launch file.

#. :doc:`Managing large projects <./Using-ROS2-Launch-For-Large-Projects>`.

   Structure launch files for large projects so they may be reused as much as possible in different situations.
   See usage examples of different launch tools like parameters, YAML files, remappings, namespaces, default arguments, and RViz configs.

.. note::

   If you are coming from ROS 1, you can use the :doc:`ROS Launch Migration guide <../../../How-To-Guides/Migrating-from-ROS1/Migrating-Launch-Files>` to help you migrate your launch files to ROS 2.
",What guide can help you migrate your launch files from ROS 1 to ROS 2?
".. redirect-from::

    Tutorials/Launch-Files/Using-Substitutions
    Tutorials/Launch/Using-Substitutions

Using substitutions
===================

**Goal:** Learn about substitutions in ROS 2 launch files.

**Tutorial level:** Intermediate

**Time:** 15 minutes

.. contents:: Table of Contents
   :depth: 2
   :local:

Background
----------

Launch files are used to start nodes, services and execute processes.
This set of actions may have arguments, which affect their behavior.
Substitutions can be used in arguments to provide more flexibility when describing reusable launch files.
Substitutions are variables that are only evaluated during execution of the launch description and can be used to acquire specific information like a launch configuration, an environment variable, or to evaluate an arbitrary Python expression.

This tutorial shows usage examples of substitutions in ROS 2 launch files.

Prerequisites
-------------

This tutorial uses the :doc:`turtlesim <../../Beginner-CLI-Tools/Introducing-Turtlesim/Introducing-Turtlesim>` package.
This tutorial also assumes you are familiar with :doc:`creating packages <../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>`.

As always, don’t forget to source ROS 2 in :doc:`every new terminal you open <../../Beginner-CLI-Tools/Configuring-ROS2-Environment>`.

Using substitutions
-------------------

1 Create and setup the package
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First, create a new package with the name ``launch_tutorial``:

.. tabs::

  .. group-tab:: Python package

    Create a new package of build_type ``ament_python``:

    .. code-block:: console

      ros2 pkg create --build-type ament_python --license Apache-2.0 launch_tutorial

  .. group-tab:: C++ package

    Create a new package of build_type ``ament_cmake``:

    .. code-block:: console

      ros2 pkg create --build-type ament_cmake --license Apache-2.0 launch_tutorial

Inside of that package, create a directory called ``launch``:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      mkdir launch_tutorial/launch

  .. group-tab:: macOS

    .. code-block:: bash

      mkdir launch_tutorial/launch

  .. group-tab:: Windows

    .. code-block:: bash

      md launch_tutorial/launch

Finally, make sure to install the launch files:

.. tabs::

  .. group-tab:: Python package

    Add in following changes to the ``setup.py`` of the package:

    .. code-block:: python

      import os
      from glob import glob
      from setuptools import find_packages, setup

      package_name = 'launch_tutorial'

      setup(
          # Other parameters ...
          data_files=[
              # ... Other data files
              # Include all launch files.
              (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*launch.[pxy][yma]*')))
          ]
      )

  .. group-tab:: C++ package

    Append following code to the ``CMakeLists.txt`` just before ``ament_package()``:

    .. code-block:: cmake

      install(DIRECTORY
              launch
              DESTINATION share/${PROJECT_NAME}/
      )



2 Parent launch file
^^^^^^^^^^^^^^^^^^^^

Let's create a launch file that will call and pass arguments to another launch file.
This launch file can either be in Python, or in YAML.

To do this, create following file in the ``launch`` folder of the ``launch_tutorial`` package.

.. tabs::

  .. group-tab:: Python


    Copy and paste the complete code into the ``launch/example_main_launch.py`` file:

    .. code-block:: python

      from launch_ros.substitutions import FindPackageShare

      from launch import LaunchDescription
      from launch.actions import IncludeLaunchDescription
      from launch.launch_description_sources import PythonLaunchDescriptionSource
      from launch.substitutions import PathJoinSubstitution, TextSubstitution


      def generate_launch_description():
          colors = {
              'background_r': '200'
          }

          return LaunchDescription([
              IncludeLaunchDescription(
                  PythonLaunchDescriptionSource([
                      PathJoinSubstitution([
                          FindPackageShare('launch_tutorial'),
                          'launch',
                          'example_substitutions_launch.py'
                      ])
                  ]),
                  launch_arguments={
                      'turtlesim_ns': 'turtlesim2',
                      'use_provided_red': 'True',
                      'new_background_r': TextSubstitution(text=str(colors['background_r']))
                  }.items()
              )
          ])


    The ``FindPackageShare`` substitution is used to find the path to the ``launch_tutorial`` package.
    The ``PathJoinSubstitution`` substitution is then used to join the path to that package path with the ``example_substitutions_launch.py`` file name.

    .. code-block:: python

      PathJoinSubstitution([
          FindPackageShare('launch_tutorial'),
          'launch',
          'example_substitutions_launch.py'
      ])

    The ``launch_arguments`` dictionary with ``turtlesim_ns`` and ``use_provided_red`` arguments is passed to the ``IncludeLaunchDescription`` action.
    The ``TextSubstitution`` substitution is used to define the ``new_background_r`` argument with the value of the ``background_r`` key in the ``colors`` dictionary.

    .. code-block:: python

      launch_arguments={
          'turtlesim_ns': 'turtlesim2',
          'use_provided_red': 'True',
          'new_background_r': TextSubstitution(text=str(colors['background_r']))
      }.items()

  .. group-tab:: YAML


    Copy and paste the complete code into the ``launch/example_main_launch.yaml`` file:

    .. code-block:: yaml

      launch:
        - let:
            name: 'background_r'
            value: '200'
        - include:
            file: '$(find-pkg-share launch_tutorial)/launch/example_substitutions_launch.yaml'
            arg:
              - name: 'turtlesim_ns'
                value: 'turtlesim2'
              - name: 'use_provided_red'
                value: 'True'
              - name: 'new_background_r'
                value: '$(var background_r)'

    The ``$(find-pkg-share launch_tutorial)`` substitution is used to find the path to the ``launch_tutorial`` package.
    The path substitution is then joined with the ``example_substitutions_launch.yaml`` file name.

    .. code-block:: yaml

      file: '$(find-pkg-share launch_tutorial)/launch/example_substitutions_launch.yaml'

    The ``background_r`` variable with ``turtlesim_ns`` and ``use_provided_red`` arguments is passed to the ``include`` action.
    The ``$(var background_r)`` substitution is used to define the ``new_background_r`` argument with the value of the ``background_r`` variable.

    .. code-block:: yaml

      arg:
        - name: 'turtlesim_ns'
          value: 'turtlesim2'
        - name: 'use_provided_red'
          value: 'True'
        - name: 'new_background_r'
          value: '$(var background_r)'

3 Substitutions example launch file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now create the substitution launch file in the same folder:

.. tabs::

  .. group-tab:: Python

    Create the file ``launch/example_substitutions_launch.py`` and insert the following code:

    .. code-block:: python

        from launch_ros.actions import Node

        from launch import LaunchDescription
        from launch.actions import DeclareLaunchArgument, ExecuteProcess, TimerAction
        from launch.conditions import IfCondition
        from launch.substitutions import LaunchConfiguration, PythonExpression


        def generate_launch_description():
            turtlesim_ns = LaunchConfiguration('turtlesim_ns')
            use_provided_red = LaunchConfiguration('use_provided_red')
            new_background_r = LaunchConfiguration('new_background_r')

            turtlesim_ns_launch_arg = DeclareLaunchArgument(
                'turtlesim_ns',
                default_value='turtlesim1'
            )
            use_provided_red_launch_arg = DeclareLaunchArgument(
                'use_provided_red',
                default_value='False'
            )
            new_background_r_launch_arg = DeclareLaunchArgument(
                'new_background_r',
                default_value='200'
            )

            turtlesim_node = Node(
                package='turtlesim',
                namespace=turtlesim_ns,
                executable='turtlesim_node',
                name='sim'
            )
            spawn_turtle = ExecuteProcess(
                cmd=[[
                    'ros2 service call ',
                    turtlesim_ns,
                    '/spawn ',
                    'turtlesim_msgs/srv/Spawn ',
                    '""{x: 2, y: 2, theta: 0.2}""'
                ]],
                shell=True
            )
            change_background_r = ExecuteProcess(
                cmd=[[
                    'ros2 param set ',
                    turtlesim_ns,
                    '/sim background_r ',
                    '120'
                ]],
                shell=True
            )
            change_background_r_conditioned = ExecuteProcess(
                condition=IfCondition(
                    PythonExpression([
                        new_background_r,
                        ' == 200',
                        ' and ',
                        use_provided_red
                    ])
                ),
                cmd=[[
                    'ros2 param set ',
                    turtlesim_ns,
                    '/sim background_r ',
                    new_background_r
                ]],
                shell=True
            )

            return LaunchDescription([
                turtlesim_ns_launch_arg,
                use_provided_red_launch_arg,
                new_background_r_launch_arg,
                turtlesim_node,
                spawn_turtle,
                change_background_r,
                TimerAction(
                    period=2.0,
                    actions=[change_background_r_conditioned],
                )
            ])

    The ``turtlesim_ns``, ``use_provided_red``, and ``new_background_r`` launch configurations are defined.
    They are used to store values of launch arguments in the above variables and to pass them to required actions.
    These ``LaunchConfiguration`` substitutions allow us to acquire the value of the launch argument in any part of the launch description.

    ``DeclareLaunchArgument`` is used to define the launch argument that can be passed from the above launch file or from the console.

    .. code-block:: python

        turtlesim_ns = LaunchConfiguration('turtlesim_ns')
        use_provided_red = LaunchConfiguration('use_provided_red')
        new_background_r = LaunchConfiguration('new_background_r')

        turtlesim_ns_launch_arg = DeclareLaunchArgument(
            'turtlesim_ns',
            default_value='turtlesim1'
        )
        use_provided_red_launch_arg = DeclareLaunchArgument(
            'use_provided_red',
            default_value='False'
        )
        new_background_r_launch_arg = DeclareLaunchArgument(
            'new_background_r',
            default_value='200'
        )

    The ``turtlesim_node`` node with the ``namespace`` set to ``turtlesim_ns`` ``LaunchConfiguration`` substitution is defined.

    .. code-block:: python

        turtlesim_node = Node(
            package='turtlesim',
            namespace=turtlesim_ns,
            executable='turtlesim_node',
            name='sim'
        )

    Afterwards, the ``ExecuteProcess`` action called ``spawn_turtle`` is defined with the corresponding ``cmd`` argument.
    This command makes a call to the spawn service of the turtlesim node.

    Additionally, the ``LaunchConfiguration`` substitution is used to get the value of the ``turtlesim_ns`` launch argument to construct a command string.

    .. code-block:: python

        spawn_turtle = ExecuteProcess(
            cmd=[[
                'ros2 service call ',
                turtlesim_ns,
                '/spawn ',
                'turtlesim_msgs/srv/Spawn ',
                '""{x: 2, y: 2, theta: 0.2}""'
            ]],
            shell=True
        )

    The same approach is used for the ``change_background_r`` and ``change_background_r_conditioned`` actions that change the turtlesim background's red color parameter.
    The difference is that the ``change_background_r_conditioned`` action is only executed if the provided ``new_background_r`` argument equals ``200`` and the ``use_provided_red`` launch argument is set to ``True``.
    The evaluation inside the ``IfCondition`` is done using the ``PythonExpression`` substitution.

    .. code-block:: python

        change_background_r = ExecuteProcess(
            cmd=[[
                'ros2 param set ',
                turtlesim_ns,
                '/sim background_r ',
                '120'
            ]],
            shell=True
        )
        change_background_r_conditioned = ExecuteProcess(
            condition=IfCondition(
                PythonExpression([
                    new_background_r,
                    ' == 200',
                    ' and ',
                    use_provided_red
                ])
            ),
            cmd=[[
                'ros2 param set ',
                turtlesim_ns,
                '/sim background_r ',
                new_background_r
            ]],
            shell=True
        )

  .. group-tab:: YAML

    Create the file ``launch/example_substitutions_launch.yaml`` and insert the following code:

    .. code-block:: yaml

      launch:
        - arg:
            name: 'turtlesim_ns'
            default: 'turtlesim1'
        - arg:
            name: 'use_provided_red'
            default: 'False'
        - arg:
            name: 'new_background_r'
            default: '200'

        - node:
            pkg: 'turtlesim'
            namespace: '$(var turtlesim_ns)'
            exec: 'turtlesim_node'
            name: 'sim'
        - executable:
            cmd: 'ros2 service call $(var turtlesim_ns)/spawn turtlesim_msgs/srv/Spawn ""{x: 5, y: 2, theta: 0.2}""'
        - executable:
            cmd: 'ros2 param set $(var turtlesim_ns)/sim background_r 120'
        - timer:
            period: 2.0
            children:
              - executable:
                  cmd: 'ros2 param set $(var turtlesim_ns)/sim background_r $(var new_background_r)'
                  if: '$(eval ""$(var new_background_r) == 200 and $(var use_provided_red)"")'

    The ``turtlesim_ns``, ``use_provided_red``, and ``new_background_r`` launch configurations are defined.
    They are used to store values of launch arguments in the above variables and to pass them to required actions.
    The launch configuration arguments can later be used with the ``$(var <name>)`` substitution to acquire the value of the launch argument in any part of the launch description.

    The ``arg`` tag is used to define the launch argument that can be passed from the above launch file or from the console.

    .. code-block:: yaml

      - arg:
          name: 'turtlesim_ns'
          default: 'turtlesim1'
      - arg:
          name: 'use_provided_red'
          default: 'False'
      - arg:
          name: 'new_background_r'
          default: '200'

    The ``turtlesim_node`` node with the ``namespace`` set to the ``turtlesim_ns`` launch configuration value using the ``$(var <name>)`` substitution is defined.

    .. code-block:: yaml

      - node:
          pkg: 'turtlesim'
          namespace: '$(var turtlesim_ns)'
          exec: 'turtlesim_node'
          name: 'sim'

    Afterwards, an ``executable`` action is defined with the corresponding ``cmd`` tag.
    This command makes a call to the spawn service of the turtlesim node.

    Additionally, the ``$(var <name>)`` substitution is used to get the value of the ``turtlesim_ns`` launch argument to construct a command string.

    .. code-block:: yaml

        - executable:
            cmd: 'ros2 service call $(var turtlesim_ns)/spawn turtlesim_msgs/srv/Spawn ""{x: 5, y: 2, theta: 0.2}""'

    The same approach is used for the ``ros2 param`` ``executable`` actions that change the turtlesim background's red color parameter.
    The difference is that the second action inside of the timer is only executed if the provided ``new_background_r`` argument equals ``200`` and the ``use_provided_red`` launch argument is set to ``True``.
    The evaluation of the ``if`` predicate is done using the ``$(eval <python-expression>)`` substitution.

    .. code-block:: yaml

        - executable:
            cmd: 'ros2 param set $(var turtlesim_ns)/sim background_r 120'
        - timer:
            period: 2.0
            children:
              - executable:
                  cmd: 'ros2 param set $(var turtlesim_ns)/sim background_r $(var new_background_r)'
                  if: '$(eval ""$(var new_background_r) == 200 and $(var use_provided_red)"")'

4 Build the package
^^^^^^^^^^^^^^^^^^^

Go to the root of the workspace, and build the package:

.. code-block:: console

  colcon build

Also remember to source the workspace after building.

Launching example
-----------------

Now you can launch using the ``ros2 launch`` command.

.. tabs::

  .. group-tab:: Python

    .. code-block:: console

        ros2 launch launch_tutorial example_main_launch.py

  .. group-tab:: YAML

    .. code-block:: console

        ros2 launch launch_tutorial example_main_launch.yaml

This will do the following:

#. Start a turtlesim node with a blue background
#. Spawn the second turtle
#. Change the color to purple
#. Change the color to pink after two seconds if the provided ``background_r`` argument is ``200`` and ``use_provided_red`` argument is ``True``

Modifying launch arguments
--------------------------

.. tabs::

  .. group-tab:: Python

    If you want to change the provided launch arguments, you can either update them in ``launch_arguments`` dictionary in the ``example_main_launch.py`` or launch the ``example_substitutions_launch.py`` with preferred arguments.
    To see arguments that may be given to the launch file, run the following command:

    .. code-block:: console

        ros2 launch launch_tutorial example_substitutions_launch.py --show-args

  .. group-tab:: YAML

    If you want to change the provided launch arguments, you can either update the ``background_r`` variable in the ``example_main_launch.yaml`` or launch the ``example_substitutions_launch.yaml`` with preferred arguments.
    To see arguments that may be given to the launch file, run the following command:

    .. code-block:: console

        ros2 launch launch_tutorial example_substitutions_launch.yaml --show-args

This will show the arguments that may be given to the launch file and their default values.

.. code-block:: console

    Arguments (pass arguments as '<name>:=<value>'):

        'turtlesim_ns':
            no description given
            (default: 'turtlesim1')

        'use_provided_red':
            no description given
            (default: 'False')

        'new_background_r':
            no description given
            (default: '200')

Now you can pass the desired arguments to the launch file as follows:

.. tabs::

  .. group-tab:: Python

    .. code-block:: console

        ros2 launch launch_tutorial example_substitutions_launch.py turtlesim_ns:='turtlesim3' use_provided_red:='True' new_background_r:=200

  .. group-tab:: YAML

    .. code-block:: console

        ros2 launch launch_tutorial example_substitutions_launch.yaml turtlesim_ns:='turtlesim3' use_provided_red:='True' new_background_r:=200

Documentation
-------------

`The launch documentation <https://docs.ros.org/en/{DISTRO}/p/launch/architecture.html>`_ provides detailed information about available substitutions.

Summary
-------

In this tutorial, you learned about using substitutions in launch files.
You learned about their possibilities and capabilities to create reusable launch files.

You can now learn more about :doc:`using event handlers in launch files <./Using-Event-Handlers>` which are used to define a complex set of rules which can be used to dynamically modify the launch file.
",What are substitutions and how are they used in ROS 2 launch files?
".. redirect-from::

  Tutorials/Launch-Files/Creating-Launch-Files
  Tutorials/Launch/Creating-Launch-Files

Creating a launch file
======================

**Goal:** Create a launch file to run a complex ROS 2 system.

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Prerequisites
-------------

This tutorial uses the :doc:`rqt_graph and turtlesim <../../Beginner-CLI-Tools/Introducing-Turtlesim/Introducing-Turtlesim>` packages.

You will also need to use a text editor of your preference.

As always, don’t forget to source ROS 2 in :doc:`every new terminal you open <../../Beginner-CLI-Tools/Configuring-ROS2-Environment>`.

Background
----------

The launch system in ROS 2 is responsible for helping the user describe the configuration of their system and then execute it as described.
The configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS-specific conventions which make it easy to reuse components throughout the system by giving them each a different configuration.
It is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes.

Launch files written in Python, XML, or YAML can start and stop different nodes as well as trigger and act on various events.
See :doc:`../../../How-To-Guides/Launch-file-different-formats` for a description of the different formats.
The package providing this framework is ``launch_ros``, which uses the non-ROS-specific ``launch`` framework underneath.

The `design document <https://design.ros2.org/articles/roslaunch.html>`__ details the goal of the design of ROS 2's launch system (not all functionality is currently available).

Tasks
-----

1 Setup
^^^^^^^

Create a new directory to store your launch files:

.. code-block:: console

  mkdir launch

2 Write the launch file
^^^^^^^^^^^^^^^^^^^^^^^

Let’s put together a ROS 2 launch file using the ``turtlesim`` package and its executables.
As mentioned above, this can either be in Python, XML, or YAML.

.. tabs::

  .. group-tab:: Python

    Copy and paste the complete code into the ``launch/turtlesim_mimic_launch.py`` file:

    .. code-block:: python

      from launch import LaunchDescription
      from launch_ros.actions import Node

      def generate_launch_description():
          return LaunchDescription([
              Node(
                  package='turtlesim',
                  namespace='turtlesim1',
                  executable='turtlesim_node',
                  name='sim'
              ),
              Node(
                  package='turtlesim',
                  namespace='turtlesim2',
                  executable='turtlesim_node',
                  name='sim'
              ),
              Node(
                  package='turtlesim',
                  executable='mimic',
                  name='mimic',
                  remappings=[
                      ('/input/pose', '/turtlesim1/turtle1/pose'),
                      ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'),
                  ]
              )
          ])

  .. group-tab:: XML

    Copy and paste the complete code into the ``launch/turtlesim_mimic_launch.xml`` file:

    .. code-block:: xml

      <launch>
        <node pkg=""turtlesim"" exec=""turtlesim_node"" name=""sim"" namespace=""turtlesim1""/>
        <node pkg=""turtlesim"" exec=""turtlesim_node"" name=""sim"" namespace=""turtlesim2""/>
        <node pkg=""turtlesim"" exec=""mimic"" name=""mimic"">
          <remap from=""/input/pose"" to=""/turtlesim1/turtle1/pose""/>
          <remap from=""/output/cmd_vel"" to=""/turtlesim2/turtle1/cmd_vel""/>
        </node>
      </launch>

  .. group-tab:: YAML

    Copy and paste the complete code into the ``launch/turtlesim_mimic_launch.yaml`` file:

    .. code-block:: yaml

      launch:

      - node:
          pkg: ""turtlesim""
          exec: ""turtlesim_node""
          name: ""sim""
          namespace: ""turtlesim1""

      - node:
          pkg: ""turtlesim""
          exec: ""turtlesim_node""
          name: ""sim""
          namespace: ""turtlesim2""

      - node:
          pkg: ""turtlesim""
          exec: ""mimic""
          name: ""mimic""
          remap:
          -
              from: ""/input/pose""
              to: ""/turtlesim1/turtle1/pose""
          -
              from: ""/output/cmd_vel""
              to: ""/turtlesim2/turtle1/cmd_vel""


2.1 Examine the launch file
~~~~~~~~~~~~~~~~~~~~~~~~~~~

All of the launch files above are launching a system of three nodes, all from the ``turtlesim`` package.
The goal of the system is to launch two turtlesim windows, and have one turtle mimic the movements of the other.

When launching the two turtlesim nodes, the only difference between them is their namespace values.
Unique namespaces allow the system to start two nodes without node name or topic name conflicts.
Both turtles in this system receive commands over the same topic and publish their pose over the same topic.
With unique namespaces, messages meant for different turtles can be distinguished.

The final node is also from the ``turtlesim`` package, but a different executable: ``mimic``.
This node has added configuration details in the form of remappings.
``mimic``'s ``/input/pose`` topic is remapped to ``/turtlesim1/turtle1/pose`` and it's ``/output/cmd_vel`` topic to ``/turtlesim2/turtle1/cmd_vel``.
This means ``mimic`` will subscribe to ``/turtlesim1/sim``'s pose topic and republish it for ``/turtlesim2/sim``'s velocity command topic to subscribe to.
In other words, ``turtlesim2`` will mimic ``turtlesim1``'s movements.

.. tabs::

  .. group-tab:: Python

    These import statements pull in some Python ``launch`` modules.

    .. code-block:: python

      from launch import LaunchDescription
      from launch_ros.actions import Node

    Next, the launch description itself begins:

    .. code-block:: python

      def generate_launch_description():
         return LaunchDescription([

         ])

    The first two actions in the launch description launch the two turtlesim windows:

    .. code-block:: python

      Node(
          package='turtlesim',
          namespace='turtlesim1',
          executable='turtlesim_node',
          name='sim'
      ),
      Node(
          package='turtlesim',
          namespace='turtlesim2',
          executable='turtlesim_node',
          name='sim'
      ),

    The final action launches the mimic node with the remaps:

    .. code-block:: python

      Node(
          package='turtlesim',
          executable='mimic',
          name='mimic',
          remappings=[
            ('/input/pose', '/turtlesim1/turtle1/pose'),
            ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'),
          ]
      )

  .. group-tab:: XML

    The first two actions launch the two turtlesim windows:

    .. code-block:: xml

      <node pkg=""turtlesim"" exec=""turtlesim_node"" name=""sim"" namespace=""turtlesim1""/>
      <node pkg=""turtlesim"" exec=""turtlesim_node"" name=""sim"" namespace=""turtlesim2""/>

    The final action launches the mimic node with the remaps:

    .. code-block:: xml

      <node pkg=""turtlesim"" exec=""mimic"" name=""mimic"">
        <remap from=""/input/pose"" to=""/turtlesim1/turtle1/pose""/>
        <remap from=""/output/cmd_vel"" to=""/turtlesim2/turtle1/cmd_vel""/>
      </node>

  .. group-tab:: YAML

    The first two actions launch the two turtlesim windows:

    .. code-block:: yaml

      - node:
          pkg: ""turtlesim""
          exec: ""turtlesim_node""
          name: ""sim""
          namespace: ""turtlesim1""

      - node:
          pkg: ""turtlesim""
          exec: ""turtlesim_node""
          name: ""sim""
          namespace: ""turtlesim2""


    The final action launches the mimic node with the remaps:

    .. code-block:: yaml

      - node:
          pkg: ""turtlesim""
          exec: ""mimic""
          name: ""mimic""
          remap:
          -
              from: ""/input/pose""
              to: ""/turtlesim1/turtle1/pose""
          -
              from: ""/output/cmd_vel""
              to: ""/turtlesim2/turtle1/cmd_vel""


3 ros2 launch
^^^^^^^^^^^^^

To run the launch file created above, enter into the directory you created earlier and run the following command:

.. tabs::

  .. group-tab:: Python

    .. code-block:: console

      cd launch
      ros2 launch turtlesim_mimic_launch.py

  .. group-tab:: XML

    .. code-block:: console

      cd launch
      ros2 launch turtlesim_mimic_launch.xml

  .. group-tab:: YAML

    .. code-block:: console

      cd launch
      ros2 launch turtlesim_mimic_launch.yaml

.. note::

  It is possible to launch a launch file directly (as we do above), or provided by a package.
  When it is provided by a package, the syntax is:

  .. code-block:: console

      ros2 launch <package_name> <launch_file_name>

  You learned about creating packages in :doc:`../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package`.

.. note::

  For packages with launch files, it is a good idea to add an ``exec_depend`` dependency on the ``ros2launch`` package in your package's ``package.xml``:

  .. code-block:: xml

    <exec_depend>ros2launch</exec_depend>

  This helps make sure that the ``ros2 launch`` command is available after building your package.
  It also ensures that all :doc:`launch file formats <../../../How-To-Guides/Launch-file-different-formats>` are recognized.

Two turtlesim windows will open, and you will see the following ``[INFO]`` messages telling you which nodes your launch file has started:

.. code-block:: console

  [INFO] [launch]: Default logging verbosity is set to INFO
  [INFO] [turtlesim_node-1]: process started with pid [11714]
  [INFO] [turtlesim_node-2]: process started with pid [11715]
  [INFO] [mimic-3]: process started with pid [11716]

To see the system in action, open a new terminal and run the ``ros2 topic pub`` command on the ``/turtlesim1/turtle1/cmd_vel`` topic to get the first turtle moving:

.. code-block:: console

  ros2 topic pub -r 1 /turtlesim1/turtle1/cmd_vel geometry_msgs/msg/Twist ""{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: -1.8}}""

You will see both turtles following the same path.

.. image:: images/mimic.png

4 Introspect the system with rqt_graph
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

While the system is still running, open a new terminal and run ``rqt_graph`` to get a better idea of the relationship between the nodes in your launch file.

Run the command:

.. code-block:: console

  rqt_graph

.. image:: images/mimic_graph.png

A hidden node (the ``ros2 topic pub`` command you ran) is publishing data to the ``/turtlesim1/turtle1/cmd_vel`` topic on the left, which the ``/turtlesim1/sim`` node is subscribed to.
The rest of the graph shows what was described earlier: ``mimic`` is subscribed to ``/turtlesim1/sim``'s pose topic, and publishes to ``/turtlesim2/sim``'s velocity command topic.

Summary
-------

Launch files simplify running complex systems with many nodes and specific configuration details.
You can create launch files using Python, XML, or YAML, and run them using the ``ros2 launch`` command.
",What are the different formats in which launch files can be written in ROS 2 as mentioned in the text?
".. redirect-from::

    Tutorials/Launch-Files/Using-Event-Handlers
    Tutorials/Launch/Using-Event-Handlers

Using event handlers
====================

**Goal:** Learn about event handlers in ROS 2 launch files

**Tutorial level:** Intermediate

**Time:** 15 minutes

.. contents:: Table of Contents
   :depth: 2
   :local:

Background
----------

Launch in ROS 2 is a system that executes and manages user-defined processes.
It is responsible for monitoring the state of processes it launched, as well as reporting and reacting to changes in the state of those processes.
These changes are called events and can be handled by registering an event handler with the launch system.
Event handlers can be registered for specific events and can be useful for monitoring the state of processes.
Additionally, they can be used to define a complex set of rules which can be used to dynamically modify the launch file.

This tutorial shows usage examples of event handlers in ROS 2 launch files.

Prerequisites
-------------

This tutorial uses the :doc:`turtlesim <../../Beginner-CLI-Tools/Introducing-Turtlesim/Introducing-Turtlesim>` package.
This tutorial also assumes you have :doc:`created a new package <../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>` of build type ``ament_python`` called ``launch_tutorial``.

This tutorial extends the code shown in the :doc:`Using substitutions in launch files <./Using-Substitutions>` tutorial.

Using event handlers
--------------------

1 Event handlers example launch file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Create a new file called ``example_event_handlers_launch.py`` file in the ``launch`` folder of the ``launch_tutorial`` package.

.. code-block:: python

    from launch_ros.actions import Node

    from launch import LaunchDescription
    from launch.actions import (DeclareLaunchArgument, EmitEvent, ExecuteProcess,
                                LogInfo, RegisterEventHandler, TimerAction)
    from launch.conditions import IfCondition
    from launch.event_handlers import (OnExecutionComplete, OnProcessExit,
                                    OnProcessIO, OnProcessStart, OnShutdown)
    from launch.events import Shutdown
    from launch.substitutions import (EnvironmentVariable, FindExecutable,
                                    LaunchConfiguration, LocalSubstitution,
                                    PythonExpression)


    def generate_launch_description():
        turtlesim_ns = LaunchConfiguration('turtlesim_ns')
        use_provided_red = LaunchConfiguration('use_provided_red')
        new_background_r = LaunchConfiguration('new_background_r')

        turtlesim_ns_launch_arg = DeclareLaunchArgument(
            'turtlesim_ns',
            default_value='turtlesim1'
        )
        use_provided_red_launch_arg = DeclareLaunchArgument(
            'use_provided_red',
            default_value='False'
        )
        new_background_r_launch_arg = DeclareLaunchArgument(
            'new_background_r',
            default_value='200'
        )

        turtlesim_node = Node(
            package='turtlesim',
            namespace=turtlesim_ns,
            executable='turtlesim_node',
            name='sim'
        )
        spawn_turtle = ExecuteProcess(
            cmd=[[
                FindExecutable(name='ros2'),
                ' service call ',
                turtlesim_ns,
                '/spawn ',
                'turtlesim_msgs/srv/Spawn ',
                '""{x: 2, y: 2, theta: 0.2}""'
            ]],
            shell=True
        )
        change_background_r = ExecuteProcess(
            cmd=[[
                FindExecutable(name='ros2'),
                ' param set ',
                turtlesim_ns,
                '/sim background_r ',
                '120'
            ]],
            shell=True
        )
        change_background_r_conditioned = ExecuteProcess(
            condition=IfCondition(
                PythonExpression([
                    new_background_r,
                    ' == 200',
                    ' and ',
                    use_provided_red
                ])
            ),
            cmd=[[
                FindExecutable(name='ros2'),
                ' param set ',
                turtlesim_ns,
                '/sim background_r ',
                new_background_r
            ]],
            shell=True
        )

        return LaunchDescription([
            turtlesim_ns_launch_arg,
            use_provided_red_launch_arg,
            new_background_r_launch_arg,
            turtlesim_node,
            RegisterEventHandler(
                OnProcessStart(
                    target_action=turtlesim_node,
                    on_start=[
                        LogInfo(msg='Turtlesim started, spawning turtle'),
                        spawn_turtle
                    ]
                )
            ),
            RegisterEventHandler(
                OnProcessIO(
                    target_action=spawn_turtle,
                    on_stdout=lambda event: LogInfo(
                        msg='Spawn request says ""{}""'.format(
                            event.text.decode().strip())
                    )
                )
            ),
            RegisterEventHandler(
                OnExecutionComplete(
                    target_action=spawn_turtle,
                    on_completion=[
                        LogInfo(msg='Spawn finished'),
                        change_background_r,
                        TimerAction(
                            period=2.0,
                            actions=[change_background_r_conditioned],
                        )
                    ]
                )
            ),
            RegisterEventHandler(
                OnProcessExit(
                    target_action=turtlesim_node,
                    on_exit=[
                        LogInfo(msg=(EnvironmentVariable(name='USER'),
                                ' closed the turtlesim window')),
                        EmitEvent(event=Shutdown(
                            reason='Window closed'))
                    ]
                )
            ),
            RegisterEventHandler(
                OnShutdown(
                    on_shutdown=[LogInfo(
                        msg=['Launch was asked to shutdown: ',
                            LocalSubstitution('event.reason')]
                    )]
                )
            ),
        ])

``RegisterEventHandler`` actions for the ``OnProcessStart``, ``OnProcessIO``, ``OnExecutionComplete``, ``OnProcessExit``, and ``OnShutdown`` events were defined in the launch description.

The ``OnProcessStart`` event handler is used to register a callback function that is executed when the turtlesim node starts.
It logs a message to the console and executes the ``spawn_turtle`` action when the turtlesim node starts.

.. code-block:: python

    RegisterEventHandler(
        OnProcessStart(
            target_action=turtlesim_node,
            on_start=[
                LogInfo(msg='Turtlesim started, spawning turtle'),
                spawn_turtle
            ]
        )
    ),

The ``OnProcessIO`` event handler is used to register a callback function that is executed when the ``spawn_turtle`` action writes to its standard output.
It logs the result of the spawn request.

.. code-block:: python

    RegisterEventHandler(
        OnProcessIO(
            target_action=spawn_turtle,
            on_stdout=lambda event: LogInfo(
                msg='Spawn request says ""{}""'.format(
                    event.text.decode().strip())
            )
        )
    ),

The ``OnExecutionComplete`` event handler is used to register a callback function that is executed when the ``spawn_turtle`` action completes.
It logs a message to the console and executes the ``change_background_r`` and ``change_background_r_conditioned`` actions when the spawn action completes.

.. code-block:: python

    RegisterEventHandler(
        OnExecutionComplete(
            target_action=spawn_turtle,
            on_completion=[
                LogInfo(msg='Spawn finished'),
                change_background_r,
                TimerAction(
                    period=2.0,
                    actions=[change_background_r_conditioned],
                )
            ]
        )
    ),

The ``OnProcessExit`` event handler is used to register a callback function that is executed when the turtlesim node exits.
It logs a message to the console and executes the ``EmitEvent`` action to emit a ``Shutdown`` event when the turtlesim node exits.
It means that the launch process will shutdown when the turtlesim window is closed.

.. code-block:: python

    RegisterEventHandler(
        OnProcessExit(
            target_action=turtlesim_node,
            on_exit=[
                LogInfo(msg=(EnvironmentVariable(name='USER'),
                        ' closed the turtlesim window')),
                EmitEvent(event=Shutdown(
                    reason='Window closed'))
            ]
        )
    ),

Finally, the ``OnShutdown`` event handler is used to register a callback function that is executed when the launch file is asked to shutdown.
It logs a message to the console why the launch file is asked to shutdown.
It logs the message with a reason for shutdown like the closure of turtlesim window or :kbd:`ctrl-c` signal made by the user.

.. code-block:: python

    RegisterEventHandler(
        OnShutdown(
            on_shutdown=[LogInfo(
                msg=['Launch was asked to shutdown: ',
                    LocalSubstitution('event.reason')]
            )]
        )
    ),

Build the package
-----------------

Go to the root of the workspace, and build the package:

.. code-block:: console

  colcon build

Also remember to source the workspace after building.

Launching example
-----------------

Now you can launch the ``example_event_handlers_launch.py`` file using the ``ros2 launch`` command.

.. code-block:: console

    ros2 launch launch_tutorial example_event_handlers_launch.py turtlesim_ns:='turtlesim3' use_provided_red:='True' new_background_r:=200

This will do the following:

#. Start a turtlesim node with a blue background
#. Spawn the second turtle
#. Change the color to purple
#. Change the color to pink after two seconds if the provided ``background_r`` argument is ``200`` and ``use_provided_red`` argument is ``True``
#. Shutdown the launch file when the turtlesim window is closed

Additionally, it will log messages to the console when:

#. The turtlesim node starts
#. The spawn action is executed
#. The ``change_background_r`` action is executed
#. The ``change_background_r_conditioned`` action is executed
#. The turtlesim node exits
#. The launch process is asked to shutdown.

Documentation
-------------

`The launch documentation <https://docs.ros.org/en/{DISTRO}/p/launch/architecture.html>`_ provides detailed information about available event handlers.

Summary
-------

In this tutorial, you learned about using event handlers in launch files.
You learned about their syntax and usage examples to define a complex set of rules to dynamically modify launch files.
","What event handlers are defined in the provided launch file, and how are they used in the tutorial?"
".. redirect-from::

  Tutorials/Launch-system
  Tutorials/Launch-Files/Launch-system
  Tutorials/Launch/Launch-system

Integrating launch files into ROS 2 packages
============================================

**Goal:** Add a launch file to a ROS 2 package

**Tutorial level:** Intermediate

**Time:** 10 minutes

.. contents:: Contents
   :depth: 2
   :local:

Prerequisites
-------------

You should have gone through the tutorial on how to :doc:`create a ROS 2 package <../../Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>`.

As always, don’t forget to source ROS 2 in :doc:`every new terminal you open <../../Beginner-CLI-Tools/Configuring-ROS2-Environment>`.

Background
----------

In the :doc:`previous tutorial <Creating-Launch-Files>`, we saw how to write a standalone launch file.
This tutorial will show how to add a launch file to an existing package, and the conventions typically used.

Tasks
-----

1 Create a package
^^^^^^^^^^^^^^^^^^

Create a workspace for the package to live in:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

      mkdir -p launch_ws/src
      cd launch_ws/src

  .. group-tab:: macOS

    .. code-block:: bash

      mkdir -p launch_ws/src
      cd launch_ws/src

  .. group-tab:: Windows

    .. code-block:: bash

      md launch_ws\src
      cd launch_ws\src

.. tabs::

  .. group-tab:: Python package

    .. code-block:: console

      ros2 pkg create --build-type ament_python --license Apache-2.0 py_launch_example

  .. group-tab:: C++ package

    .. code-block:: console

      ros2 pkg create --build-type ament_cmake --license Apache-2.0 cpp_launch_example

2 Creating the structure to hold launch files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

By convention, all launch files for a package are stored in the ``launch`` directory inside of the package.
Make sure to create a ``launch`` directory at the top-level of the package you created above.

.. tabs::

  .. group-tab:: Python package

    For Python packages, the directory containing your package should look like this:

    .. code-block:: console

      src/
        py_launch_example/
          launch/
          package.xml
          py_launch_example/
          resource/
          setup.cfg
          setup.py
          test/

    To enable colcon to locate and utilize our launch files, we need to inform Python's setup tools of their presence.
    To achieve this, open the ``setup.py`` file, add the necessary ``import`` statements at the top, and include the launch files into the ``data_files`` parameter of ``setup``:

    .. code-block:: python

      import os
      from glob import glob
      # Other imports ...

      package_name = 'py_launch_example'

      setup(
          # Other parameters ...
          data_files=[
              # ... Other data files
              # Include all launch files.
              (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*launch.[pxy][yma]*')))
          ]
      )

  .. group-tab:: C++ package

    For C++ packages, we will only be adjusting the ``CMakeLists.txt`` file by adding:

    .. code-block:: cmake

      # Install launch files.
      install(DIRECTORY
        launch
        DESTINATION share/${PROJECT_NAME}/
      )

    to the end of the file (but before ``ament_package()``).


3 Writing the launch file
^^^^^^^^^^^^^^^^^^^^^^^^^

.. tabs::

  .. group-tab:: Python launch file

    Inside your ``launch`` directory, create a new launch file called ``my_script_launch.py``.
    ``_launch.py`` is recommended, but not required, as the file suffix for Python launch files.
    However, the launch file name needs to end with ``launch.py`` to be recognized and autocompleted by ``ros2 launch``.

    Your launch file should define the ``generate_launch_description()`` function which returns a ``launch.LaunchDescription()`` to be used by the ``ros2 launch`` verb.

    .. code-block:: python

      import launch
      import launch_ros.actions

      def generate_launch_description():
          return launch.LaunchDescription([
              launch_ros.actions.Node(
                  package='demo_nodes_cpp',
                  executable='talker',
                  name='talker'),
        ])

  .. group-tab:: XML launch file

    Inside your ``launch`` directory, create a new launch file called ``my_script_launch.xml``.
    ``_launch.xml`` is recommended, but not required, as the file suffix for XML launch files.

    .. code-block:: xml

      <launch>
        <node pkg=""demo_nodes_cpp"" exec=""talker"" name=""talker""/>
      </launch>

  .. group-tab:: YAML launch file

    Inside your ``launch`` directory, create a new launch file called ``my_script_launch.yaml``.
    ``_launch.yaml`` is recommended, but not required, as the file suffix for YAML launch files.

    .. code-block:: yaml

      launch:

      - node:
          pkg: ""demo_nodes_cpp""
          exec: ""talker""
          name: ""talker""


4 Building and running the launch file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Go to the top-level of the workspace, and build it:

.. code-block:: console

  colcon build

After the ``colcon build`` has been successful and you've sourced the workspace, you should be able to run the launch file as follows:

.. tabs::

  .. group-tab:: Python package

    .. tabs::

      .. group-tab:: Python launch file

        .. code-block:: console

          ros2 launch py_launch_example my_script_launch.py

      .. group-tab:: XML launch file

        .. code-block:: console

          ros2 launch py_launch_example my_script_launch.xml

      .. group-tab:: YAML launch file

        .. code-block:: console

          ros2 launch py_launch_example my_script_launch.yaml

  .. group-tab:: C++ package

    .. tabs::

      .. group-tab:: Python launch file

        .. code-block:: console

          ros2 launch cpp_launch_example my_script_launch.py

      .. group-tab:: XML launch file

        .. code-block:: console

          ros2 launch cpp_launch_example my_script_launch.xml

      .. group-tab:: YAML launch file

        .. code-block:: console

          ros2 launch cpp_launch_example my_script_launch.yaml


Documentation
-------------

`The launch documentation <https://docs.ros.org/en/{DISTRO}/p/launch/architecture.html>`__ provides more details on concepts that are also used in ``launch_ros``.

Additional documentation/examples of launch capabilities are forthcoming.
See the source code (https://github.com/ros2/launch and https://github.com/ros2/launch_ros) in the meantime.
",What is the recommended file suffix for Python launch files when creating a new launch file according to the text provided?
"Basic Concepts
==============

ROS 2 is a middleware based on a strongly-typed, anonymous publish/subscribe mechanism that allows for message passing between different processes.

At the heart of any ROS 2 system is the ROS graph.
The ROS graph refers to the network of nodes in a ROS system and the connections between them by which they communicate.

These are the concepts that will help you get started understanding the basics of ROS 2.

.. toctree::
   :maxdepth: 1

   Basic/About-Nodes
   Basic/About-Discovery
   Basic/About-Interfaces
   Basic/About-Topics
   Basic/About-Services
   Basic/About-Actions
   Basic/About-Parameters
   Basic/About-Command-Line-Tools
   Basic/About-Launch
   Basic/About-Client-Libraries
",What is the significance of the ROS graph in a ROS 2 system?
"Intermediate Concepts
=====================

These are the concepts that further your understanding of a basic ROS 2 system.

.. toctree::
   :maxdepth: 1

   Intermediate/About-Domain-ID
   Intermediate/About-Different-Middleware-Vendors
   Intermediate/About-Logging
   Intermediate/About-Quality-of-Service-Settings
   Intermediate/About-Executors
   Intermediate/About-Topic-Statistics
   Intermediate/About-RQt
   Intermediate/About-Composition
   Intermediate/About-Cross-Compilation
   Intermediate/About-Security
   Intermediate/About-Tf2
",What are some intermediate concepts that further understanding of a basic ROS 2 system?
"Advanced Concepts
=================

These conceptual documents are intended for developers who plan to modify or contribute to the ROS 2 core.

.. toctree::
   :maxdepth: 1

   Advanced/About-Build-System
   Advanced/About-Internal-Interfaces
   Advanced/About-Middleware-Implementations
","What are the topics covered in the ""Advanced Concepts"" section of the ROS 2 core documentation?"
"Nodes
=====

.. contents:: Table of Contents
   :local:

A node is a participant in the ROS 2 graph, which uses a :doc:`client library <About-Client-Libraries>` to communicate with other nodes.
Nodes can communicate with other nodes within the same process, in a different process, or on a different machine.
Nodes are typically the unit of computation in a ROS graph; each node should do one logical thing.

Nodes can :doc:`publish <About-Topics>` to named topics to deliver data to other nodes, or :doc:`subscribe <About-Topics>` to named topics to get data from other nodes.
They can also act as a :doc:`service client <About-Services>` to have another node perform a computation on their behalf, or as a :doc:`service server <About-Services>` to provide functionality to other nodes.
For long-running computations, a node can act as an :doc:`action client <About-Actions>` to have another node perform it on their behalf, or as an :doc:`action server <About-Actions>` to provide functionality to other nodes.
Nodes can provide configurable :doc:`parameters <About-Parameters>` to change behavior during run-time.

Nodes are often a complex combination of publishers, subscribers, service servers, service clients, action servers, and action clients, all at the same time.

Connections between nodes are established through a distributed :doc:`discovery <About-Discovery>` process.
",What types of communication can nodes engage in within a ROS 2 graph as mentioned in the text?
"Topics
======

.. contents:: Table of Contents
   :local:

Topics are one of the three primary styles of interfaces provided by ROS 2.
Topics should be used for continuous data streams, like sensor data, robot state, etc.

As stated earlier, ROS 2 is a strongly-typed, anonymous publish/subscribe system.
Let's break down that sentence and explain it a bit more.

Publish/Subscribe
-----------------

A publish/subscribe system is one in which there are producers of data (publishers) and consumers of data (subscribers).
The publishers and subscribers know how to contact each other through the concept of a ""topic"", which is a common name so that the entites can find each other.
For instance, when you create a publisher, you must also give it a string that is the name of the topic; the same goes for the subscriber.
Any publishers and subscribers that are on the same topic name can directly communicate with each other.
There may be zero or more publishers and zero or more subscribers on any particular topic.
When data is published to the topic by any of the publishers, all subscribers in the system will receive the data.
This system is also known as a ""bus"", since it somewhat resembles a device bus from electrical engineering.
This concept of a bus is part of what makes ROS 2 a powerful and flexible system.
Publishers and subscribers can come and go as needed, meaning that debugging and introspection are natural extensions to the system.
For instance, if you want to record data, you can use the ``ros2 bag record`` command.
Under the hood, ``ros2 bag record`` creates a new subscriber to whatever topic you tell it, without interrupting the flow of data to the other parts of the system.

Anonymous
---------

Another fact mentioned in the introduction is that ROS 2 is ""anonymous"".
This means that when a subscriber gets a piece of data, it doesn't generally know or care which publisher originally sent it (though it can find out if it wants).
The benefit to this architecture is that publishers and subscribers can be swapped out at will without affecting the rest of the system.

Strongly-typed
--------------

Finally, the introduction also mentioned that the publish/subscribe system is ""strongly-typed"".
That has two meanings in this context:

1. The types of each field in a ROS message are typed, and that type is enforced at various levels.
   For instance, if the ROS message contains:

   .. code::

      uint32 field1
      string field2

   Then the code will ensure that ``field1`` is always an unsigned integer and that ``field2`` is always a string.

2. The semantics of each field are well-defined.  There is no automated mechanism to ensure this, but all of the core ROS types have strong semantics associated with them.  For instance, the IMU message contains a 3-dimensional vector for the measured angular velocity, and each of the dimensions is specified to be in radians/second.  Other interpretations should not be placed into the message.
",What are the key characteristics of a publish/subscribe system in ROS 2 according to the text?
".. redirect-from::

    Introspection-with-command-line-tools
    Tutorials/Introspection-with-command-line-tools
    Concepts/About-Command-Line-Tools

Introspection with command line tools
=====================================

.. contents:: Table of Contents
   :local:

ROS 2 includes a suite of command-line tools for introspecting a ROS 2 system.

Usage
-----

The main entry point for the tools is the command ``ros2``, which itself has various sub-commands for introspecting and working with nodes, topics, services, and more.

To see all available sub-commands run:

.. code-block:: bash

   ros2 --help

Examples of sub-commands that are available include:

* ``action``: Introspect/interact with ROS actions
* ``bag``: Record/play a rosbag
* ``component``: Manage component containers
* ``daemon``: Introspect/configure the ROS 2 daemon
* ``doctor``: Check ROS setup for potential issues
* ``interface``: Show information about ROS interfaces
* ``launch``: Run/introspect a launch file
* ``lifecycle``: Introspect/manage nodes with managed lifecycles
* ``multicast``: Multicast debugging commands
* ``node``: Introspect ROS nodes
* ``param``: Introspect/configure parameters on a node
* ``pkg``: Introspect ROS packages
* ``run``: Run ROS nodes
* ``security``: Configure security settings
* ``service``: Introspect/call ROS services
* ``test``: Run a ROS launch test
* ``topic``: Introspect/publish ROS topics
* ``trace``: Tracing tools to get information on ROS nodes execution (only available on Linux)
* ``wtf``: An alias for ``doctor``

Example
-------

To produce the typical talker-listener example using command-line tools, the ``topic`` sub-command can be used to publish and echo messages on a topic.

Publish messages in one terminal with:

.. code-block:: bash

   $ ros2 topic pub /chatter std_msgs/msg/String ""data: Hello world""
   publisher: beginning loop
   publishing #1: std_msgs.msg.String(data='Hello world')

   publishing #2: std_msgs.msg.String(data='Hello world')

Echo messages received in another terminal with:

.. code-block:: bash

   $ ros2 topic echo /chatter
   data: Hello world

   data: Hello world

Behind the scenes
-----------------

ROS 2 uses a distributed discovery process for nodes to connect to each other.
As this process purposefully does not use a centralized discovery mechanism, it can take time for ROS nodes to discover all other participants in the ROS graph.
Because of this, there is a long-running daemon in the background that stores information about the ROS graph to provide faster responses to queries, e.g. the list of node names.

The daemon is automatically started when the relevant command-line tools are used for the first time.
You can run ``ros2 daemon --help`` for more options for interacting with the daemon.

Implementation
--------------

The source code for the ``ros2`` command is available at https://github.com/ros2/ros2cli.

The ``ros2`` tool has been implemented as a framework that can be extended via plugins.
For example, the `sros2 <https://github.com/ros2/sros2>`__ package provides a ``security`` sub-command that is automatically detected by the ``ros2`` tool if the ``sros2`` package is installed.
","What is the purpose of the ""ros2"" command in the ROS 2 system and how can its various sub-commands be accessed?"
"Discovery
=========

.. contents:: Table of Contents
   :local:

Discovery of nodes happens automatically through the underlying middleware of ROS 2.
It can be summarized as follows:

#. When a node is started, it advertises its presence to other nodes on the network with the same ROS domain (set with the ROS_DOMAIN_ID environment variable).
   Nodes respond to this advertisement with information about themselves so that the appropriate connections can be made and the nodes can communicate.
#. Nodes periodically advertise their presence so that connections can be made with new-found entities, even after the initial discovery period.
#. Nodes advertise to other nodes when they go offline.

Nodes will only establish connections with other nodes if they have compatible :doc:`Quality of Service <../../Tutorials/Demos/Quality-of-Service>` settings.

Take the :ref:`talker-listener demo <talker-listener>` for example.
Running the C++ talker node in one terminal will publish messages on a topic,
and the Python listener node running in another terminal  will subscribe to messages on the same topic.

You should see that these nodes discover each other automatically, and begin to exchange messages.
",What happens when a node is started in ROS 2 and how do nodes establish connections with each other?
"Launch
======

.. contents:: Table of Contents
   :local:

A ROS 2 system typically consists of many nodes running across many different processes (and even different machines).
While it is possible to run each of these nodes separately, it gets cumbersome quite quickly.

The launch system in ROS 2 is meant to automate the running of many nodes with a single command.
It helps the user describe the configuration of their system and then executes it as described.
The configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS-specific conventions which make it easy to reuse components throughout the system by giving them each a different configuration.
It is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes.

All of the above is specified in a launch file, which can be written in Python, XML, or YAML.
This launch file can then be run using the ``ros2 launch`` command, and all of the nodes specified will be run.

The `design document <https://design.ros2.org/articles/roslaunch.html>`__ details the goal of the design of ROS 2's launch system (not all functionality is currently available).
",What are the key responsibilities of the launch system in ROS 2?
".. redirect-from::

   Concepts/About-Client-Interfaces
   Concepts/About-ROS-2-Client-Libraries

.. include:: ../../../global_substitutions.txt

Client libraries
================

.. contents:: Table of Contents
   :local:

Overview
--------

Client libraries are the APIs that allow users to implement their ROS 2 code.
Using client libraries, users gain access to ROS 2 concepts such as nodes, topics, services, etc.
Client libraries come in a variety of programming languages so that users may write ROS 2 code in the language that is best-suited for their application.
For example, you might prefer to write visualization tools in Python because it makes prototyping iterations faster, while for parts of your system that are concerned with efficiency, the nodes might be better implemented in C++.

Nodes written using different client libraries are able to share messages with each other because all client libraries implement code generators that provide users with the capability to interact with ROS 2 interface files in the respective language.

In addition to the language-specific communication tools, client libraries expose to users the core functionality that makes ROS ""ROS"".
For example, here is a list of functionality that can typically be accessed through a client library:

* Names and namespaces
* Time (real or simulated)
* Parameters
* Console logging
* Threading model
* Intra-process communication

Supported client libraries
--------------------------

The C++ client library (``rclcpp``) and the Python client library (``rclpy``) are both client libraries which utilize common functionality in ``rcl``.

The ``rclcpp`` package
~~~~~~~~~~~~~~~~~~~~~~

The ROS Client Library for C++ (``rclcpp``) is the user facing, C++ idiomatic interface which provides all of the ROS client functionality like creating nodes, publishers, and subscriptions.
``rclcpp`` builds on top of ``rcl`` and the ``rosidl`` |API|, and it is designed to be used with the C++ messages generated by ``rosidl_generator_cpp``.

``rclcpp`` makes use of all the features of C++ and C++17 to make the interface as easy to use as possible, but since it reuses the implementation in ``rcl`` it is able maintain a consistent behavior with the other client libraries that use the ``rcl`` |API|.

The ``rclcpp`` repository is located on GitHub at `ros2/rclcpp <https://github.com/ros2/rclcpp>`_ and contains the |package| ``rclcpp``.
The generated |API| documentation is here:

`api/rclcpp/index.html <http://docs.ros.org/en/{DISTRO}/p/rclcpp>`_

The ``rclpy`` package
~~~~~~~~~~~~~~~~~~~~~

The ROS Client Library for Python (``rclpy``) is the Python counterpart to the C++ client library.
Like the C++ client library, ``rclpy`` also builds on top of the ``rcl`` C API for its implementation.
The interface provides an idiomatic Python experience that uses native Python types and patterns like lists and context objects.
By using the ``rcl`` |API| in the implementation, it stays consistent with the other client libraries in terms of feature parity and behavior.
In addition to providing Python idiomatic bindings around the ``rcl`` |API| and Python classes for each message, the Python client library takes care of the execution model, using ``threading.Thread`` or similar to run the functions in the ``rcl`` |API|.

Like C++ it generates custom Python code for each ROS message that the user interacts with, but unlike C++ it eventually converts the native Python message object into the C version of the message.
All operations happen on the Python version of the messages until they need to be passed into the ``rcl`` layer, at which point they are converted into the plain C version of the message so it can be passed into the ``rcl`` C |API|.
This is avoided if possible when communicating between publishers and subscriptions in the same process to cut down on the conversion into and out of Python.

The ``rclpy`` repository is located on GitHub at `ros2/rclpy <https://github.com/ros2/rclpy>`_ and contains the |package| ``rclpy``.
The generated |API| documentation is here:

`api/rclpy/index.html <https://docs.ros.org/en/{DISTRO}/p/rclpy/>`_


Community-maintained
~~~~~~~~~~~~~~~~~~~~

While the C++ and Python client libraries are maintained by the core ROS 2 team, members of the ROS 2 community maintain additional client libraries:

* `Ada <https://github.com/ada-ros/ada4ros2>`__  This is a set of packages (binding to ``rcl``, message generator, binding to ``tf2``, examples and tutorials) that allows the writing of Ada applications for ROS 2.
* `C <https://github.com/ros2/rclc>`__  ``rclc`` does not put a layer on top of rcl but complements rcl to make rcl+rclc a feature-complete client library in C. See `micro.ros.org <https://micro.ros.org/>`__ for tutorials.
* `JVM and Android <https://github.com/ros2-java>`__ Java and Android bindings for ROS 2.
* `.NET Core, UWP and C# <https://github.com/esteve/ros2_dotnet>`__ This is a collection of projects (bindings, code generator, examples and more) for writing ROS 2 applications for .NET Core and .NET Standard.
* `Node.js <https://www.npmjs.com/package/rclnodejs>`__ rclnodejs is a Node.js client for ROS 2. It provides a simple and easy JavaScript API for ROS 2 programming.
* `Rust <https://github.com/ros2-rust/ros2_rust>`__ This is a set of projects (the rclrs client library, code generator, examples and more) that enables developers to write ROS 2 applications in Rust.
* `Flutter and Dart <https://github.com/rcldart>`__ Flutter and Dart bindings for ROS 2.

Older, unmaintained client libraries are:

* `C# <https://github.com/firesurfer/rclcs>`__
* `Objective C and iOS <https://github.com/esteve/ros2_objc>`__
* `Zig <https://github.com/jacobperron/rclzig>`__


Common functionality: ``rcl``
-----------------------------

Most of the functionality found in a client library is not specific to the programming language of the client library.
For example, the behavior of parameters and the logic of namespaces should ideally be the same across all programming languages.
Because of this, rather than implementing the common functionality from scratch, client libraries make use of a common core ROS Client Library (RCL) interface that implements logic and behavior of ROS concepts that is not language-specific.
As a result, client libraries only need to wrap the common functionality in the RCL with foreign function interfaces.
This keeps client libraries thinner and easier to develop.
For this reason the common RCL functionality is exposed with C interfaces as the C language is typically the easiest language for client libraries to wrap.

In addition to making the client libraries light-weight, an advantage of having the common core is that the behavior between languages is more consistent.
If any changes are made to the logic/behavior of the functionality in the core RCL -- namespaces, for example -- all client libraries that use the RCL will have these changes reflected.
Furthermore, having the common core means that maintaining multiple client libraries becomes less work when it comes to bug fixes.

The API documentation for ``rcl`` can be found `here <https://docs.ros.org/en/{DISTRO}/p/rcl/>`__.

Language-specific functionality
-------------------------------

Client library concepts that require language-specific features/properties are not implemented in the RCL but instead are implemented in each client library.
For example, threading models used by “spin” functions will have implementations that are specific to the language of the client library.

Demo
----

For a walkthrough of the message exchange between a publisher using ``rclpy`` and a subscription using ``rclcpp``\ , we encourage you to watch `this ROSCon talk <https://vimeo.com/187696091>`__ starting at 17:25 (`see the slides here <https://roscon.ros.org/2016/presentations/ROSCon%202016%20-%20ROS%202%20Update.pdf>`__).

Comparison to ROS 1
-------------------

In ROS 1, all client libraries are developed ""from the ground up"".
This allows for the ROS 1 Python client library to be implemented purely in Python, for example, which brings benefits of such as not needing to compile code.
However, naming conventions and behaviors are not always consistent between client libraries, bug fixes have to be done in multiple places, and there is a lot of functionality that has only ever been implemented in one client library (e.g. UDPROS).

Summary
-------

By utilizing the common core ROS client library, client libraries written in a variety of programming languages are easier to write and have more consistent behavior.
",What are some benefits of using client libraries in ROS 2 for implementing code in different programming languages?
"Services
========

.. contents:: Table of Contents
   :local:

In ROS 2, a service refers to a remote procedure call.
In other words, a node can make a remote procedure call to another node which will do a computation and return a result.

This structure is reflected in how a service message definition looks:

.. code::

   uint32 request
   ---
   uint32 response

In ROS 2, services are expected to return quickly, as the client is generally waiting on the result.
Services should never be used for longer running processes, in particular processes that might need to be preempted for exceptional situations.
If you have a service that will be doing a long-running computation, consider using an :doc:`action <About-Actions>` instead.

Services are identified by a service name, which looks much like a topic name (but is in a different namespace).

A service consists of two parts: the service server and the service client.

Service server
--------------

A service server is the entity that will accept a remote procedure request, and perform some computation on it.
For instance, suppose the ROS 2 message contains the following:

.. code::

   uint32 a
   uint32 b
   ---
   uint32 sum

The service server would be the entity that receives this message, adds ``a`` and ``b`` together, and returns the ``sum``.

.. note::

   There should only ever be one service server per service name.
   It is undefined which service server will receive client requests in the case of multiple service servers on the same service name.

Service client
--------------

A service client is an entity that will request a remote service server to perform a computation on its behalf.
Following from the example above, the service client is the entity that creates the initial message containing ``a`` and ``b``, and waits for the service server to compute the sum and return the result.

Unlike the service server, there can be arbitrary numbers of service clients using the same service name.
",What is the role of a service server in ROS 2 services?
".. redirect-from::

    About-ROS-2-Parameters
    Concepts/About-ROS-2-Parameters

Parameters
==========

.. contents:: Table of Contents
   :local:

Overview
--------

Parameters in ROS 2 are associated with individual nodes.
Parameters are used to configure nodes at startup (and during runtime), without changing the code.
The lifetime of a parameter is tied to the lifetime of the node (though the node could implement some sort of persistence to reload values after restart).

Parameters are addressed by node name, node namespace, parameter name, and parameter namespace.
Providing a parameter namespace is optional.

Each parameter consists of a key, a value, and a descriptor.
The key is a string and the value is one of the following types: ``bool``, ``int64``, ``float64``, ``string``, ``byte[]``, ``bool[]``, ``int64[]``, ``float64[]`` or ``string[]``.
By default all descriptors are empty, but can contain parameter descriptions, value ranges, type information, and additional constraints.

For a hands-on tutorial with ROS parameters see :doc:`../../Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters`.

Parameters background
---------------------

Declaring parameters
^^^^^^^^^^^^^^^^^^^^

By default, a node needs to *declare* all of the parameters that it will accept during its lifetime.
This is so that the type and name of the parameters are well-defined at node startup time, which reduces the chances of misconfiguration later on.
See :doc:`../../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python` for tutorials on declaring and using parameters from a node.

For some types of nodes, not all of the parameters will be known ahead of time.
In these cases, the node can be instantiated with ``allow_undeclared_parameters`` set to ``true``, which will allow parameters to be get and set on the node even if they haven't been declared.

Parameter types
^^^^^^^^^^^^^^^

Each parameter on a ROS 2 node has one of the pre-defined parameter types as mentioned in the Overview.
By default, attempts to change the type of a declared parameter at runtime will fail.
This prevents common mistakes, such as putting a boolean value into an integer parameter.

If a parameter needs to be multiple different types, and the code using the parameter can handle it, this default behavior can be changed.
When the parameter is declared, it should be declared using a ``ParameterDescriptor`` with the ``dynamic_typing`` member variable set to ``true``.

Parameter callbacks
^^^^^^^^^^^^^^^^^^^

A ROS 2 node can register three different types of callbacks to be informed when changes are happening to parameters.
All three of the callbacks are optional.

The first is known as a ""pre set parameter"" callback, and can be set by calling ``add_pre_set_parameters_callback`` from the node API.
This callback is passed a list of the ``Parameter`` objects that are being changed, and returns nothing.
When it is called, it can modify the ``Parameter`` list to change, add, or remove entries.
As an example, if ``parameter2`` should change anytime that ``parameter1`` changes, that can be implemented with this callback.

The second is known as a ""set parameter"" callback, and can be set by calling ``add_on_set_parameters_callback`` from the node API.
The callback is passed a list of immutable ``Parameter`` objects, and returns an ``rcl_interfaces/msg/SetParametersResult``.
The main purpose of this callback is to give the user the ability to inspect the upcoming change to the parameter and explicitly reject the change.

.. note::
   It is important that ""set parameter"" callbacks have no side-effects.
   Since multiple ""set parameter"" callbacks can be chained, there is no way for an individual callback to know if a later callback will reject the update.
   If the individual callback were to make changes to the class it is in, for instance, it may get out-of-sync with the actual parameter.
   To get a callback *after* a parameter has been successfully changed, see the next type of callback below.

The third type of callback is known as an ""post set parameter"" callback, and can be set by calling ``add_post_set_parameters_callback`` from the node API.
The callback is passed a list of immutable ``Parameter`` objects, and returns nothing.
The main purpose of this callback is to give the user the ability to react to changes from parameters that have successfully been accepted.

The ROS 2 demos have an `example <https://github.com/ros2/demos/blob/{DISTRO}/demo_nodes_cpp/src/parameters/set_parameters_callback.cpp>`__ of all of these callbacks in use.

Interacting with parameters
---------------------------

ROS 2 nodes can perform parameter operations through node APIs as described in :doc:`../../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python`.
External processes can perform parameter operations via parameter services that are created by default when a node is instantiated.
The services that are created by default are:

* ``/node_name/describe_parameters``: Uses a service type of ``rcl_interfaces/srv/DescribeParameters``.
  Given a list of parameter names, returns a list of descriptors associated with the parameters.
* ``/node_name/get_parameter_types``: Uses a service type of ``rcl_interfaces/srv/GetParameterTypes``.
  Given a list of parameter names, returns a list of parameter types associated with the parameters.
* ``/node_name/get_parameters``: Uses a service type of ``rcl_interfaces/srv/GetParameters``.
  Given a list of parameter names, returns a list of parameter values associated with the parameters.
* ``/node_name/list_parameters``: Uses a service type of ``rcl_interfaces/srv/ListParameters``.
  Given an optional list of parameter prefixes, returns a list of the available parameters with that prefix.  If the prefixes are empty, returns all parameters.
* ``/node_name/set_parameters``: Uses a service type of ``rcl_interfaces/srv/SetParameters``.
  Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a list of results from trying to set each parameter; some of them may have succeeded and some may have failed.
* ``/node_name/set_parameters_atomically``: Uses a service type of ``rcl_interfaces/srv/SetParametersAtomically``.
  Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a single result from trying to set all parameters, so if one failed, all of them failed.

Setting initial parameter values when running a node
----------------------------------------------------

Initial parameter values can be set when running the node either through individual command-line arguments, or through YAML files.
See :ref:`NodeArgsParameters` for examples on how to set initial parameter values.

Setting initial parameter values when launching nodes
-----------------------------------------------------

Initial parameter values can also be set when running the node through the ROS 2 launch facility.
See :doc:`this document <../../Tutorials/Intermediate/Launch/Using-ROS2-Launch-For-Large-Projects>` for information on how to specify parameters via launch.

Manipulating parameter values at runtime
----------------------------------------

The ``ros2 param`` command is the general way to interact with parameters for nodes that are already running.
``ros2 param`` uses the parameter service API as described above to perform the various operations.
See :doc:`this how-to guide <../../How-To-Guides/Using-ros2-param>` for details on how to use ``ros2 param``.

Migrating from ROS 1
--------------------

The :doc:`Launch file migration guide <../../How-To-Guides/Migrating-from-ROS1/Migrating-Launch-Files>` explains how to migrate ``param`` and ``rosparam`` launch tags from ROS 1 to ROS 2.

The :doc:`YAML parameter file migration guide <../../How-To-Guides/Migrating-from-ROS1/Migrating-Parameters>` explains how to migrate parameter files from ROS 1 to ROS 2.

In ROS 1, the ``roscore`` acted like a global parameter blackboard where all nodes could get and set parameters.
Since there is no central ``roscore`` in ROS 2, that functionality no longer exists.
The recommended approach in ROS 2 is to use per-node parameters that are closely tied to the nodes that use them.
If a global blackboard is still needed, it is possible to create a dedicated node for this purpose.
ROS 2 ships with one in the ``ros-{DISTRO}-demo-nodes-cpp`` package called ``parameter_blackboard``; it can be run with:

.. code-block:: console

   ros2 run demo_nodes_cpp parameter_blackboard

The code for the ``parameter_blackboard`` is `here <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/parameters/parameter_blackboard.cpp>`__.
",What services are created by default for parameter operations in ROS 2 nodes?
"Actions
=======

.. contents:: Table of Contents
   :local:

In ROS 2, an action refers to a long-running remote procedure call with feedback and the ability to cancel or preempt the goal.
For instance, the high-level state machine running a robot may call an action to tell the navigation subsystem to travel to a waypoint, which may take several seconds (or minutes) to do.
Along the way, the navigation subsystem can provide feedback on how far along it is, and the high-level state machine has the option to cancel or preempt the travel to that waypoint.

This structure is reflected in how an action message definition looks:

.. code::

   int32 request
   ---
   int32 response
   ---
   int32 feedback

In ROS 2, actions are expected to be long running procedures, as there is overhead in setting up and monitoring the connection.
If you need a short running remote procedure call, consider using a :doc:`service <About-Services>` instead.

Actions are identified by an action name, which looks much like a topic name (but is in a different namespace).

An action consists of two parts: the action server and the action client.

Action server
-------------

The action server is the entity that will accept the remote procedure request and perform some procedure on it.
It is also responsible for sending out feedback as the action progresses and should react to cancellation/preemption requests.
For instance, consider an action to calculate the Fibonacci sequence with the following interface:

.. code::

   int32 order
   ---
   int32[] sequence
   ---
   int32[] sequence

The action server is the entity that receives this message, starts calculating the sequence up to ``order`` (providing feedback along the way), and finally returns a full result in ``sequence``.

.. note::

   There should only ever be one action server per action name.
   It is undefined which action server will receive client requests in the case of multiple action servers on the same action name.

Action client
-------------

An action client is an entity that will request a remote action server to perform a procedure on its behalf.
Following the example above, the action client is the entity that creates the initial message containing the ``order``, and waits for the action server to compute the sequence and return it (with feedback along the way).

Unlike the action server, there can be arbitrary numbers of action clients using the same action name.
",What are the two main parts that make up an action in ROS 2?
".. redirect-from::

    About-ROS-Interfaces
    Concepts/About-ROS-Interfaces

Interfaces
==========

.. contents:: Table of Contents
   :local:

Background
----------

ROS applications typically communicate through interfaces of one of three types: :doc:`topics <About-Topics>`, :doc:`services <About-Services>`, or :doc:`actions <About-Actions>`.
ROS 2 uses a simplified description language, the interface definition language (IDL), to describe these interfaces.
This description makes it easy for ROS tools to automatically generate source code for the interface type in several target languages.

In this document we will describe the supported types:

* msg: ``.msg`` files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages.
* srv: ``.srv`` files describe a service. They are composed of two parts: a request and a response. The request and response are message declarations.
* action: ``.action`` files describe actions. They are composed of three parts: a goal, a result, and feedback.
  Each part is a message declaration itself.

Messages
--------

Messages are a way for a ROS 2 node to send data on the network to other ROS nodes, with no response expected.
For instance, if a ROS 2 node reads temperature data from a sensor, it can then publish that data on the ROS 2 network using a ``Temperature`` message.
Other nodes on the ROS 2 network can subscribe to that data and receive the ``Temperature`` message.

Messages are described and defined in ``.msg`` files in the ``msg/`` directory of a ROS package.
``.msg`` files are composed of two parts: fields and constants.

Fields
^^^^^^

Each field consists of a type and a name, separated by a space, i.e:

.. code-block:: bash

   fieldtype1 fieldname1
   fieldtype2 fieldname2
   fieldtype3 fieldname3

For example:

.. code-block:: bash

   int32 my_int
   string my_string

Field types
~~~~~~~~~~~

Field types can be:

* a built-in-type
* names of Message descriptions defined on their own, such as ""geometry_msgs/PoseStamped""

*Built-in-types currently supported:*

.. list-table::
   :header-rows: 1

   * - Type name
     - `C++ <https://design.ros2.org/articles/generated_interfaces_cpp.html>`__
     - `Python <https://design.ros2.org/articles/generated_interfaces_python.html>`__
     - `DDS type <https://design.ros2.org/articles/mapping_dds_types.html>`__
   * - bool
     - bool
     - builtins.bool
     - boolean
   * - byte
     - uint8_t
     - builtins.bytes*
     - octet
   * - char
     - char
     - builtins.int*
     - char
   * - float32
     - float
     - builtins.float*
     - float
   * - float64
     - double
     - builtins.float*
     - double
   * - int8
     - int8_t
     - builtins.int*
     - octet
   * - uint8
     - uint8_t
     - builtins.int*
     - octet
   * - int16
     - int16_t
     - builtins.int*
     - short
   * - uint16
     - uint16_t
     - builtins.int*
     - unsigned short
   * - int32
     - int32_t
     - builtins.int*
     - long
   * - uint32
     - uint32_t
     - builtins.int*
     - unsigned long
   * - int64
     - int64_t
     - builtins.int*
     - long long
   * - uint64
     - uint64_t
     - builtins.int*
     - unsigned long long
   * - string
     - std::string
     - builtins.str
     - string
   * - wstring
     - std::u16string
     - builtins.str
     - wstring

*Every built-in-type can be used to define arrays:*

.. list-table::
   :header-rows: 1

   * - Type name
     - `C++ <https://design.ros2.org/articles/generated_interfaces_cpp.html>`__
     - `Python <https://design.ros2.org/articles/generated_interfaces_python.html>`__
     - `DDS type <https://design.ros2.org/articles/mapping_dds_types.html>`__
   * - static array
     - std::array<T, N>
     - builtins.list*
     - T[N]
   * - unbounded dynamic array
     - std::vector
     - builtins.list
     - sequence
   * - bounded dynamic array
     - custom_class<T, N>
     - builtins.list*
     - sequence<T, N>
   * - bounded string
     - std::string
     - builtins.str*
     - string

All types that are more permissive than their ROS definition enforce the ROS constraints in range and length by software.

*Example of message definition using arrays and bounded types:*

.. code-block:: bash

   int32[] unbounded_integer_array
   int32[5] five_integers_array
   int32[<=5] up_to_five_integers_array

   string string_of_unbounded_size
   string<=10 up_to_ten_characters_string

   string[<=5] up_to_five_unbounded_strings
   string<=10[] unbounded_array_of_strings_up_to_ten_characters_each
   string<=10[<=5] up_to_five_strings_up_to_ten_characters_each

Field names
~~~~~~~~~~~

Field names must be lowercase alphanumeric characters with underscores for separating words.
They must start with an alphabetic character, and they must not end with an underscore or have two consecutive underscores.

Field default value
~~~~~~~~~~~~~~~~~~~

Default values can be set to any field in the message type.
Currently default values are not supported for string arrays and complex types (i.e. types not present in the built-in-types table above; that applies to all nested messages).

Defining a default value is done by adding a third element to the field definition line, i.e:

.. code-block:: bash

   fieldtype fieldname fielddefaultvalue

For example:

.. code-block:: bash

   uint8 x 42
   int16 y -2000
   string full_name ""John Doe""
   int32[] samples [-200, -100, 0, 100, 200]

.. note::

  * string values must be defined in single ``'`` or double ``""`` quotes
  * currently string values are not escaped

Constants
^^^^^^^^^

Each constant definition is like a field description with a default value, except that this value can never be changed programatically.
This value assignment is indicated by use of an equal '=' sign, e.g.

.. code-block:: bash

   constanttype CONSTANTNAME=constantvalue

For example:

.. code-block:: bash

   int32 X=123
   int32 Y=-123
   string FOO=""foo""
   string EXAMPLE='bar'

.. note::

   Constants names have to be UPPERCASE

Services
--------

Services are a request/response communication, where the client (requester) is waiting for the server (responder) to make a short computation and return a result.

Services are described and defined in ``.srv`` files in the ``srv/`` directory of a ROS package.

A service description file consists of a request and a response msg type, separated by ``---``.
Any two ``.msg`` files concatenated with a ``---`` are a legal service description.

Here is a very simple example of a service that takes in a string and returns a string:

.. code-block:: bash

   string str
   ---
   string str

We can of course get much more complicated (if you want to refer to a message from the same package you must not mention the package name):

.. code-block:: bash

   # request constants
   int8 FOO=1
   int8 BAR=2
   # request fields
   int8 foobar
   another_pkg/AnotherMessage msg
   ---
   # response constants
   uint32 SECRET=123456
   # response fields
   another_pkg/YetAnotherMessage val
   CustomMessageDefinedInThisPackage value
   uint32 an_integer

You cannot embed another service inside of a service.

Actions
-------

Actions are a long-running request/response communication, where the action client (requester) is waiting for the action server (the responder) to take some action and return a result.
In contrast to services, actions can be long-running (many seconds or minutes), provide feedback while they are happening, and can be interrupted.

Action definitions have the following form:

.. code::

   <request_type> <request_fieldname>
   ---
   <response_type> <response_fieldname>
   ---
   <feedback_type> <feedback_fieldname>

Like services, the request fields are before and the response fields are after the first triple-dash (``---``), respectively.
There is also a third set of fields after the second triple-dash, which is the fields to be sent when sending feedback.

There can be arbitrary numbers of request fields (including zero), arbitrary numbers of response fields (including zero), and arbitrary numbers of feedback fields (including zero).

The ``<request_type>``, ``<response_type>``, and ``<feedback_type>`` follow all of the same rules as the ``<type>`` for a message.
The ``<request_fieldname>``, ``<response_fieldname>``, and ``<feedback_fieldname>`` follow all of the same rules as the ``<fieldname>`` for a message.

For instance, the ``Fibonacci`` action definition contains the following:

.. code::

   int32 order
   ---
   int32[] sequence
   ---
   int32[] sequence

This is an action definition where the action client is sending a single ``int32`` field representing the number of Fibonacci steps to take, and expecting the action server to produce an array of ``int32`` containing the complete steps.
Along the way, the action server may also provide an intermediate array of ``int32`` containing the steps accomplished up until a certain point.
",What are the three types of interfaces that ROS applications typically communicate through?
".. redirect-from::

   Concepts/About-Internal-Interfaces

Internal ROS 2 interfaces
=========================

.. contents:: Table of Contents
   :local:

.. include:: ../../../global_substitutions.txt

The internal ROS interfaces are public C |APIs| that are intended for use by developers who are creating |client libraries| or adding a new underlying middleware, but are not intended for use by typical ROS users.
The ROS |client libraries| provide the user facing |APIs| that most ROS users are familiar with, and may come in a variety of programming languages.

Internal API Architecture Overview
----------------------------------

There are two main internal interfaces:

- the ROS middleware interface (``rmw`` |API|)
- the ROS client library interface (``rcl`` |API|)

The ``rmw`` |API| is the interface between the ROS 2 software stack and the underlying middleware implementation.
The underlying middleware used for ROS 2 is either a DDS or RTPS implementation, and is responsible for discovery, publish and subscribe mechanics, request-reply mechanics for services, and serialization of message types.

The ``rcl`` |API| is a slightly higher level |API| which is used to implement the |client libraries| and does not touch the middleware implementation directly, but rather does so through the ROS middleware interface (``rmw`` |API|) abstraction.

.. figure:: ../images/ros_client_library_api_stack.png
   :alt: ros2 software stack

As the diagram shows, these |APIs| are stacked such that the typical ROS user will use the |client library| |API|, e.g. ``rclcpp``, to implement their code (executable or library).
The implementation of the |client libraries|, e.g. ``rclcpp``, use the ``rcl`` interface which provides access to the ROS graph and graph events.
The ``rcl`` implementation in turn uses the ``rmw`` |API| to access the ROS graph.
The purpose of the ``rcl`` implementation is to provide a common implementation for more complex ROS concepts and utilities that may be used by various |client libraries|, while remaining agnostic to the underlying middleware being used.
The purpose of the ``rmw`` interface is to capture the absolute minimum middleware functionality needed to support ROS's client libraries.
Finally, the implementation of the ``rmw`` |API| is provided by a middleware implementation specific |package|, e.g. ``rmw_fastrtps_cpp``, the library of which is compiled against vendor specific DDS interfaces and types.

In the diagram above there is also a box labeled ``ros_to_dds``, and the purpose of this box is to represent a category of possible packages which allow the user to access DDS vendor specific objects and settings using the ROS equivalents.
One of the goals of this abstraction interface is to completely insulate the ROS user space code from the middleware being used, so that changing DDS vendors or even middleware technology has a minimal impact on the users code.
However, we recognize that on occasion it is useful to reach into the implementation and manually adjust settings despite the consequences that might have.
By requiring the use of one of these packages in order to access the underlying DDS vendor's objects, we can avoid exposing vendor specific symbols and headers in the normal interface.
It also makes it easy to see what code is potentially violating the vendor portability by inspecting the package's dependencies to see if one of these ``ros_to_dds`` packages are being used.

.. _Type Specific Interfaces:

Type Specific Interfaces
------------------------

All along the way there are some parts of the |APIs| that are necessarily specific to the message types being exchanged, e.g. publishing a message or subscribing to a topic, and therefore require generated code for each message type.
The following diagram layouts the path from user defined ``rosidl`` files, e.g. ``.msg`` files, to the type specific code used by the user and system to perform type specific functions:

.. figure:: ../images/ros_idl_api_stack_static.png
   :alt: ros2 idl static type support stack

   Figure: flow chart of ""static"" type support generation, from ``rosidl`` files to user facing code.

The right hand side of the diagram shows how the ``.msg`` files are passed directly to language specific code generators, e.g. ``rosidl_generator_cpp`` or ``rosidl_generator_py``.
These generators are responsible for creating the code that the user will include (or import) and use as the in-memory representation of the messages that were defined in the ``.msg`` files.
For example, consider the message ``std_msgs/String``, a user might use this file in C++ with the statement ``#include <std_msgs/msg/string.hpp>``, or they might use the statement ``from std_msgs.msg import String`` in Python.
These statements work because of the files generated by these language specific (but middleware agnostic) generator packages.

Separately, the ``.msg`` files are used to generate type support code for each type.
In this context, type support means: meta data or functions that are specific to a given type and that are used by the system to perform particular tasks for the given type.
The type support for a given message might include things like a list of the names and types for each field in the message.
It might also contain a reference to code that can perform particular tasks for that type, e.g. publish a message.

Static Type Support
^^^^^^^^^^^^^^^^^^^

When the type support references code to do particular functions for a specific message type, that code sometimes needs to do middleware specific work.
For example, consider the type specific publish function, when using ""vendor A"" the function will need to call some of ""vendor A""'s |API|, but when using ""vendor B"" it will need to call ""vendor B""'s |API|.
To allow for middleware vendor specific code, the user defined ``.msg`` files may result in the generation of vendor specific code.
This vendor specific code is still hidden from the user through the type support abstraction, which is similar to how the ""Private Implementation"" (or Pimpl) pattern works.

Static Type Support with DDS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For middleware vendors based on DDS, and specifically those which generate code based on the OMG IDL files (``.idl`` files), the user defined ``rosidl`` files (``.msg`` files) are converted into equivalent OMG IDL files (``.idl`` files).
From these OMG IDL files, vendor specific code is created and then used within the type specific functions which are referenced by the type support for a given type.
The above diagram shows this on the left hand side, where the ``.msg`` files are consumed by the ``rosidl_dds`` package to produce ``.idl`` files, and then those ``.idl`` files are given to language specific and DDS vendor specific type support generation packages.

For example, consider the Fast DDS implementation, which has a package called ``rosidl_typesupport_fastrtps_cpp``.
This package is responsible for generating code to handle things like converting a C++ message object into a serialized octet buffer to be written over the network.
This code, while specific to Fast DDS, is still not exposed to the user because of the abstraction in the type support code.

Dynamic Type Support
^^^^^^^^^^^^^^^^^^^^

Another way to implement type support is to have generic functions for things like publishing to a topic, rather than generating a version of the function for each message type.
In order to accomplish this, this generic function needs some meta information about the message type being published, things like a list of field names and types in the order in which they appear in the message type.
Then to publish a message, you call a generic publish function and pass a message to be published along with a structure which contains the necessary meta data about the message type.
This is referred to as ""dynamic"" type support, as opposed to ""static"" type support which requires generated versions of a function for each type.

.. figure:: ../images/ros_idl_api_stack_dynamic.png
   :alt: ros2 idl dynamic type support stack

   Figure: flow chart of ""dynamic"" type support generation, from ``rosidl`` files to user facing code.

The above diagram shows the flow from user defined ``rosidl`` files to generated user facing code.
It is very similar to the diagram for static type support, and differs only in how the type support is generated which is represented by the left hand side of the diagram.
In dynamic type support the ``.msg`` files are converted directly into user facing code.

This code is also middleware agnostic, because it only contains meta information about the messages.
The function to actually do the work, e.g. publishing to a topic, is generic to the message type and will make any necessary calls to the middleware specific |APIs|.
Note that rather than dds vendor specific packages providing the type support code, which is the case in static type support, this method has middleware agnostic package for each language, e.g. ``rosidl_typesupport_introspection_c`` and ``rosidl_typesupport_introspection_cpp``.
The ``introspection`` part of the package name refers to the ability to introspect any message instance with the generated meta data for the message type.
This is the fundamental capability that allows for generic implementations of functions like ""publish to a topic"".

This approach has the advantage that all generated code is middleware agnostic, which means it can be reused for different middleware implementations, so long as they allow for dynamic type support.
It also results in less generated code, which reduces compile time and code size.

However, dynamic type support requires that the underlying middleware support a similar form of dynamic type support.
In the case of DDS the DDS-XTypes standard allows for publishing of messages using meta information rather than generated code.
DDS-XTypes, or something like it, is required in the underlying middleware in order to support dynamic type support.
Also, this approach to type support is normally slower than the static type support alternative.
The type specific generated code in static type support can be written to be more efficient as it does not need to iterate over the message type's meta data to perform things like serialization.

The ``rcl`` repository
----------------------

The ROS Client Library interface (``rcl`` |API|) can be used by |client libraries| (e.g. ``rclc``, ``rclcpp``, ``rclpy``, etc.) in order to avoid duplicating logic and features.
By reusing the ``rcl`` |API|, client libraries can be smaller and more consistent with each other.
Some parts of the client library are intentionally left out of the ``rcl`` |API| because the language idiomatic method should be used to implement those parts of the system.
A good example of this is the execution model, which ``rcl`` does not address at all.
Instead the client library should provide a language idiomatic solution like ``pthreads`` in C, ``std::thread`` in C++11, and ``threading.Thread`` in Python.
Generally the ``rcl`` interface provides functions that are not specific to a language pattern and are not specific to a particular message type.

The ``rcl`` |API| is located in the `ros2/rcl <https://github.com/ros2/rcl>`_ repository on |GitHub|_ and contains the interface as C headers.
The ``rcl`` C implementation is provided by the ``rcl`` |package| in the same repository.
This implementation avoids direct contact with the middleware by instead using the ``rmw`` and ``rosidl`` |APIs|.

For a complete definition of the ``rcl`` |API|, see `the rcl docs <http://docs.ros.org/en/{DISTRO}/p/rcl/>`_.

The ``rmw`` repository
----------------------

The ROS middleware interface (``rmw`` |API|) is the minimal set of primitive middleware capabilities needed to build ROS on top.
Providers of different middleware implementations must implement this interface in order to support the entire ROS stack on top.
Currently all of the middleware implementations are for different DDS vendors.

The ``rmw`` |API| is located in the `ros2/rmw <https://github.com/ros2/rmw>`_ repository.
The ``rmw`` |package| contains the C headers which define the interface, the implementation of which is provided by the various |packages| of rmw implementations for different DDS vendors.

For a definition of the ``rmw`` |API|, see `the rmw docs <http://docs.ros.org/en/{DISTRO}/p/rmw/>`_.


The ``rosidl`` repository
-------------------------

The ``rosidl`` |API| consists of a few message related static functions and types along with a definition of what code should be generated by messages in different languages.
The generated message code specified in the |API| will be language specific, but may or may not reuse generated code for other languages.
The generated message code specified in the |API| contains things like the message data structure, functions for construction, destruction, etc.
The |API| will also implement a way to get the type support structure for the message type, which is used when publishing or subscribing to a topic of that message type.

There are several repositories that play a role in the ``rosidl`` |API| and implementation.

The ``rosidl`` repository, located on |GitHub|_ at `ros2/rosidl <https://github.com/ros2/rosidl>`_, defines the message IDL syntax, i.e. syntax of ``.msg`` files, ``.srv`` files, etc., and contains |packages| for parsing the files, for providing CMake infrastructure to generate code from the messages, for generating implementation agnostic code (headers and source files), and for establishing the default set of generators.
The repository contains these |packages|:

-  ``rosidl_cmake``: provides CMake functions and modules for generating code from ``rosidl`` files, e.g. ``.msg`` files, ``.srv`` files, etc.
-  ``rosidl_default_generators``: defines the list of default generators which ensures that they are installed as dependencies, but other injected generators can also be used.
-  ``rosidl_generator_c``: provides tools to generate C header files (``.h``) for ``rosidl`` files.
-  ``rosidl_generator_cpp``: provides tools to generate C++ header files (``.hpp``) for ``rosidl`` files.
-  ``rosidl_generator_py``: provides tools to generate Python modules for ``rosidl`` files.
-  ``rosidl_parser``: provides Python |API| for parsing ``rosidl`` files.

Generators for other languages, e.g. ``rosidl_generator_java``, are hosted externally (in different repositories) but would use the same mechanism that the above generators use to ""register"" themselves as a ``rosidl`` generator.

In addition to the aforementioned |packages| for parsing and generating headers for the ``rosidl`` files, the ``rosidl`` repository also contains |packages| concerned with ""type support"" for the message types defined in the files.
Type support refers to the ability to interpret and manipulate the information represented by ROS message instances of particular types (publishing the messages, for example).
Type support can either be provided by code that is generated at compile time or it can be done programmatically based on the contents of the ``rosidl`` file, e.g. the ``.msg`` or ``.srv`` file, and the data received, by introspecting the data.
In the case of the latter, where type support is done through runtime interpretation of the messages, the message code generated by ROS 2 can be agnostic to the rmw implementation.
The packages that provide this type support through introspection of the data are:

-  ``rosidl_typesupport_introspection_c``: provides tools for generating C code for supporting ``rosidl`` message data types.
-  ``rosidl_typesupport_introspection_cpp``: provides tools for generating C++ code for supporting ``rosidl`` message data types.

In the case where type support is to be generated at compile time instead of being generated programmatically, a package specific to the rmw implementation will need to be used.
This is because typically a particular rmw implementation will require data to be stored and manipulated in a manner that is specific to the DDS vendor in order for the DDS implementation to make use of it.
See the :ref:`Type Specific Interfaces` section above for more details.

For more information on what exactly is in the ``rosidl`` |API| (static and generated) see this page:

The ``rcutils`` repository
--------------------------

ROS 2 C Utilities (``rcutils``) is a C |API| composed of macros, functions, and data structures used throughout the ROS 2 codebase.
These are mainly used for error handling, commandline argument parsing, and logging which are not specific to the client or middleware layers and can be shared by both.

The ``rcutils`` |API| and implementation are located in the `ros2/rcutils <https://github.com/ros2/rcutils>`_ repository on |GitHub|_ which contains the interface as C headers.

For a complete definition of the ``rcutils`` |API|, see `the rcutils docs <https://docs.ros.org/en/{DISTRO}/p/rcutils/>`_.
",What are the two main internal interfaces in ROS 2 mentioned in the text document?
".. redirect-from::

   Concepts/About-Build-System

The build system
================

.. contents:: Table of Contents
   :local:

.. include:: ../../../global_substitutions.txt

The build system is what allows developers to build their ROS 2 code as needed.
ROS 2 relies heavily on the division of code into packages, with each package containing a manifest file (``package.xml``).
This manifest file contains essential metadata about the package, including its dependencies on other packages.
This manifest is required for the meta-build tool to function.

The ROS 2 build system consists of 3 major concepts.

Build tool
----------

This is the software that controls the compilation and testing of a single package.
In ROS 2 this is usually CMake for C++, and setuptools for Python, but other build tools are supported.

Build helpers
-------------

These are helper functions that hook into the build tool to developer experience.
ROS 2 packages typically rely on the ``ament`` series of packages for this.
``ament`` consists of a few important repositories which are all in the `GitHub organization <https://github.com/ament>`_.

The ``ament_package`` package
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Located on |GitHub|_ at `ament/ament_package <https://github.com/ament/ament_package>`_, this repository contains a single :term:`ament Python package` that provides various utilities for |ament packages|, e.g. templates for environment hooks.

All |ament packages| must contain a single :term:`package.xml` file at the root of the package regardless of their underlying build system.
The :term:`package.xml` ""manifest"" file contains information that is required in order to process and operate on a |package|.
This |package| information includes things like the |package|'s name, which is globally unique, and the package's dependencies.
The :term:`package.xml` file also serves as the marker file which indicates the location of the |package| on the file system.

Parsing of the :term:`package.xml` files is provided by ``catkin_pkg`` (as in ROS 1), while functionality to locate |packages| by searching the file system for these :term:`package.xml` files is provided by build tools such as ``colcon``.

.. glossary::

   package.xml
       Package manifest file which marks the root of a :term:`package` and contains meta information about the :term:`package` including its name, version, description, maintainer, license, dependencies, and more.
       The contents of the manifest are in machine readable XML format and the contents are described in the |REPs| `127 <http://www.ros.org/reps/rep-0127.html>`_ and `140 <http://www.ros.org/reps/rep-0140.html>`_, with the possibility of further modifications in future |REPs|.

So anytime some |package| is referred to as an :term:`ament package`, it means that it is a single unit of software (source code, build files, tests, documentation, and other resources) which is described using a :term:`package.xml` manifest file.

.. glossary::

   ament package
       Any |package| which contains a :term:`package.xml` and follows the packaging guidelines of ``ament``, regardless of the underlying build system.

Since the term :term:`ament package` is build system agnostic, there can be different kinds of |ament packages|, e.g. :term:`ament CMake package`, :term:`ament Python package`, etc.

Here is a list of common package types that you might run into in this software stack:

.. glossary::

    CMake package
        Any |package| containing a plain CMake project and a :term:`package.xml` manifest file.

    ament CMake package
        A :term:`CMake package` that also follows the ``ament`` packaging guidelines.

    Python package
        Any |package| containing a `setuptools <https://pypi.org/project/setuptools/>`_ based Python project and a :term:`package.xml` manifest file.

    ament Python package
        A :term:`Python package` that also follows the ``ament`` packaging guidelines.

The ``ament_cmake`` repository
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Located on |GitHub|_ at `ament/ament_cmake <https://github.com/ament/ament_cmake>`_, this repository contains many ""ament CMake"" and pure CMake packages which provide the infrastructure in CMake that is required to create ""ament CMake"" packages.
In this context ""ament CMake"" packages means: ``ament`` packages that are built using CMake.
So the |packages| in this repository provide the necessary CMake functions/macros and CMake Modules to facilitate creating more ""ament CMake"" (or ``ament_cmake``) packages.
Packages of this type are identified with the ``<build_type>ament_cmake</build_type>`` tag in the ``<export>`` tag of the :term:`package.xml` file.

The |packages| in this repository are extremely modular, but there is a single ""bottleneck"" |package| called ``ament_cmake``.
Anyone can depend on the ``ament_cmake`` |package| to get all of the aggregate functionality of the |packages| in this repository.
Here a list of the |packages| in the repository along with a short description:

-  ``ament_cmake``

   - aggregates all other |packages| in this repository, users need only to depend on this

-  ``ament_cmake_auto``

   - provides convenience CMake functions which automatically handle a lot of the tedious parts of writing a |package|'s ``CMakeLists.txt`` file

-  ``ament_cmake_core``

   - provides all built-in core concepts for ``ament``, e.g. environment hooks, resource indexing, symbolic linking install and others

-  ``ament_cmake_gmock``

   - adds convenience functions for making gmock based unit tests

-  ``ament_cmake_gtest``

   - adds convenience functions for making gtest based automated tests

-  ``ament_cmake_nose``

   - adds convenience functions for making nosetests based python automated tests

-  ``ament_cmake_python``

   - provides CMake functions for |packages| that contain Python code
   - see the :doc:`ament_cmake_python user documentation <../../How-To-Guides/Ament-CMake-Python-Documentation>`

-  ``ament_cmake_test``

   - aggregates different kinds of tests, e.g. gtest and nosetests, under a single target using `CTest <https://cmake.org/Wiki/CMake/Testing_With_CTest>`_

The ``ament_cmake_core`` |package| contains a lot of the CMake infrastructure that makes it possible to cleanly pass information between |packages| using conventional interfaces.
This makes the |packages| have more decoupled build interfaces with other |packages|, promoting their reuse and encouraging conventions in the build systems of different |packages|.
For instance, it provides a standard way to pass include directories, libraries, definitions, and dependencies between |packages| so that consumers of this information can access this information in a conventional way.

The ``ament_cmake_core`` |package| also provides features of the ``ament`` build system like symbolic link installation, which allows you to symbolically link files from either the source space or the build space into the install space rather than copying them.
This allows you to install once and then edit non-generated resources like Python code and configuration files without having to rerun the install step for them to take effect.
This feature essentially replaces the ""devel space"" from ``catkin`` because it has most of the advantages with few of the complications or drawbacks.

Another feature provided by ``ament_cmake_core`` is the |package| resource indexing which is a way for |packages| to indicate that they contain a resource of some type.
The design of this feature makes it much more efficient to answer simple questions like what |packages| are in this prefix (e.g. ``/usr/local``) because it only requires that you list the files in a single possible location under that prefix.
You can read more about this feature in the `design docs <https://github.com/ament/ament_cmake/blob/{REPOS_FILE_BRANCH}/ament_cmake_core/doc/resource_index.md>`_ for the resource index.

Like ``catkin``, ``ament_cmake_core`` also provides environment setup files and |package| specific environment hooks.
The environment setup files, often named something like ``setup.bash``, are a place for |package| developers to define changes to the environment that are needed to utilize their |package|.
The developers are able to do this using an ""environment hook"" which is basically an arbitrary bit of shell code that can set or modify environment variables, define shell functions, setup auto-completion rules, etc...
This feature is how, for example, ROS 1 set the ``ROS_DISTRO`` environment variable without ``catkin`` knowing anything about the ROS distribution.

The ``ament_lint`` repository
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Located on |GitHub|_ at `ament/ament_lint <https://github.com/ament/ament_lint>`_, this repository provides several |packages| which provide linting and testing services in a convenient and consistent manner.
Currently there are |packages| to support C++ style linting using ``uncrustify``, static C++ code checks using ``cppcheck``, checking for copyright in source code, Python style linting using ``pep8``, and other things.
The list of helper packages will likely grow in the future.

Meta-build tool
---------------

This is a piece of software that knows how to topologically order a group of packages, and build or test them in the correct dependency order.
This software will call into the Build Tool to do the actual work of compiling, testing, and installing the package.

In ROS 2, the tool named `colcon <https://colcon.readthedocs.io/en/released/>`__ is used for this.
",What is the purpose of the manifest file (``package.xml``) in a ROS 2 package?
".. redirect-from::

   Concepts/About-Middleware-Implementations

ROS 2 middleware implementations
================================

.. contents:: Table of Contents
   :local:

.. include:: ../../../global_substitutions.txt

ROS middleware implementations are sets of |packages| that implement some of the internal ROS interfaces, e.g. the ``rmw``, ``rcl``, and ``rosidl`` |APIs|.

Common Packages for DDS Middleware Packages
-------------------------------------------

All of the current ROS middleware implementations are based on full or partial DDS implementations.
For example, there is a middleware implementation that uses RTI's Connext DDS and an implementation which uses eProsima's Fast DDS.
Because of this, there are some shared |packages| amongst most DDS based middleware implementations.

In the `ros2/rosidl_dds <https://github.com/ros2/rosidl_dds>`_ repository on |GitHub|_, there is the following |package|:

-  ``rosidl_generator_dds_idl``: provides tools to generate DDS ``.idl`` files from ``rosidl`` files, e.g. ``.msg`` files, ``.srv`` files, etc.

The ``rosidl_generator_dds_idl`` |package| generates a DDS ``.idl`` file for each ``rosidl`` file, e.g. ``.msg`` file, defined by |packages| containing messages.
Currently DDS based ROS middleware implementations make use of this generator's output ``.idl`` files to generate pre-compiled type support that is vendor specific.

Structure of ROS Middleware Implementations
-------------------------------------------

A ROS middleware implementation is typically made up of a few |packages| in a single repository:

- ``<implementation_name>_cmake_module``: contains CMake Module for discovering and exposing required dependencies
- ``rmw_<implementation_name>_<language>``: contains the implementation of the ``rmw`` |API| in a particular language, typically C++
- ``rosidl_typesupport_<implementation_name>_<language>``: contains tools to generate static type support code for ``rosidl`` files, tailored to the implementation in a particular language, typically C or C++

The ``<implementation_name>_cmake_module`` |package| contains any CMake Modules and functions needed to find the supporting dependencies for the middleware implementation.
For example, ``rti_connext_dds_cmake_module`` provides wrapper logic around the CMake Module shipped with RTI Connext DDS to make sure that all packages that depend on it will select the same installation of RTI Connext DDS.
Similarly, ``fastrtps_cmake_module`` includes a CMake Module to find eProsima's Fast DDS and ``gurumdds_cmake_module`` includes a CMake Module to find GurumNetworks GurumDDS.
Not all implementations will have a package like this: for example, Eclipe's Cyclone DDS already provides a CMake Module which is used directly by its RMW implementation without the need of additional wrappers.

The ``rmw_<implementation_name>_<language>`` |package| implements the ``rmw`` C |API| in a particular language.
The implementation itself can be C++, it just must expose the header's symbols as ``extern ""C""`` so that C applications can link against it.

The ``rosidl_typesupport_<implementation_name>_<language>`` |package| provides a generator which generates DDS code in a particular language.
This is done using the ``.idl`` files generated by the ``rosidl_generator_dds_idl`` |package| and the DDS IDL code generator provided by the DDS vendor.
It also generates code for converting ROS message structures to and from DDS message structures.
This generator is also responsible for creating a shared library for the message package it is being used in, which is specific to the messages in the message package and to the DDS vendor being used.

As mentioned above, the ``rosidl_typesupport_introspection_<language>`` may be used instead of a vendor specific type support package if an rmw implementation supports runtime interpretation of messages.
This ability to programmatically send and receive types over topics without generating code beforehand is achieved by supporting the `DDS X-Types Dynamic Data standard <http://www.omg.org/spec/DDS-XTypes>`_.
As such, rmw implementations may provide support for the X-Types standard, and/or provide a package for type support generated at compile time specific to their DDS implementation.

As an example of an rmw implementation repository, the ``Eclipse Cyclone DDS`` ROS middleware implementation is on |GitHub|_ at `ros2/rmw_cyclonedds <https://github.com/ros2/rmw_cyclonedds>`_.

The rmw implementation for ``Fast DDS`` is on |GitHub|_ at `ros2/rmw_fastrtps_cpp <https://github.com/ros2/rmw_fastrtps_cpp>`_.

The rmw implementation for ``Connext DDS`` is on |GitHub|_ at `ros2/rmw_connextdds <https://github.com/ros2/rmw_connextdds>`_.

The rmw implementation for ``GurumDDS`` is on |GitHub|_ at `ros/rmw_gurumdds <https://github.com/ros2/rmw_gurumdds>`_.
",What are some examples of ROS 2 middleware implementations based on DDS implementations mentioned in the text?
".. redirect-from::

   RQt-Overview-Usage
   Tutorials/RQt-Overview-Usage
   Concepts/About-RQt

Overview and usage of RQt
=========================

.. contents:: Table of Contents
   :local:

Overview
--------

RQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins.
One can run all the existing GUI tools as dockable windows within RQt.
The tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout.

You can run any RQt tools/plugins easily by:

.. code-block:: bash

   rqt

This GUI allows you to choose any available plugins on your system.
You can also run plugins in standalone windows.
For example, RQt Python Console:

.. code-block:: bash

   ros2 run rqt_py_console rqt_py_console

Users can create their own plugins for RQt with either ``Python`` or ``C++``.
To see what RQt plugins are available for your system, run:

.. code-block:: bash

   ros2 pkg list

And then look for packages that start with ``rqt_``.

System setup
------------

Installing From debs
^^^^^^^^^^^^^^^^^^^^

.. code-block:: bash

   sudo apt install ros-{DISTRO}-rqt*


RQt Components Structure
------------------------

RQt consists of two metapackages:

* *rqt* - core infrastucture modules.
* *rqt_common_plugins* - Commonly useful debugging tools.

Advantage of RQt framework
--------------------------

Compared to building your own GUIs from scratch:

* Standardized common procedures for GUI (start-shutdown hook, restore previous states).
* Multiple widgets can be docked in a single window.
* Easily turn your existing Qt widgets into RQt plugins.
* Expect support at `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__ (ROS community website for the questions).

From system architecture's perspective:

* Support multi-platform (basically wherever `QT <http://qt-project.org/>`__ and ROS run) and multi-language (``Python``, ``C++``).
* Manageable lifecycle: RQt plugins using a common API makes maintainance & reuse easier.


Further Reading
---------------

* ROS 2 Discourse `announcement of porting to ROS 2 <https://discourse.ros.org/t/rqt-in-ros2/6428>`__)
* `RQt for ROS 1 documentation <https://wiki.ros.org/rqt>`__
* Brief overview of RQt (from `a Willow Garage intern blog post <http://web.archive.org/web/20130518142837/http://www.willowgarage.com/blog/2012/10/21/ros-gui>`__)

  .. raw:: html

     <iframe width=""560"" height=""315"" src=""https://www.youtube-nocookie.com/embed/CyP9wHu2PpY"" frameborder=""0"" allow=""accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
",What are the two metapackages that RQt consists of and what are their respective purposes?
".. redirect-from::

    About-Quality-of-Service-Settings
    Concepts/About-Quality-of-Service-Settings

Quality of Service settings
===========================

.. contents:: Table of Contents
   :local:

Overview
--------

ROS 2 offers a rich variety of Quality of Service (QoS) policies that allow you to tune communication between nodes.
With the right set of Quality of Service policies, ROS 2 can be as reliable as TCP or as best-effort as UDP, with many, many possible states in between.
Unlike ROS 1, which primarily only supported TCP, ROS 2 benefits from the flexibility of the underlying DDS transport in environments with lossy wireless networks where a ""best effort"" policy would be more suitable, or in real-time computing systems where the right Quality of Service profile is needed to meet deadlines.

A set of QoS ""policies"" combine to form a QoS ""profile"".
Given the complexity of choosing the correct QoS policies for a given scenario, ROS 2 provides a set of predefined QoS profiles for common use cases (e.g. sensor data).
At the same time, developers are given the flexibility to control specific policies of the QoS profiles.

QoS profiles can be specified for publishers, subscriptions, service servers and clients.
A QoS profile can be applied independently to each instance of the aforementioned entities, but if different profiles are used, it is possible that they will be incompatible, preventing the delivery of messages.


QoS policies
------------

The base QoS profile currently includes settings for the following policies:

* History

  * *Keep last*: only store up to N samples, configurable via the queue depth option.
  * *Keep all*: store all samples, subject to the configured resource limits of the underlying middleware.

* Depth

  * *Queue size*: only honored if the ""history"" policy was set to ""keep last"".

* Reliability

  * *Best effort*: attempt to deliver samples, but may lose them if the network is not robust.
  * *Reliable*: guarantee that samples are delivered, may retry multiple times.

* Durability

  * *Transient local*: the publisher becomes responsible for persisting samples for ""late-joining"" subscriptions.
  * *Volatile*: no attempt is made to persist samples.

* Deadline

  * *Duration*: the expected maximum amount of time between subsequent messages being published to a topic

* Lifespan

  * *Duration*: the maximum amount of time between the publishing and the reception of a message without the message being considered stale or expired (expired messages are silently dropped and are effectively never received).

* Liveliness

  * *Automatic*: the system will consider all of the node’s publishers to be alive for another ""lease duration"" when any one of its publishers has published a message.
  * *Manual by topic*: the system will consider the publisher to be alive for another ""lease duration"" if it manually asserts that it is still alive (via a call to the publisher API).

* Lease Duration

  * *Duration*: the maximum period of time a publisher has to indicate that it is alive before the system considers it to have lost liveliness (losing liveliness could be an indication of a failure).

For each of the policies that is not a duration, there is also the option of ""system default"", which uses the default of the underlying middleware.
For each of the policies that is a duration, there also exists a ""default"" option that means the duration is unspecified, which the underlying middleware will usually interpret as an infinitely long duration.

Comparison to ROS 1
^^^^^^^^^^^^^^^^^^^

The ""history"" and ""depth"" policies in ROS 2 combine to provide functionality akin to the queue size in ROS 1.

The ""reliability"" policy in ROS 2 is akin to the use of either UDPROS (only in ``roscpp``) for ""best effort"", or TCPROS (ROS 1 default) for ""reliable"".
Note however that even the reliable policy in ROS 2 is implemented using UDP, which allows for multicasting if appropriate.

The ""durability"" policy ""transient local"", combined with any depth, provides functionality similar to that of ""latching"" publishers.
The remaining policies in ROS 2 are not akin to anything that is available in ROS 1, meaning that ROS 2 is more featureful than ROS 1 in this respect.
It is possible that in the future, even more QoS policies will be available in ROS 2.


QoS profiles
------------

Profiles allow developers to focus on their applications without worrying about every QoS setting possible.
A QoS profile defines a set of policies that are expected to go well together for a particular use case.

The currently defined QoS profiles are:

* Default QoS settings for publishers and subscriptions

  In order to make the transition from ROS 1 to ROS 2 easier, exercising a similar network behavior is desirable.
  By default, publishers and subscriptions in ROS 2 have ""keep last"" for history with a queue size of 10, ""reliable"" for reliability, ""volatile"" for durability, and ""system default"" for liveliness.
  Deadline, lifespan, and lease durations are also all set to ""default"".

* Services

  In the same vein as publishers and subscriptions, services are reliable.
  It is especially important for services to use volatile durability, as otherwise service servers that re-start may receive outdated requests.
  While the client is protected from receiving multiple responses, the server is not protected from side-effects of receiving the outdated requests.

* Sensor data

  For sensor data, in most cases it’s more important to receive readings in a timely fashion, rather than ensuring that all of them arrive.
  That is, developers want the latest samples as soon as they are captured, at the expense of maybe losing some.
  For that reason the sensor data profile uses best effort reliability and a smaller queue size.

* Parameters

  Parameters in ROS 2 are based on services, and as such have a similar profile.
  The difference is that parameters use a much larger queue depth so that requests do not get lost when, for example, the parameter client is unable to reach the parameter service server.

* System default

  This uses the RMW implementation’s default values for all of the policies.
  Different RMW implementations may have different defaults.

`Click here <https://github.com/ros2/rmw/blob/{REPOS_FILE_BRANCH}/rmw/include/rmw/qos_profiles.h>`__ for the specific policies in use for the above profiles.
The settings in these profiles are subject to further tweaks, based on the feedback from the community.


QoS compatibilities
-------------------

**Note:** This section refers to publishers and subscriptions but the content applies to service servers and clients in the same manner.

QoS profiles may be configured for publishers and subscriptions independently.
A connection between a publisher and a subscription is only made if the pair has compatible QoS profiles.

QoS profile compatibility is determined based on a ""Request vs Offered"" model.
Subscriptions *request* a QoS profile that is the ""minimum quality"" that it is willing to accept, and publishers *offer* a QoS profile that is the ""maximum quality"" that it is able to provide.
Connections are only made if every policy of the requested QoS profile is not more stringent than that of the offered QoS profile.
Multiple subscriptions can be connected to a single publisher simultaneously even if their requested QoS profiles are different.
The compatibility between a publisher and a subscription is unaffected by the presence of other publishers and subscriptions.

The following tables show the compatibility of the different policy settings and the result:

*Compatibility of reliability QoS policies:*

.. list-table::
   :header-rows: 1

   * - Publisher
     - Subscription
     - Compatible
   * - Best effort
     - Best effort
     - Yes
   * - Best effort
     - Reliable
     - No
   * - Reliable
     - Best effort
     - Yes
   * - Reliable
     - Reliable
     - Yes

*Compatibility of durability QoS policies:*

.. list-table::
   :header-rows: 1

   * - Publisher
     - Subscription
     - Compatible
     - Result
   * - Volatile
     - Volatile
     - Yes
     - New messages only
   * - Volatile
     - Transient local
     - No
     - No communication
   * - Transient local
     - Volatile
     - Yes
     - New messages only
   * - Transient local
     - Transient local
     - Yes
     - New and old messages

To achieve a ""latched"" topic that is visible to late subscribers,
both the publisher and subscriber must agree to use 'Transient Local'.

*Compatibility of deadline QoS policies:*

  Assume *x* and *y* are arbitrary valid duration values.

.. list-table::
   :header-rows: 1

   * - Publisher
     - Subscription
     - Compatible
   * - Default
     - Default
     - Yes
   * - Default
     - *x*
     - No
   * - *x*
     - Default
     - Yes
   * - *x*
     - *x*
     - Yes
   * - *x*
     - *y* (where *y* > *x*)
     - Yes
   * - *x*
     - *y* (where *y* < *x*)
     - No

*Compatibility of liveliness QoS policies:*

.. list-table::
   :header-rows: 1

   * - Publisher
     - Subscription
     - Compatible
   * - Automatic
     - Automatic
     - Yes
   * - Automatic
     - Manual by topic
     - No
   * - Manual by topic
     - Automatic
     - Yes
   * - Manual by topic
     - Manual by topic
     - Yes

*Compatibility of lease duration QoS policies:*

  Assume *x* and *y* are arbitrary valid duration values.

.. list-table::
   :header-rows: 1

   * - Publisher
     - Subscription
     - Compatible
   * - Default
     - Default
     - Yes
   * - Default
     - *x*
     - No
   * - *x*
     - Default
     - Yes
   * - *x*
     - *x*
     - Yes
   * - *x*
     - *y* (where *y* > *x*)
     - Yes
   * - *x*
     - *y* (where *y* < *x*)
     - No

In order for a connection to be made, all of the policies that affect compatibility must be compatible.
For example, even if a requested and offered QoS profile pair has compatible reliability QoS policies, but they have incompatible durability QoS policies, a connection will still not be made.

When connections are not made, no messages will be passed between the publisher and subscription.
There are mechanisms to detect this situation, which will be covered in a later section.

Comparison to ROS 1
^^^^^^^^^^^^^^^^^^^

Historically in ROS 1, any publisher and subscriber with the same message type on the same topic would be connected.
The possibility of incompatible requested and offered QoS profiles is something new to be aware of when using ROS 2.


QoS events
----------

Some QoS policies have possible events related to them.
Developers may provide each publisher and subscription with callback functions that are triggered by these QoS events and handle them in a way they see fit, similar to how messages received on a topic are handled.

Developers may subscribe to the following QoS events that are associated with a publisher:

* Offered deadline missed

  The publisher has not published a message within the expected duration that was set out by the deadline QoS policy.

* Liveliness lost

  The publisher has failed to indicate its liveliness within the lease duration.

* Offered incompatible QoS

  The publisher has encountered a subscription on the same topic that is requesting a QoS profile that the offered QoS profile cannot satisfy, resulting in no connection between the publisher and that subscription.

Developers may subscribe to the following QoS events that are associated with a subscription:

* Requested deadline missed

  The subscription has not received a message within the expected duration that was set out by the deadline QoS policy.

* Liveliness changed

  The subscription has noticed that one or more publishers on the subscribed topic has failed to indicate their liveliness within the lease duration.

* Requested incompatible QoS

  The subscription has encountered a publisher on the same topic that is offering a QoS profile that does not satisfy the requested QoS profile, resulting in no connection between the subscription and that publisher.


Matched events
--------------

In addition to QoS events, matched events can be generated when any publisher and subscription establishes or drops the connection between them.
Developers may provide each publisher and subscription with callback functions that are triggered by matched events and handle them in a way they see fit, similar to how messages received on a topic are handled.

Developers can subscribe to this event with a publisher or a subscription.

* publisher: this event happens when it finds a subscription which matches the topic and has compatible QoS or a connected subscription is disconnected
* subscription: this event happens when it finds a publisher which matches the topic and has compatible QoS or a connected publisher is disconnected

There are demos showing how to use the event:

* rclcpp: `demo code <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_cpp/src/events/matched_event_detect.cpp>`__
* rclpy: `demo code <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/demo_nodes_py/demo_nodes_py/events/matched_event_detect.py>`__
",What are some of the possible events associated with Quality of Service (QoS) policies that developers may subscribe to for publishers and subscriptions in a ROS 2 system?
".. redirect-from::

   Concepts/About-Security

ROS 2 Security
==============

.. contents:: Table of Contents
   :local:

Overview
--------

ROS 2 includes the ability to secure communications among nodes within the ROS 2 computational graph.
Similar to discovery, security happens through the underlying ROS 2 middleware (provided it has support for the corresponding security plugins).
No additional software installation is needed to enable security; however, the middleware requires configuration files for each ROS graph participant.
These files enable encryption and authentication, and define policies both for individual nodes and for the overall ROS graph.
ROS 2 also adds a master ""on/off"" switch to control security behavior.

ROS utilities can create the authoritative `trust anchor <https://en.wikipedia.org/wiki/Trust_anchor>`_ for a ROS application, or an external certificate authority can be used.

Built-in ROS 2 security features enable control over communications throughout the ROS graph.
This not only allows for encrypting data in transit between ROS domain participants, but also enables authentication of participants sending data, ensures the integrity of data being sent, and enables domain-wide access controls.

ROS 2 security services are provided by the underlying `Data Distribution Service (DDS) <https://www.omg.org/spec/DDS/>`_ which is used for communications between nodes.
DDS vendors provide open source and commercial DDS implementations that work with ROS.
However, in order to create a specification-compliant implementation of DDS, all vendors must include security plugins as outlined in the `DDS Security Specification <https://www.omg.org/spec/DDS-SECURITY/About-DDS-SECURITY/>`_.
ROS security features take advantage of these DDS security plugins to provide policy-based encryption, authentication and access control.
DDS and ROS security is enabled through predefined configuration files and environment variables.


The Security Enclave
--------------------

A security enclave encapsulates a single policy for protecting ROS communications.
The enclave may set policy for multiple nodes, for an entire ROS graph, or any combination of protected ROS processes and devices.
Security enclaves can be flexibly mapped to processes, users, or devices at deployment.
Adjusting this default behavior becomes important for optimizing communications and for complex systems.
See the ROS 2 Security Enclaves `design document <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ for additional details.


Security Files
--------------

A `ROS 2 security enclave <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ is established with six files as outlined by the DDS specification.
Three of these files define an enclave's identity, while three other files define the permissions to be granted to the enclave.
All six files reside in a single directory, and nodes launched without a qualified enclave path use files in the default root level enclave.

Enclave Identity
^^^^^^^^^^^^^^^^

The Identity Certificate Authority file ``identity_ca.cert.pem`` acts as the trust anchor used to identify participants.
Each enclave also holds its unique identifying certificate in the file ``cert.pem``, and the associated private key in the file ``key.pem``.
Because the ``cert.pem`` certificate has been signed by identity certificate, when a participant presents this certificate to other domain members, they are able to validate the participant's identity using their own copy of the identity certificate.
This valid certificate exchange allows the enclave to securely establish trusted communications with other participants.
The enclave does not not share the ``key.pem`` private key, but only uses it for decryption and message signing.

Enclave Permissions
^^^^^^^^^^^^^^^^^^^

The Permissions Certificate Authority file ``permissions_ca.cert.pem`` serves as the trust anchor to grant permissions to security enclaves.
This certificate is used to create the signed file ``governance.p7s``, an XML document which defines domain-wide protection policies.
Similarly the XML file ``permissions.p7s`` outlines permissions of this particular enclave and has been signed by the Permissions CA.
Domain members use a copy of the permissions CA to validate these signed files and grant the requested access.

Although these two certificate authorities enable separate workflows for identity and permissions, often the same certificate serves as both the identity and the permissions authority.

Private Keys
^^^^^^^^^^^^

The identity and permissions certificates also have associated private key files.
Add new enclaves to the domain by signing their Certificate Signing Request (CSR) with the identity certificate's private key.
Similarly, grant permissions for a new enclave by signing a permissions XML document with the permission certificate's private key.


Security Environment Variables
------------------------------

The environment variable ``ROS_SECURITY_ENABLE`` acts as the enclave's master ""on/off"" switch for ROS 2 security features.
Security has been turned off by default, so security features will not be enabled even when the proper security files are present.
In order to enable ROS 2 security, set this environment variable to ``true`` (case sensitive).

Once security has been enabled, the environment variable ``ROS_SECURITY_STRATEGY`` defines how domain participants handle problems when launching participants.
Security features depend on certificates and properly signed configuration files, yet by default, an improperly configured participant will still launch successfully but without security features.
In order to enforce strict compliance with security settings and fail to launch non-compliant enclaves, set this environment variable to ``Enforce`` (case sensitive).

Additional security-related environment variables can be found in the `ROS 2 DDS-Security Integration design document <https://design.ros2.org/articles/ros2_dds_security.html>`_.
These variables generally assist ROS in managing enclaves and locating the security files.


Learn More
----------

For more information and hands-on exercises enabling ROS 2 communications security, see the :doc:`../../Tutorials/Advanced/Security/Introducing-ros2-security`.
",What is the purpose of the ROS 2 security enclave and how is it established?
".. redirect-from::

   Concepts/About-Tf2

Tf2
===

.. contents:: Table of Contents
   :local:

Overview
--------

tf2 is the transform library, which lets the user keep track of multiple coordinate frames over time.
tf2 maintains the relationship between coordinate frames in a tree structure buffered in time and lets the user transform points, vectors, etc. between any two coordinate frames at any desired point in time.

.. image:: ../images/ros2_tf2_frames.png

Properties of tf2
-----------------

A robotic system typically has many 3D coordinate frames that change over time, such as a world frame, base frame, gripper frame, head frame, etc.
tf2 keeps track of all these frames over time, and allows you to ask questions like:

* Where was the head frame relative to the world frame 5 seconds ago?
* What is the pose of the object in my gripper relative to my base?
* What is the current pose of the base frame in the map frame?

tf2 can operate in a distributed system.
This means all the information about the coordinate frames of a robot is available to all ROS 2 components on any computer in the system.
tf2 can have every component in your distributed system build its own transform information database or have a central node that gathers and stores all transform information.

Tutorials
---------

We created a set of :doc:`tutorials <../../Tutorials/Intermediate/Tf2/Tf2-Main>` that walks you through using tf2, step by step.
You can get started on the :doc:`introduction to tf2 <../../Tutorials/Intermediate/Tf2/Introduction-To-Tf2>` tutorial.
For a complete list of all tf2 and tf2-related tutorials check out the :doc:`tutorials <../../Tutorials/Intermediate/Tf2/Tf2-Main>` page.

There are essentially two main tasks that any user would use tf2 for, listening for transforms and broadcasting transforms.

If you want to use tf2 to transform between coordinate frames, your nodes will need to listen for transforms.
What you will do is receive and buffer all coordinate frames that are broadcasted in the system, and query for specific transforms between frames.
Check out the ""Writing a listener"" tutorial :doc:`(Python) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Py>` :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Cpp>` to learn more.

To extend the capabilities of a robot, you will need to start broadcasting transforms.
Broadcasting transforms means to send out the relative pose of coordinate frames to the rest of the system.
A system can have many broadcasters that each provide information about a different part of the robot.
Check out the ""Writing a broadcaster"" tutorial :doc:`(Python) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Py>` :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Cpp>` to learn more.

In addition to that, tf2 can broadcast static transforms that do not change over time.
This mainly saves storage and lookup time, but also reduces the publishing overhead.
You should note that static transforms are published once and assumed to not change, so no history is stored.
If you want to define static transforms in your tf2 tree, take a look at the ""Writing a static broadcaster"" :doc:`(Python) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Py>` :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Cpp>` tutorial.

You can also learn how to add fixed and dynamic frames to your tf2 tree in the ""Adding a frame"" :doc:`(Python) <../../Tutorials/Intermediate/Tf2/Adding-A-Frame-Py>` :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Adding-A-Frame-Cpp>` tutorial.

Once you are finished with the basic tutorials, you can move on to learn about tf2 and time.
The tf2 and time tutorial :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Cpp>` teaches the basic principles of tf2 and time.
The advanced tutorial about tf2 and time :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Cpp>` teaches the principles of time traveling with tf2.

Paper
-----

There is a paper on tf2 presented at TePRA 2013: `tf: The transform library <https://ieeexplore.ieee.org/abstract/document/6556373>`_.
",What is the purpose of tf2 in robotics systems and what kind of questions can you ask using it?
".. redirect-from::

    Logging
    Concepts/About-Logging

Logging and logger configuration
================================

.. contents:: Table of Contents
   :local:

Overview
--------

The logging subsystem in ROS 2 aims to deliver logging messages to a variety of targets, including:

* To the console (if one is attached)
* To log files on disk (if local storage is available)
* To the ``/rosout`` topic on the ROS 2 network

By default, log messages in ROS 2 nodes will go out to the console (on stderr), to log files on disk, and to the ``/rosout`` topic on the ROS 2 network.
All of the targets can be individually enabled or disabled on a per-node basis.

The rest of this document will go over some of the ideas behind the logging subsystem.

Severity level
--------------

Log messages have a severity level associated with them: ``DEBUG``, ``INFO``, ``WARN``, ``ERROR`` or ``FATAL``, in ascending order.

A logger will only process log messages with severity at or higher than a specified level chosen for the logger.

Each node has a logger associated with it that automatically includes the node's name and namespace.
If the node's name is externally remapped to something other than what is defined in the source code, it will be reflected in the logger name.
Non-node loggers can also be created that use a specific name.

Logger names represent a hierarchy.
If the level of a logger named ""abc.def"" is unset, it will defer to the level of its parent named ""abc"", and if that level is also unset, the default logger level will be used.
When the level of logger ""abc"" is changed, all of its descendants (e.g. ""abc.def"", ""abc.ghi.jkl"") will have their level impacted unless their level has been explicitly set.

APIs
----

These are the APIs that end users of the ROS 2 logging infrastructure should use, split up by client library.

.. tabs::

  .. group-tab:: C++

    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}`` - output the given printf-style message every time this line is hit
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_ONCE`` - output the given printf-style message only the first time this line is hit
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_EXPRESSION`` - output the given printf-style message only if the given expression is true
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_FUNCTION`` - output the given printf-style message only if the given function returns true
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST`` - output the given printf-style message all but the first time this line is hit
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_THROTTLE`` - output the given printf-style message no more than the given rate in integer milliseconds
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST_THROTTLE`` - output the given printf-style message no more than the given rate in integer milliseconds, but skip the first
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM`` - output the given C++ stream-style message every time this line is hit
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_ONCE`` - output the given C++ stream-style message only the first time this line is hit
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_EXPRESSION`` - output the given C++ stream-style message only if the given expression is true
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_FUNCTION`` - output the given C++ stream-style message only if the given function returns true
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST`` - output the given C++ stream-style message all but the first time this line is hit
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_THROTTLE`` - output the given C++ stream-style message no more than the given rate in integer milliseconds
    * ``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST_THROTTLE`` - output the given C++ stream-style message no more than the given rate in integer milliseconds, but skip the first

    Each of the above APIs takes an ``rclcpp::Logger`` object as the first argument.
    This can be pulled from the node API by calling ``node->get_logger()`` (recommended), or by constructing a stand-alone ``rclcpp::Logger`` object.

    * ``rcutils_logging_set_logger_level`` - Set the logging level for a particular logger name to the given severity level
    * ``rcutils_logging_get_logger_effective_level`` - Given a logger name, return the logger level (which may be unset)

  .. group-tab:: Python

    * ``logger.{debug,info,warning,error,fatal}`` - output the given Python string to the logging infrastructure.  The calls accept the following keyword args to control behavior:

      * ``throttle_duration_sec`` - if not None, the duration of the throttle interval in floating-point seconds
      * ``skip_first`` - if True, output the message all but the first time this line is hit
      * ``once`` - if True, only output the message the first time this line is hit

    * ``rclpy.logging.set_logger_level`` - Set the logging level for a particular logger name to the given severity level
    * ``rclpy.logging.get_logger_effective_level`` - Given a logger name, return the logger level (which may be unset)

Configuration
-------------

Since ``rclcpp`` and ``rclpy`` use the same underlying logging infrastructure, the configuration options are the same.

.. _logging-configuration-environment-variables:

Environment variables
^^^^^^^^^^^^^^^^^^^^^

The following environment variables control some aspects of the ROS 2 loggers.
For each of the environment settings, note that this is a process-wide setting, so it applies to all nodes in that process.

* ``ROS_LOG_DIR`` - Control the logging directory that is used for writing logging messages to disk (if that is enabled).  If non-empty, use the exact directory as specified in this variable.  If empty, use the contents of the ``ROS_HOME`` environment variable to construct a path of the form ``$ROS_HOME/.log``.  In all cases, the ``~`` character is expanded to the user's HOME directory.
* ``ROS_HOME`` - Control the home directory that is used for various ROS files, including logging and config files.  In the context of logging, this variable is used to construct a path to a directory for log files.  If non-empty, use the contents of this variable for the ROS_HOME path.  In all cases, the ``~`` character is expanded to the users's HOME directory.
* ``RCUTILS_LOGGING_USE_STDOUT`` - Control what stream output messages go to.  If this is unset or 0, use stderr.  If this is 1, use stdout.
* ``RCUTILS_LOGGING_BUFFERED_STREAM`` - Control whether the logging stream (as configured in ``RCUTILS_LOGGING_USE_STDOUT``) should be line buffered or unbuffered.  If this is unset, use the default of the stream (generally line buffered for stdout, and unbuffered for stderr).  If this is 0, force the stream to be unbuffered.  If this is 1, force the stream to be line buffered.
* ``RCUTILS_COLORIZED_OUTPUT`` - Control whether colors are used when outputting messages.  If unset, automatically determine based on the platform and whether the console is a TTY.  If 0, force disable using colors for output.  If 1, force enable using colors for output.
* ``RCUTILS_CONSOLE_OUTPUT_FORMAT`` - Control the fields that are output for each log message.  The available fields are:

  * ``{severity}`` - The severity level.
  * ``{name}`` - The name of the logger (may be empty).
  * ``{message}`` - The log message (may be empty).
  * ``{function_name}`` - The function name this was called from (may be empty).
  * ``{file_name}`` - The file name this was called from (may be empty).
  * ``{time}`` - The time in seconds since the epoch.
  * ``{time_as_nanoseconds}`` - The time in nanoseconds since the epoch.
  * ``{date_time_with_ms}`` - The time in ISO format, e.g. ``2024-06-11 09:29:19.304``
  * ``{line_number}`` - The line number this was called from (may be empty).

  If no format is given, a default of ``[{severity}] [{time}] [{name}]: {message}`` is used.

``RCUTILS_CONSOLE_OUTPUT_FORMAT`` also supports the following escape character syntax.

.. list-table::
    :header-rows: 1

    * - Escape character syntax
      - Character represented
    * - ``\a``
      - Alert
    * - ``\b``
      - Backspace
    * - ``\n``
      - New line
    * - ``\r``
      - Carriage return
    * - ``\t``
      - Horizontal tab

Node creation
^^^^^^^^^^^^^

When initializing a ROS 2 node, it is possible to control some aspects of the behavior via node options.
Since these are per-node options, they can be set differently for different nodes even when the nodes are composed into a single process.

* ``log_levels`` - The log level to use for a component within this particular node.  This can be set with the following: ``ros2 run demo_nodes_cpp talker --ros-args --log-level talker:=DEBUG``
* ``external_log_config_file`` - The external file to use to configure the backend logger.  If it is NULL, the default configuration will be used.  Note that the format of this file is backend-specific (and is currently unimplemented for the default backend logger of spdlog).  This can be set with the following: ``ros2 run demo_nodes_cpp talker --ros-args --log-config-file log-config.txt``
* ``log_stdout_disabled`` - Whether to disable writing log messages to the console.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-stdout-logs``
* ``log_rosout_disabled`` - Whether to disable writing log messages out to ``/rosout``.  This can significantly save on network bandwidth, but external observers will not be able to monitor logging.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-rosout-logs``
* ``log_ext_lib_disabled`` - Whether to completely disable the use of an external logger.  This may be faster in some cases, but means that logs will not be written to disk.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-external-lib-logs``

Logging subsystem design
------------------------

The image below shows the five main pieces to the logging subsystem and how they interact.

.. figure:: ../images/ros2_logging_architecture.png
   :alt: ROS 2 logging architecture
   :width: 550px
   :align: center

rcutils
^^^^^^^

``rcutils`` has a logging implementation that can format log messages according to a certain format (see ``Configuration`` above), and output those log messages to a console.
``rcutils`` implements a complete logging solution, but allows higher-level components to insert themselves into the logging infrastructure in a dependency-injection model.
This will become more evident when we talk about the ``rcl`` layer below.

Note that this is a *per-process* logging implementation, so anything that is configured at this level will affect the entire process, not just individual nodes.

rcl_logging_spdlog
^^^^^^^^^^^^^^^^^^

``rcl_logging_spdlog`` implements the ``rcl_logging_interface`` API, and thus provides external logging services to the ``rcl`` layer.
In particular, the ``rcl_logging_spdlog`` implementation takes formatted log messages and writes them out to log files on disk using the ``spdlog`` library, typically within ``~/.ros/log`` (though this is configurable; see ``Configuration`` above).

rcl
^^^

The logging subsystem in ``rcl`` uses ``rcutils`` and ``rcl_logging_spdlog`` to provide the bulk of the ROS 2 logging services.
When log messages come in, ``rcl`` decides where to send them.
There are 3 main places that logging messages can be delivered; an individual node may have any combination of them enabled:

* To the console via the ``rcutils`` layer
* To disk via the ``rcl_logging_spdlog`` layer
* To the ``/rosout`` topic on the ROS 2 network via the RMW layer

rclcpp
^^^^^^

This is the main ROS 2 C++ API which sits atop the ``rcl`` API.
In the context of logging, ``rclcpp`` provides the ``RCLCPP_`` logging macros; see ``APIs`` above for a complete list.
When one of the ``RCLCPP_`` macros runs, it checks the current severity level of the node against the severity level of the macro.
If the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured.
Note that ``rclcpp`` uses a global mutex for log calls, so all logging calls within the same process end up being single-threaded.


rclpy
^^^^^

This is the main ROS 2 Python API which sits atop the ``rcl`` API.
In the context of logging, ``rclpy`` provides the ``logger.debug``-style functions; see ``APIs`` above for a complete list.
When one of the ``logger.debug`` functions runs, it checks the current severity level of the node against the severity level of the macro.
If the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured.


Logging usage
-------------

.. tabs::

  .. group-tab:: C++

    * See the `rclcpp logging demo <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/logging_demo>`_ for some simple examples.
    * See the :doc:`logging demo <../../Tutorials/Demos/Logging-and-logger-configuration>` for example usage.

  .. group-tab:: Python

    * See the `rclpy examples <https://github.com/ros2/examples/blob/{REPOS_FILE_BRANCH}/rclpy/services/minimal_client/examples_rclpy_minimal_client/client.py>`__ for example usage of a node's logger.
    * See the `rclpy tests <https://github.com/ros2/rclpy/blob/{REPOS_FILE_BRANCH}/rclpy/test/test_logging.py>`__ for example usage of keyword arguments (e.g. ``skip_first``, ``once``).
","What environment variables control some aspects of the ROS 2 loggers, and how are they set for process-wide application?"
".. redirect-from::

    About-Topic-Statistics
    Concepts/About-Topic-Statistics

Topic statistics
================

.. contents:: Table of Contents
   :local:

Overview
--------

ROS 2 provides integrated measurement of statistics for messages received by any subscription.
Allowing a user to collect subscription statistics enables them to characterize the performance of their system or aid in diagnosis of any present issues.

The measurements provided are the received message age and received message period.
For each measurement the statistics provided are the average, maximum, minimum, standard deviation, and sample count.
These statistics are calculated in a moving window.

How statistics are calculated
-----------------------------

Each statistic set is calculated in constant time and constant memory by using the utilities implemented in the `libstatistics_collector <https://github.com/ros-tooling/libstatistics_collector>`__ package.
When a new message is received by a subscription, this is a new sample for calculation in the current measurement window.
The average calculated is simply a `moving average <https://en.wikipedia.org/wiki/Moving_average>`__.
The maximum, minimum, and sample count are updated upon receipt of each new sample, whereas the standard deviation is calculated using `Welford's online algorithm <https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm>`__.

Types of statistics calculated
------------------------------

* Received message period

  * Units: milliseconds
  * Uses the system clock to measure the period between received messages

* Received message age

  * Units: milliseconds
  * Requires a message to have a timestamp populated in the header field in order to calculate the age of the message as sent from a publisher

Behavior
--------

By default, Topic Statistics measurements are not enabled.
After enabling this feature for a specific node via the subscription configuration options, both received message age and received message period measurements are enabled for that specific subscription.

The data is published as a `statistics_msg/msg/MetricsMessage
<https://github.com/ros2/rcl_interfaces/blob/{REPOS_FILE_BRANCH}/statistics_msgs/msg/MetricsMessage.msg>`__ at a configurable period (default 1 second) to a configurable topic (default ``/statistics``).
Note that the publishing period also serves as the sample collection window period.

Since received message period requires a message timestamp in a header field, empty data is published.
That is, all statistics values are NaN if no timestamp is found.
Publishing NaN values instead of not publishing at all avoids the absence of a signal problem and is meant to explicitly show that a measurement could not be made.

The first sample of each window for the received message period statistic does not yield a measurement.
This is because calculating this statistic requires knowing the time the previous message arrived, so subsequent samples in the window yield measurements.

Comparison to ROS 1
-------------------

Similar to ROS 1 `Topic Statistics <https://wiki.ros.org/Topics#Topic_statistics>`__, both message age and message period are calculated, albeit from the subscription side.
Other ROS 1 metrics, e.g., the number of dropped messages or traffic volume, are currently not provided.

Support
-------

This feature is currently supported in ROS 2 Foxy for C++ only (rclcpp).
Future work and improvements, such as Python support, can be found
`here <https://github.com/ros2/ros2/issues/917>`__.
",What types of statistics are calculated for each measurement in ROS 2 Topic Statistics and how are they calculated?
".. redirect-from::

   Concepts/About-Domain-ID

The ROS_DOMAIN_ID
=================

.. contents:: Table of Contents
   :local:

Overview
--------

As explained elsewhere, the default middleware that ROS 2 uses for communication is DDS.
In DDS, the primary mechanism for having different logical networks share a physical network is known as the Domain ID.
ROS 2 nodes on the same domain can freely discover and send messages to each other, while ROS 2 nodes on different domains cannot.
All ROS 2 nodes use domain ID 0 by default.
To avoid interference between different groups of computers running ROS 2 on the same network, a different domain ID should be set for each group.

Choosing a domain ID (short version)
------------------------------------

The text below explains the derivation of the range of domain IDs that should be used in ROS 2.
To skip that background and just choose a safe number, simply choose a domain ID between 0 and 101, inclusive.


Choosing a domain ID (long version)
-----------------------------------

The domain ID is used by DDS to compute the UDP ports that will be used for discovery and communication.
See `this article <https://community.rti.com/content/forum-topic/statically-configure-firewall-let-omg-dds-traffic-through>`__ for details on how the ports are computed.
Remembering our basic networking, the UDP port is an `unsigned 16-bit integer <https://en.wikipedia.org/wiki/User_Datagram_Protocol#Ports>`__.
Thus, the highest port number that can be allocated is 65535.
Doing some math with the formula in the article above, this means that the highest domain ID that can possibly be assigned is 232, while the lowest that can be assigned is 0.

Platform-specific constraints
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For maximum compatibility, some additional platform-specific constraints should be followed when choosing a domain ID.
In particular, it is best to avoid allocating domain IDs in the operating system's `ephemeral port range <https://en.wikipedia.org/wiki/Ephemeral_port>`__.
This avoids possible conflicts between the ports used by the ROS 2 nodes and other networking services on the computers.

Here are some platform-specific notes about ephemeral ports.

.. tabs::

   .. group-tab:: Linux

     By default, the Linux kernel uses ports 32768-60999 for ephemeral ports.
     This means that domain IDs 0-101 and 215-232 can be safely used without colliding with ephemeral ports.
     The ephemeral port range is configurable in Linux by setting custom values in ``/proc/sys/net/ipv4/ip_local_port_range``.
     If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly.

   .. group-tab:: macOS

     By default, the ephemeral port range on macOS is 49152-65535.
     This means that domain IDs 0-166 can be safely used without colliding with ephemeral ports.
     The ephemeral port range is configurable in macOS by setting custom sysctl values for ``net.inet.ip.portrange.first`` and ``net.inet.ip.portrange.last``.
     If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly.

   .. group-tab:: Windows

     By default, the ephemeral port range on Windows is 49152-65535.
     This means that domain IDs 0-166 can be safely used without colliding with ephemeral ports.
     The ephemeral port range is configurable in Windows by `using netsh <https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/default-dynamic-port-range-tcpip-chang>`__.
     If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly.

Participant constraints
^^^^^^^^^^^^^^^^^^^^^^^

For each ROS 2 process running on a computer, one DDS ""participant"" is created.
Since each DDS participant takes up two ports on the computer, running more than 120 ROS 2 processes on one computer may spill over into other domain IDs or the ephemeral ports.

To see why, consider the domain IDs 1 and 2.

- Domain ID 1 uses port 7650 and 7651 for multicast.
- Domain ID 2 uses port 7900 and 7901 for multicast.
- When creating the 1st process (zeroth participant) in domain ID 1, the ports 7660 and 7661 are used for unicast.
- When creating the 120th process (119th participant) in domain ID 1, the ports 7898 and 7899 are used for unicast.
- When creating the 121st process (120th participant) in domain ID 1, the ports 7900 and 7901 are used for unicast and overlap with domain ID 2.

If it is known that the computer will only ever be on a single domain ID at a time, and the domain ID is low enough, it is safe to create more ROS 2 processes than this.

When choosing a domain ID that is near the top of the range of platform-specific domain IDs, one additional constraint should be considered.

For instance, assume a Linux computer with a domain ID of 101:

- The zero'th ROS 2 process on the computer will connect to ports 32650, 32651, 32660, and 32661.
- The first ROS 2 process on the computer will connect to ports 32650, 32651, 32662, and 32663.
- The 53rd ROS 2 process on the computer will connect to ports 32650, 32651, 32766, and 32767.
- The 54th ROS 2 process on the computer will connect to ports 32650, 32651, 32768, and 32769, running into the ephemeral port range.

Thus the maximum number of processes that should be created when using domain ID 101 on Linux is 54.
Similarly, the maximum number of processes that should be created when using domain ID 232 on Linux is 63, as the maximum port number is 65535.

The situation is similar on macOS and Windows, though the numbers are different.
On macOS and Windows, when choosing a domain ID of 166 (the top of the range), the maximum number of ROS 2 processes that can be created on a computer before running into the ephemeral port range is 120.

Domain ID to UDP Port Calculator
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. raw:: html

    <table>
      <tr>
        <td style=""text-align: right; vertical-align: middle;""><label>Domain ID:</label></td>
        <td><input type=""number"" min=""0"" max=""232"" size=""3"" class=""display"" value=""0"" id=""domainID"" onChange=""calculate(this.value)""/></td>
      </tr>
      <tr>
        <td style=""text-align: right; vertical-align: middle;""><label>Participant ID:</label></td>
        <td><input type=""number"" min=""0"" size=""3"" class=""display"" value=""0"" id=""participantID"" onChange=""calculate(this.value)""/></td>
      </tr>
    </table>
    <hr/>
    <table>
      <tr>
        <td style=""text-align: right; vertical-align: middle;""><label>Discovery Multicast Port:</label></td>
        <td><input type=""text"" size=""5"" class=""discoveryMulticastPort"" disabled/></td>
      </tr>
      <tr>
        <td style=""text-align: right; vertical-align: middle;""><label>User Multicast Port:</label></td>
        <td><input type=""text"" size=""5"" class=""userMulticastPort"" disabled/></td>
      </tr>
      <tr>
        <td style=""text-align: right; vertical-align: middle;""><label>Discovery Unicast Port:</label></td>
        <td><input type=""text"" size=""5"" class=""discoveryUnicastPort"" disabled/></td>
      </tr>
      <tr>
        <td style=""text-align: right; vertical-align: middle;""><label>User Unicast Port:</label></td>
        <td><input type=""text"" size=""5"" class=""userUnicastPort"" disabled/></td>
      </tr>
    </table>
    <br/>
    <br/>

    <script type=""text/javascript"">
      window.addEventListener('load', (event) => {
         calculate(event);
      });
      const discoveryMcastPort = document.querySelector('.discoveryMulticastPort');
      const userMcastPort = document.querySelector('.userMulticastPort');
      const discoveryUnicastPort = document.querySelector('.discoveryUnicastPort');
      const userUnicastPort = document.querySelector('.userUnicastPort');

      const domainID = document.getElementById('domainID');
      const participantID = document.getElementById('participantID');

      // calculate function
      function calculate(event) {
        const d0 = 0;
        const d2 = 1;
        const d1 = 10;
        const d3 = 11;
        const PB = 7400;
        const DG = 250;
        const PG = 2;

        discoveryMcastPort.value = PB + (DG * domainID.value) + d0;
        userMcastPort.value = PB + (DG * domainID.value) + d2;
        discoveryUnicastPort.value = PB + (DG * domainID.value) + d1 + (PG * participantID.value);
        userUnicastPort.value = PB + (DG * domainID.value) + d3 + (PG * participantID.value);
      }
    </script>
",What is the purpose of the Domain ID in ROS 2 communication and what considerations should be made when choosing one?
".. redirect-from::

   Concepts/About-Cross-Compilation

Cross-compilation
=================

.. contents:: Table of Contents
   :local:

Overview
--------

Open Robotics provides pre-built ROS 2 packages for multiple platforms, but a number of developers still rely on `cross-compilation <https://en.wikipedia.org/wiki/Cross_compiler>`__ for different reasons such as:
 - The development machine does not match the target system.
 - Tuning the build for specific core architecture (e.g. setting -mcpu=cortex-a53 -mfpu=neon-fp-armv8 when building for Raspberry Pi3).
 - Targeting a file system other than the ones supported by the pre-built images released by Open Robotics.

How does it work ?
------------------

Cross-compiling simple software (e.g. no dependencies on external libraries) is relatively simple and only requiring a cross-compiler toolchain to be used instead of the native toolchain.

There are a number of factors which make this process more complex:
 - The software being built must support the target architecture. Architecture specific code must be properly isolated and enabled during the build according to the target architecture. Examples include assembly code.
 - All dependencies (e.g. libraries) must be present, either as pre-built or cross-compiled packages, before the target software using them is cross-compiled.
 - When building software stacks (as opposed to standalone software) using build tools (e.g. colcon), it is expected that the build tool provides a mechanism to allow the developer to enable cross-compilation on the underlying build system used by each piece of software in the stack.

Alternatives
------------

An alternative to cross-compilation is to `build multi-platform Docker images <https://github.com/docker/buildx#building-multi-platform-images>`__ using ``docker buildx``.
",How can developers enable cross-compilation for software stacks when using build tools like colcon?
".. redirect-from::

    DDS-and-ROS-middleware-implementations
    Concepts/About-Different-Middleware-Vendors

Different ROS 2 middleware vendors
==================================

.. contents:: Table of Contents
   :local:

ROS 2 is built on top of DDS/RTPS as its middleware, which provides discovery, serialization and transportation.
`This article <https://design.ros2.org/articles/ros_on_dds.html>`__ explains the motivation behind using DDS implementations, and/or the RTPS wire protocol of DDS, in detail.
In summary, DDS is an end-to-end middleware that provides features which are relevant to ROS systems, such as distributed discovery (not centralized like in ROS 1) and control over different ""Quality of Service"" options for the transportation.

`DDS <https://www.omg.org/omg-dds-portal>`__ is an industry standard which is implemented by a range of vendors, such as RTI's `Connext DDS <https://www.rti.com/products/>`__, eProsima's `Fast DDS <https://fast-dds.docs.eprosima.com/>`__, Eclipse's `Cyclone DDS <https://projects.eclipse.org/projects/iot.cyclonedds>`__, or GurumNetworks's `GurumDDS <https://gurum.cc/index_eng>`__.
RTPS (a.k.a. `DDSI-RTPS <https://www.omg.org/spec/DDSI-RTPS/About-DDSI-RTPS/>`__\ ) is the wire protocol used by DDS to communicate over the network.

ROS 2 supports multiple DDS/RTPS implementations because it is not necessarily ""one size fits all"" when it comes to choosing a vendor/implementation.
There are many factors you might consider while choosing a middleware implementation: logistical considerations like the license, or technical considerations like platform availability, or computation footprint.
Vendors may provide more than one DDS or RTPS implementation targeted at meeting different needs.
For example, RTI has a few variations of their Connext implementation that vary in purpose, like one that specifically targets microcontrollers and another which targets applications requiring special safety certifications (we only support their standard desktop version at this time).

In order to use a DDS/RTPS implementation with ROS 2, a ""\ **R**\ OS **M**\ iddle\ **w**\ are interface"" (a.k.a. ``rmw`` interface or just ``rmw``\ ) package needs to be created that implements the abstract ROS middleware interface using the DDS or RTPS implementation's API and tools.
It's a lot of work to implement and maintain RMW packages for supporting DDS implementations, but supporting at least a few implementations is important for ensuring that the ROS 2 codebase is not tied to any one particular implementation, as users may wish to switch out implementations depending on their project's needs.

Supported RMW implementations
-----------------------------

.. list-table::
   :header-rows: 1

   * - Product name
     - License
     - RMW implementation
     - Status
   * - eProsima *Fast DDS*
     - Apache 2
     - ``rmw_fastrtps_cpp``
     - Full support. Default RMW. Packaged with binary releases.
   * - Eclipse *Cyclone DDS*
     - Eclipse Public License v2.0
     - ``rmw_cyclonedds_cpp``
     - Full support. Packaged with binary releases.
   * - RTI *Connext DDS*
     - commercial, research
     - ``rmw_connextdds``
     - Full support. Support included in binaries, but Connext installed separately.
   * - GurumNetworks *GurumDDS*
     - commercial
     - ``rmw_gurumdds_cpp``
     - Community support. Support included in binaries, but GurumDDS installed separately.

For practical information on working with multiple RMW implementations, see the :doc:`""Working with multiple RMW implementations"" <../../How-To-Guides/Working-with-multiple-RMW-implementations>` tutorial.

Multiple RMW implementations
----------------------------

The ROS 2 binary releases for currently active distros have built-in support for several RMW implementations out of the box (Fast DDS, RTI Connext Pro, Eclipse Cyclone DDS, GurumNetworks GurumDDS).
The default is Fast DDS, which works without any additional installation steps because we distribute it with our binary packages.

Other RMWs like Cyclone DDS, Connext or GurumDDS can be enabled by :doc:`installing additional packages <../../Installation/DDS-Implementations>`, but without having to rebuild anything or replace any existing packages.

A ROS 2 workspace that has been built from source may build and install multiple RMW implementations simultaneously.
While the core ROS 2 code is being compiled, any RMW implementation that is found will be built if the relevant DDS/RTPS implementation has been installed properly and the relevant environment variables have been configured.
For example, if the code for the `RMW package for RTI Connext DDS <https://github.com/ros2/rmw_connextdds>`__ is in the workspace, it will be built if an installation of RTI's Connext Pro can also be found.

For many cases you will find that nodes using different RMW implementations are able to communicate, however this is not true under all circumstances.
Here is a list of inter-vendor communication configurations that are not supported:

- Fast DDS <-> Connext
   - ``WString`` published by Fast DDS can't be received correctly by Connext on macOS
- Connext <-> Cyclone DDS
   - does not support pub/sub communication for ``WString``

Default RMW implementation
--------------------------

If a ROS 2 workspace has multiple RMW implementations, Fast DDS is selected as the default RMW implementation if it is available.
If the Fast DDS RMW implementation is not installed, the RMW implementation with the first RMW implementation identifier in alphabetical order will be used.
The implementation identifier is the name of the ROS package that provides the RMW implementation, e.g. ``rmw_cyclonedds_cpp``.
For example, if both ``rmw_cyclonedds_cpp`` and ``rmw_connextdds`` ROS packages are installed, ``rmw_connextdds`` would be the default.
If ``rmw_fastrtps_cpp`` is ever installed, it would be the default.

See the :doc:`guide <../../How-To-Guides/Working-with-multiple-RMW-implementations>` for how to specify which RMW implementation is to be used when running the ROS 2 examples.

Cross-Vendor Communication
--------------------------

While different RMW implementations may be compatible in limited circumstances, this is not guaranteed.
Thus it is suggested that users ensure that all parts of the distributed system are using the same ROS version and the same RMW implementation.
",What are some factors to consider when choosing a middleware implementation for ROS 2?
".. redirect-from::

   Concepts/About-Composition

Composition
===========

.. contents:: Table of Contents
   :local:

ROS 1 - Nodes vs. Nodelets
--------------------------

In ROS 1 you can write your code either as a `ROS node <https://wiki.ros.org/Nodes>`__ or as a `ROS nodelet <https://wiki.ros.org/nodelet>`__.
ROS 1 nodes are compiled into executables.
ROS 1 nodelets on the other hand are compiled into a shared library which is then loaded at runtime by a container process.

ROS 2 - Unified API
-------------------

In ROS 2 the recommended way of writing your code is similar to a nodelet - we call it a ``Component``.
This makes it easy to add common concepts to existing code, like a `life cycle <https://design.ros2.org/articles/node_lifecycle.html>`__.
Having different APIs, which was the biggest drawback in ROS 1, is avoided in ROS 2 since both approaches use the same API.

.. note::

   It is still possible to use the node-like style of ""writing your own main"" but for the common case it is not recommended.

By making the process layout a deploy-time decision the user can choose between:

* running multiple nodes in separate processes with the benefits of process/fault isolation as well as easier debugging of individual nodes and
* running multiple nodes in a single process with the lower overhead and optionally more efficient communication (see :doc:`Intra Process Communication <../../Tutorials/Demos/Intra-Process-Communication>`).

Additionally ``ros2 launch`` can be used to automate these actions through specialized launch actions.

Writing a Component
-------------------

Since a component is only built into a shared library, it doesn't have a ``main`` function (see `Talker source code <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/composition/src/talker_component.cpp>`__).
A component is commonly a subclass of ``rclcpp::Node``.
Since it is not in control of the thread, it shouldn't perform any long running or blocking tasks in its constructor.
Instead, it can use timers to get periodic notifications.
Additionally, it can create publishers, subscriptions, servers, and clients.

An important aspect of making such a class a component is that the class registers itself using macros from the package ``rclcpp_components`` (see the last line in the source code).
This makes the component discoverable when its library is being loaded into a running process - it acts as kind of an entry point.

Additionally, once a component is created, it must be registered with the index to be discoverable by the tooling.

.. code-block:: cmake

   add_library(talker_component SHARED src/talker_component.cpp)
   rclcpp_components_register_nodes(talker_component ""composition::Talker"")
   # To register multiple components in the same shared library, use multiple calls
   # rclcpp_components_register_nodes(talker_component ""composition::Talker2"")

For an example, :doc:`check out this tutorial <../../Tutorials/Intermediate/Writing-a-Composable-Node>`

.. note::

   In order for the component_container to be able to find desired components, it must be executed or launched from a shell that has sourced the corresponding workspace.

Using Components
----------------

The `composition <https://github.com/ros2/demos/tree/{REPOS_FILE_BRANCH}/composition>`__ package contains a couple of different approaches on how to use components.
The three most common ones are:

#. Start a (`generic container process <https://github.com/ros2/rclcpp/blob/{REPOS_FILE_BRANCH}/rclcpp_components/src/component_container.cpp>`__) and call the ROS service `load_node <https://github.com/ros2/rcl_interfaces/blob/{REPOS_FILE_BRANCH}/composition_interfaces/srv/LoadNode.srv>`__ offered by the container.
   The ROS service will then load the component specified by the passed package name and library name and start executing it within the running process.
   Instead of calling the ROS service programmatically you can also use a `command line tool <https://github.com/ros2/ros2cli/tree/{REPOS_FILE_BRANCH}/ros2component>`__ to invoke the ROS service with the passed command line arguments
#. Create a `custom executable <https://github.com/ros2/demos/blob/{REPOS_FILE_BRANCH}/composition/src/manual_composition.cpp>`__ containing multiple nodes which are known at compile time.
   This approach requires that each component has a header file (which is not strictly needed for the first case).
#. Create a launch file and use ``ros2 launch`` to create a container process with multiple components loaded.

Practical application
---------------------

Try the :doc:`Composition demos <../../Tutorials/Intermediate/Composition>`.
",What are the differences between ROS 1 nodes and nodelets in terms of compilation and execution processes?
".. redirect-from::

   Concepts/About-Executors

Executors
=========

.. contents:: Table of Contents
   :local:

Overview
--------

Execution management in ROS 2 is handled by Executors.
An Executor uses one or more threads of the underlying operating system to invoke the callbacks of subscriptions, timers, service servers, action servers, etc. on incoming messages and events.
The explicit Executor class (in `executor.hpp <https://github.com/ros2/rclcpp/blob/{REPOS_FILE_BRANCH}/rclcpp/include/rclcpp/executor.hpp>`_ in rclcpp, in `executors.py <https://github.com/ros2/rclpy/blob/{REPOS_FILE_BRANCH}/rclpy/rclpy/executors.py>`_ in rclpy, or in `executor.h <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_ in rclc) provides more control over execution management than the spin mechanism in ROS 1, although the basic API is very similar.

In the following, we focus on the C++ Client Library *rclcpp*.

Basic use
---------

In the simplest case, the main thread is used for processing the incoming messages and events of a Node by calling ``rclcpp::spin(..)`` as follows:

.. code-block:: cpp

   int main(int argc, char* argv[])
   {
      // Some initialization.
      rclcpp::init(argc, argv);
      ...

      // Instantiate a node.
      rclcpp::Node::SharedPtr node = ...

      // Run the executor.
      rclcpp::spin(node);

      // Shutdown and exit.
      ...
      return 0;
   }

The call to ``spin(node)`` basically expands to an instantiation and invocation of the Single-Threaded Executor, which is the simplest Executor:

.. code-block:: cpp

   rclcpp::executors::SingleThreadedExecutor executor;
   executor.add_node(node);
   executor.spin();

By invoking ``spin()`` of the Executor instance, the current thread starts querying the rcl and middleware layers for incoming messages and other events and calls the corresponding callback functions until the node shuts down.
In order not to counteract the QoS settings of the middleware, an incoming message is not stored in a queue on the Client Library layer but kept in the middleware until it is taken for processing by a callback function.
(This is a crucial difference to ROS 1.)
A *wait set* is used to inform the Executor about available messages on the middleware layer, with one binary flag per queue.
The *wait set* is also used to detect when timers expire.

.. image:: ../images/executors_basic_principle.png

The Single-Threaded Executor is also used by the container process for :doc:`components <./About-Composition>`, i.e. in all cases where nodes are created and executed without an explicit main function.

Types of Executors
------------------

Currently, rclcpp provides three Executor types, derived from a shared parent class:

.. graphviz::

   digraph Flatland {

      Executor -> SingleThreadedExecutor [dir = back, arrowtail = empty];
      Executor -> MultiThreadedExecutor [dir = back, arrowtail = empty];
      Executor -> StaticSingleThreadedExecutor [dir = back, arrowtail = empty];
      Executor  [shape=polygon,sides=4];
      SingleThreadedExecutor  [shape=polygon,sides=4];
      MultiThreadedExecutor  [shape=polygon,sides=4];
      StaticSingleThreadedExecutor  [shape=polygon,sides=4];

      }

The *Multi-Threaded Executor* creates a configurable number of threads to allow for processing multiple messages or events in parallel.

.. note::

   The *Static Single-Threaded Executor* has been deprecated, and *Single-Threaded Executor* is recommended instead.
   The *Static Single-Threaded Executor* was developed to reduce the the runtime costs for scanning the entities of a node in terms of subscriptions, timers, service servers, action servers, etc.
   These runtime improvements are now available also in all the other *Executor*.
   Besides, the *Static Single-Threaded Executor* has a few issues such as `max duration is not respected in spin_some <https://github.com/ros2/rclcpp/issues/2462>`__.
   Because of these unstable issues, some unit tests are skipped for *Static Single-Threaded Executor*.
   You can see more details for `ROS Discourse: The ROS 2 C++ Executors <https://discourse.ros.org/t/the-ros-2-c-executors/38296>`__.

All three executors can be used with multiple nodes by calling ``add_node(..)`` for each node.

.. code-block:: cpp

   rclcpp::Node::SharedPtr node1 = ...
   rclcpp::Node::SharedPtr node2 = ...
   rclcpp::Node::SharedPtr node3 = ...

   rclcpp::executors::SingleThreadedExecutor executor;
   executor.add_node(node1);
   executor.add_node(node2);
   executor.add_node(node3);
   executor.spin();

In the above example, the one thread of a Single-Threaded Executor is used to serve three nodes together.
In case of a Multi-Threaded Executor, the actual parallelism depends on the callback groups.

Callback groups
---------------

ROS 2 allows organizing the callbacks of a node in groups.
In rclcpp, such a *callback group* can be created by the ``create_callback_group`` function of the Node class.
In rclpy, the same is done by calling the constructor of the specific callback group type.
The callback group must be stored throughout execution of the node (eg. as a class member), or otherwise the executor won't be able to trigger the callbacks.
Then, this callback group can be specified when creating a subscription, timer, etc. - for example by the subscription options:

.. tabs::

   .. group-tab:: C++

      .. code-block:: cpp

        my_callback_group = create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);

        rclcpp::SubscriptionOptions options;
        options.callback_group = my_callback_group;

        my_subscription = create_subscription<Int32>(""/topic"", rclcpp::SensorDataQoS(),
                                                     callback, options);
   .. group-tab:: Python

      .. code-block:: python

        my_callback_group = MutuallyExclusiveCallbackGroup()
        my_subscription = self.create_subscription(Int32, ""/topic"", self.callback, qos_profile=1,
                                                   callback_group=my_callback_group)

All subscriptions, timers, etc. that are created without the indication of a callback group are assigned to the *default callback group*.
The default callback group can be queried via ``NodeBaseInterface::get_default_callback_group()`` in rclcpp
and by ``Node.default_callback_group`` in rclpy.

There are two types of callback groups, where the type has to be specified at instantiation time:

* *Mutually exclusive:* Callbacks of this group must not be executed in parallel.
* *Reentrant:* Callbacks of this group may be executed in parallel.

Callbacks of different callback groups may always be executed in parallel.
The Multi-Threaded Executor uses its threads as a pool to process as many callbacks as possible in parallel according to these conditions.
For tips on how to use callback groups efficiently, see :doc:`Using Callback Groups <../../How-To-Guides/Using-callback-groups>`.

The Executor base class in rclcpp also has the function ``add_callback_group(..)``, which allows distributing callback groups to different Executors.
By configuring the underlying threads using the operating system scheduler, specific callbacks can be prioritized over other callbacks.
For example, the subscriptions and timers of a control loop can be prioritized over all other subscriptions and standard services of a node.
The `examples_rclcpp_cbg_executor package <https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclcpp/executors/cbg_executor>`_ provides a demo of this mechanism.

Scheduling semantics
--------------------

If the processing time of the callbacks is shorter than the period with which messages and events occur, the Executor basically processes them in FIFO order.
However, if the processing time of some callbacks is longer, messages and events will be queued on the lower layers of the stack.
The wait set mechanism reports only very little information about these queues to the Executor.
In detail, it only reports whether there are any messages for a certain topic or not.
The Executor uses this information to process the messages (including services and actions) in a round-robin fashion - but not in FIFO order.
The following flow diagram visualizes this scheduling semantics.

.. image:: ../images/executors_scheduling_semantics.png

This semantics was first described in a `paper by Casini et al. at ECRTS 2019 <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_.
(Note: The paper also explains that timer events are prioritized over all other messages. `This prioritization was removed in Eloquent. <https://github.com/ros2/rclcpp/pull/841>`_)


Outlook
-------

While the three Executors of rclcpp work well for most applications, there are some issues that make them not suitable for real-time applications, which require well-defined execution times, determinism, and custom control over the execution order.
Here is a summary of some of these issues:

1. Complex and mixed scheduling semantics.
   Ideally you want well defined scheduling semantics to perform a formal timing analysis.
2. Callbacks may suffer from priority inversion.
   Higher priority callbacks may be blocked by lower priority callbacks.
3. No explicit control over the callbacks execution order.
4. No built-in control over triggering for specific topics.

Additionally, the executor overhead in terms of CPU and memory usage is considerable.

These issues have been partially addressed by the following developments:

* `rclcpp WaitSet <https://github.com/ros2/rclcpp/blob/{REPOS_FILE_BRANCH}/rclcpp/include/rclcpp/wait_set.hpp>`_: The ``WaitSet`` class of rclcpp allows waiting directly on subscriptions, timers, service servers, action servers, etc. instead of using an Executor.
  It can be used to implement deterministic, user-defined processing sequences, possibly processing multiple messages from different subscriptions together.
  The `examples_rclcpp_wait_set package <https://github.com/ros2/examples/tree/{REPOS_FILE_BRANCH}/rclcpp/wait_set>`_ provides several examples for the use of this user-level wait set mechanism.
* `rclc Executor <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_: This Executor from the C Client Library *rclc*, developed for micro-ROS, gives the user fine-grained control over the execution order of callbacks and allows for custom trigger conditions to activate callbacks.
  Furthermore, it implements ideas of the Logical Execution Time (LET) semantics.

Further information
-------------------

* Michael Pöhnl et al.: `""ROS 2 Executor: How to make it efficient, real-time and deterministic?"" <https://www.apex.ai/roscon-21>`_. Workshop at ROS World 2021. Virtual event. 19 October 2021.
* Ralph Lange: `""Advanced Execution Management with ROS 2"" <https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. ROS Industrial Conference. Virtual event. 16 December 2020.
* Daniel Casini, Tobias Blass, Ingo Lütkebohle, and Björn Brandenburg: `“Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling” <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_, Proc. of 31st ECRTS 2019, Stuttgart, Germany, July 2019.
",What are some issues that make the current Executors in ROS 2 not suitable for real-time applications?
".. redirect-from::

  ROSCon-Content

.. _ROSCon:

ROSCon Talks
============

The following `ROSCon <https://roscon.ros.org>`__ talks have been given on ROS 2 and provide information about the workings of ROS 2 and various demos:

.. tabs::

   .. group-tab:: 2024

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - Saving lives sooner: leveraging ROS 2 for end-stage kidney disease
         - `video <https://vimeo.com/1024971800>`__
       * - The State of ROS: Beneath the Kilt
         - `video <https://vimeo.com/1024972452>`__
       * - RMW Zenoh: An alternative middleware for ROS 2
         - `video <https://vimeo.com/1024971621>`__
       * - The State of the Infrastructure
         - `video <https://vimeo.com/1024972551>`__
       * - In the Spot Light: Controlling Spot with ROS 2
         - `video <https://vimeo.com/1024970544>`__
       * - Panel: Successfully Deploying ROS 2 Into Production
         - `video <https://vimeo.com/1026020629>`__
       * - Executors in ROS 2
         - `video <https://vimeo.com/1024970052>`__
       * - The Multithreaded Events Executor
         - `video <https://vimeo.com/1024972104>`__
       * - Accelerating Robotics Development with Embedded Linux
         - `video <https://vimeo.com/1024969135>`__
       * - Real-time ROS 2 applications made easy with cactus-rt
         - `video <https://vimeo.com/1024971584>`__
       * - Something big is coming in ros2_control with ROS 2 Jazzy!
         - `video <https://vimeo.com/1024972003>`__
       * - How to Use a Dragon's Algorithm: Integrating Drake with MoveIt 2
         - `video <https://vimeo.com/1024970427>`__
       * - More than just an actuator -- Better ROS support for a manipulator
         - `video <https://vimeo.com/1024971285>`__
       * - A ROS 2 Package for Dynamic Collision Avoidance Based On On-Board Prox...
         - `video <https://vimeo.com/1024969079>`__
       * - GSplines: Generalized Splines for Motion Optimization and Smooth Colli...
         - `video <https://vimeo.com/1024970194>`__
       * - KOI and EBIKE: Optimizing Kinematics Structures and IK Parameters by C...
         - `video <https://vimeo.com/1024970959>`__
       * - A Fuzzy-Matching Trajectory Cache for MoveIt 2
         - `video <https://vimeo.com/1024968990>`__
       * - iceoryx2: A Journey to Becoming a First-Class RMW Alternative
         - `video <https://vimeo.com/1026024533>`__
       * - J1939 CAN Device Support in ROS 2
         - `video <https://vimeo.com/1026028313>`__
       * - Integration of ETSI ITS messages for V2X communication in ROS
         - `video <https://vimeo.com/1026026851>`__
       * - Unlocking the Potential of the Nicla Vision Board with ROS / ROS 2
         - `video <https://vimeo.com/1026030054>`__
       * - We Hate Serial: Experiments using CAN-FD as a transport layer for micro-ROS
         - `video <https://vimeo.com/1026031720>`__
       * - ROS 2 Gateway to Professional 24/7 Applications
         - `video <https://vimeo.com/1026037209>`__
       * - Optimizing Gazebo simulation: Challenges in building complex simulatio...
         - `video <https://vimeo.com/1024971478>`__
       * - Building Humanoid Robots: Mastering Design and Control with ROS
         - `video <https://vimeo.com/1024969444>`__
       * - URDF Creator: Bridging the Gap Between Learning and Applying ROS 2
         - `video <https://vimeo.com/1024972602>`__
       * - Enabling ROS 2 Benchmarks: A Medical Robotics Perspective
         - `video <https://vimeo.com/1024969888>`__
       * - Scenario Execution for Robotics: A generic, backend-agnostic library f...
         - `video <https://vimeo.com/1024971964>`__
       * - ⚡Lightning Talks⚡
         - `video <https://vimeo.com/1026038503>`__
       * - Mobile Robotics Scale-up Leveraging ROS
         - `video <https://vimeo.com/1024971160>`__
       * - The State of Gazebo
         - `video <https://vimeo.com/1024972138>`__
       * - The State of Open-RMF
         - `video <https://vimeo.com/1024972217>`__
       * - Migrating a Mobile Manipulator to ROS 2
         - `video <https://vimeo.com/1024971060>`__
       * - Jazzy Jalisco rosbag2 updates and new features
         - `video <https://vimeo.com/1024970794>`__
       * - ⚡ Lightning Talks ⚡
         - `video <https://vimeo.com/1024969633>`__
       * - How is my robot? - On the state of ROS Diagnostics
         - `video <https://vimeo.com/1024970271>`__
       * - Accelerating the CI/CD-to-robot cycle by 10x for 1/10th the cost
         - `video <https://vimeo.com/1024969227>`__
       * - r2s: A Terminal User Interface for ROS 2
         - `video <https://vimeo.com/1024971542>`__
       * - The Lighthouse project: from Virtual Reality to Onboard Positioning for Robotics
         - `video <https://vimeo.com/1024972070>`__
       * - Building system packages with colcon in your own compact buildfarm
         - `video <https://vimeo.com/1024969541>`__
       * - robot_folders -- your favorite meta-workspace manager
         - `video <https://vimeo.com/1024971677>`__
       * - Scaling Open-RMF from a Test Bench → Lab → Controlled Environment → Production
         - `video <https://vimeo.com/1024971907>`__
       * - Open-RMF and the Challenge of Resource Contention in Large-Scale Robot Fleets
         - `video <https://vimeo.com/1024971441>`__
       * - ROS in Large-scale Factory Automation
         - `video <https://vimeo.com/1024971718>`__
       * - Enhancing Robotic Communication & Scalability with Topic Keys in ROS 2
         - `video <https://vimeo.com/1024969988>`__
       * - ROS 2 (and DDS) Compatible Selective Large Data Transfer
         - `video <https://vimeo.com/1024971699>`__
       * - Agent-based AI Framework for ROS 2
         - `video <https://vimeo.com/1026029511>`__
       * - ros2ai Next-Gen ROS 2 CLI empowered by OpenAI
         - `video <https://vimeo.com/1026034712>`__
       * - Building Foundation Model-powered Robots with ROS: A Survey
         - `video <https://vimeo.com/1026027743>`__
       * - Scenic for ROS: A Probabilistic Programming Language for World Modelin...
         - `video <https://vimeo.com/1026032775>`__
       * - Software Platform Design and SDK Development for ROS 2-based LG AI Com...
         - `video <https://vimeo.com/1026030733>`__
       * - Beluga AMCL: A modern Monte Carlo Localization implementation for ROS
         - `video <https://vimeo.com/1024969330>`__
       * - Radar Tracks for Path Planning in the presence of Dynamic Obstacles
         - `video <https://vimeo.com/1024971565>`__
       * - On Use of Nav2 Docking
         - `video <https://vimeo.com/1024971348>`__
       * - ROS robot health monitoring: the Bonsai approach
         - `video <https://vimeo.com/1024971769>`__
       * - Navigation à la carte: choose navigation profile and strategy as you go
         - `video <https://vimeo.com/1024971326>`__

   .. group-tab:: 2023

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - Building the iRobot® Create® 3 Robot: Challenges and Solutions for ROS...
         - `video <https://vimeo.com/879000844/153752c34c>`__
       * - The State of ROS: From the Iron Age to the Jazzy Age
         - `video <https://vimeo.com/879001905/d5ee7c2edf>`__
       * - ROS 2 Types On-the-wire: Type Descriptions and Hashing in Iron and onwards
         - `video <https://vimeo.com/879001665/27481b49b7>`__
       * - Releasing a new ROS 2 distribution
         - `video <https://vimeo.com/879001580/48297314e8>`__
       * - Panel: Getting Involved with ROS as an Organization
         - `video <https://vimeo.com/879001441/4f278b5543>`__
       * - Licensing of ROS Packages: Changes to package.xml and new tool support
         - `video <https://vimeo.com/879001224/d6461b638a>`__
       * - SDFormat: A robot description format in constant evolution
         - `video <https://vimeo.com/879001733/c2df0a1823>`__
       * - Repeatable Reproducible Accessible ROS Development via Dev Containers
         - `video <https://vimeo.com/879001614/2d1a22a0e1>`__
       * - Colcon-in-container: say bye to the ""it builds on my machine"" syndrome
         - `video <https://vimeo.com/879000903/bb474a0534>`__
       * - ROS with Kubernetes/KubeEdge
         - `video <https://vimeo.com/879001688/33b2495a49>`__
       * - A New ROS 2 Driver for FANUC Robots Utilizing Ethernet/IP
         - `video <https://vimeo.com/879000528/3062efc119>`__
       * - A ROS 2 Package for Online Cobots Impedance Modulation
         - `video <https://vimeo.com/879000599/2045e57716>`__
       * - Real-Time Motion Control in ROS: Uniting HAL with Tormach's ZA6 Robot
         - `video <https://vimeo.com/879001566/b20f712d4b>`__
       * - A safe and secure ROS 2 multi-domain architecture for AMD embedded het...
         - `video <https://vimeo.com/879000629/a2d2d1cf34>`__
       * - Optimizing MoveIt - Costs, Constraints and Betterments
         - `video <https://vimeo.com/879001424/7fdb9ef68b>`__
       * - Leveraging a functional approach for more testable and maintainable ROS code
         - `video <https://vimeo.com/879001204/ad5a36bb36>`__
       * - Real-time Data-flow extension for ROS 2
         - `video <https://vimeo.com/879001546/54514e92c0>`__
       * - An Integrated Modelling and Testing Architecture for ROS Nodes
         - `video <https://vimeo.com/879000742/0d9939e399>`__
       * - Breaking Bots: Robustness Testing for ROS
         - `video <https://vimeo.com/879000822/a658e675f4>`__
       * - Rclex on Nerves: a bare minimum runtime platform for ROS 2 nodes in Elixir
         - `video <https://vimeo.com/879001529/b23eaacae8>`__
       * - On Use of Nav2 MPPI Controller
         - `video <https://vimeo.com/879001391/40d175c156>`__
       * - Bidirectional navigation with Nav2
         - `video <https://vimeo.com/879000809/b32f8ebec4>`__
       * - Autonomous Robot Navigation and Localization on 3D Mesh Surfaces in ROS
         - `video <https://vimeo.com/879000775/aa280cc0a4>`__
       * - ROS 2 powered Android VHAL.
         - `video <https://vimeo.com/879001655/c96bc5225b>`__
       * - ⚡Lightning Talks⚡
         - `video <https://vimeo.com/879001275/172b83b7d2>`__
       * - Up, Up, and Away: Adventures in Aerial Robotics
         - `video <https://vimeo.com/879001926/02a07b8277>`__
       * - NEXUS: A ROS 2 framework for orchestrating industrial robotic lines and cells
         - `video <https://vimeo.com/879001338/fb3bcc8741>`__
       * - Aerostack2: A framework for developing Multi-Robot Aerial Systems
         - `video <https://vimeo.com/879000655/24398f48ef>`__
       * - Creating scalable customized robotic platforms
         - `video <https://vimeo.com/879000942/31be900d11>`__
       * - Create® 3 Robot in the Classroom: Teaching ROS 2 to Undergraduates
         - `video <https://vimeo.com/879000913/524facf2e5>`__
       * - ROS 2 On the Browser with WebAssembly for Teaching Robotics
         - `video <https://vimeo.com/879001638/18ab3e5c71>`__
       * - ⚡Lightning Talks⚡
         - `video <https://vimeo.com/879001243/0c3777a18d>`__
       * - Octomap is dead: long life Bonxai
         - `video <https://vimeo.com/879001365/4e5a1c2e0a>`__
       * - Parameters Should be Boring
         - `video <https://vimeo.com/879001499/558ba81bef>`__
       * - Using Reference System to evaluate features and performance in a stand...
         - `video <https://vimeo.com/881734034/8f6282d0ee>`__
       * - RosLibRust: Why we built it, why you might want to use it...
         - `video <https://vimeo.com/879001716/ddf60792e8>`__
       * - Leveraging Secure Discovery Server in ROS 2
         - `video <https://vimeo.com/880191276/fd5fa3d2ca>`__
       * - Simulate your World: A deeper look at extending Gazebo
         - `video <https://vimeo.com/879001776/82b8a1d6d9>`__
       * - Simulate robots like never before with Open 3D Engine
         - `video <https://vimeo.com/879001753/80b62256e1>`__
       * - Simulation of Highly Dynamic Omnidirectional Robots in Isaac Sim
         - `video <https://vimeo.com/879001799/0e54e12495>`__
       * - An Integrated Distributed Simulation Environment weaving by Hakoniwa and mROS 2
         - `video <https://vimeo.com/879000700/6e149a4a3a>`__
       * - Multi-drone simulation with deep q-learning
         - `video <https://vimeo.com/879001334/4f57afe509>`__
       * - Supporting Robotic Deliberation: The Deliberation Working Group and To...
         - `video <https://vimeo.com/879001877/4978646728>`__
       * - FlexBE - The Flexible Behavior Engine: Collaborative Autonomy in ROS 2
         - `video <https://vimeo.com/879001093/0590a625cf>`__
       * - SkiROS2 - A skill-based Robot Control Platform for ROS
         - `video <https://vimeo.com/879001825/2a0e9d5412>`__
       * - Mastering your ROS system state with Petri nets
         - `video <https://vimeo.com/879001315/270b755f56>`__
       * - SpatialVision: Bringing Popping-Out RViz to Life with AirPods
         - `video <https://vimeo.com/879001856/e8a108481b>`__
       * - What is Robotics Observability? Scaling ROS from Prototype to Production
         - `video <https://vimeo.com/879001947/f15b94d3a4>`__
       * - Surviving the Flood (of Rosbags)
         - `video <https://vimeo.com/879001892/66580b9633>`__
       * - Improving Your Application's Algorithms and Optimizing Performance Usi...
         - `video <https://vimeo.com/879001159/7d588b2cc4>`__
       * - ROSBag2NuScenes: Share the Bags, Spread the Joy - Autonomous Vehicle R...
         - `video <https://vimeo.com/879001709/593416f29a>`__
       * - PostgreSQL / PostGIS to ROS 2 Bridge for Spatial Data
         - `video <https://vimeo.com/879001513/61784cb23e>`__
       * - Efficient data recording and replaying in ROS 2
         - `video <https://vimeo.com/879001076/d2219656dd>`__
       * - Developing on ROS while Scaling
         - `video <https://vimeo.com/879000977/b6ddf83e60>`__

  .. group-tab:: 2022

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - Panel: The ROS 2 Developer Experience
         - `video <https://vimeo.com/showcase/9954564/video/767155188>`__
       * - Wearable ROS: Development of wearable robot system using ROS 2
         - `video <https://vimeo.com/showcase/9954564/video/767140298>`__
       * - Building ROS 2 enabled Android apps with C++
         - `video <https://vimeo.com/showcase/9954564/video/767161955>`__
       * - Distributed Robotics Simulator with Unreal Engine
         - `video <https://vimeo.com/showcase/9954564/video/767139975>`__
       * - Tools and processes for improving the certifiability of ROS 2
         - `video <https://vimeo.com/showcase/9954564/video/767150613>`__
       * - Failover ROS Framework : Consensus-based node redundancy
         - `video <https://vimeo.com/showcase/9954564/video/767156308>`__
       * - ROS 2 and Gazebo Integration Best Practices
         - `video <https://vimeo.com/showcase/9954564/video/767127300>`__
       * - Chain-Aware ROS Evaluation Tool (CARET)
         - `video <https://vimeo.com/showcase/9954564/video/767150288>`__
       * - ROS 2 network monitoring
         - `video <https://vimeo.com/showcase/9954564/video/767140681>`__
       * - How custom tasks are defined, assigned, and executed in Open-RMF
         - `video <https://vimeo.com/showcase/9954564/video/767157210>`__
       * - A practitioner's guide to ros2_control
         - `video <https://vimeo.com/showcase/9954564/video/767139648>`__
       * - Zenoh: How to Make ROS 2 Work at any Scale and Integrate with Anything
         - `video <https://vimeo.com/769972405>`__
       * - A case study in optics manufacturing with MoveIt2 and ros2_control
         - `video <https://vimeo.com/showcase/9954564/video/767140351>`__
       * - 20/20 Robot Vision - How to setup cameras in ROS 1 & ROS 2 using camera_aravis
         - `video <https://vimeo.com/showcase/9954564/video/767140329>`__
       * - Filter your ROS 2 content
         - `video <https://vimeo.com/767166447>`__
       * - Evolving Message Types, and Other Interfaces, Over Time
         - `video <https://vimeo.com/showcase/9954564/video/767140015>`__
       * - Migrating from ROS1 to ROS 2 - choosing the right bridge
         - `video <https://vimeo.com/showcase/9954564/video/767140113>`__
       * - On Use of Nav2 Smac Planners
         - `video <https://vimeo.com/showcase/9954564/video/767157646>`__
       * - Bazel and ROS 2 – building large scale safety applications
         - `video <https://vimeo.com/showcase/9954564/video/767139879>`__
       * - Native Rust components for ROS 2
         - `video <https://vimeo.com/showcase/9954564/video/767140150>`__
       * - The ROS build farm and you: How ROS packages you release become binary packages.
         - `video <https://vimeo.com/showcase/9954564/video/767169376>`__
       * - mROS 2: yet another runtime environment onto embedded devices
         - `video <https://vimeo.com/showcase/9954564/video/767150435>`__
       * - ROS 2 & Edge Impulse: Embedded AI in robotics applications
         - `video <https://vimeo.com/showcase/9954564/video/767140724>`__
       * - micro-ROS goes Automotive: supporting AUTOSAR-based microcontrollers
         - `video <https://vimeo.com/769963507>`__
       * - An open architecture for Hardware Acceleration in ROS 2
         - `video <https://vimeo.com/769967795>`__
       * - ROS 2 and the Crazyflie: Aerial swarms and Autonomy with a tiny flying robot
         - `video <https://vimeo.com/showcase/9954564/video/767140197>`__
       * - A Raspberry Pi image with ROS 2 + RT and a customizable image builder
         - `video <https://vimeo.com/showcase/9954564/video/767139709>`__

  .. group-tab:: 2021

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - SMACC2
         - `video <https://vimeo.com/649655394/f9b25be7f9>`__
       * - rospy2: Convert a ROS1 node to ROS2 by changing only one line of code
         - `video <https://vimeo.com/649655340/127d801385>`__
       * - Hello Robot: Democratizing Mobile Manipulation with ROS
         - `video <https://vimeo.com/649649087/b1a3a67369>`__
       * - Challenges for ROS2 in Autonomous Agricultural Applications
         - `video <https://vimeo.com/649646777>`__
       * - ESP32 microcontroller robot with Navigation 2 ROS 2 running in the Cloud
         - `video <https://vimeo.com/649648283>`__
       * - Middleware interconnecting ROS/ROS2 with the EtherCAT protocol
         - `video <https://vimeo.com/649651918>`__
       * - Build and Manage Cloud-enhanced ROS Robots with AWS IoT Greengrass 2.0
         - `video <https://vimeo.com/649647971/0f36010e6e>`__
       * - Driving Autonomy in Mobile Robotics with ROS2 and PX4
         - `video <https://vimeo.com/649648867/c524ae57fd>`__
       * - Integrating ROS 2 with existing DDS networks
         - `video <https://vimeo.com/649649793/31032f6fba>`__
       * - VIPER: Volatiles Investigating Polar Exploration Rover
         - `video <https://vimeo.com/649657650/ce9245dc22>`__
       * - Chronicles of Caching and Containerising CI for Nav2
         - `video <https://vimeo.com/649647161/5b0c278e6c>`__
       * - A New Way to Interact with PointCloud2 Messages
         - `video <https://vimeo.com/649643457/7ba0e85107>`__
       * - ROS 2 Grasp Library – Acceleration for 3D Object Pose Detection
         - `video <https://vimeo.com/649654728/25bef7e247>`__
       * - ros2_control: The future of ros_control
         - `video <https://vimeo.com/649654948>`__
       * - ROS 2 Rolling Ridley
         - `video <https://vimeo.com/649650919>`__
       * - Hybrid Planning - Enabling Reactive Manipulation with MoveIt 2
         - `video <https://vimeo.com/649649286/17fb9b9f4d>`__
       * - Apex.OS Cert: Taking ROS 2 from prototype into production
         - `video <https://vimeo.com/649645295/67e0a6569f>`__
       * - Making a robot ROS 2 powered - a case study using the UR manipulators
         - `video <https://vimeo.com/649651707/46a3be27ed>`__
       * - Online Trajectory Generation and Admittance Control in ROS2
         - `video <https://vimeo.com/649652452/682bd92e95>`__
       * - VSCode, Docker and ROS2
         - `video <https://vimeo.com/649658020/9ef0b5ec32>`__
       * - ROS 2 Content Filtered Topics
         - `video <https://vimeo.com/649654533/c8104829db>`__
       * - Rosbag2 for Power Users
         - `video <https://vimeo.com/649655219/75630c8cff>`__
       * - We Have Ignition: The Next Generation of Gazebo Simulation
         - `video <https://vimeo.com/649658182>`__
       * - Using NVIDIA Isaac Sim For Synthetic Data Generation & ROS Development
         - `video <https://vimeo.com/649656932/3d8d5abb53>`__
       * - Augmented Reality and Robotics
         - `video <https://vimeo.com/649645502/9be46e9ff8>`__
       * - Modeling sensors for simulation of ROS applications in Unity
         - `video <https://vimeo.com/649652075/295c92d323>`__
       * - Panel: Simulation Tools for ROS
         - `video <https://vimeo.com/649653566/9d02eac6cb>`__

  .. group-tab:: 2020

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - Accelerating Innovation with ROS: Lessons in Healthcare
         - `video <https://vimeo.com/showcase/7812155/video/480611811>`__
       * - Panel: Software Quality in Robotics
         - `video <https://vimeo.com/showcase/7812155/video/480586443>`__
       * - Panel: ROS Agriculture
         - `video <https://vimeo.com/showcase/7812155/video/480592013>`__
       * - Achieving Generality and Robustness in Semantic Segmentation
         - `video <https://vimeo.com/showcase/7812155/video/480600107>`__
       * - Navigation2: The Next Generation Navigation System
         - `video <https://vimeo.com/showcase/7812155/video/480604621>`__
       * - CHAMP Quadruped Control
         - `video <https://vimeo.com/showcase/7812155/video/480603868>`__
       * - Kiwibot: ROS2 in the atoms delivery industry
         - `video <https://vimeo.com/showcase/7812155/video/480601709>`__
       * - MoveItWorld
         - `video <https://vimeo.com/showcase/7812155/video/480482977>`__
       * - OpenCV
         - `video <https://vimeo.com/showcase/7812155/video/480465027>`__
       * - ROBOTIS TurtleBot3
         - `video <https://vimeo.com/showcase/7812155/video/480460365>`__
       * - Autoware
         - `video <https://vimeo.com/showcase/7812155/video/480450941>`__
       * - Dronecode
         - `video <https://vimeo.com/showcase/7812155/video/480477960>`__
       * - FIWARE
         - `video <https://vimeo.com/showcase/7812155/video/480473016>`__
       * - Lightning Talks and Sponsor Videos 1
         - `video <https://vimeo.com/showcase/7812155/video/480530126>`__
       * - Lightning Talks and Sponsor Videos 2
         - `video <https://vimeo.com/showcase/7812155/video/480435216>`__
       * - Lightning Talks and Sponsor Videos 3
         - `video <https://vimeo.com/showcase/7812155/video/480436954>`__
       * - Lightning Talks and Sponsor Videos 4
         - `video <https://vimeo.com/showcase/7812155/video/490004991>`__

  .. group-tab:: 2019

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - Migrating a large ROS 1 codebase to ROS 2
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_migrating_a_large_ros_1_codebase_to_ros_2.pdf>`__ / `video <https://vimeo.com/378682692>`__
       * - The New Architecture of Gazebo Wrappers for ROS 2
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_gazebo_ros2.pdf>`__ / `video <https://vimeo.com/378683414>`__
       * - Migrating to ROS 2: Advice from Rover Robotics
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_migrating_to_ros_2.pdf>`__ / `video <https://vimeo.com/378682068>`__
       * - ROS 2 on VxWorks
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_ros2onvxworks.pdf>`__ / `video <https://vimeo.com/378682144>`__
       * - Navigation2 Overview
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_navigation2_overview_final.pdf>`__ / `video <https://vimeo.com/378682188>`__
       * - Launch Testing - Launch description and integration testing for ros2
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_launch_testing_presentation.pdf>`__ / `video <https://vimeo.com/378683186>`__
       * - ROS 2 for Consumer Robotics: : The iRobot use-case
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_irobot_usecase.pdf>`__ / `video <https://vimeo.com/378916114>`__
       * - Composable Nodes in ROS2
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_composablenodes.pdf>`__ / `video <https://vimeo.com/378916125>`__
       * - Concurrency in ROS 1 and ROS 2
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_concurrency.pdf>`__ / `video <https://vimeo.com/379127709>`__
       * - A True Zero-Copy RMW Implementation for ROS2
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_truezerocopy.pdf>`__ / `video <https://vimeo.com/379127778>`__
       * - ROS2 Real-Time Behavior: Static Memory Allocation
         - `video <https://vimeo.com/379127767>`__
       * - PackML2: State Machine Based System Programming, Monitoring and Control in ROS2
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_packml2.pdf>`__ / `video <https://vimeo.com/378683073>`__
       * - Quality of Service Policies for ROS2 Communications
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_qos.pdf>`__ / `video <https://vimeo.com/379127762>`__
       * - Micro-ROS: ROS2 on Microcontrollers
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_microros.pdf>`__ / `video <https://vimeo.com/379127756>`__
       * - ROS2 on Large Scale Systems: Discovery Server
         - `video <https://vimeo.com/379127745>`__
       * - Bridging Your Transitions from ROS 1 to ROS 2
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_bridging_ros1_to_ros2.pdf>`__ / `video <https://vimeo.com/379127737>`__
       * - Markup Extensions for ROS 2 Launch
         - `slides <https://roscon.ros.org/2019/talks/roscon2019_markupextensionsforros2launch.pdf>`__ / `video <https://vimeo.com/379127678>`__


  .. group-tab:: 2018

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - Hands-on ROS 2: A Walkthrough
         - `slides <https://roscon.ros.org/2018/presentations/ROSCon2018_ROS2HandsOn.pdf>`__ / `video <https://vimeo.com/292693129>`__
       * - Launch for ROS 2
         - `slides <https://roscon.ros.org/2018/presentations/ROSCon2018_launch.pdf>`__ / `video <https://vimeo.com/292699162>`__

  .. group-tab:: 2017

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - The ROS 2 vision for advancing the future of robotics development
         - `slides <https://roscon.ros.org/2017/presentations/ROSCon%202017%20ROS2%20Vision.pdf>`__ / `video <https://vimeo.com/236161417>`__

  .. group-tab:: 2016

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - ROS 2 Update - summary of alpha releases, architectural overview
         - `slides <https://roscon.ros.org/2016/presentations/ROSCon%202016%20-%20ROS%202%20Update.pdf>`__ / `video <https://vimeo.com/187696091>`__
       * - Evaluating the resilience of ROS2 communication layer
         - `slides <https://roscon.ros.org/2016/presentations/rafal.kozik-ros2evaluation.pdf>`__ / `video <https://vimeo.com/187705229>`__

  .. group-tab:: 2015

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - State of ROS 2 - demos and the technology behind
         - `slides <https://roscon.ros.org/2015/presentations/state-of-ros2.pdf>`__ / `video <https://vimeo.com/142151734>`__
       * - ROS 2 on ""small"" embedded systems
         - `slides <https://roscon.ros.org/2015/presentations/ros2_on_small_embedded_systems.pdf>`__ / `video <https://vimeo.com/142150576>`__
       * - Real-time control in ROS and ROS 2
         - `slides <https://roscon.ros.org/2015/presentations/RealtimeROS2.pdf>`__ / `video <https://vimeo.com/142621778>`__

  .. group-tab:: 2014

    .. list-table::
       :header-rows: 1

       * - Title
         - Links
       * - Why you want to use ROS 2
         - `slides <https://www.osrfoundation.org/wordpress2/wp-content/uploads/2015/04/ROSCON-2014-Why-you-want-to-use-ROS-2.pdf>`__ / `video <https://vimeo.com/107531013>`__
       * - Next-generation ROS: Building on DDS
         - `slides <https://roscon.ros.org/2014/wp-content/uploads/2014/07/ROSCON-2014-Next-Generation-of-ROS-on-top-of-DDS.pdf>`__ / `video <https://vimeo.com/106992622>`__
",What is the title of the talk about leveraging ROS 2 for end-stage kidney disease and where can the video be found?
".. redirect-from::

  Marketing

.. _Marketing:

Marketing
=========

General Use ROS Artwork
-----------------------

The ROS 2 media kit, which includes branding language, high resolution ROS logo
graphics, and release images, can be found in the `ROS art
repository. <https://github.com/ros-infrastructure/artwork>`__ Please refer to
this repository for ROS art work and our branding guidelines.

Stickers, Posters, and Canvas Prints
------------------------------------

Open Robotics hosts an online storefront on `Zazzle.com <https://www.zazzle.com/store/openrobotics?rf=238583394320947238>`__ with artwork available in various formats.

* `Posters <https://www.zazzle.com/store/openrobotics/products?dp=0&cg=196892405499231339&rf=238583394320947238>`__ Printed on paper with selectable sizes.
* `Canvas Prints <https://www.zazzle.com/store/openrobotics/products?dp=0&cg=196964974640243022&rf=238583394320947238>`__ Printed on wrapped canvas with selectable sizes.
* `Sticker Sheets <https://www.zazzle.com/store/openrobotics/products?dp=0&cg=196936312033387169&rf=238583394320947238>`__ Printed on a sheet, 20 per sheet for the small, 6 per sheet in the large size.

Brochure: Why ROS 2?
--------------------

Use this brochure to promote the goals and features of ROS 2 and encourage adoption.

License: `CC BY-ND 4.0 <https://creativecommons.org/licenses/by-nd/4.0/>`__

Available formats:

* :download:`A4 (for web/email) <Marketing/documents/ros2-brochure-a4-web.pdf>`
* :download:`A4 (for print) <Marketing/documents/ros2-brochure-a4-print.pdf>`
* :download:`US Letter (for web/email) <Marketing/documents/ros2-brochure-ltr-web.pdf>`
* :download:`US Letter (for print) <Marketing/documents/ros2-brochure-ltr-print.pdf>`
",What online platform does Open Robotics use to host an online storefront for artwork available in various formats?
".. redirect-from::

  Features

.. _Features:

Features Status
===============

The features listed below are available in the current ROS 2 release.
Unless otherwise specified, the features are available for all supported platforms (Ubuntu 24.04 (Noble), Windows 10), DDS implementations (eProsima Fast DDS, RTI Connext DDS, and Eclipse Cyclone DDS) and programming language client libraries (C++ and Python).
For planned future development, see the :doc:`Roadmap <Roadmap>`.

.. list-table::
   :header-rows: 1

   * - Functionality
     - Link
     - Fine print
   * - Discovery, transport and serialization over DDS
     - `Article <https://design.ros2.org/articles/ros_on_dds.html>`__
     -
   * - Support for :doc:`multiple DDS implementations <../Concepts/Intermediate/About-Different-Middleware-Vendors>`, chosen at runtime
     - :doc:`Concept <../Concepts/Intermediate/About-Different-Middleware-Vendors>`, :doc:`How-to Guide <../How-To-Guides/Working-with-multiple-RMW-implementations>`
     - Currently Eclipse Cyclone DDS, eProsima Fast DDS, and RTI Connext DDS are fully supported.
   * - Common core client library that is wrapped by language-specific libraries
     - :doc:`Details <../Concepts/Basic/About-Client-Libraries>`
     -
   * - Publish/subscribe over topics
     - `Sample code <https://github.com/ros2/examples>`__\ , `Article <https://design.ros2.org/articles/topic_and_service_names.html>`__
     -
   * - Clients and services
     - `Sample code <https://github.com/ros2/examples>`__
     -
   * - Set/retrieve parameters
     - `Sample code <https://github.com/ros2/demos/tree/0.5.1/demo_nodes_cpp/src/parameters>`__
     -
   * - ROS 1 - ROS 2 communication bridge
     - `Tutorial <https://github.com/ros2/ros1_bridge/blob/master/README.md>`__
     - Available for topics and services, not yet available for actions.
   * - Quality of service settings for handling non-ideal networks
     - :doc:`Demo <../Tutorials/Demos/Quality-of-Service>`
     -
   * - Inter- and intra-process communication using the same API
     - :doc:`Demo <../Tutorials/Demos/Intra-Process-Communication>`
     - Currently only in C++.
   * - Composition of node components at compile, link, load, or run time
     - :doc:`Demo <../Tutorials/Intermediate/Composition>`
     - Currently only in C++.
   * - Multiple executors (at level of callback groups) in same node
     - `Demo <https://github.com/ros2/examples/tree/{DISTRO}/rclcpp/executors/cbg_executor>`__
     - Only in C++.
   * - Support for nodes with managed lifecycles
     - :doc:`Demo <../Tutorials/Demos/Managed-Nodes>`
     - Currently only in C++.
   * - DDS-Security support
     - `Demo <https://github.com/ros2/sros2>`__
     -
   * - Command-line introspection tools using an extensible framework
     - :doc:`Concept <../Concepts/Basic/About-Command-Line-Tools>`
     -
   * - Launch system for coordinating multiple nodes
     - :doc:`Tutorial <../Tutorials/Intermediate/Launch/Launch-system>`
     -
   * - Namespace support for nodes and topics
     - `Article <https://design.ros2.org/articles/topic_and_service_names.html>`__
     -
   * - Static remapping of ROS names
     - :doc:`How-to Guide <../How-To-Guides/Node-arguments>`
     -
   * - Demos of an all-ROS 2 mobile robot
     - `Demo <https://github.com/ros2/turtlebot2_demo>`__
     -
   * - Preliminary support for real-time code
     - :doc:`Demo <../Tutorials/Demos/Real-Time-Programming>`, :doc:`demo <../Tutorials/Advanced/Allocator-Template-Tutorial>`
     - Linux only. Not available for Fast RTPS.
   * - Preliminary support for ""bare-metal"" microcontrollers
     - `Wiki <https://github.com/ros2/freertps/wiki>`__
     -
   * - Content filtering subscription
     - :doc:`Demo <../Tutorials/Demos/Content-Filtering-Subscription>`
     - Currently only in C++.
   * - Service Introspection
     - :doc:`Demo <../Tutorials/Demos/Service-Introspection>`
     -

Besides core features of the platform, the biggest impact of ROS comes from its available packages.
The following are a few high-profile packages which are available in the latest release:

* `gazebo_ros_pkgs <https://index.ros.org/r/gazebo_ros_pkgs/>`__
* `image_transport <https://index.ros.org/r/image_common>`__
* `navigation2 <https://index.ros.org/r/navigation2/>`__
* `rosbag2 <https://index.ros.org/r/rosbag2/>`__
* `RQt <https://index.ros.org/r/rqt/>`__
* `RViz2 <https://index.ros.org/r/rviz/>`__
",What are some high-profile packages available in the latest ROS release?
".. redirect-from::

  Feature-Ideas

.. _FeatureIdeas:

Feature Ideas
=============

.. contents:: Table of Contents
   :depth: 2
   :local:

The following are feature ideas in no specific order.
This list contains features that we think are important and can make for good contributions to ROS 2.
:doc:`Please get in touch with us <../Contact>` before digging into a new feature.
We can offer guidance, and connect you with other developers.

Design / Concept
----------------

* IDL format

  * Leverage new features like grouping constants into enums
  * Extend usage to ``.idl`` files with just constants and/or declare parameters with ranges
  * Revisit constraints of IDL interface naming, see `ros2/design#220 <https://github.com/ros2/design/pull/220>`_

* Create migration plan for ROS 1 -> ROS 2 transition
* Uniqueness of node names, see `ros2/design#187 <https://github.com/ros2/design/issues/187>`_
* Specific ""API"" of a node in terms of topics / services / etc. in a descriptive format, see `ros2/design#266 <https://github.com/ros2/design/pull/266>`_

Infrastructure and tools
------------------------

* Building

  * Consolidate https://build.ros2.org and https://ci.ros2.org
  * Provision macOS
  * Windows and macOS packages
  * Support profiles in ``colcon``

* Documentation

  * Deprecate https://design.ros2.org.  Content should move to either an REP, to https://github.com/ros2/ros2_documentation, or be removed.
  * Fix per-package documentation builder to be able to document build artifacts, i.e. messages, services, actions, etc.
  * Make https://docs.ros.org/en/ros2_documentation automatically rebuild on changes to https://github.com/ros2/ros2_documentation.
  * ``ament`` documentation
  * Add documentation examples of using ROS 2 with Jupyter notebooks.
  * Add documentation for implementing a new RMW.
  * Provide three different kinds of content:

    * ""demos"" to show features and cover them with tests
    * ""examples"" to show a simple/minimalistic usage which might have multiple ways to do something
    * ""tutorials"" which contain more comments and anchors for the wiki (teaching one recommended way)

New features
------------

The trailing stars indicate the rough effort: 1 star for small, 2 stars for medium, 3 stars for large.


* Logging improvements [\* / \*\*]

  * Configuration specified in a file
  * Per-logger configuration (enabling e.g. ``rqt_logger_level``)

* Time related

  * Support rate and sleep based on clock

* Additional Graph API features [\*\* / \*\*\*]

  * Introspect QoS setting for all (especially remote) topics
  * a la ROS 1 Master API: https://wiki.ros.org/ROS/Master_API
  * Event-based notification
  * Requires knowledge of the rmw interface which needs to be extended

* Executor

  * Performance improvements (mostly around the waitset)
  * Deterministic ordering (fair scheduling)
  * Decouple waitables

* Message generation

  * Catch-up message generation for languages not supported out-of-the-box
  * Mangle field names in message to avoid language specific keywords
  * Improve generator performance by running them in the same Python interpreter

* Launch

  * Support for launching multi-node executables (i.e. manual composition)
  * Extend launch XML/YAML support: events and event handlers, tag namespaces and aliasing

* Rosbag

  * Support recording services (and actions)

* ros1_bridge

  * Support bridging actions

* RMW configuration

  * Unified standard way of configuring the middleware

* Remapping [\*\* / \*\*\*]

  * Dynamic remapping and aliasing through a Service interface

* Type masquerading [\*\*\*]

  * a la ROS 1's message traits: https://wiki.ros.org/roscpp/Overview/MessagesSerializationAndAdaptingTypes
  * Requires knowledge of the typesupport system

* Expand on real-time safety [\*\*\*]

  * For services, clients, and parameters
  * Expose more quality of service parameters related to real-time performance
  * Real-time-safe intra-process messaging

* Multi-robot supporting features and demos [\*\*\*]

  * Undesired that all nodes across all robots share the same domain (and discover each other)
  * Design how to “partition” the system

* Support more DDS / RTPS implementations:

  * RTI Connext DDS Micro (implemented, not enabled by default or officially supported).

* Security improvements:

  * More granularity in security configuration (allow authentication only, authentication and encryption, etc.) [\*]
  * Integrate DDS-Security logging plugin (unified way to aggregate security events and report them to the users through a ROS interface) [\*\*]
  * Key storage security (right now, keys are just stored in the filesystem) [\*\*]
  * More user friendly interface (make it easier to specify security config). Maybe a Qt GUI? This GUI could also assist in distributing keys somehow. [\*\*\*]
  * A way to say ""please secure this running system"" with some UI that would auto-generate keys and policies for everything that is currently running. [\*\*\*]
  * If there are hardware-specific features for securing keys or accelerating encryption/signing messages, that could be interesting to add to DDS/RTPS implementations that don't use it already. [\*\*\*]

Reducing Technical Debt
-----------------------

* Fix flaky tests on https://ci.ros2.org/view/nightly.
* Ability to run (all) unit tests with tools e.g. valgrind, clang-tidy, clang static analysis (scan-build), ASAN, TSAN, UBSAN, etc.
* API review, specifically user-facing APIs in rclcpp and rclpy
* Refactor the rclcpp API into separate packages focused on a single aspect, rclcpp should afterward still provide the combined user-facing API
* Revisit message allocators, consider using std::polymorphic_allocator to address problems
* Synchronize / reconcile `design docs <https://design.ros2.org>`__ with the implementation.
* Address / classify pending tickets
* Address TODOs in code / docs
* Remove tinyxml as a dependency
","What type of logging improvements are suggested in the text, and how is the effort estimated for implementing them?"
".. redirect-from::

  Governance

.. _Governance:

Project Governance
==================

.. contents:: Table of Contents
   :depth: 2
   :local:

The Open Source Robotics Alliance (OSRA)
----------------------------------------

Since 2024, the ROS 2 project has been governed by the `Open Source Robotics Alliance (OSRA) <https://osralliance.org/>`__.
The information below is meant to give a quick overview of the project governance, but for full information please see `the OSRA's website <https://osralliance.org/how-it-works/>`__.

The Technical Governance Committee (TGC)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The Technical Governance Committee is responsible for the oversight of all projects within the OSRA.
The TGC is made up of a combination of paid members, project management leaders, OSRF leaders, and members based on merits.
For more details about the TGC, please see `the Charter for the OSRA <https://osralliance.org/staging/wp-content/uploads/2024/03/OSRA-Program-Charter.pdf>`__.
One of the projects that the TGC oversees is ROS 2, which is managed by the ROS Project Management Committee.

The ROS Project Management Committee (ROS PMC)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ROS Project Management Committee is responsible for the day-to-day operations of the ROS 2 project.
The ROS PMC consists of the Project Leader, the ROS PMC Members (who have full voting rights), a Supporting Individual Representative, and the Chair of the TGC.
The project also has Committers, who help manage one or more repositories but are not a part of the PMC.
The Project Leader, all PMC Members, and all Committers are chosen on a meritocratic basis.

The day-to-day operations of the ROS PMC include managing the members and committers, managing the repositories that make up ROS 2, reviewing and merging code from the ROS community, maintaining the repositories, and making technical decisions that decide the direction of the project.

For more details about the ROS PMC, please see the `Charter for the ROS Project <https://osralliance.org/staging/wp-content/uploads/2024/03/ros_project_charter.pdf>`__.

Current ROS PMC Constituents
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ROS PMC currently consists of the following constituents:

.. list-table::
   :header-rows: 1

   * - Name
     - Affiliation
     - GitHub handle
     - PMC role
     - Time Zone (optional)
   * - Christophe Bédard
     - `Apex.AI <https://www.apex.ai/>`_
     - `christophebedard <https://github.com/christophebedard>`_
     - Member
     - PST (UTC-8)/PDT (UTC-7)
   * - Michael Carroll
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `mjcarroll <https://github.com/mjcarroll>`_
     - Member
     - CST (UTC-6)/CDT (UTC-5)
   * - Alejandro Hernandez Cordero
     - `Honu Robotics <https://www.honurobotics.com/>`_
     - `ahcorde <https://github.com/ahcorde>`_
     - Member
     - CET (UTC+1)/CEST (UTC+2)
   * - Tomoya Fujita
     - `Sony <https://www.sony.com/>`_
     - `fujitatomoya <https://github.com/fujitatomoya>`_
     - Member
     - PST (UTC-8)/PDT (UTC-7)
   * - Marco A. Gutiérrez
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `marcoag <https://github.com/marcoag>`_
     - Member
     - SGT (UTC+8)
   * - Chris Lalancette
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `clalancette <https://github.com/clalancette>`_
     - Project Leader
     - N/A
   * - Scott Logan
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `cottsay <https://github.com/cottsay>`_
     - Member
     - CST (UTC-6)/CDT (UTC-5)
   * - Shane Loretz
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `sloretz <https://github.com/sloretz>`_
     - Member
     - PST (UTC-8)/PDT (UTC-7)
   * - Audrow Nash
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `Audrow <https://github.com/audrow>`_
     - Member
     - CST (UTC-6)/CDT (UTC-5)
   * - Michael Orlov
     - `Apex.AI <https://www.apex.ai/>`_
     - `MichaelOrlov <https://github.com/MichaelOrlov>`_
     - Member
     - PST (UTC-8)/PDT (UTC-7)
   * - Steven! Ragnarök
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `nuclearsandwich <https://github.com/nuclearsandwich>`_
     - Member / Infrastructure Project Lead
     - PST (UTC-8)/PDT (UTC-7)
   * - Kat Scott
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `kscottz <https://github.com/kscottz>`_
     - OSRA Developer Advocate
     - PST (UTC-8)/PDT (UTC-7)
   * - Alberto Soragna
     - `iRobot <https://www.irobot.com/>`_
     - `alsora <https://github.com/alsora>`_
     - Member
     - PST (UTC-8)/PDT (UTC-7)
   * - Yadunund Vijay
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `Yadunund <https://github.com/Yadunund>`_
     - Member
     - PST (UTC-8)/PDT (UTC-7)
   * - William Woodall
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `wjwwood <https://github.com/wjwwood>`_
     - Member
     - PST (UTC-8)/PDT (UTC-7)

Current ROS Committers
^^^^^^^^^^^^^^^^^^^^^^

The ROS committers (who are not also part of the ROS PMC) consists of the following constituents:

.. list-table::
   :header-rows: 1

   * - Name
     - Affiliation
     - GitHub handle
     - Time Zone (optional)
   * - Barry Xu
     - `Sony <https://www.sony.com/>`_
     - `Barry-Xu-2018 <https://github.com/Barry-Xu-2018>`_
     - CST (UTC+8)
   * - Dharini Dutia
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `quarkytale <https://github.com/quarkytale>`_
     - PST (UTC-8)/PDT (UTC-7)
   * - Miguel Company
     - `eProsima <https://www.eprosima.com/>`_
     - `MiguelCompany <https://github.com/MiguelCompany>`_
     - CET (UTC+1)/CEST (UTC+2)
   * - Steve Peters
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `scpeters <https://github.com/scpeters>`_
     - PST (UTC-8)/PDT (UTC-7)
   * - Tully Foote
     - `Intrinsic <https://www.intrinsic.ai/>`_
     - `tfoote <https://github.com/tfoote>`_
     - PST (UTC-8)/PDT (UTC-7)

Past ROS PMC Constituents
^^^^^^^^^^^^^^^^^^^^^^^^^

The ROS PMC thanks the following past constituents for their service:

.. list-table::
   :header-rows: 1

   * - Name
     - PMC role
     - GitHub handle (optional)
   * - None yet
     - None yet
     - None yet

Repositories managed by the ROS PMC
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following repositories are managed by the ROS PMC:

.. list-table::
   :header-rows: 1

   * - Repository URL
     - Committers
   * - https://github.com/ament/ament_cmake
     - Not Yet Available
   * - https://github.com/ament/ament_index
     - Not Yet Available
   * - https://github.com/ament/ament_lint
     - Not Yet Available
   * - https://github.com/ament/ament_package
     - Not Yet Available
   * - https://github.com/ament/google_benchmark_vendor
     - Not Yet Available
   * - https://github.com/ament/googletest
     - Not Yet Available
   * - https://github.com/ament/uncrustify_vendor
     - Not Yet Available
   * - https://github.com/gazebo-release/gz_cmake_vendor
     - Not Yet Available
   * - https://github.com/gazebo-release/gz_math_vendor
     - Not Yet Available
   * - https://github.com/gazebo-release/gz_utils_vendor
     - Not Yet Available
   * - https://github.com/osrf/osrf_pycommon
     - Not Yet Available
   * - https://github.com/osrf/osrf_testing_tools_cpp
     - Not Yet Available
   * - https://github.com/ros-infrastructure/rep
     - Not Yet Available
   * - https://github.com/ros-infrastructure/rosdoc2
     - Not Yet Available
   * - https://github.com/ros-perception/image_common
     - Not Yet Available
   * - https://github.com/ros-perception/laser_geometry
     - Not Yet Available
   * - https://github.com/ros-perception/point_cloud_transport
     - Not Yet Available
   * - https://github.com/ros-perception/pointcloud_to_laserscan
     - Not Yet Available
   * - https://github.com/ros-planning/navigation_msgs
     - Not Yet Available
   * - https://github.com/ros-tooling/keyboard_handler
     - Not Yet Available
   * - https://github.com/ros-tooling/libstatistics_collector
     - Not Yet Available
   * - https://github.com/ros-visualization/interactive_markers
     - Not Yet Available
   * - https://github.com/ros-visualization/python_qt_binding
     - Not Yet Available
   * - https://github.com/ros-visualization/qt_gui_core
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_action
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_bag
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_console
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_graph
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_msg
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_plot
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_publisher
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_py_console
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_reconfigure
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_service_caller
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_shell
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_srv
     - Not Yet Available
   * - https://github.com/ros-visualization/rqt_topic
     - Not Yet Available
   * - https://github.com/ros-visualization/tango_icons_vendor
     - Not Yet Available
   * - https://github.com/ros-visualization/visualization_tutorials
     - Not Yet Available
   * - https://github.com/ros/angles
     - Not Yet Available
   * - https://github.com/ros/class_loader
     - Not Yet Available
   * - https://github.com/ros/console_bridge
     - Not Yet Available
   * - https://github.com/ros/eigen_stl_containers
     - Not Yet Available
   * - https://github.com/ros/geometry_tutorials
     - Not Yet Available
   * - https://github.com/ros/geometry2
     - Not Yet Available
   * - https://github.com/ros/kdl_parser
     - Not Yet Available
   * - https://github.com/ros/pluginlib
     - Not Yet Available
   * - https://github.com/ros/resource_retriever
     - Not Yet Available
   * - https://github.com/ros/robot_state_publisher
     - Not Yet Available
   * - https://github.com/ros/ros_environment
     - Not Yet Available
   * - https://github.com/ros/ros_tutorials
     - Not Yet Available
   * - https://github.com/ros/rosdistro
     - Not Yet Available
   * - https://github.com/ros/urdf_parser_py
     - Not Yet Available
   * - https://github.com/ros/urdfdom
     - Not Yet Available
   * - https://github.com/ros/urdfdom_headers
     - Not Yet Available
   * - https://github.com/ros2/ament_cmake_ros
     - Not Yet Available
   * - https://github.com/ros2/common_interfaces
     - Not Yet Available
   * - https://github.com/ros2/console_bridge_vendor
     - Not Yet Available
   * - https://github.com/ros2/demos
     - Not Yet Available
   * - https://github.com/ros2/design
     - Not Yet Available
   * - https://github.com/ros2/eigen3_cmake_module
     - Not Yet Available
   * - https://github.com/ros2/example_interfaces
     - Not Yet Available
   * - https://github.com/ros2/examples
     - Not Yet Available
   * - https://github.com/ros2/geometry2
     - Not Yet Available
   * - https://github.com/ros2/launch
     - Not Yet Available
   * - https://github.com/ros2/launch_ros
     - Not Yet Available
   * - https://github.com/ros2/libyaml_vendor
     - Not Yet Available
   * - https://github.com/ros2/message_filters
     - Not Yet Available
   * - https://github.com/ros2/mimick_vendor
     - Not Yet Available
   * - https://github.com/ros2/orocos_kdl_vendor
     - Not Yet Available
   * - https://github.com/ros2/performance_test_fixture
     - Not Yet Available
   * - https://github.com/ros2/pybind11_vendor
     - Not Yet Available
   * - https://github.com/ros2/python_cmake_module
     - Not Yet Available
   * - https://github.com/ros2/rcl
     - Not Yet Available
   * - https://github.com/ros2/rcl_interfaces
     - Not Yet Available
   * - https://github.com/ros2/rcl_logging
     - Not Yet Available
   * - https://github.com/ros2/rclcpp
     - Not Yet Available
   * - https://github.com/ros2/rclpy
     - Not Yet Available
   * - https://github.com/ros2/rcpputils
     - Not Yet Available
   * - https://github.com/ros2/rcutils
     - Not Yet Available
   * - https://github.com/ros2/realtime_support
     - Not Yet Available
   * - https://github.com/ros2/rmw
     - Not Yet Available
   * - https://github.com/ros2/rmw_connextdds
     - Not Yet Available
   * - https://github.com/ros2/rmw_cyclonedds
     - Not Yet Available
   * - https://github.com/ros2/rmw_dds_common
     - Not Yet Available
   * - https://github.com/ros2/rmw_fastrtps
     - Not Yet Available
   * - https://github.com/ros2/rmw_implementation
     - Not Yet Available
   * - https://github.com/ros2/rmw_zenoh
     - Not Yet Available
   * - https://github.com/ros2/ros_testing
     - Not Yet Available
   * - https://github.com/ros2/ros1_bridge
     - Not Yet Available
   * - https://github.com/ros2/ros2
     - Not Yet Available
   * - https://github.com/ros2/ros2_documentation
     - Not Yet Available
   * - https://github.com/ros2/ros2_tracing
     - Not Yet Available
   * - https://github.com/ros2/ros2cli
     - Not Yet Available
   * - https://github.com/ros2/ros2cli_common_extensions
     - Not Yet Available
   * - https://github.com/ros2/rosbag2
     - Not Yet Available
   * - https://github.com/ros2/rosidl
     - Not Yet Available
   * - https://github.com/ros2/rosidl_core
     - Not Yet Available
   * - https://github.com/ros2/rosidl_dds
     - Not Yet Available
   * - https://github.com/ros2/rosidl_defaults
     - Not Yet Available
   * - https://github.com/ros2/rosidl_dynamic_typesupport
     - Not Yet Available
   * - https://github.com/ros2/rosidl_dynamic_typesupport_fastrtps
     - Not Yet Available
   * - https://github.com/ros2/rosidl_python
     - Not Yet Available
   * - https://github.com/ros2/rosidl_runtime_py
     - Not Yet Available
   * - https://github.com/ros2/rosidl_typesupport
     - Not Yet Available
   * - https://github.com/ros2/rosidl_typesupport_fastrtps
     - Not Yet Available
   * - https://github.com/ros2/rpyutils
     - Not Yet Available
   * - https://github.com/ros2/rviz
     - Not Yet Available
   * - https://github.com/ros2/spdlog_vendor
     - Not Yet Available
   * - https://github.com/ros2/sros2
     - Not Yet Available
   * - https://github.com/ros2/system_tests
     - Not Yet Available
   * - https://github.com/ros2/test_interface_files
     - Not Yet Available
   * - https://github.com/ros2/tinyxml_vendor
     - Not Yet Available
   * - https://github.com/ros2/tinyxml2_vendor
     - Not Yet Available
   * - https://github.com/ros2/tlsf
     - Not Yet Available
   * - https://github.com/ros2/unique_identifier_msgs
     - Not Yet Available
   * - https://github.com/ros2/urdf
     - Not Yet Available
   * - https://github.com/ros2/yaml_cpp_vendor
     - Not Yet Available

Upcoming ROS Events
-------------------

Upcoming ROS Events can be found in this `Google Calendar <https://calendar.google.com/calendar/embed?src=agf3kajirket8khktupm9go748%40group.calendar.google.com&ctz=America%2FLos_Angeles>`_.
It can be accessed via `iCal <https://calendar.google.com/calendar/ical/agf3kajirket8khktupm9go748%40group.calendar.google.com/public/basic.ics>`_.

.. raw:: html

    <!--
    The below code comes from https://www.mpking.com/2021/04/making-google-calendar-embeddable.html.
    The basic idea is that if we are on a desktop device (defined as anything that has more than 767 pixels),
    then we show the monthly version of the calendar. If we are on a device with 767 or less, show the agenda
    version, which is much narrower.
    -->
    <style>
      .responsiveCal {
        position: relative; padding-bottom: 75%; height: 0; overflow: hidden;
      }

      .responsiveCal iframe {
        position: absolute; top:0; left: 0; width: 100%; height: 100%;
      }

      @media all and (min-width: 768px) {
        .deskContent {display:block;}
        .phoneContent {display:none;}
      }

      @media all and (max-width: 767px) {
        .deskContent {display:none;}
        .phoneContent {display:block;}
      }
    </style>
    <div class=""responsiveCal"">
      <div class=""deskContent"">
        <iframe src=""https://calendar.google.com/calendar/embed?src=agf3kajirket8khktupm9go748%40group.calendar.google.com"" style=""border: 0"" width=""800"" height=""600"" frameborder=""0"" scrolling=""no""></iframe>
      </div>
      <div class=""phoneContent""><iframe src=""https://calendar.google.com/calendar/embed?mode=AGENDA&amp;height=400&amp;wkst=1&amp;src=agf3kajirket8khktupm9go748%40group.calendar.google.com"" style=""border: 0"" width=""280"" height=""500"" frameborder=""0"" scrolling=""no""></iframe>
      </div>
    </div>

If you have an individual event or series of events that you'd like to post please contact info@openrobotics.org.
",What is the role of the ROS Project Management Committee within the Open Source Robotics Alliance (OSRA) governance structure?
".. _Metrics:

Metrics
=======

.. contents:: Table of Contents
   :depth: 2
   :local:


We measure aspects of the ROS community to understand and track the impact of our work and identify areas for improvement.
We take inspiration from the MeeGo Project's metrics.

Metrics.ros.org
---------------

At `metrics.ros.org <https://metrics.ros.org>`_ you can find many visualizations of metrics about ROS.

Periodic Metrics Report
-----------------------

We periodically publish a metrics report that provides a quantitative view of the ROS community.
We're collectively learning what to measure and how and evoloving as systems change.
Please provide feedback!
Add your suggestions on how to improve these reports by posting them to `ROS Discourse Site Feedback Category <http://discourse.ros.org/c/site-feedback>`_.

Historical Metrics Reports
..........................

* `2023 <http://download.ros.org/downloads/metrics/metrics-report-2024-01.pdf>`_
* `2022 <http://download.ros.org/downloads/metrics/metrics-report-2022-07.pdf>`_
* `2021 <http://download.ros.org/downloads/metrics/metrics-report-2021-07.pdf>`_
* `2020 <http://download.ros.org/downloads/metrics/metrics-report-2020-07.pdf>`_
* `2019 <http://download.ros.org/downloads/metrics/metrics-report-2019-07.pdf>`_
* `2018 <http://download.ros.org/downloads/metrics/metrics-report-2018-07.pdf>`_
* `2017 <http://download.ros.org/downloads/metrics/metrics-report-2017-07.pdf>`_
* `2016 <http://download.ros.org/downloads/metrics/metrics-report-2016-07.pdf>`_
* `2015 <http://download.ros.org/downloads/metrics/metrics-report-2015-07.pdf>`_
* `2014 <http://download.ros.org/downloads/metrics/metrics-report-2014-07.pdf>`_
* `2013 <http://download.ros.org/downloads/metrics/metrics-report-2013-08.pdf>`_
* `2012 <http://download.ros.org/downloads/metrics/metrics-report-2012-07.pdf>`_
* `2011 <http://download.ros.org/downloads/metrics/metrics-report-2011-08.pdf>`_
",What is the purpose of metrics in the ROS community?
".. redirect-from::

  Roadmap

.. _Roadmap:

Roadmap
=======

.. contents:: Table of Contents
   :depth: 2
   :local:

This page describes planned work for ROS 2.
The set of planned features and development efforts should provide insight into the overall direction of ROS 2.
If you would like to see other features on the roadmap, please get in touch with us at info@openrobotics.org.

Kilted Roadmap
--------------

Kilted Kaiju is the ROS 2 release expected in May 2025.
See the :doc:`release page <../Releases/Release-Kilted-Kaiju>` for a detailed timeline.

The items in the roadmap below are the major features being worked on by the ROS 2 community.
The ""Size"" is an estimated size of the task, where *Small* means person-days to complete, *Medium* means person-weeks to complete, and *Large* means person-months to complete.

If you are working on a feature for ROS 2 and would like to have it listed, please open a pull request to `ROS 2 Documentation <https://github.com/ros2/ros2_documentation>`__.
If you'd like to take on one of these tasks, please :doc:`get in touch with us <../Contact>`.

.. raw:: html

   <style>
     .wy-table-responsive table td, .wy-table-responsive table th {
       white-space: normal;
     }
   </style>

.. list-table::
   :widths: 40 10 25 25
   :header-rows: 1

   * - Task
     - Size
     - Owner
     - Expected Completion
   * - Make ``rmw_zenoh_cpp`` a Tier-1 RMW
     - Large
     - Intrinsic
     - May 2025

Planned releases
----------------

Please see the :doc:`Distributions page <../Releases>` for the timeline of and information about future distributions.

Contributing to ROS 2
---------------------

Looking for something to work on, or just want to help out? Here are a few resources to get you going.

1. The :doc:`Contributing <Contributing>` guide describes how to make a contribution to ROS 2.
2. Check out the list of :doc:`Feature Ideas <Feature-Ideas>` for inspiration.
3. For more information on the design of ROS 2 please see `design.ros2.org <https://design.ros2.org>`__.
4. The core code for ROS 2 is in the `ros2 GitHub organization <https://github.com/ros2>`__.
5. The Discourse forum/mailing list for discussing ROS 2 design is `ng-ros <https://discourse.ros.org/c/ng-ros>`__.
6. Questions should be asked on `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__\ , make sure to include at least the ``ros2`` tag and the rosdistro version you are running, e.g. ``{DISTRO}``.
","What is the expected completion date for making ""rmw_zenoh_cpp"" a Tier-1 RMW in ROS 2 roadmap?"
".. redirect-from::

  Contributing

.. _Contributing:

Contributing
============

.. contents:: Table of Contents
   :depth: 1
   :local:

A few things to remember before you start contributing to the ROS 2 project.

Tenets
------

* Respect what came before

  ROS has been around for more than a decade and is used by developers and across the world.
  Keep a humble attitude and an open mindset while contributing.

* Engage Open Robotics as early as possible

  * Open Robotics acts as a gate-keeper and advocate for the ROS community.
    Rely on their expertise and technical judgement from the design phase.
  * Start discussions with Open Robotics and the community early.
    Long time ROS contributors may have a clearer vision of the bigger picture.
    If you implement a feature and send a pull request without discussing with the community first, you are taking the risk of it being rejected, or you may be asked to largely rethink your design.
  * Opening issues or using Discourse to socialize an idea before starting the implementation is generally preferable.

* Adopt community best-practices whenever possible instead of ad-hoc processes

  Think about your end-user's experience when developing and contributing.
  Avoid using non-standard tools or libraries that may not be accessible to everyone.

* Think about the community as a whole

  Think about the bigger picture.
  There are developers building different robots with different constraints.
  ROS needs to accommodate requirements of the whole community.

There are a number of ways you can contribute to the ROS 2 project.

Discussions and support
-----------------------

Some of the easiest ways to contribute to ROS 2 involve engaging in community discussions and support.
You can find more information on how to pitch in on the :doc:`Contact <../../Contact>` page.

Contributing code
-----------------

Setting up your development environment
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To get started, you'll want to install from source; follow :ref:`the source installation instructions <building-from-source>` for your platform.

Development Guides
^^^^^^^^^^^^^^^^^^

.. toctree::
   :titlesonly:
   :maxdepth: 1

   Contributing/Developer-Guide
   Contributing/Code-Style-Language-Versions
   Contributing/Quality-Guide
   Contributing/Build-Farms
   Contributing/Windows-Tips-and-Tricks
   Contributing/Contributing-To-ROS-2-Documentation

What to work on
^^^^^^^^^^^^^^^

We have identified a number of tasks that could be worked on by community members: they can be listed by `searching across the ROS 2 repositories for issues labeled as ""help wanted"" <https://github.com/search?q=user%3Aament+user%3Aros2+is%3Aopen+label%3A""help+wanted""&type=Issues>`__.
If you see something on that list that you would like to work on, please comment on the item to let others know that you are looking into it.

We also have a label for issues that we think should be more accessible for first-time contributors, `labeled “good first issue” <https://github.com/search?q=user%3Aament+user%3Aros2+is%3Aopen+label%3A%22good+first+issue%22&type=Issues>`__.
If you are interested in contributing to the ROS 2 project, we encourage you to take a look at those issues first.
If you’d like to cast a wider net, we welcome contributions on any open issue (or others that you might propose), particularly tasks that have a milestone signifying they’re targeted for the next ROS 2 release (the milestone will be the next release's e.g. 'crystal').

If you have some code to contribute that fixes a bug or improves documentation, please submit it as a pull request to the relevant repository.
For larger changes, it is a good idea to discuss the proposal `on the ROS 2 forum <https://discourse.ros.org/c/ng-ros>`__ before you start to work on it so that you can identify if someone else is already working on something similar.
If your proposal involves changes to the APIs, it is especially recommended that you discuss the approach before starting work.

Submitting your code changes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Code contributions should be made via pull requests to `the appropriate ros2 repositories <https://github.com/ros2>`__.

We ask all contributors to follow the practices explained in :doc:`the developer guide <Contributing/Developer-Guide>`.

Please be sure to :ref:`run tests <colcon-run-the-tests>` for your code changes because most packages have tests that check that the code complies with our style guidelines.

Becoming a core maintainer
^^^^^^^^^^^^^^^^^^^^^^^^^^

The ROS 2 maintainers ensure that the project is generally making progress.
The responsibilities of the maintainers include:

* Reviewing incoming code contributions for style, quality, and overall fit into the goals of the repository/ROS 2.
* Ensuring that CI continues to stay green.
* Merging pull requests that meet the quality and CI standards above.
* Addressing issues opened up by users.

Each repository in the `ros2 <https://github.com/ros2>`__ and `ament <https://github.com/ament>`__ organizations has a separate set of maintainers.
Becoming a maintainer of one or more of those repositories is an invitation-only process, and generally involves the following steps:

* Within the last year, have a substantial number of code contributions to the repository.
* Within the last year, do a substantial number of reviews on incoming pull requests to the repository.

Approximately every 3 months, the ROS 2 team will review the contributions in all of the repositories and send out invitations to new maintainers.
Once the invitation is accepted, the new maintainer will be asked to go through a short training process on the mechanisms and policies of the ROS 2 repositories.
After that training process is completed, the new maintainer will be given write access to the appropriate repositories.
",What are some responsibilities of the ROS 2 maintainers as mentioned in the text?
".. redirect-from::

    Developer-Guide
    Contributing/Developer-Guide

ROS 2 developer guide
=====================

.. contents:: Table of Contents
   :depth: 2
   :local:

This page defines the practices and policies we employ when developing ROS 2.

General Principles
------------------

Some principles are common to all ROS 2 development:


* **Shared ownership**:
  Everybody working on ROS 2 should feel ownership over all parts of the system.
  The original author of a chunk of code does not have any special permission or obligation to control or maintain that chunk of code.
  Everyone is free to propose changes anywhere, to handle any type of ticket, and to review any pull request.
* **Be willing to work on anything**:
  As a corollary to shared ownership, everybody should be willing to take on any available task and contribute to any aspect of the system.
* **Ask for help**:
  If you run into trouble on something, ask your fellow developers for help, via tickets, comments, or email, as appropriate.

Quality Practices
-----------------

Packages can ascribe to different levels of quality based on the development practices they adhere to, as per the guidelines in `REP 2004: Package Quality Categories <https://www.ros.org/reps/rep-2004.html>`_.
The categories are differentiated by their policies on versioning, testing, documentation, and more.

The following sections are the specific development rules we follow to ensure core packages are of the highest quality ('Level 1').
We recommend all ROS developers strive to adhere to the following policies to ensure quality across the ROS ecosystem.

For more specific code recommendations please see :doc:`the Quality Guide <Quality-Guide>`.

.. _semver:

Versioning
^^^^^^^^^^

We will use the `Semantic Versioning guidelines <http://semver.org/>`__ (``semver``) for versioning.

We will also adhere to some ROS-specific rules built on top of ``semver's`` full meaning:

* Major version increments (i.e. breaking changes) should not be made within a released ROS distribution.

  * Patch (interface-preserving) and minor (non-breaking) version increments do not break compatibility, so these sorts of changes *are* allowed within a release.

  * Major ROS releases are the best time to release breaking changes.
    If a core package needs multiple breaking changes, they should be merged into their integration branch (e.g. rolling) to allow catching problems in CI quickly, but released together to reduce the number of major releases for ROS users.

  * Though major increments require a new distribution, a new distribution does not necessarily require a major bump (if development and release can happen without breaking API).

* For compiled code, the ABI is considered part of the public interface.
  Any change that requires recompiling dependent code is considered major (breaking).

  * ABI breaking changes *can* be made in a minor version bump *before* a distribution release (getting added to the rolling release).

* We enforce API stability for core packages in Dashing and Eloquent even though their major version components are ``0``, despite `SemVer's specification <https://semver.org/#spec-item-4>`_ regarding initial development.

  * Subsequently, packages should strive to reach a mature state and increase to version ``1.0.0`` so to match ``semver's`` specifications.

Caveats
~~~~~~~

These rules are *best-effort*.
In unlikely, extreme cases, it may be necessary to break API within a major version/distribution.
Whether an unplanned break increments the major or minor version will be assessed on a case-by-case basis.

For example, consider a situation involving released X-turtle, corresponding to major version ``1.0.0``, and released Y-turtle, corresponding to major version ``2.0.0``.

If an API-breaking fix is identified to be absolutely necessary in X-turtle, bumping to ``2.0.0`` is obviously not an option because ``2.0.0`` already exists.

The solutions for handling X-turtle's version in such a case, both non-ideal, are:

1. Bumping X-turtle's minor version: non-ideal because it violates SemVer's principle that breaking changes must bump the major version.

2. Bumping X-turtle's major version past Y-turtle (to ``3.0.0``): non-ideal because the older distro's version would become higher than the already-available version of a newer distro, which would invalidate/break version-specific conditional code.

The developer will have to decide which solution to use, or more importantly, which principle they are willing to break.
We cannot suggest one or the other, but in either case we do require that explicit measures be taken to communicate the disruption and its explanation to users manually (beyond just the version increment).

If there were no Y-turtle, even though the fix would technically just be a patch, X-turtle would have to bump to ``2.0.0``.
This case adheres to SemVer, but breaks from our own rule that major increments should not be introduced in a released distribution.

This is why we consider the versioning rules *best-effort*.
As unlikely as the examples above are, it is important to accurately define our versioning system.

Public API declaration
~~~~~~~~~~~~~~~~~~~~~~

According to ``semver``, every package must clearly declare a public API.
We will use the ""Public API Declaration"" section of the quality declaration of a package to declare what symbols are part of the public API.

For most C and C++ packages the declaration is any header that it installs.
However, it is acceptable to define a set of symbols which are considered private.
Avoiding private symbols in headers can help with ABI stability, but is not required.

For other languages like Python, a public API must be explicitly defined, so that it is clear what symbols can be relied on with respect to the versioning guidelines.
The public API can also be extended to build artifacts like configuration variables, CMake config files, etc. as well as executables and command-line options and output.
Any elements of the public API should be clearly stated in the package's documentation.
If something you are using is not explicitly listed as part of the public API in the package's documentation, then you cannot depend on it not changing between minor or patch versions.

Deprecation strategy
~~~~~~~~~~~~~~~~~~~~

Where possible, we will also use the tick-tock deprecation and migration strategy for major version increments.
New deprecations will come in a new distribution release, accompanied by compiler warnings expressing that the functionality is being deprecated.
In the next release, the functionality will be completely removed (no warnings).

Example of function ``foo`` deprecated and replaced by function ``bar``:

=========  ========================================================
 Version    API
=========  ========================================================
X-turtle   void foo();
Y-turtle   [[deprecated(""use bar()"")]] void foo(); <br> void bar();
Z-turtle   void bar();
=========  ========================================================

We must not add deprecations after a distribution is released.
Deprecations do not necessarily require a major version bump, though.
A deprecation can be introduced in a minor version bump if the bump happens before the distro is released (similar to ABI breaking changes).

For example, if X-turtle begins development as ``2.0.0``, a deprecation can be added in ``2.1.0`` before X-turtle is released.

We will attempt to maintain compatibility across distros as much as possible.
However, like the caveats associated with SemVer, tick-tock or even deprecation in general may be impossible to completely adhere to in certain cases.

Change control process
^^^^^^^^^^^^^^^^^^^^^^

* All changes must go through a pull request.

* We will enforce the `Developer Certificate of Origin (DCO) <https://developercertificate.org/>`_ on pull requests in ROSCore repositories.

  * It requires all commit messages to contain the ``Signed-off-by`` line with an email address that matches the commit author.

  * You can pass ``-s`` / ``--signoff`` to the ``git commit`` invocation or write the expected message manually (e.g. ``Signed-off-by: Your Name Developer <your.name@example.com>``).

  * DCO is *not* required for pull requests that only address whitespace removal, typo correction, and other `trivial changes <http://cr.openjdk.java.net/~jrose/draft/trivial-fixes.html>`_.

* Always run CI jobs for all `tier 1 platforms <https://www.ros.org/reps/rep-2000.html#support-tiers>`_ for every pull request and include links to jobs in the pull request.
  (If you don't have access to the Jenkins jobs someone will trigger the jobs for you.)

* A minimum of 1 approval from a fellow developer who did not author the pull request is required to consider it approved.
  Approval is required before merging.

  * Packages may choose to increase this number.

* Any required changes to documentation (API documentation, feature documentation, release notes, etc.) must be proposed before merging related changes.

Guidelines for backporting PRs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When changing an older version of ROS:

* Make sure the features or fixes are accepted and merged in the rolling branch before opening a PR to backport the changes to older versions.
* When backporting to older versions, also consider backporting to any other :doc:`still supported versions <../../Releases>`, even non-LTS versions.
* If you are backporting a single PR in its entirety, title the backport PR ""[Distro] <name of original PR>"".
  If backporting a subset of changes from one or multiple PRs, the title should be ""[Distro] <description of changes>"".
* Link to all PRs whose changes you're backporting from the description of your backport PR.
  In a Dashing backport of a Foxy change, you do not need to link to the Eloquent backport of the same change.

Documentation
^^^^^^^^^^^^^

All packages should have these documentation elements present in their README or linked to from their README:

* Description and purpose
* Definition and description of the public API
* Examples
* How to build and install (should reference external tools/workflows)
* How to build and run tests
* How to build documentation
* How to develop (useful for describing things like ``python setup.py develop``)
* License and copyright statements

Each source file must have a license and copyright statement, checked with an automated linter.

Each package must have a LICENSE file, typically the Apache 2.0 license, unless the package has an existing permissive license (e.g. rviz uses three-clause BSD).

Each package should describe itself and its purpose assuming, as much as possible, that the reader has stumbled onto it without previous knowledge of ROS or other related projects.

Each package should define and describe its public API so that there is a reasonable expectation for users about what is covered by the semantic versioning policy.
Even in C and C++, where the public API can be enforced by API and ABI checking, it is a good opportunity to describe the layout of the code and the function of each part of the code.

It should be easy to take any package and from that package's documentation understand how to build, run, build and run tests, and build the documentation.
Obviously we should avoid repeating ourselves for common workflows, like building a package in a workspace, but the basic workflows should be either described or referenced.

Finally, it should include any documentation for developers.
This might include workflows for testing the code using something like ``python setup.py develop``, or it might mean describing how to make use of extension points provided by your package.

Examples:

* capabilities: https://docs.ros.org/hydro/api/capabilities/html/

  * This one gives an example of docs which describe the public API

* catkin_tools: https://catkin-tools.readthedocs.org/en/latest/development/extending_the_catkin_command.html

  * This is an example of describing an extension point for a package

API Documetation for ROS Packages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

API documentation for all released ROS packages can be `found here <https://docs.ros.org/en/{DISTRO}/p/>`__.
We recommend using `index.ros.org <https://index.ros.org/>`_ to search through available ROS packages to find their documentation.

If you are a ROS package developer looking for guidance on documenting your package please see :doc:`our ""how to"" guide on package level documentation <../../How-To-Guides/Documenting-a-ROS-2-Package>`.
The documentation for all released ROS 2 packages is automatically hosted on `docs.ros.org <https://docs.ros.org/en/{DISTRO}/p/>`_.

Testing
^^^^^^^

All packages should have some level of :ref:`system, integration, and/or unit tests.<TestingMain>`

**Unit tests** should always be in the package which is being tested and should make use of tools like ``Mock`` to try and test narrow parts of the codebase in constructed scenarios.
Unit tests should not bring in test dependencies that are not testing tools, e.g. gtest, nosetest, pytest, mock, etc...

**Integration tests** can test interactions between parts of the code or between parts of the code and the system.
They often test software interfaces in ways that we expect the user to use them.
Like Unit tests, Integration tests should be in the package which is being tested and should not bring in non-tool test dependencies unless absolutely necessary, i.e. all non-tool dependencies should only be allowed under extreme scrutiny so they should be avoided if possible.

**System tests** are designed to test end-to-end situations between packages and should be in their own packages to avoid bloating or coupling packages and to avoid circular dependencies.

In general external or cross package test dependencies should be minimized to prevent circular dependencies and tightly coupled test packages.

All packages should have some unit tests and possibly integration tests, but the degree to which they should have them is based on the package's quality category.
The following subsections apply to 'Level 1' packages:

Code coverage
~~~~~~~~~~~~~

We will provide line coverage, and achieve line coverage above 95%.
If a lower percentage target is justifiable, it must be prominently documented.
We may provide branch coverage, or exclude code from coverage (test code, debug code, etc.).
We require that coverage increase or stay the same before merging a change, but it may be acceptable to make a change that decreases code coverage with proper justification (e.g. deleting code that was previously covered can cause the percentage to drop).

Performance
~~~~~~~~~~~

We strongly recommend performance tests, but recognize they don't make sense for some packages.
If there are performance tests, we will choose to either check each change or before each release or both.
We will also require justification for merging a change or making a release that lowers performance.

Linters and static analysis
~~~~~~~~~~~~~~~~~~~~~~~~~~~

We will use :doc:`ROS code style <Code-Style-Language-Versions>` and enforce it with linters from `ament_lint_common <https://github.com/ament/ament_lint/tree/{REPOS_FILE_BRANCH}/ament_lint_common/doc/index.rst>`_.
All linters/static analysis that are part of ``ament_lint_common`` must be used.

The `ament_lint_auto <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_lint_auto/doc/index.rst>`_ documentation provides information on running ``ament_lint_common``.

General Practices
-----------------

Some practices are common to all ROS 2 development.

These practices don't affect package quality level as described in `REP 2004 <https://www.ros.org/reps/rep-2004.html>`_, but are still highly recommended for the development process.

Issues
^^^^^^

When filing an issue please make sure to:

- Include enough information for another person to understand the issue.
  In ROS 2, the following points are needed for narrowing down the cause of an issue.
  Testing with as many alternatives in each category as feasible will be especially helpful.

  - **The operating system and version.**
    Reasoning: ROS 2 supports multiple platforms, and some bugs are specific to particular versions of operating systems/compilers.
  - **The installation method.**
    Reasoning: Some issues only manifest if ROS 2 has been installed from binary archives or from debs.
    This can help us determine if the issue is with the packaging process.
  - **The specific version of ROS 2.**
    Reasoning: Some bugs may be present in a particular ROS 2 release and later fixed.
    It is important to know if your installation includes these fixes.
  - **The DDS/RMW implementation being used** (see `this page <../../Concepts/Intermediate/About-Different-Middleware-Vendors>` for how to determine which one).
    Reasoning: Communication issues may be specific to the underlying ROS middleware being used.
  - **The ROS 2 client library being used.**
    Reasoning: This helps us narrow down the layer in the stack at which the issue might be.

- Include a list of steps to reproduce the issue.
- In case of a bug consider to provide a `short, self contained, correct (compilable), example <http://sscce.org/>`__.
  Issues are much more likely to be resolved if others can reproduce them easily.

- Mention troubleshooting steps that have been tried already, including:

  - Upgrading to the latest version of the code, which may include bug fixes that have not been released yet.
    See `this section <building-from-source>` and follow the instructions to get the ""rolling"" branches.
  - Trying with a different RMW implementation.
    See `this page <../../How-To-Guides/Working-with-multiple-RMW-implementations>` for how to do that.

Branches
^^^^^^^^

.. note::
    These are just guidelines.
    It is up to the package maintainer to choose branch names that match their own workflow.

It is good practice to have **separate branches** in a package's source repository for each ROS distribution it is targeting.
These branches are typically named after the distribution they target.
For example, a ``humble`` branch for development targeted specifically at the Humble distribution.

Releases are also made from these branches, targeting the appropriate distribution.
Development targeted at a specific ROS distribution can happen on the appropriate branch.
For example: Development commits targeting ``foxy`` are made to the ``foxy`` branch, and package releases for ``foxy`` are made from that same branch.

.. note::
    This requires the package maintainers to perform backports or forwardports as appropriate to keep all branches up to date with features.
    The maintainers must also perform general maintenance (bug fixes, etc.) on all branches from which package releases are still made.

    For example, if a feature is merged into the Rolling-specific branch (e.g. ``rolling`` or ``main``), and that feature is also appropriate
    to the Humble distribution (does not break API, etc.), then it is good practice to backport the feature to the Humble-specific branch.

    The maintainers may make releases for those older distributions if there are new features or bug fixes available.

**What about** ``main`` **and** ``rolling`` **?**

``main`` typically targets :doc:`Rolling <../../Releases/Release-Rolling-Ridley>` (and so, the next unreleased ROS distribution), though the maintainers may decide to develop and release from a ``rolling`` branch instead.

Pull requests
^^^^^^^^^^^^^

* A pull request should only focus on one change.
  Separate changes should go into separate pull requests.
  See `GitHub's guide to writing the perfect pull request <https://github.com/blog/1943-how-to-write-the-perfect-pull-request>`__.

* A patch should be minimal in size and avoid any kind of unnecessary changes.

* A pull request must contain minimum number of meaningful commits.

  * You can create new commits while the pull request is under review.

* Before merging a pull request all changes should be squashed into a small number of semantic commits to keep the history clear.

  * But avoid squashing commits while a pull request is under review.
    Your reviewers might not notice that you made the change, thereby introducing potential for confusion.
    Plus, you're going to squash before merging anyway; there's no benefit to doing it early.

* Any developer is welcome to review and approve a pull request (see `General Principles`_).

* When you are working on a change that is not ready for review or to be merged, use a draft pull request.
  When that change is ready for review, move the pull request out of the draft state.
  Note that if you want early feedback from specific people on a draft pull request, you can @ mention them in the pull request's description or in a comment on the pull request.

* If your pull request depends on other pull requests, link to each depended on pull request by adding ``- Depends on <link>`` at the top of your pull request's description.
  Doing so helps reviewers understand the context of the pull request.

* When you start reviewing a pull request, comment on the pull request so that other developers know that you're reviewing it.

* Pull-request review is not read-only, with the reviewer making comments and then waiting for the author to address them.
  As a reviewer, feel free to make minor improvements (typos, style issues, etc.) in-place.
  As the opener of a pull-request, if you are working in a fork, checking the box to `allow edits from upstream contributors <https://github.com/blog/2247-improving-collaboration-with-forks>`__ will assist with the aforementioned.
  As a reviewer, also feel free to make more substantial improvements, but consider putting them in a separate branch (either mention the new branch in a comment, or open another pull request from the new branch to the original branch).

* Any developer (the author, the reviewer, or somebody else) can merge any approved pull request.

Library versioning
^^^^^^^^^^^^^^^^^^

We will version all libraries within a package together.
This means that libraries inherit their version from the package.
This keeps library and package versions from diverging and shares reasoning with the policy of releasing packages which share a repository together.
If you need libraries to have different versions then consider splitting them into different packages.

Development process
^^^^^^^^^^^^^^^^^^^

* The default branch (in most cases the rolling branch) must always build, pass all tests and compile without warnings.
  If at any time there is a regression it is the top priority to restore at least the previous state.
* Always build with tests enabled.
* Always run tests locally after changes and before proposing them in a pull request.
  Besides using automated tests, also run the modified code path manually to ensure that the patch works as intended.
* Always run CI jobs for all platforms for every pull request and include links to the jobs in the pull request.

For more details on recommended software development workflow, see `Software Development Lifecycle`_ section.

Changes to RMW API
^^^^^^^^^^^^^^^^^^

When updating `RMW API <https://github.com/ros2/rmw>`__, it is required that RMW implementations for the Tier 1 middleware libraries are updated as well.
For example, a new function ``rmw_foo()`` introduced to the RMW API must be implemented in the following packages (as of ROS Galactic):

* `rmw_connextdds <https://github.com/ros2/rmw_connextdds>`__
* `rmw_cyclonedds <https://github.com/ros2/rmw_cyclonedds>`__
* `rmw_fastrtps <https://github.com/ros2/rmw_fastrtps>`__

Updates for non-Tier 1 middleware libraries should also be considered if feasible (e.g. depending on the size of the change).
See `REP-2000 <https://www.ros.org/reps/rep-2000.html>`__ for the list of middleware libraries and their tiers.

Tracking tasks
^^^^^^^^^^^^^^

To help organize work on ROS 2, the core ROS 2 development team uses kanban-style `GitHub project boards <https://github.com/orgs/ros2/projects>`_.

Not all issues and pull requests are tracked on the project boards, however.
A board usually represents an upcoming release or specific project.
Tickets can be browsed on a per-repo basis by browsing the `ROS 2 repositories' <https://github.com/ros2>`_ individual issue pages.

The names and purposes of columns in any given ROS 2 project board vary, but typically follow the same general structure:

* **To do**:
  Issues that are relevant to the project, ready to be assigned
* **In progress**:
  Active pull requests on which work is currently in progress
* **In review**:
  Pull requests where work is complete and ready for review, and for those currently under active review
* **Done**:
  Pull requests and related issues are merged/closed (for informational purposes)

To request permission to make changes, simply comment on the tickets you're interested in.
Depending on the complexity, it might be useful to describe how you plan to address it.
We will update the status (if you don't have the permission) and you can start working on a pull request.
If you contribute regularly we will likely just grant you permission to manage the labels etc. yourself.

Package Naming Conventions
^^^^^^^^^^^^^^^^^^^^^^^^^^

Names play an important role in ROS and following naming conventions simplifies the process of learning and understanding large systems.

The ROS packages occupy a flat namespace, so naming should be done carefully and consistently. There is a standard for package naming in `REP-144 <https://www.ros.org/reps/rep-0144.html>`__

* Package names should follow common C variable naming conventions: lower case, start with a letter, use underscore separators, e.g. laser_viewer

* Package names should be specific enough to identify what the package does.
  For example, a motion planner is not called planner.
  If it implements the wavefront propagation algorithm, it might be called wavefront_planner.
  There's obviously tension between making a name specific and keeping it from becoming overly verbose.

  * Using catchall names such as utils should be avoided as they do not scope what goes into the package or what should be outside the package.

* To check whether a name is taken, consult `<https://index.ros.org/packages/>`__.
  If you'd like your repository included in that list, see the `rosdistro Contributing Guide <https://github.com/ros/rosdistro/blob/master/CONTRIBUTING.md>`__.

* Our goal is to develop a canonical set of tools for making robots do interesting things.
  The package name should tell you what the package does, not where it came from.
  It should be possible for us, as a community, to make this work.
  An Ubuntu distribution offers approximately 33,000 packages without inserting origin or authorship into names.

* Prefixing a package name is recommended only when the package is not meant to be used more widely (e.g., packages that are specific to the PR2 robot use the ``pr2_`` prefix).
  You might prefix the package name when forking an existing package, but again, the prefix would hopefully communicate what changed, not who changed it.

* Prefixing a package name with 'ros' is redundant for a ROS package.
  This is not recommended except for very core packages.

Units of Measure and Coordinate System Conventions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Standard units and coordinate conventions for use in ROS have been formalized in `REP-103 <https://www.ros.org/reps/rep-0103.html>`__.
All messages should follow these guidelines unless there's a very strong reason which is very clearly documented to avoid confusion.

Representation of special conditions within distance measurements like ""too close"" or ""too far"" in ROS have been formalized in `REP-0117 <https://www.ros.org/reps/rep-0117.html>`__.

Programming conventions
^^^^^^^^^^^^^^^^^^^^^^^

* Defensive programming: ensure that assumptions are held as early as possible.
  E.g. check every return code and make sure to at least throw an exception until the case is handled more gracefully.
* All error messages must be directed to ``stderr``.
* Declare variables in the narrowest scope possible.
* Keep group of items (dependencies, imports, includes, etc.) ordered alphabetically.

C++ specific
~~~~~~~~~~~~

* Avoid using direct streaming (``<<``) to ``stdout`` / ``stderr`` to prevent interleaving between multiple threads.
* Avoid using references for ``std::shared_ptr`` since that subverts the reference counting.
  If the original instance goes out of scope and the reference is being used it accesses freed memory.

Filesystem layout
^^^^^^^^^^^^^^^^^

The filesystem layout of packages and repositories should follow the same conventions in order to provide a consistent experience for users browsing our source code.

Package layout
~~~~~~~~~~~~~~

* ``src``: contains all C and C++ code

  * Also contains C/C++ headers which are not installed

* ``include``: contains all C and C++ headers which are installed

  * ``<package name>``: for all C and C++ installed headers they should be folder namespaced by the package name

* ``<package_name>``: contains all Python code
* ``test``: contains all automated tests and test data
* ``config``: contains configuration files, e.g. YAML parameters files and RViz config files
* ``doc``: contains all the documentation
* ``launch``: contains all launch files
* ``msg``: contains all ROS Message definitions
* ``srv``: contains all ROS Service definitions
* ``action``: contains all ROS Action definitions
* ``package.xml``: as defined by `REP-0140 <https://www.ros.org/reps/rep-0140.html>`_ (may be updated for prototyping)
* ``CMakeLists.txt``: only ROS packages which use CMake
* ``setup.py``: only ROS packages which use Python code only
* ``README``: can be rendered on GitHub as a landing page for the project

  * This can be as short or detailed as is convenient, but it should at least link to project documentation
  * Consider putting a CI or code coverage tag in this README
  * It can also be ``.rst`` or anything else that GitHub supports

* ``CONTRIBUTING``: describes the contribution guidelines

  * This might include license implication, e.g. when using the Apache 2 License.

* ``LICENSE``: a copy of the license or licenses for this package
* ``CHANGELOG.rst``: `REP-0132 <https://www.ros.org/reps/rep-0132.html>`_ compliant changelog

Repository layout
~~~~~~~~~~~~~~~~~

Each package should be in a subfolder which has the same name as the package.
If a repository contains only a single package it can optionally be in the root of the repository.

Upstream Packages
^^^^^^^^^^^^^^^^^

Packages in Debian and Ubuntu Upstream
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Thanks to diligent effort from Jochen Sprickerhof and Leopold Palomo-Avellaneda, some of the `ROS 2 packages are now available <https://wiki.debian.org/DebianScience/Robotics/ROS2/Packages>`_ from the main Debian and Ubuntu repositories.
`Here is a short overview of the process from Jochen at ROSCon 2015 <https://vimeo.com/142151399#t=29m15s>`_.
The original ROS packages have been modified to follow Debian guidelines, which includes splitting packages into multiple pieces, changing names in some cases, installing to /usr according to FHS guidelines, and using soversions on shared libraries.

In addition several of the bootstrap dependencies such as command line tools like ``vcstool`` and ``colcon`` as well as some libraries like ``osrf-pycommon`` and ``ament`` are also packaged upstream.

Unlike the OSRF-provided ROS packages from http://packages.ros.org, the packages in the upstream repositories are not attached to a specific :doc:`ROS distribution <../../Releases>`.
Rather, they represent a snapshot in time that will be updated periodically within Debian unstable and then latched at various points into downstream Debian and Ubuntu distributions.

Don't mix the streams
~~~~~~~~~~~~~~~~~~~~~

We strongly recommend against mixing ROS packages from upstream Debian/Ubuntu and from http://packages.ros.org on the same system.
In some cases such a mixed system will work correctly, but there can be negative interactions between the two sets of packages.
We’re working with Jochen and friends to minimize the chance of problems via documentation and package conflict specifications, but we expect some risks to remain, including some fairly subtle issues.

As such, we recommend that you choose to either install packages from upstream or from http://packages.ros.org, but not both.
Not only should you not install packages from both at the same time, but if you intend to use the upstream packages then you should not even have the http://packages.ros.org entries in your apt sources (i.e. in any files in ``/etc/apt/sources*``).
Having both of them enabled can cause mixing of packages which overlap by name between the two sources, e.g. ``python3-rospkg``.

Known Differences
~~~~~~~~~~~~~~~~~

As compared to the ROS packages from packages.ros.org, there are some differences in the upstream ROS packages that people should be aware of:

* The package set is incomplete.
* Packages may have different names and be partitioned differently.

Developer Workflow
------------------

We track open tickets and active PRs related to upcoming releases and larger projects using `GitHub project boards <https://github.com/orgs/ros2/projects>`_.

The usual workflow is:

* Discuss design (GitHub ticket on the appropriate repository, and a design PR to https://github.com/ros2/design if needed)
* Write implementation on a feature branch on a fork

  * Please check out the `developer guide <Developer-Guide>` for guidelines and best practices

* Write tests
* Enable and run linters
* Run tests locally using ``colcon test`` (see the :doc:`colcon tutorial <../../Tutorials/Beginner-Client-Libraries/Colcon-Tutorial>`)
* Once everything builds locally without warnings and all tests are passing, run CI on your feature branch:

  * Go to ci.ros2.org
  * Log in (top right corner)
  * Click on the ``ci_launcher`` job
  * Click ""Build with Parameters"" (left column)
  * In the first box ""CI_BRANCH_TO_TEST"" enter your feature branch name
  * Hit the ``build`` button

  (if you are not a ROS 2 committer, you don't have access to the CI farm. In that case, ping the reviewer of your PR to run CI for you)

* If your use case requires running code coverage:

  * Go to ci.ros2.org
  * Log in (top right corner)
  * Click on the ``ci_linux_coverage`` job
  * Click ""Build with Parameters"" (left column)
  * Be sure of leaving ""CI_BUILD_ARGS"" and ""CI_TEST_ARGS"" with the default values
  * Hit the ``build`` button
  * At the end of the document there are instructions on how to :ref:`interpret the result of the report <read-coverage-report>` and :ref:`calculate the coverage rate <calculate-coverage-rate>`

* If the CI job built without warnings, errors and test failures, post the links of your jobs on your PR or high-level ticket aggregating all your PRs (see example `here <https://github.com/ros2/rcl/pull/106#issuecomment-271119200>`__)

  * Note that the markdown for these badges is in the console output of the ``ci_launcher`` job

* When the PR has been approved:

  * the person who submitted the PR merges it using ""Squash and Merge"" option so that we keep a clean history

    * If the commits deserve to keep separated: squash all the nitpick/linters/typo ones together and merge the remaining set

      * Note: each PR should target a specific feature so Squash and Merge should make sense 99% of the time

* Delete the branch once merged

Architectural Development Practices
-----------------------------------

This section describes the ideal lifecycle that should be employed when making large architectural changes to ROS 2.

Software Development Lifecycle
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This section describes step-by-step how to plan, design, and implement a new feature:

1. Task Creation
2. Creating the Design Document
3. Design Review
4. Implementation
5. Code Review

Task creation
~~~~~~~~~~~~~

Tasks requiring changes to critical parts of ROS 2 should have design reviews during early stages of the release cycle.
If a design review is happening in the later stages, the changes will be part of a future release.

* An issue should be created in the appropriate `ros2 repository <https://github.com/ros2/>`__, clearly describing the task being worked on.

  * It should have a clear success criteria and highlight the concrete improvements expected from it.
  * If the feature is targeting a ROS release, ensure this is tracked in the ROS release ticket (`example <https://github.com/ros2/ros2/issues/607>`__).

Writing the design document
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Design docs must never include confidential information.
Whether or not a design document is required for your change depends on how big the task is.

1. You are making a small change or fixing a bug:

  * A design document is not required, but an issue should be opened in the appropriate repository to track the work and avoid duplication of efforts.

2. You are implementing a new feature or would like to contribute to OSRF-owned infrastructure (like Jenkins CI):

  * Design doc is required and should be contributed to `ros2/design <https://github.com/ros2/design/>`__ to be made accessible on https://design.ros2.org/.
  * You should fork the repository and submit a pull request detailing the design.

  Mention the related ros2 issue (for example, ``Design doc for task ros2/ros2#<issue id>``) in the pull request or the commit message.
  Detailed instructions are on the `ROS 2 Contribute <https://design.ros2.org/contribute.html>`__ page.
  Design comments will be made directly on the pull request.

If the task is planned to be released with a specific version of ROS, this information should be included in the pull request.

Design document review
~~~~~~~~~~~~~~~~~~~~~~

Once the design is ready for review, a pull request should be opened and appropriate reviewers should be assigned.
It is recommended to include project owner(s) -
maintainers of all impacted packages (as defined by ``package.xml`` maintainer field, see `REP-140 <https://www.ros.org/reps/rep-0140.html#maintainer-multiple-but-at-least-one>`__) - as reviewers.

* If the design doc is complex or reviewers have conflicting schedules, an optional design review meeting can be set up.
  In this case,

  **Before the meeting**

  * Send a meeting invite at least one week in advance
  * Meeting duration of one hour is recommended
  * Meeting invite should list all decisions to be made during the review (decisions requiring package maintainer approval)
  * Meeting required attendees: design pull request reviewers
      Meeting optional attendees: all OSRF engineers, if applicable

  **During the meeting**

  * The task owner drives the meeting, presents their ideas and manages discussions to ensure an agreement is reached on time

  **After the meeting**

  * The task owner should send back meeting notes to all attendees
  * If minor issues have been raised about the design:

    * The task owner should update the design doc pull request based on the feedback
    * Additional review is not required

  * If major issues have been raised about the design:

    * It is acceptable to remove sections for which there is no clear agreement
    * The debatable parts of the design can be resubmitted as a separate task in the future
    * If removing the debatable parts is not an option, work directly with package owners to reach an agreement

* Once consensus is reached:

  * Ensure the `ros2/design <https://github.com/ros2/design/>`__ pull request has been merged, if applicable
  * Update and close the GitHub issue associated with this design task

Implementation
~~~~~~~~~~~~~~

Before starting, go through the `Pull requests`_ section for best practices.

* For each repo to be modified:

  * Modify the code, go to the next step if finished or at regular intervals to backup your work.
  * `Self-review <https://git-scm.com/book/en/v2/Git-Tools-Interactive-Staging>`__ your changes using ``git add -i``.
  * Create a new signed commit using ``git commit -s``.

    * A pull request should contain minimal semantically meaningful commits (for instance, a large number of 1-line commits is not acceptable).
      Create new fixup commits while iterating on feedback, or optionally, amend existing commits using ``git commit --amend`` if you don't want to create a new commit every time.
    * Each commit must have a properly written, meaningful, commit message.
      More instructions `here <https://chris.beams.io/posts/git-commit/>`__.
    * Moving files must be done in a separate commit, otherwise git may fail to accurately track the file history.
    * Either the pull request description or the commit message must contain a reference to the related ros2 issue, so it gets automatically closed when the pull request is merged.
      See this `doc <https://help.github.com/articles/closing-issues-using-keywords/>`__ for more details.
    * Push the new commits.

Code review
~~~~~~~~~~~

Once the change is ready for code review:

* Open a pull request for each modified repository.

  * Remember to follow `Pull requests`_ best practices.
  * `GitHub <https://hub.github.com/>`__ can be used to create pull requests from the command-line.
  * If the task is planned to be released with a specific version of ROS, this information should be included in each pull request.

* Package owners who reviewed the design document should be mentioned in the pull request.
* Code review SLO: although reviewing pull requests is best-effort,
  it is helpful to have reviewers comment on pull requests within a week and
  code authors to reply back to comments within a week, so there is no loss of context.
* Iterate on feedback as usual, amend and update the development branch as needed.
* Once the PR is approved, package maintainers will merge the changes in.


Build Farm Introduction
-----------------------

The build farm is located at `ci.ros2.org <https://ci.ros2.org/>`__.

Every night we run nightly jobs which build and run all the tests in various scenarios on various platforms.
Additionally, we test all pull requests against these platforms before merging.

This is the current set of target platforms and architectures, though it evolves overtime:


* Ubuntu 24.04 Noble

  * amd64
  * aarch64

* Windows 10

  * amd64

There are several categories of jobs on the buildfarm:


* manual jobs (triggered manually by developers):

  * ci_linux: build + test the code on Ubuntu
  * ci_linux-aarch64: build + test the code on Ubuntu on an ARM 64-bit machine (aarch64)
  * ci_linux_coverage: build + test + generation of test coverage
  * ci_windows: build + test the code on Windows
  * ci_launcher: trigger all the jobs listed above

* nightly (run every night):

  * Debug: build + test the code with CMAKE_BUILD_TYPE=Debug

    * nightly_linux_debug
    * nightly_linux-aarch64_debug
    * nightly_win_deb

  * Release: build + test the code with CMAKE_BUILD_TYPE=Release

    * nightly_linux_release
    * nightly_linux-aarch64_release
    * nightly_win_rel

  * Repeated: build then run each test up to 20 times or until failed (aka flakiness hunter)

    * nightly_linux_repeated
    * nightly_linux-aarch64_repeated
    * nightly_win_rep

  * Coverage:

    * nightly_linux_coverage: build + test the code + analyses coverage for c/c++ and python

      * results are exported as a cobertura report


* packaging (run every night; result is bundled into an archive):

  * packaging_linux
  * packaging_windows

Two additional build farms support the ROS / ROS 2 ecosystem by providing building of source and
binary packages, continuous integration, testing, and analysis.

For details, frequently asked questions, and troubleshooting see :doc:`build farms <Build-Farms>`.

Note on Coverage runs
^^^^^^^^^^^^^^^^^^^^^

ROS 2 packages are organized in a way that the testing code for a given package is not only contained within the package, but could also be present in a different package.
In other words: packages can exercise code belonging to other packages during the testing phase.

To achieve the coverage rate reached by all code available in the ROS 2 core packages it is recommended to run builds using a fixed set of proposed repositories.
That set is defined in the default parameters of coverage jobs in Jenkins.


.. _read-coverage-report:

How to read the coverage rate from the buildfarm report
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To see the coverage report for a given package:

* When the ``ci_linux_coverage`` build finishes, click on ``Coverage Report``
* Scroll down to the ``Coverage Breakdown by Package`` table
* In the table, look at the first column called ""Name""

The coverage reports in the buildfarm include all the packages that were used in the ROS workspace.
The coverage report includes different paths corresponding to the same package:

* Name entries with the form: ``src.*.<repository_name>.<package_name>.*``
  These correspond to the unit test runs available in a package against its own source code
* Name entries with the form: ``build.<repository_name>.<package_name>.*``
  These correspond to the unit test runs available in a package against its files generated at building or configuring time
* Name entries with the form: ``install.<package_name>.*``
  These correspond to the system/integration tests coming from testing runs of other packages

.. _calculate-coverage-rate:

How to calculate the coverage rate from the buildfarm report
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Get the combined unit coverage rate using the automatic script:

 * From the ci_linux_coverage Jenkins build copy the URL of the build
 * Download the `get_coverage_ros2_pkg <https://raw.githubusercontent.com/ros2/ci/master/tools/get_coverage_ros2_pkg.py>`__ script
 * Execute the script: ``./get_coverage_ros2_pkg.py <jenkins_build_url> <ros2_package_name>`` (`README <https://github.com/ros2/ci/blob/master/tools/README.md>`__)
 * Grab the results from the ""Combined unit testing"" final line in the output of the script

Alternative: get the combined unit coverage rate from coverage report (require manual calculation):

* When the ci_linux_coverage build finishes, click on ``Cobertura Coverage Report``
* Scroll down to the ``Coverage Breakdown by Package`` table
* In the table, under the first column ""Name"", look for (where <package_name> is your package under testing):

  * all the directories under the pattern ``src.*.<repository_name>.<package_name>.*`` grab the two absolute values in the column ""Lines"".
  * all the directories under the pattern ``build/.<repository_name>.*`` grab the two absolute values in the column ""Lines"".

* With the previous selection: for each cell, the first value is the lines tested and the second is the total lines of code.
  Aggregate all rows for getting the total of the lines tested and the total of lines of code under test.
  Divide to get the coverage rate.

.. _measure-coverage-locally:

How to measure coverage locally using lcov (Ubuntu)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To measure coverage on your own machine, install ``lcov``.

.. code-block:: bash

     sudo apt install -y lcov

The rest of this section assumes you are working from your colcon workspace.
Compile in debug with coverage flags.
Feel free to use colcon flags to target specific packages.

.. code-block:: bash

     colcon build --cmake-args -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_FLAGS=""${CMAKE_CXX_FLAGS} --coverage"" -DCMAKE_C_FLAGS=""${CMAKE_C_FLAGS} --coverage""

``lcov`` requires an initial baseline, which you can produce with the following command.
Update the output file location for your needs.

.. code-block:: bash

     lcov --no-external --capture --initial --directory . --output-file ~/ros2_base.info

Run tests for the packages that matter for your coverage measurements.
For example, if measuring ``rclcpp`` also with ``test_rclcpp``

.. code-block:: bash

     colcon test --packages-select rclcpp test_rclcpp

Capture the lcov results with a similar command this time dropping the ``--initial`` flag.

.. code-block:: bash

     lcov --no-external --capture --directory . --output-file ~/ros2.info

Combine the trace .info files:

.. code-block:: bash

     lcov --add-tracefile ~/ros2_base.info --add-tracefile ~/ros2.info --output-file ~/ros2_coverage.info

Generate html for easy visualization and annotation of covered lines.

.. code-block:: bash

    mkdir -p coverage
    genhtml ~/ros2_coverage.info --output-directory coverage
",What is the recommended way to measure coverage locally for ROS 2 packages on Ubuntu using lcov?
".. redirect-from::

    Quality-Guide
    Contributing/Quality-Guide

Quality guide: ensuring code quality
====================================

.. contents:: Table of Contents
   :depth: 2
   :local:

This page gives guidance about how to improve the software quality of ROS 2 packages, focusing on more specific areas than the Quality Practices section of the :doc:`Developer Guide <Developer-Guide>`.

The sections below intend to address ROS 2 core, application and ecosystem packages and the core client libraries, C++ and Python.
The solutions presented are motivated by design and implementation considerations to improve quality attributes like ""Reliability"", ""Security"", ""Maintainability"", ""Determinism"", etc. which relate to non-functional requirements.


Static code analysis as part of the ament package build
-------------------------------------------------------

**Context**:

* You have developed your C++ production code.
* You have created a ROS 2 package with build support with ``ament``.

**Problem**:

* Library level static code analysis is not run as part of the package build procedure.
* Library level static code analysis needs to be executed manually.
* Risk of forgetting to execute library level static code analysis before building
  a new package version.

**Solution**:

* Use the integration capabilities of ``ament`` to execute static code analysis as
  part of the package build procedure.

**Implementation**:

* Insert into the packages ``CMakeLists.txt`` file.

.. code-block:: bash

   ...
   if(BUILD_TESTING)
     find_package(ament_lint_auto REQUIRED)
     ament_lint_auto_find_test_dependencies()
     ...
   endif()
   ...

* Insert the ``ament_lint`` test dependencies into the packages ``package.xml`` file.

.. code-block:: bash

   ...
   <package format=""2"">
     ...
     <test_depend>ament_lint_auto</test_depend>
     <test_depend>ament_lint_common</test_depend>
     ...
   </package>

**Examples**:

* ``rclcpp``:

  * `rclcpp/rclcpp/CMakeLists.txt <https://github.com/ros2/rclcpp/blob/{REPOS_FILE_BRANCH}/rclcpp/CMakeLists.txt>`__
  * `rclcpp/rclcpp/package.xml <https://github.com/ros2/rclcpp/blob/{REPOS_FILE_BRANCH}/rclcpp/package.xml>`__

* ``rclcpp_lifecycle``:

  * `rclcpp/rclcpp_lifecycle/CMakeLists.txt <https://github.com/ros2/rclcpp/blob/{REPOS_FILE_BRANCH}/rclcpp_lifecycle/CMakeLists.txt>`__
  * `rclcpp/rclcpp_lifecycle/package.xml <https://github.com/ros2/rclcpp/blob/{REPOS_FILE_BRANCH}/rclcpp_lifecycle/package.xml>`__

**Resulting context**:

* The static code analysis tools supported by ``ament`` are run as part of the package build.
* Static code analysis tools not supported by ``ament`` need to be executed separately.

Static Thread Safety Analysis via Code Annotation
-------------------------------------------------

**Context:**

* You are developing/debugging your multithreaded C++ production code
* You access data from multiple threads in C++ code

**Problem:**

* Data races and deadlocks can lead to critical bugs.

**Solution:**

* Utilize Clang's static `Thread Safety Analysis <https://clang.llvm.org/docs/ThreadSafetyAnalysis.html>`__ by annotating threaded code

**Context For Implementation:**


To enable Thread Safety Analysis, code must be annotated to let the compiler know more about the semantics of the code.
These annotations are Clang-specific attributes - e.g. ``__attribute__(capability()))``.
Instead of using those attributes directly, ROS 2 provides preprocessor macros that are erased when using other compilers.

These macros can be found in `rcpputils/thread_safety_annotations.hpp <https://github.com/ros2/rcpputils/blob/{REPOS_FILE_BRANCH}/include/rcpputils/thread_safety_annotations.hpp>`__

The Thread Safety Analysis documentation states
  Thread safety analysis can be used with any threading library, but it does require that the threading API be wrapped in classes and methods which have the appropriate annotations

We have decided that we want ROS 2 developers to be able to use ``std::`` threading primitives directly for their development.
We do not want to provide our own wrapped types as is suggested above.

There are three C++ standard libraries to be aware of

* The GNU standard library ``libstdc++`` - default on Linux, explicitly via the compiler option ``-stdlib=libstdc++``
* The LLVM standard library ``libc++`` (also called ``libcxx`` ) - default on macOS,  explicitly set by the compiler option ``-stdlib=libc++``
* The Windows C++ Standard Library - not relevant to this use case

``libcxx`` annotates its ``std::mutex`` and ``std::lock_guard`` implementations for Thread Safety Analysis. When using GNU ``libstdc++`` , those annotations are not present, so Thread Safety Analysis cannot be used on non-wrapped ``std::`` types.

*Therefore, to use Thread Safety Analysis directly with* ``std::`` *types, we must use* ``libcxx``

**Implementation:**

The code migration suggestions here are by no means complete - when writing (or annotating existing) threaded code, you are encouraged to utilize as many of the annotations as is logical for your use case.
However, this step-by-step is a great place to start!

* Enabling Analysis for Package/Target

  When the C++ compiler is Clang, enable the ``-Wthread-safety`` flag. Example below for CMake-based projects

  .. code-block:: cmake

     if(CMAKE_CXX_COMPILER_ID MATCHES ""Clang"")
       add_compile_options(-Wthread-safety)   # for your whole package
       target_compile_options(${MY_TARGET} PUBLIC -Wthread-safety)  # for a single library or executable
     endif()

* Annotating Code

  * Step 1 - Annotate data members

    * Find anywhere that ``std::mutex`` is used to protect some member data
    * Add the ``RCPPUTILS_TSA_GUARDED_BY(mutex_name)`` annotation to the data that is protected by the mutex

    .. code-block:: cpp

      class Foo {
      public:
        void incr(int amount) {
          std::lock_guard<std::mutex> lock(mutex_);
          bar += amount;
        }

        void get() const {
          return bar;
        }

      private:
        mutable std::mutex mutex_;
        int bar RCPPUTILS_TSA_GUARDED_BY(mutex_) = 0;
      };

  * Step 2 - Fix Warnings

    * In the above example - ``Foo::get`` will produce a compiler warning! To fix it, lock before returning bar

    .. code-block:: cpp

      void get() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return bar;
      }

  * Step 3 - (Optional but Recommended) Refactor Existing Code to Private-Mutex Pattern

    A recommended pattern in threaded C++ code is to always keep your ``mutex`` as a ``private:`` member of the data structure. This makes data safety the concern of the containing structure, offloading that responsibility from users of the structure and minimizing the surface area of affected code.

    Making your locks private may require rethinking the interfaces to your data. This is a great exercise - here are a few things to consider

    * You may want to provide specialized interfaces for performing analysis that requires complex locking logic, e.g. counting members in a filtered set of a mutex-guarded map structure, instead of actually returning the underlying structure to consumers
    * Consider copying to avoid blocking, where the amount of data is small. This can let other threads get on with accessing the shared data, which can potentially lead to better overall performance.

  * Step 4 - (Optional) Enable Negative Capability Analysis

    https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#negative-capabilities

    Negative Capability Analysis lets you specify “this lock must not be held when calling this function”. It can reveal potential deadlock cases that other annotations cannot.

    * Where you specified ``-Wthread-safety``, add the additional flag ``-Wthread-safety-negative``
    * On any function that acquires a lock, use the ``RCPPUTILS_TSA_REQUIRES(!mutex)`` pattern

* How to run the analysis

  * The ROS CI build farm runs a nightly job with ``libcxx``, which will surface any issues in the ROS 2 core stack by being marked ""Unstable"" when Thread Safety Analysis raises warnings
  * For local runs, you have the following options, all equivalent

    * Use the colcon `clang-libcxx mixin <https://github.com/colcon/colcon-mixin-repository/blob/master/clang-libcxx.mixin>`__ (see the `documentation <https://github.com/colcon/colcon-mixin-repository/blob/master/README.md>`__ for configuring mixins)
      ::

          colcon build --mixin clang-libcxx

    * Passing compiler to CMake
      ::

          colcon build --cmake-args -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_CXX_FLAGS='-stdlib=libc++ -D_LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS' -DFORCE_BUILD_VENDOR_PKG=ON --no-warn-unused-cli

    * Overriding system compiler
      ::

          CC=clang CXX=clang++ colcon build --cmake-args -DCMAKE_CXX_FLAGS='-stdlib=libc++ -D_LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS' -DFORCE_BUILD_VENDOR_PKG=ON --no-warn-unused-cli

**Resulting Context:**

* Potential deadlocks and race conditions will be surfaced at compile time, when using Clang and ``libcxx``


Dynamic analysis (data races & deadlocks)
-----------------------------------------

**Context:**

* You are developing/debugging your multithreaded C++ production code.
* You use pthreads or C++11 threading + llvm libc++ (in case of ThreadSanitizer).
* You do not use Libc/libstdc++ static linking (in case of ThreadSanitizer).
* You do not build non-position-independent executables (in case of ThreadSanitizer).

**Problem:**

* Data races and deadlocks can lead to critical bugs.
* Data races and deadlocks cannot be detected using static analysis (reason: limitation of static analysis).
* Data races and deadlocks must not show up during development debugging / testing (reason: usually not all possible control paths through production code exercised).

**Solution:**

* Use a dynamic analysis tool which focuses on finding data races and deadlocks (here clang ThreadSanitizer).

**Implementation:**

* Compile and link the production code with clang using the option ``-fsanitize=thread`` (this instruments the production code).
* In case different production code shall be executed during analysis consider conditional compilation e.g. `ThreadSanitizers _has_feature(thread_sanitizer) <https://clang.llvm.org/docs/ThreadSanitizer.html#has-feature-thread-sanitizer>`__.
* In case some code shall not be instrumented consider `ThreadSanitizers _/*attribute*/_((no_sanitize(""thread""))) <https://clang.llvm.org/docs/ThreadSanitizer.html#attribute-no-sanitize-thread>`__.
* In case some files shall not be instrumented consider file or function-level exclusion `ThreadSanitizers blacklisting <https://clang.llvm.org/docs/ThreadSanitizer.html#ignorelist>`__, more specific: `ThreadSanitizers Sanitizer Special Case List <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html>`__ or with `ThreadSanitizers no_sanitize(""thread"") <https://clang.llvm.org/docs/ThreadSanitizer.html#ignorelist>`__ and use the option ``--fsanitize-blacklist``.

**Resulting context:**

* Higher chance to find data races and deadlocks in production code before deploying it.
* Analysis result may lack reliability, tool in beta phase stage (in case of ThreadSanitizer).
* Overhead due to production code instrumentation (maintenance of separate branches for instrumented/not instrumented production code, etc.).
* Instrumented code needs more memory per thread (in case of ThreadSanitizer).
* Instrumented code maps a lot virtual address space (in case of ThreadSanitizer).
",What steps can be taken to implement static code analysis as part of the package build procedure in ROS 2 packages following the guidance provided in the text document?
".. redirect-from::

  Contributing/Code-Style-Language-Versions

.. _CodeStyle:

Code style and language versions
================================

.. contents:: Table of Contents
   :depth: 2
   :local:

In order to achieve a consistent looking product we will all follow externally (if possible) defined style guidelines for each language.
For other things like package layout or documentation layout we will need to come up with our own guidelines, drawing on current, popular styles in use now.

Additionally, wherever possible, developers should use integrated tools to allow them to check that these guidelines are followed in their editors.
For example, everyone should have a PEP8 checker built into their editor to cut down on review iterations related to style.

Also where possible, packages should check style as part of their unit tests to help with the automated detection of style issues (see `ament_lint_auto <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_lint_auto/doc/index.rst>`__).

C
-

Standard
^^^^^^^^

We will target C99.

Style
^^^^^

We will use `Python's PEP7 <https://www.python.org/dev/peps/pep-0007/>`__ for our C style guide, with some modifications and additions:

* We will target C99, as we do not need to support C89 (as PEP7 recommends)

  * rationale: among other things it allows us to use both ``//`` and ``/* */`` style comments
  * rationale: C99 is pretty much ubiquitous now

* C++ style ``//`` comments are allowed
* (optional) Always place literals on the left-hand side of comparison operators, e.g. ``0 == ret`` instead of ``ret == 0``

  * rationale: ``ret == 0`` too easily turns into ``ret = 0`` by accident
  * optional because when using ``-Wall`` (or equivalent) modern compilers will warn you when this happens

All of the following modifications only apply if we are not writing Python modules:

* Do not use ``Py_`` as a prefix for everything

  * instead use a CamelCase version of the package name or other appropriate prefix

* The stuff about documentation strings doesn't apply

We can use the `pep7 <https://github.com/mike-perdide/pep7>`__ python module for style checking. The editor integration seems slim, we may need to look into automated checking for C in more detail.

C++
---

Standard
^^^^^^^^

{DISTRO_TITLE} targets C++17.

Style
^^^^^


We will use the `Google C++ Style Guide <https://google.github.io/styleguide/cppguide.html>`__, with some modifications:

Line Length
~~~~~~~~~~~

* Our maximum line length is 100 characters.

File Extensions
~~~~~~~~~~~~~~~

* Header files should use the .hpp extension.

  * rationale: Allow tools to determine content of files, C++ or C.

* Implementation files should use the .cpp extension.

  * rationale: Allow tools to determine content of files, C++ or C.

Variable Naming
~~~~~~~~~~~~~~~

* For global variables use lowercase with underscores prefixed with ``g_``

  * rationale: keep variable naming case consistent across the project
  * rationale: easy to tell the scope of a variable at a glance
  * consistency across languages

Function and Method Naming
~~~~~~~~~~~~~~~~~~~~~~~~~~

* Google style guide says ``CamelCase``, but the C++ std library's style of ``snake_case`` is also allowed

  * rationale: ROS 2 core packages currently use ``snake_case``

    * reason: either an historical oversight or a personal preference that didn't get checked by the linter
    * reason for not changing: retroactively changing would be too disruptive
  * other considerations:

    * ``cpplint.py`` does not check this case (hard to enforce other than with review)
    * ``snake_case`` can result in more consistency across languages
  * specific guidance:

    * for existing projects, prefer the existing style
    * for new projects, either is acceptable, but a preference for matching related existing projects is advised
    * final decision is always developer discretion

      * special cases like function pointers, callable types, etc. may require bending the rules
    * Note that classes should still use ``CamelCase`` by default

Access Control
~~~~~~~~~~~~~~

* Drop requirement for all class members to be private and therefore require accessors

  * rationale: this is overly constraining for user API design
  * we should prefer private members, only making them public when they are needed
  * we should consider using accessors before choosing to allow direct member access
  * we should have a good reason for allowing direct member access, other than because it is convenient for us

Exceptions
~~~~~~~~~~

* Exceptions are allowed

  * rationale: this is a new codebase, so the legacy argument doesn't apply to us
  * rationale: for user-facing API's it is more idiomatic C++ to have exceptions
  * Exceptions in destructors should be explicitly avoided

* We should consider avoiding Exceptions if we intend to wrap the resulting API in C

  * rationale: it will make it easier to wrap in C
  * rationale: most of our dependencies in code we intend to wrap in C do not use exceptions anyways

Function-like Objects
~~~~~~~~~~~~~~~~~~~~~

* No restrictions on Lambda's or ``std::function`` or ``std::bind``

Boost
~~~~~

* Boost should be avoided unless absolutely required.

Comments and Doc Comments
~~~~~~~~~~~~~~~~~~~~~~~~~

* Use ``///`` and ``/** */`` comments for *documentation* purposes and ``//`` style comments for notes and general comments

  * Class and Function comments should use ``///`` and ``/** */`` style comments
  * rationale: these are recommended for Doxygen and Sphinx in C/C++
  * rationale: mixing ``/* */`` and ``//`` is convenient for block commenting out code which contains comments
  * Descriptions of how the code works or notes within classes and functions should use ``//`` style comments

Pointer Syntax Alignment
~~~~~~~~~~~~~~~~~~~~~~~~

* Use ``char * c;`` instead of ``char* c;`` or ``char *c;`` because of this scenario ``char* c, *d, *e;``

Class Privacy Keywords
~~~~~~~~~~~~~~~~~~~~~~

* Do not put 1 space before ``public:``, ``private:``, or ``protected:``, it is more consistent for all indentions to be a multiple of 2

  * rationale: most editors don't like indentions which are not a multiple of the (soft) tab size
  * Use zero spaces before ``public:``, ``private:``, or ``protected:``, or 2 spaces
  * If you use 2 spaces before, indent other class statements by 2 additional spaces
  * Prefer zero spaces, i.e. ``public:``, ``private:``, or ``protected:`` in the same column as the class

Nested Templates
~~~~~~~~~~~~~~~~

* Never add whitespace to nested templates

  * Prefer ``set<list<string>>`` (C++11 feature) to ``set<list<string> >`` or ``set< list<string> >``

Always Use Braces
~~~~~~~~~~~~~~~~~

* Always use braces following ``if``, ``else``, ``do``, ``while``, and ``for``, even when the body is a single line.

  * rationale: less opportunity for visual ambiguity and for complications due to use of macros in the body

Open Versus Cuddled Braces
~~~~~~~~~~~~~~~~~~~~~~~~~~

* Use open braces for ``function``, ``class``, ``enum``, and ``struct`` definitions, but cuddle braces on ``if``, ``else``, ``while``, ``for``, etc...

  * Exception: when an ``if`` (or ``while``, etc.) condition is long enough to require line-wrapping, then use an open brace (i.e., don't cuddle).

* When a function call cannot fit on one line, wrap at the open parenthesis (not in between arguments) and start them on the next line with a 2-space indent.  Continue with the 2-space indent on subsequent lines for more arguments.  (Note that the `Google style guide <https://google.github.io/styleguide/cppguide.html#Function_Calls>`__ is internally contradictory on this point.)

  * Same goes for ``if`` (and ``while``, etc.) conditions that are too long to fit on one line.

Examples
~~~~~~~~

This is OK:

.. code-block:: c++

   int main(int argc, char **argv)
   {
     if (condition) {
       return 0;
     } else {
       return 1;
     }
   }

   if (this && that || both) {
     ...
   }

   // Long condition; open brace
   if (
     this && that || both && this && that || both && this && that || both && this && that)
   {
     ...
   }

   // Short function call
   call_func(foo, bar);

   // Long function call; wrap at the open parenthesis
   call_func(
     foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar,
     foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar);

   // Very long function argument; separate it for readability
   call_func(
     bang,
     fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo,
     bar, bat);

This is **not** OK:

.. code-block:: c++

   int main(int argc, char **argv) {
     return 0;
   }

   if (this &&
       that ||
       both) {
     ...
   }


Use open braces rather than excessive indention, e.g. for distinguishing constructor code from constructor initializer lists

This is OK:

.. code-block:: c++

   ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
     Type par_name1,  // 2 space indent
     Type par_name2,
     Type par_name3)
   {
     DoSomething();  // 2 space indent
     ...
   }

   MyClass::MyClass(int var)
   : some_var_(var),
     some_other_var_(var + 1)
   {
     ...
     DoSomething();
     ...
   }

This is **not** OK, even weird (the google way?):

.. code-block:: c++

   ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
       Type par_name1,  // 4 space indent
       Type par_name2,
       Type par_name3) {
     DoSomething();  // 2 space indent
     ...
   }

   MyClass::MyClass(int var)
       : some_var_(var),             // 4 space indent
         some_other_var_(var + 1) {  // lined up
     ...
     DoSomething();
     ...
   }

Linters
~~~~~~~

We check these styles with a combination of Google's `cpplint.py <https://github.com/google/styleguide>`__ and `uncrustify <https://github.com/uncrustify/uncrustify>`__.

We provide command line tools with custom configurations:

* `ament_clang_format <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_clang_format/doc/index.rst>`__: `configuration <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_clang_format/ament_clang_format/configuration/.clang-format>`__
* `ament_cpplint <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_cpplint/doc/index.rst>`__
* `ament_uncrustify <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_uncrustify/doc/index.rst>`__: `configuration <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_uncrustify/ament_uncrustify/configuration/ament_code_style.cfg>`__

Some formatters such as ament_uncrustify and ament_clang_format support ``--reformat`` options to apply changes in place.

We also run other tools to detect and eliminate as many warnings as possible.
Here's a non-exhaustive list of additional things we try to do on all of our packages:

* use compiler flags like ``-Wall -Wextra -Wpedantic``
* run static code analysis like ``cppcheck``, which we have integrated in `ament_cppcheck <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_cppcheck/doc/index.rst>`__.

Python
------

Version
^^^^^^^

We will target Python 3 for our development.

Style
^^^^^

We will use the `PEP8 guidelines <https://www.python.org/dev/peps/pep-0008/>`_ for code format.

We chose the following more precise rule where PEP 8 leaves some freedom:

* `We allow up to 100 characters per line (fifth paragraph) <https://www.python.org/dev/peps/pep-0008/#maximum-line-length>`_.
* `We pick single quotes over double quotes as long as no escaping is necessary <https://www.python.org/dev/peps/pep-0008/#string-quotes>`_.
* `We prefer hanging indents for continuation lines <https://www.python.org/dev/peps/pep-0008/#indentation>`_.

Tools like the ``(ament_)pycodestyle`` Python package should be used in unit-test and/or editor integration for checking Python code style.

The pycodestyle configuration used in the linter is `here <https://github.com/ament/ament_lint/blob/{REPOS_FILE_BRANCH}/ament_pycodestyle/ament_pycodestyle/configuration/ament_pycodestyle.ini>`__.

Integration with editors:

* atom: https://atom.io/packages/linter-pycodestyle
* emacs: https://www.emacswiki.org/emacs/PythonProgrammingInEmacs
* Sublime Text: https://sublime.wbond.net/packages/SublimeLinter-flake8
* vim: https://github.com/nvie/vim-flake8

CMake
-----

Version
^^^^^^^

We will target CMake 3.8.

Style
^^^^^

Since there is not an existing CMake style guide we will define our own:

* Use lowercase command names (``find_package``, not ``FIND_PACKAGE``).
* Use ``snake_case`` identifiers (variables, functions, macros).
* Use empty ``else()`` and ``end...()`` commands.
* No whitespace before ``(``\ 's.
* Use two spaces of indention, do not use tabs.
* Do not use aligned indentation for parameters of multi-line macro invocations. Use two spaces only.
* Prefer functions with ``set(PARENT_SCOPE)`` to macros.
* When using macros prefix local variables with ``_`` or a reasonable prefix.

Markdown / reStructured Text / docblocks
----------------------------------------

Style
^^^^^

The following rules to format text is intended to increase readability as well as versioning.

* *[.md, .rst only]* Each section title should be preceded by one empty line and succeeded by one empty line.

  * Rationale: It expedites to get an overview about the structure when screening the document.

* *[.rst only]* In reStructured Text the headings should follow the hierarchy described in the `Sphinx style guide <https://documentation-style-guide-sphinx.readthedocs.io/en/latest/style-guide.html#headings>`__:

  * ``#`` with overline (only once, used for the document title)
  * ``*`` with overline
  * ``=``
  * ``-``
  * ``^``
  * ``""``
  * Rationale: A consistent hierarchy expedites getting an idea about the nesting level when screening the document.

* *[.md only]* In Markdown the headings should follow the ATX-style described in the `Markdown syntax documentation <https://daringfireball.net/projects/markdown/syntax#header>`__

  * ATX-style headers use 1-6 hash characters (``#``) at the start of the line to denote header levels 1-6.
  * A space between the hashes and the header title should be used (such as ``# Heading 1``) to make it easier to visually separate them.
  * Justification for the ATX-style preference comes from the `Google Markdown style guide <https://github.com/google/styleguide/blob/gh-pages/docguide/style.md#atx-style-headings>`__
  * Rationale: ATX-style headers are easier to search and maintain, and make the first two header levels consistent with the other levels.

* *[any]* Each sentence must start on a new line.

  * Rationale: For longer paragraphs a single change in the beginning makes the diff unreadable since it carries forward through the whole paragraph.

* *[any]* Each sentence can optionally be wrapped to keep each line short.
* *[any]* The lines should not have any trailing white spaces.
* *[.md, .rst only]* A code block must be preceded and succeeded by an empty line.

  * Rationale: Whitespace is significant only directly before and directly after fenced code blocks.
    Following these instructions will ensure that highlighting works properly and consistently.

* *[.md, .rst only]* A code block should specify a syntax (e.g. ``bash``).
",What are some of the modifications and additions made to Python's PEP7 for the C style guide mentioned in the text?
".. redirect-from::

  Contributing/Build-Farms

.. _BuildFarms:

===============
ROS Build Farms
===============

.. contents:: Table of Contents
   :depth: 1
   :local:

The ROS build farms are an important infrastructure to support the ROS ecosystem, provided and
maintained by `Open Robotics`_.
They provide building of source and binary packages, continuous integration, testing, and analysis for ROS 1 and ROS 2 packages.
There are two hosted instance for open source packages:

#. https://build.ros.org/ for ROS 1 packages
#. https://build.ros2.org/ for ROS 2 packages

If you are going to use any of the provided infrastructure please consider signing up for the
`build farm discussion forum <http://discourse.ros.org/c/buildfarm>`__ in order to receive notifications,
e.g., about any upcoming changes.


Jobs and Deployment
-------------------

The ROS build farms perform several different jobs.
For each job type you will find a detailed description of what they do and how they work:

* `release jobs`_ generate binary packages, e.g., deb packages
* `devel jobs`_ build and test ROS packages within a single repository on a polling basis
* `pull_request jobs`_ build and test ROS packages within a single repository triggered by webhooks
* `CI jobs`_ build and test ROS packages across repositories with the option of using artifacts
  from other CI jobs to speed up the build
* `doc jobs`_ generate the API documentation of packages and extract information from the manifests
* `miscellaneous jobs`_ perform maintenance tasks and generate informational data to visualize the
  status of the build farm and its generated artifacts

Creation and Deployment
.......................

The above jobs are created and deployed when packages are bloomed_, i.e. released for ROS
1 or ROS 2.
Once blooming is successful and a package is incorporated in one of the ROS
distributions (via pull request to rosdistro_), the according jobs will be spawned.
The names of the jobs encode their type and purpose: [1]_

* release jobs:

   * ``{distro}src_{platf}__{package}__{platform}__source`` build source packages of releases
   * ``{distro}bin_{platf}__{package}__{platform}__binary`` build binary packages of releases

   For instance, the binary packaging job of rclcpp on ROS 2 Rolling (running on Ubuntu Noble amd64) is named ``Rbin_uN64__rclcpp__ubuntu_noble_amd64__binary``.

* devel jobs:

   * ``{distro}dev__{package}__{platform}`` perform a CI build for the releasing branch

* pull_request jobs

   * ``{distro}pr__{package}__{platform}`` perform a CI build for a pull request

   For instance, the PR job for rclcpp on ROS 2 Rolling (running on Ubuntu Noble amd64) is named ``Rpr__rclcpp__ubuntu_noble_amd64``.

Execution
.........

Execution of the jobs depends on the type of the job:

* `devel jobs`_ will be triggered every time a commit is done to the respective branch polling based on a configured frequency.
* `pull_request jobs`_ will be triggered by webhooks from respective pull request of the upstream [2]_ repository
* `release jobs`_ will be triggered once every time a new package version is released, i.e. a new
  rosdistro_ pull request was accepted for this package. The source jobs are triggered by a version
  change in the rosdistro distribution file, the binary jobs are triggered by their source counterpart.


Frequency Asked Questions (FAQ) and Troubleshooting
---------------------------------------------------

#. **I get Jenkins mails from failing build farm jobs. What do I do?**

   Go to the job that raised the issue. You find the link on top of the Jenkins email.
   Once you followed the link to the build job, click *Console Output* on the left, then click
   *Full Log*. This will give you the full console output of the failing build. Try to find the
   top-most error as it is usually the most important and other errors might be follow-ups.

   The bottom of the email might read ``'apt-src build [...]' failed. This is usually because of
   an error building the package.`` This usually hints at missing dependencies, see 2.

#. **I seem to be missing a dependency, how do I find out which one?**

   You basically have two options, a. is easier but may take several iterations, b. is more
   elaborate and gives you the full insight as well as local debugging.

   a) Inspect the release job that raised the issue (see 1.) and localize the cmake dependency
      issue. To do so, browse to the cmake section, e.g., navigate to the *build binarydeb*
      section through the menu on the left in case of a Ubuntu/Debian build job. The *CMake Error*
      will typically hint at a dependency required by the cmake configuration but missing in the
      `package manifest`_. Once you have fixed the dependency in the manifest, do a new release
      of your package and wait for feedback from the build farms or...
   b) To get the full insight and faster, local debugging, you can `run the release jobs locally`_.
      This allows to iterate the manifest locally until all dependencies are fixed.

#. **Why do release jobs fail when devel jobs / my github actions / my local builds succeed?**

   There are several potential reasons for this.
   First, release jobs build against a minimal ROS installation to check if all dependencies are
   properly declared in the `package manifest`_. Devel jobs / github actions / local builds may
   be performed in an environment that has the dependencies already installed, therefore does not
   notice dependency issues. Second, they might build different versions of the source code.
   While devel jobs / github actions / local builds usually build the latest version from the
   *upstream* [2]_ repository, `release jobs`_ build the source code of the latest release, i.e.
   the source code in the respective *upstream* branches of the *release* repository [3]_.


Further Reading
---------------

The following links provide more details and insights into the build farms:

* https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/index.rst - General
  documentation of the build farm infrastructure and the generated build jobs
* http://wiki.ros.org/regression_tests#Setting_up_Your_Computer_for_Prerelease
* http://wiki.ros.org/buildfarm - ROS wiki entry for the ROS 1 build farm (partially *outdated*)
* https://github.com/ros-infrastructure/cookbook-ros-buildfarm - Installs and configures ROS build
  farm machines


.. [1] ``{distro}`` is the first letter of the ROS distribution, ``{platform}`` (``{platf}``)
   names the platform the package is built for (and its short code), and ``{package}`` is the
   name of the ROS package being built.
.. [2] The *upstream* repository is the repository containing the original source code of the
   respective ROS 1 / ROS 2 package.
.. [3] The *release* repository is the repository that ROS 2 infrastructure uses for releasing
   packages, see https://github.com/ros2-gbp/.

.. _`release jobs`:
   https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/jobs/release_jobs.rst
.. _`devel jobs`:
   https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/jobs/devel_jobs.rst
.. _`pull_request jobs`:
   https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/jobs/devel_jobs.rst
.. _`CI jobs`:
   https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/jobs/ci_jobs.rst
.. _`doc jobs`:
   https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/jobs/doc_jobs.rst
.. _`miscellaneous jobs`:
   https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/jobs/miscellaneous_jobs.rst
.. _bloomed:
   http://wiki.ros.org/bloom
.. _rosdistro:
   https://github.com/ros/rosdistro
.. _`run the release jobs locally`:
   https://github.com/ros-infrastructure/ros_buildfarm/blob/master/doc/jobs/release_jobs.rst#run-the-release-job-locally
.. _`Open Robotics`:
   https://www.openrobotics.org/
.. _`job descriptions above`:
   #jobs-and-deployment
.. _`package manifest`:
   http://wiki.ros.org/Manifest
",What are the various types of jobs performed by the ROS build farms and how are they triggered?
".. redirect-from::

    Contributing/Windows-Tips-and-Tricks

Windows Tips and Tricks
=======================

.. contents:: Table of Contents
   :depth: 2
   :local:

ROS 2 supports Windows 10 as a Tier 1 platform, which means that all code that goes into the ROS 2 core must support Windows.
For those used to traditional development on Linux or other Unix-like systems, developing on Windows can be a bit of a challenge.
This document aims to lay out some of those differences.

Maximum Path Length
-------------------
By default, Windows has a `maximum path length <https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation>`__ of 260 characters.
Practically speaking, 4 of those characters are always used by the drive letter, colon, initial backslash, and final NULL character.
That means that only 256 characters are available for the *sum* of all parts of the path.
This has two practical consequences for ROS 2:

* Some of the ROS 2 internal path names are fairly long. Because of this, we always recommend using a short path name for the root of your ROS 2 directory, like ``C:\dev``.
* When building ROS 2 from source, the default isolated build mode of colcon can generate very long path names. To avoid these very long path names, use ``--merge-install`` when building on Windows.

**Note**: It is possible to change Windows to have much longer maximum path lengths.
See `this article <https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=cmd#enable-long-paths-in-windows-10-version-1607-and-later>`__ for more information.

.. _Windows_Symbol_Visibility:

Symbol Visibility
-----------------
The Microsoft Visual C++ Compiler (MSVC) exposes symbols from a Dynamic Link Library (DLL) only if they are explicitly exported.
The clang and gcc compilers have an option to do the same, but it is off by default.
As a result, when a library previously built on Linux is built on Windows, other libraries may be unable to resolve the external symbols.
Below are examples of common error messages which can be caused by symbols not being exposed:

.. code-block:: console

   error C2448: '__attribute__': function-style initializer appears to be a function definition
   'visibility': identifier not found

.. code-block:: console

   CMake Error at C:/ws_ros2/install/random_numbers/share/random_numbers/cmake/ament_cmake_export_libraries-extras.cmake:48 (message):
      Package 'random_numbers' exports the library 'random_numbers' which
      couldn't be found

Symbol Visibility also impacts binary loading.
If you are finding that a composable node does not run or a Qt Visualizer isn't working, it may be that the hosting process can not find an expected symbol export from the binary.
To diagnose this on Windows, the Windows developer tools includes a program called Gflags to enable various options.
One of those options is called *Loader Snaps* which enables you to detect load failures while debugging.
Please visit the Microsoft Documentation for more information on `Gflags <https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-and-clearing-image-file-flags>`__ and `Loaders snaps <https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/show-loader-snaps>`__.

Two solutions to export symbols on Windows are Visibility Control Headers and the ``WINDOWS_EXPORT_ALL_SYMBOLS`` property.
Microsoft recommends ROS developers use Visibility Control Headers to control the export of symbols from a binary.
Visibility Control Headers provide more control over the symbol export macro and offer other benefits including smaller binary size and reduced link times.

Visibility Control Headers
^^^^^^^^^^^^^^^^^^^^^^^^^^
The purpose of Visibility Control Headers headers is to define a macro for each shared library which correctly declares symbols as dllimport or dllexport.
This is decided based on whether the library is being consumed or being built itself.
The logic in the macro also takes the compiler into account and includes logic to select the appropriate syntax.
The `GCC visibility documentation <https://gcc.gnu.org/wiki/Visibility>`__ includes step by step instructions for adding explicit symbol visibility to a library “yielding the highest quality code with the greatest reductions in binary size, load times and link times”.
A header named ``visibility_control.h`` can be placed in the ``includes`` folder for each library as shown in the example below.
The example below shows how a visibility control header would be added for a ``my_lib`` library with a class called ``example_class``.
Add a visibility header to the include folder for the library.
The boiler plate logic is used with the library name used in the macro to make it unique in the project.
In another library, ``MY_LIB`` would be replaced with the library name.

.. code-block:: c++

   #ifndef MY_LIB__VISIBILITY_CONTROL_H_
   #define MY_LIB__VISIBILITY_CONTROL_H_
   #if defined _WIN32 || defined __CYGWIN__
   #ifdef __GNUC__
      #define MY_LIB_EXPORT __attribute__ ((dllexport))
      #define MY_LIB_IMPORT __attribute__ ((dllimport))
   #else
      #define MY_LIB_EXPORT __declspec(dllexport)
      #define MY_LIB_IMPORT __declspec(dllimport)
   #endif
   #ifdef MY_LIB_BUILDING_LIBRARY
      #define MY_LIB_PUBLIC MY_LIB_EXPORT
   #else
      #define MY_LIB_PUBLIC MY_LIB_IMPORT
   #endif
   #define MY_LIB_PUBLIC_TYPE MY_LIB_PUBLIC
   #define MY_LIB_LOCAL
   #else
    // Linux visibility settings
   #define MY_LIB_PUBLIC_TYPE
   #endif
   #endif  // MY_LIB__VISIBILITY_CONTROL_H_

For a complete example of this header, see `rviz_rendering <https://github.com/ros2/rviz/blob/ros2/rviz_rendering/include/rviz_rendering/visibility_control.hpp>`__.

To use the macro, add ``MY_LIB_PUBLIC`` before symbols which need to be visible to external libraries. For example:

.. code-block:: c++

   Class MY_LIB_PUBLIC example_class {}

   MY_LIB_PUBLIC void example_function (){}

In order to build your library with correctly exported symbols, you will need to add the following to your CMakeLists.txt file:

.. code-block:: cmake

  target_compile_definitions(${PROJECT_NAME}
    PRIVATE ""MY_LIB_BUILDING_LIBRARY"")


WINDOWS_EXPORT_ALL_SYMBOLS Target Property
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
CMake implements the ``WINDOWS_EXPORT_ALL_SYMBOLS`` property on Windows, which causes function symbols to be automatically exported.
More detail of how it works can be found in the `WINDOWS_EXPORT_ALL_SYMBOLS CMake Documentation <https://cmake.org/cmake/help/latest/prop_tgt/WINDOWS_EXPORT_ALL_SYMBOLS.html>`__.
The property can be implemented by adding the following to the CMakeLists file:

.. code-block:: cmake

   set_target_properties(${LIB_NAME} PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE)

If there is more than one library in a CMakeLists file you will need to call ``set_target_properties`` on each of them separately.

Note that a binary on Windows can only export 65,536 symbols.
If a binary exports more than that, you will get an error and should use the visibility_control headers.
There is an exception to this method in the case of global data symbols.
For example, a global static data member like the one below.

.. code-block:: c++

   class Example_class
   {
   public:
   static const int Global_data_num;


In these cases dllimprort/dllexport must be applied explicitly.
This can be done using generate_export_header as described in the following article: `Create dlls on Windows without declspec() using new CMake export all feature <https://blog.kitware.com/create-dlls-on-windows-without-declspec-using-new-cmake-export-all-feature/>`__.

Finally, it is important that the header file that exports the symbols be included into at least one of the ``.cpp`` files in the package so that the macros will get expanded and placed into the resulting binary.
Otherwise the symbols will still not be callable.


Debug builds
------------
When building in Debug mode on Windows, several very important things change.
The first is that all DLLs get ``_d`` automatically appended to the library name.
So if the library is called ``libfoo.dll``, in Debug mode it will be ``libfoo_d.dll``.
The dynamic linker on Windows also knows to look for libraries of that form, so it will not find libraries without the ``_d`` prefix.
Additionally, Windows turns on a whole set of compile-time and run-time checks in Debug mode that is far more strict than Release builds.
For these reasons, it is a good idea to run a Windows Debug build and test on many pull requests.

Forward-slash vs. back-slash
----------------------------
In Windows the default path separator is a backslash (``\``), which differs from the forward-slash (``/``) used in Linux and macOS.
Most of the Windows APIs can deal with either as a path separator, but this is not universally true.
For instance, the ``cmd.exe`` shell can only do tab-completion when using the backslash character, not the forward-slash.
For maximum compatibility on Windows, a backslash should always be used as the path separator on Windows.

Patching vendored packages
--------------------------
When vendoring a package in ROS 2, it is often necessary to apply a patch to fix a bug, add a feature, etc.
The typical way to do this is to modify the ``ExternalProject_add`` call to add a ``PATCH`` command, using the ``patch`` executable.
Unfortunately, the ``patch`` executable as delivered by chocolatey requires Administrator access to run.
The workaround is to use ``git apply-patch`` when applying patches to external projects.

``git apply-patch`` has its own issues in that it only works properly when applied to a git repository.
For that reason, external projects should always use the ``GIT`` method to obtain the project and then use the ``PATCH_COMMAND`` to invoke ``git apply-patch``.

An example usage of all of the above looks something like:

.. code-block:: cmake

  ExternalProject_Add(mylibrary-${version}
    GIT_REPOSITORY https://github.com/lib/mylibrary.git
    GIT_TAG ${version}
    GIT_CONFIG advice.detachedHead=false
    # Suppress git update due to https://gitlab.kitware.com/cmake/cmake/-/issues/16419
    # See https://github.com/ament/uncrustify_vendor/pull/22 for details
    UPDATE_COMMAND """"
    TIMEOUT 600
    CMAKE_ARGS
      -DCMAKE_INSTALL_PREFIX=${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}_install
      ${extra_cmake_args}
      -Wno-dev
    PATCH_COMMAND
      ${CMAKE_COMMAND} -E chdir <SOURCE_DIR> git apply -p1 --ignore-space-change --whitespace=nowarn ${CMAKE_CURRENT_SOURCE_DIR}/install-patch.diff
  )

Windows slow timers (slowness in general)
-----------------------------------------
Software running on Windows is, in general, much slower than that running on Linux.
This is due to a number of factors, from the default time slice (every 20 ms, according to the `documentation <https://docs.microsoft.com/en-us/windows/win32/procthread/multitasking>`__), to the number of anti-virus and anti-malware processes running, to the number of background processes running.
Because of all of this, tests should *never* expect tight timing on Windows.
All tests should have generous timeouts, and only expect events to happen eventually (this will also prevent tests from being flakey on Linux).

Shells
------
There are two main command-line shells on Windows: the venerable ``cmd.exe``, and PowerShell.

``cmd.exe`` is the command shell that most closely emulates the old DOS shell, though with greatly enhanced capabilities.
It is completely text based, and only understands DOS/Windows ``batch`` files.

PowerShell is the newer, object-based shell that Microsoft recommends for most new applications.
It understands ``ps1`` files for configuration.

ROS 2 supports both ``cmd.exe`` and PowerShell, so any changes (especially to things like ``ament`` or ``colcon``) should be tested on both.
",What are two practical consequences for ROS 2 due to the default maximum path length in Windows?
".. redirect-from::

    Contributing/Contributing-To-ROS-2-Documentation

Contributing to ROS 2 Documentation
===================================

.. contents:: Table of Contents
   :depth: 2
   :local:

Contributions to this site are most welcome.
This page explains how to contribute to ROS 2 Documentation.
Please be sure to read the below sections carefully before contributing.

The site is built using `Sphinx <https://www.sphinx-doc.org/en/master/>`_, and more particularly using `Sphinx multiversion <https://holzhaus.github.io/sphinx-multiversion/master/index.html>`_.

Branch structure
----------------

The source code of documentation is located in the `ROS 2 Documentation GitHub repository <https://github.com/ros2/ros2_documentation>`_.
This repository is set up with one branch per ROS 2 distribution to handle differences between the distributions.
If a change is common to all ROS 2 distributions, it should be made to the ``rolling`` branch (and then will be backported as appropriate).
If a change is specific to a particular ROS 2 distribution, it should be made to the respective branch.

Source structure
----------------

The source files for the site are all located under the ``source`` subdirectory.
Templates for various sphinx plugins are located under ``source/_templates``.
The root directory contains configuration and files required to locally build the site for testing.

Building the site locally
-------------------------

Start by creating `venv <https://docs.python.org/3/library/venv.html>`__ to build the documentation:

.. code-block:: console

   # activate the venv
   python3 -m venv ros2doc

   # activate venv
   source ros2doc/bin/activate

And install requirements located in the ``requirements.txt`` file:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

       pip install -r requirements.txt -c constraints.txt

  .. group-tab:: macOS

    .. code-block:: console

       pip install -r requirements.txt -c constraints.txt

  .. group-tab:: Windows

    .. code-block:: console

      python -m pip install -r requirements.txt -c constraints.txt

In order for Sphinx to be able to generate diagrams, the ``dot`` command must be available.

.. tabs::

  .. group-tab:: Linux

    .. code-block:: console

       sudo apt update ; sudo apt install graphviz

  .. group-tab:: macOS

    .. code-block:: console

      brew install graphviz

  .. group-tab:: Windows

      Download an installer from `the Graphviz Download page <https://graphviz.gitlab.io/_pages/Download/Download_windows.html>`__ and install it.
      Make sure to allow the installer to add it to the Windows ``%PATH%``, otherwise Sphinx will not be able to find it.

Building the site for one branch
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To build the site for just this branch, type ``make html`` at the top-level of the repository.
This is the recommended way to test out local changes.

.. code-block:: console

   make html

The build process can take some time.
To see the output, open ``build/html/index.html`` in your browser.

You can also run the documentation tests locally (using `doc8 <https://github.com/PyCQA/doc8>`_) with the following command:

.. code-block:: console

   make test

View Site Through Github CI
^^^^^^^^^^^^^^^^^^^^^^^^^^^

For small changes to the ROS 2 Docs you can view your changes as rendered HTML using artifacts generated in our Github Actions.
The ""build"" action produces the entire ROS Docs as a downloadable Zip file that contains all HTML for `docs.ros.org <https://docs.ros.org/>`_
This build action is triggered after passing the test action and lint action.

To download and view your changes first go to your pull request and under the title click the ""Checks"" tab.
On the left hand side of the checks page, click on the ""Test"" section under the ""tests"" section  click on ""build"" dialog.
This will open a menu on the right, where you can click on ""Upload document artifacts"" and scroll to the bottom to see the download link for the Zipped' HTML files under the heading ""Artifact download URL"".

.. image:: ./images/github_action.png
  :width: 100%
  :alt: Steps to find rendered HTML files on ROS Github action

Building the site for all branches
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To build the site for all branches, type ``make multiversion`` from the ``rolling`` branch.
This has two drawbacks:

#. The multiversion plugin doesn't understand how to do incremental builds, so it always rebuilds everything.
   This can be slow.

#. When typing ``make multiversion``, it will always check out exactly the branches listed in the ``conf.py`` file.
   That means that local changes will not be shown.

To show local changes in the multiversion output, you must first commit the changes to a local branch.
Then you must edit the `conf.py <https://github.com/ros2/ros2_documentation/blob/rolling/conf.py>`_ file and change the ``smv_branch_whitelist`` variable to point to your branch.

Checking for broken links
^^^^^^^^^^^^^^^^^^^^^^^^^

To check for broken links on the site, run:

.. code-block:: console

   make linkcheck

This will check the entire site for broken links, and output the results to the screen and ``build/linkcheck``.

Migrating Pages from the ROS Wiki
---------------------------------

The first step in migrating a page from the `ROS Wiki <https://wiki.ros.org>`_ to the ROS 2 documentation is to determine if the page needs to be migrated.
Check if the content, or something similar, is available on https://docs.ros.org/en/rolling by searching for related terms.
If it has already been migrated, congratulations!
You are done.
If it hasn't been migrated, then consider whether it is worth keeping.
Pages that you or others find useful, and refer to regularly, are good candidates assuming they have not been superseded by other documentation.
Pages for ROS projects and features that are no longer supported by a current distribution should not be migrated.

The next step for migrating a ROS Wiki page is to determine the correct location for the migrated page.
Only ROS Wiki pages that cover core ROS concepts belong in the ROS Documentation, these pages should be migrated to a logical location within the ROS documentation.
Package specific documentation should be migrated to the package-level documentation generated in the package's source repository.
Once the package level documentation has been updated it will be visible `as part of the package-level documentation <https://docs.ros.org/en/rolling/p/>`__.
If you are unsure whether and where to migrate a page, please get in touch via an issue on https://github.com/ros2/ros2_documentation or on https://discourse.ros.org.

Once you've determined that a ROS Wiki page is worth migrating, and found an appropriate landing spot in the ROS documentation, the next step in the migration process is to set up the conversion tools necessary to migrate the page.
In most cases the only tools necessary to migrate a single ROS Wiki page to the ROS Docs are the `PanDoc <https://pandoc.org/>`_ command line tool and a text editor.
PanDoc is supported by most modern operating systems using the installation instruction found on their website.
It is worth noting that the ROS Wiki uses an older wiki technology (MoinMoin), so the markup language used is an obscure dialect of the `MediaWiki <https://www.mediawiki.org/wiki/Help:Formatting>`__ format.
We've found that the easiest way to migrate a page from the ROS Wiki is to convert it from HTML into reStructured text using PanDoc.


Migrating a Wiki File
^^^^^^^^^^^^^^^^^^^^^

#. Clone the appropriate repository.  If you are migrating a page to the official documentation hosted here, then you should clone https://github.com/ros2/ros2_documentation.

#. Create a new Github branch for your migrated page. We suggest something like ``pagename-migration``.

#. Download the appropriate ROS Wiki page to an html file using wget or a similar tool (e.g. ``wget -O urdf.html https://wiki.ros.org/urdf``).
   Alternatively you can use your web browser to save the page's HTML.

#. Next you need to remove the extraneous HTML in the file you downloaded
   Using your browser's developer mode, find the name of the first useful HTML element in the Wiki page.
   In most cases all of the HTML between the third line of the file, starting with the ``<head>`` tag, through the start of the first ``<h1>`` tag can be safely removed.
   In the case where there is a table of contents, the first useful tag may be an ``<h2>`` tag.  Similarly, the ROS wiki contains some footer text that starts with ``<div id=""pagebottom""></div>`` and ends just above ``</body></html>`` that can also be removed.

#. Convert your html file by running a PanDoc conversion between HTML and restructured text.
   The following command coverts an HTML file to the equivalent reStructured text files: ``pandoc -f html -t rst urdf.html > URDF.rst``.

#. Attempt to build your new documentation using the ``make html`` command.
   There may be errors and warnings that you will need to address.

#. **CAREFULLY** read through the entire page making sure the material is up to date for ROS 2.
   Check every single link to make sure it points to the appropriate location on docs.ros.org.
   Internal document references must be updated to point to the equivalent ROS 2 material.
   Your updated document should not point to the ROS Wiki unless it is absolutely necessary.
   This process may require you alter the document considerably, and you may need to pull multiple wiki files.
   You should verify that every code sample in the document is working correctly under ROS 2.

#. Find and download any images that may be in the old document. The easiest way to do this is to right click in the browser and download all of the images. Alternatively you can find images by searching for ``<img src>`` tags in the HTML file.

#. For each image files downloaded update the image file links to point to the correct image directory for the ROS Docs.
   If any of the images require updating, or could be replaced with a `Mermaid <https://mermaid.js.org/intro/>`__ chart, please make this change.
   Be aware that Mermaid.js is only supported in the core ROS 2 documenation currently.

#. Once your document is complete add a table of contents to the top of your new rst document using the appropriate Sphinx commands.
   This block should replace any existing table of contents from the old ROS Wiki.

#. Issue your pull request.
   Make sure to point to the original ROS Wiki file for reference.

#. Once your pull request has been accepted please add a note to the top of the page on the original ROS Wiki article pointing to the new documentation page.

For a real-world example of this process in action, please refer to the ROS 2 Image Processing Pipeline in both `the ROS 2 Docs <https://github.com/ros-perception/image_pipeline/blob/rolling/image_pipeline/doc/tutorials.rst>`__ and in the original `ROS Wiki <https://wiki.ros.org/image_pipeline>`__.
The completed documentation page can be found in the `ROS 2 package documentation for image_pipeline <https://docs.ros.org/en/rolling/p/image_pipeline/>`__.

Building the Site with GitHub Codespaces
----------------------------------------
First, you need to have a GitHub account (if you don't have one, you can create one for free).
Then, you need to go to the `ROS 2 Documentation GitHub repository <https://github.com/ros2/ros2_documentation>`__.
After that, you can open the repository in Codespaces, it can be done just by clicking on the ""Code"" button on the repository page, then choose ""Open with Codespaces"" from the dropdown menu.

.. image:: images/codespaces.png
   :width: 100%
   :alt: Codespaces creation

After that, you will be redirected to your Codespaces page, where you can see the progress of the Codespaces creation.
Once it is done, a Visual Studio Code tab will be opened in your browser. You can open the terminal by clicking on the ""Terminal"" tab in the top panel or by pressing :kbd:`Ctrl-J`.

In this terminal, you can run any command you want, for example, you can run the following command to build the site for just this branch:

.. code-block:: console

   make html

Finally, to view the site, you can click on the ""Go Live"" button in the right bottom panel and then, it will open the site in a new tab in your browser (you will need to browse to the ``build/html`` folder).

.. image:: images/live_server.png
   :width: 100%
   :alt: Live Server

Building the Site with Devcontainer
-----------------------------------

`ROS 2 Documentation GitHub repository <https://github.com/ros2/ros2_documentation>`__ also supports ``Devcontainer`` development environment with Visual Studio Code.
This will enable you to build the documentation much easier without changing your operating system.

See :doc:`../../How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container` to install VS Code and Docker before the following procedure.

Clone repository and start VS Code:

.. code-block:: console

   git clone https://github.com/ros2/ros2_documentation
   cd ./ros2_documentation
   code .

To use ``Devcontainer``, you need to install ""Remote Development"" Extension within VS Code search in Extensions (CTRL+SHIFT+X) for it.

And then, use ``View->Command Palette...`` or ``Ctrl+Shift+P`` to open the command palette.
Search for the command ``Dev Containers: Reopen in Container`` and execute it.
This will build your development docker container for you automatically.

To build the documentation, open a terminal using ``View->Terminal`` or ``Ctrl+Shift+``` and ``New Terminal`` in VS Code.
Inside the terminal, you can build the documentation:

.. code-block:: console

   make html

.. image:: images/vscode_devcontainer.png
   :width: 100%
   :alt: VS Code Devcontainer

Writing pages
-------------

The ROS 2 documentation website uses the ``reStructuredText`` format, which is the default plaintext markup language used by Sphinx.
This section is a brief introduction to ``reStructuredText`` concepts, syntax, and best practices.

You can refer to `reStructuredText User Documentation <https://docutils.sourceforge.io/rst.html>`_ for a detailed technical specification.

Table of Contents
^^^^^^^^^^^^^^^^^

There are two types of directives used for the generation of a table of contents, ``.. toctree::`` and ``.. contents::``.
The ``.. toctree::`` is used in top-level pages like ``Tutorials.rst`` to set ordering and visibility of its child pages.
This directive creates both left navigation panel and in-page navigation links to the child pages listed.
It helps readers to understand the structure of separate documentation sections and navigate between pages.

.. code-block:: rst

   .. toctree::
      :maxdepth: 1

The ``.. contents::`` directive is used for the generation of a table of contents for that particular page.
It parses all present headings in a page and builds an in-page nested table of contents.
It helps readers to see an overview of the content and navigate inside a page.

The ``.. contents::`` directive supports the definition of maximum depth of nested sections.
Using ``:depth: 2`` will only show Sections and Subsections in the table of contents.

.. code-block:: rst

   .. contents:: Table of Contents
      :depth: 2
      :local:

Headings
^^^^^^^^

There are four main Heading types used in the documentation.
Note that the number of symbols has to match the length of the title.

.. code-block:: rst

   Page Title Header
   =================

   Section Header
   --------------

   2 Subsection Header
   ^^^^^^^^^^^^^^^^^^^

   2.4 Subsubsection Header
   ~~~~~~~~~~~~~~~~~~~~~~~~

We usually use one digit for numbering subsections and two digits (dot separated) for numbering subsubsections in Tutorials and How-To-Guides.

Lists
^^^^^

Stars ``*`` are used for listing unordered items with bullet points and number sign ``#.``  is used for listing numbered items.
Both of them support nested definitions and will render accordingly.

.. code-block:: rst

   * bullet point

     * bullet point nested
     * bullet point nested

   * bullet point

.. code-block:: rst

  #. first listed item
  #. second lited item

Code Formatting
^^^^^^^^^^^^^^^

In-text code can be formatted using ``backticks`` for showing ``highlighted`` code.

.. code-block:: rst

   In-text code can be formatted using ``backticks`` for showing ``highlighted`` code.

Code blocks inside a page need to be captured using ``.. code-block::`` directive.
``.. code-block::`` supports code highlighting for syntaxes like ``C++``, ``YAML``, ``console``, ``bash``, and more.
Code inside the directive needs to be indented.

.. code-block:: rst

   .. code-block:: C++

      int main(int argc, char** argv)
      {
         rclcpp::init(argc, argv);
         rclcpp::spin(std::make_shared<ParametersClass>());
         rclcpp::shutdown();
         return 0;
      }

Images
^^^^^^

Images can be inserted using the ``.. image::`` directive.

.. code-block:: rst

   .. image:: images/turtlesim_follow1.png

References and Links
^^^^^^^^^^^^^^^^^^^^

External links
~~~~~~~~~~~~~~

The syntax of creating links to external web pages is shown below.

.. code-block:: rst

   `ROS Docs <https://docs.ros.org>`_

The above link will appear as `ROS Docs <https://docs.ros.org>`_.
Note the underscore after the final single quote.

Internal links
~~~~~~~~~~~~~~

The ``:doc:`` directive is used to create in-text links to other pages.

.. code-block:: rst

   :doc:`Quality of Service <../Tutorials/Quality-of-Service>`

Note that the relative path to the file is used.

The ``ref`` directive is used to make links to specific parts of a page.
These could be headings, images or code sections inside the current or different page.

Definition of explicit target right before the desired object is required.
In the example below, the target is defined as ``_talker-listener`` one line before the heading ``Try some examples``.

.. code-block:: rst

   .. _talker-listener:

   Try some examples
   -----------------

Now the link from any page in the documentation to that header can be created.

.. code-block:: rst

   :ref:`talker-listener demo <talker-listener>`

This link will navigate a reader to the target page with an HTML anchor link ``#talker-listener``.

Macros
~~~~~~

Macros can be used to simplify writing documentation that targets multiple distributions.

Use a macro by including the macro name in curly braces.
For example, when generating the docs for Rolling on the ``rolling`` branch:


=====================  =====================  ==================================
Use                    Becomes (for Rolling)  Example
=====================  =====================  ==================================
\{DISTRO\}             rolling                ros-\{DISTRO\}-pkg
\{DISTRO_TITLE\}       Rolling                ROS 2 \{DISTRO_TITLE\}
\{DISTRO_TITLE_FULL\}  Rolling Ridley         ROS 2 \{DISTRO_TITLE_FULL\}
\{REPOS_FILE_BRANCH\}  rolling                git checkout \{REPOS_FILE_BRANCH\}
=====================  =====================  ==================================

The same file can be used on multiple branches (i.e., for multiple distros) and the generated content will be distro-specific.
",How can you build the ROS 2 Documentation site for all branches using Sphinx?
"ROS 2 packages are built on frequently updated Ubuntu systems.
It is always recommended that you ensure your system is up to date before installing new packages.

.. code-block:: bash

   sudo apt upgrade

",What command can you use to ensure that your Ubuntu system is up to date before installing new ROS 2 packages?
".. redirect-from::

   Installation/Linux-Install-Debians
   Installation/Ubuntu-Install-Debians

Ubuntu (deb packages)
=====================

.. contents:: Table of Contents
   :depth: 2
   :local:

Deb packages for ROS 2 {DISTRO_TITLE_FULL} are currently available for Ubuntu Noble (24.04).
The Rolling Ridley distribution will change target platforms from time to time as new platforms are selected for development.
The target platforms are defined in `REP 2000 <https://ros.org/reps/rep-2000.html>`__.
Most people will want to use a stable ROS distribution.

Resources
---------

* Status Page:

  * ROS 2 {DISTRO_TITLE} (Ubuntu Noble 24.04): `amd64 <http://repo.ros2.org/status_page/ros_{DISTRO}_default.html>`__\ , `arm64 <http://repo.ros2.org/status_page/ros_{DISTRO}_unv8.html>`__
* `Jenkins Instance <http://build.ros2.org/>`__
* `Repositories <http://repo.ros2.org>`__

System setup
------------

Set locale
^^^^^^^^^^

.. include:: _Ubuntu-Set-Locale.rst

Enable required repositories
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. include:: _Apt-Repositories.rst

.. _linux-install-debs-install-ros-2-packages:

Install development tools (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you are going to build ROS packages or otherwise do development, you can also install the development tools:

.. code-block:: bash

   sudo apt update && sudo apt install ros-dev-tools

Install ROS 2
-------------

Update your apt repository caches after setting up the repositories.

.. code-block:: bash

   sudo apt update

.. include:: _Apt-Upgrade-Admonition.rst

Desktop Install (Recommended): ROS, RViz, demos, tutorials.

.. code-block:: bash

   sudo apt install ros-{DISTRO}-desktop

ROS-Base Install (Bare Bones): Communication libraries, message packages, command line tools.
No GUI tools.

.. code-block:: bash

   sudo apt install ros-{DISTRO}-ros-base

Install additional RMW implementations (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default middleware that ROS 2 uses is ``Fast DDS``, but the middleware (RMW) can be replaced at runtime.
See the :doc:`guide <../How-To-Guides/Working-with-multiple-RMW-implementations>` on how to work with multiple RMWs.

Setup environment
-----------------

Set up your environment by sourcing the following file.

.. code-block:: bash

   # Replace "".bash"" with your shell if you're not using bash
   # Possible values are: setup.bash, setup.sh, setup.zsh
   source /opt/ros/{DISTRO}/setup.bash

Try some examples
-----------------

If you installed ``ros-{DISTRO}-desktop`` above you can try some examples.

In one terminal, source the setup file and then run a C++ ``talker``\ :

.. code-block:: bash

   source /opt/ros/{DISTRO}/setup.bash
   ros2 run demo_nodes_cpp talker

In another terminal source the setup file and then run a Python ``listener``\ :

.. code-block:: bash

   source /opt/ros/{DISTRO}/setup.bash
   ros2 run demo_nodes_py listener

You should see the ``talker`` saying that it's ``Publishing`` messages and the ``listener`` saying ``I heard`` those messages.
This verifies both the C++ and Python APIs are working properly.
Hooray!

Next steps
----------

Continue with the :doc:`tutorials and demos <../../Tutorials>` to configure your environment, create your own workspace and packages, and learn ROS 2 core concepts.

Troubleshoot
------------

Troubleshooting techniques can be found :doc:`here <../How-To-Guides/Installation-Troubleshooting>`.

Uninstall
---------

If you need to uninstall ROS 2 or switch to a source-based install once you
have already installed from binaries, run the following command:

.. code-block:: bash

   sudo apt remove ~nros-{DISTRO}-* && sudo apt autoremove

You may also want to remove the repository:

.. code-block:: bash

   sudo rm /etc/apt/sources.list.d/ros2.list
   sudo apt update
   sudo apt autoremove
   # Consider upgrading for packages previously shadowed.
   sudo apt upgrade
",What are the optional steps one can take after installing ROS 2 on Ubuntu Noble (24.04)?
"Make sure you have a locale which supports ``UTF-8``.
If you are in a minimal environment (such as a docker container), the locale may be something minimal like ``C``.
We test with the following settings. However, it should be fine if you're using a different UTF-8 supported locale.

.. code-block:: bash

   locale  # check for UTF-8

   sudo dnf install langpacks-en glibc-langpack-en
   export LANG=en_US.UTF-8

   locale  # verify settings
",What settings would you need to check and ensure are correctly configured in order to support UTF-8 encoding?
"Alternatives
============

A list of alternative ways to install ROS 2 – whether it's by building from source or installing a binary.

.. toctree::
   :maxdepth: 1

   Alternatives/Ubuntu-Development-Setup
   Alternatives/Ubuntu-Install-Binary
   Alternatives/Windows-Development-Setup
   Alternatives/RHEL-Development-Setup
   Alternatives/RHEL-Install-Binary
   Alternatives/macOS-Development-Setup
   Alternatives/Latest-Development-Setup
",What are some alternative ways to install ROS 2?
"DDS implementations
===================

By default, ROS 2 uses DDS as its `middleware <https://design.ros2.org/articles/ros_on_dds.html>`__.
It is compatible with multiple DDS or RTPS (the DDS wire protocol) vendors.
There is currently support for eProsima's Fast DDS, RTI's Connext DDS, Eclipse Cyclone DDS, and GurumNetworks GurumDDS.
See https://ros.org/reps/rep-2000.html for supported DDS vendors by distribution.

The default DDS vendor is eProsima's Fast DDS.

* :doc:`Working with Eclipse Cyclone DDS <DDS-Implementations/Working-with-Eclipse-CycloneDDS>` explains how to utilize Cyclone DDS.
* :doc:`Working with eProsima Fast DDS <DDS-Implementations/Working-with-eProsima-Fast-DDS>` explains how to utilize Fast DDS.
* :doc:`Working with GurumNetworks GurumDDS <DDS-Implementations/Working-with-GurumNetworks-GurumDDS>` explains how to utilize GurumDDS.

.. toctree::
   :hidden:
   :glob:

   DDS-Implementations/*

If you would like to use one of the other vendors you will need to install their software separately before building.
The ROS 2 build will automatically build support for vendors that have been installed and sourced correctly.

Once you've installed a new DDS vendor, you can change the vendor used at runtime: :doc:`Working with Multiple RMW Implementations <../How-To-Guides/Working-with-multiple-RMW-implementations>`.

Detailed instructions for installing other DDS vendors are provided below.

.. contents:: Platforms / Installation types
   :depth: 1
   :local:

Ubuntu Linux source install
---------------------------

RTI Connext (version 6.0.1, amd64 only)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Deb packages provided in the ROS 2 apt repositories
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can install a deb package of RTI Connext available on the ROS 2 apt repositories.
You will need to accept a license from RTI.

.. code-block:: bash

   sudo apt update && sudo apt install -q -y rti-connext-dds-6.0.1

Source the setup file to set the ``NDDSHOME`` environment variable.

.. code-block:: bash

   cd /opt/rti.com/rti_connext_dds-6.0.1/resource/scripts && source ./rtisetenv_x64Linux4gcc7.3.0.bash; cd -

Note: when using ``zsh`` you need to be in the directory of the script when sourcing it to have it work properly

Now you can build as normal and support for RTI will be built as well.

Official binary packages from RTI
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can install the Connext 6.0.1 package for Linux provided by RTI, via options available for :doc:`university, purchase or evaluation <DDS-Implementations/Install-Connext-University-Eval>`

After downloading, use ``chmod +x`` on the ``.run`` executable and then execute it.
Note that if you're installing to a system directory use ``sudo`` as well.

The default location is ``~/rti_connext_dds-6.0.1``

After installation, run RTI launcher and point it to your license file (obtained from RTI).

Add the following line to your ``.bashrc`` file pointing to your copy of the license.

.. code-block:: bash

   export RTI_LICENSE_FILE=path/to/rti_license.dat

Source the setup file to set the ``NDDSHOME`` environment variable.

.. code-block:: bash

   cd ~/rti_connext_dds-6.0.1/resource/scripts && source ./rtisetenv_x64Linux4gcc7.3.0.bash; cd -

Now you can build as normal and support for RTI will be built as well.

Ubuntu Linux binary install
---------------------------

RTI Connext (version 6.0.1, amd64 only)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To use RTI Connext DDS there are full-suite install options available for :doc:`university, purchase or evaluation <DDS-Implementations/Install-Connext-University-Eval>`
or you can install a libraries-only deb package of RTI Connext 6.0.1, available from the OSRF Apt repository
under a `non-commercial license <https://www.rti.com/ncl>`__.

To install the libs-only deb package:

.. code-block:: bash

   sudo apt update && sudo apt install -q -y rti-connext-dds-6.0.1

You will need to accept a license agreement from RTI, and will find an 'rti_license.dat file in the installation.

Add the following line to your ``.bashrc`` file pointing to your copy of the license (and source it).

.. code-block:: bash

   export RTI_LICENSE_FILE=path/to/rti_license.dat

All options need you to source the setup file to set the ``NDDSHOME`` environment variable:

.. code-block:: bash

   cd /opt/rti.com/rti_connext_dds-6.0.1/resource/scripts && source ./rtisetenv_x64Linux4gcc7.3.0.bash; cd -

Note: the above may need modification to match your RTI installation location

If you want to install the Connext DDS-Security plugins please refer to :doc:`this page <DDS-Implementations/Install-Connext-Security-Plugins>`.

OSX source install
------------------

RTI Connext (6.0.1)
^^^^^^^^^^^^^^^^^^^

If you would like to also build against RTI Connext DDS there are options available for :doc:`university, purchase or evaluation <DDS-Implementations/Install-Connext-University-Eval>`

You also need a Java runtime installed to run the RTI code generator, which you can get `here <https://support.apple.com/kb/DL1572?locale=en_US>`__.

After installing, run RTI launcher and point it to your license file.

Source the setup file to set the ``NDDSHOME`` environment variable before building your workspace.

.. code-block:: bash

   source /Applications/rti_connext_dds-6.0.1/resource/scripts/rtisetenv_x64Darwin17clang9.0.bash

You may need to increase shared memory resources following https://community.rti.com/kb/osx510

If you want to install the Connext DDS-Security plugins please refer to :doc:`this page <DDS-Implementations/Install-Connext-Security-Plugins>`.

OSX binary install
------------------


Enable Connext support
^^^^^^^^^^^^^^^^^^^^^^

To use RTI Connext DDS there are options available for :doc:`university, purchase or evaluation <DDS-Implementations/Install-Connext-University-Eval>`

After installing, run RTI launcher and point it to your license file.

Source the setup file to set the ``NDDSHOME`` environment variable before building your workspace.

.. code-block:: bash

   source /Applications/rti_connext_dds-6.0.1/resource/scripts/rtisetenv_x64Darwin17clang9.0.bash

You may need to increase shared memory resources following https://community.rti.com/kb/osx510.

If you want to install the Connext DDS-Security plugins please refer to :doc:`this page <DDS-Implementations/Install-Connext-Security-Plugins>`.

Windows source install
----------------------

RTI Connext 6.0.1
^^^^^^^^^^^^^^^^^

If you would like to also build against RTI Connext DDS there are options available for :doc:`university, purchase or evaluation <DDS-Implementations/Install-Connext-University-Eval>`

After installing, use the RTI Launcher to load your license file.

Then before building ROS 2, set up the Connext environment:

.. code-block:: bash

   call ""C:\Program Files\rti_connext_dds-6.0.1\resource\scripts\rtisetenv_x64Win64VS2017.bat""

Note that this path might need to be slightly altered depending on where you selected to install RTI Connext DDS, and which version of Visual Studio was selected.
The path above is the current default path as of version 6.0.1, but will change as the version numbers increment in the future.

If you want to install the Connext DDS-Security plugins please refer to :doc:`this page <DDS-Implementations/Install-Connext-Security-Plugins>`.

Windows binary install
----------------------


RTI Connext
^^^^^^^^^^^

To use RTI Connext DDS there are options available for :doc:`university, purchase or evaluation <DDS-Implementations/Install-Connext-University-Eval>`

After installing, run RTI launcher and point it to your license file.

Then before using ROS 2, set up the Connext environment:

.. code-block:: bash

   call ""C:\Program Files\rti_connext_dds-6.0.1\resource\scripts\rtisetenv_x64Win64VS2017.bat""

If you want to install the Connext DDS-Security plugins please refer to :doc:`this page <DDS-Implementations/Install-Connext-Security-Plugins>`.
",How can you change the default DDS vendor used at runtime in ROS 2?
"ROS 2 packages are built on frequently updated RHEL systems.
It is always recommended that you ensure your system is up to date before installing new packages.

.. code-block:: bash

   sudo dnf update

",What command is recommended to ensure that your system is up to date before installing new packages in ROS 2?
"Make sure you have a locale which supports ``UTF-8``.
If you are in a minimal environment (such as a docker container), the locale may be something minimal like ``POSIX``.
We test with the following settings. However, it should be fine if you're using a different UTF-8 supported locale.

.. code-block:: bash

   locale  # check for UTF-8

   sudo apt update && sudo apt install locales
   sudo locale-gen en_US en_US.UTF-8
   sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
   export LANG=en_US.UTF-8

   locale  # verify settings
",What steps were taken to ensure UTF-8 support and which locale was set for the environment?
"Windows (binary)
================

.. contents:: Table of Contents
   :depth: 2
   :local:

This page explains how to install ROS 2 on Windows from a pre-built binary package.

.. note::

    The pre-built binary does not include all ROS 2 packages.
    All packages in the `ROS base variant <https://ros.org/reps/rep-2001.html#ros-base>`_ are included, and only a subset of packages in the `ROS desktop variant <https://ros.org/reps/rep-2001.html#desktop-variants>`_ are included.
    The exact list of packages are described by the repositories listed in `this ros2.repos file <https://github.com/ros2/ros2/blob/{REPOS_FILE_BRANCH}/ros2.repos>`_.

System requirements
-------------------

Only Windows 10 is supported.

.. _windows-install-binary-installing-prerequisites:

.. include:: _Windows-Install-Prerequisites.rst

Install ROS 2
-------------

Binary releases of {DISTRO_TITLE_FULL} are not provided.
Instead you may download nightly :ref:`prerelease binaries <Prerelease_binaries>`.

* Download the latest package for Windows, e.g., ``ros2-package-windows-AMD64.zip``.

.. note::

   There may be more than one binary download option which might cause the file name to differ.

.. note::

   To install debug libraries for ROS 2, see `Extra Stuff for Debug`_.
   Then continue on with downloading ``ros2-package-windows-debug-AMD64.zip``.

* Unpack the zip file somewhere (we'll assume ``C:\dev\ros2_{DISTRO}``\ ).

Install additional RMW implementations (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default middleware that ROS 2 uses is ``Fast DDS``, but the middleware (RMW) can be replaced at runtime.
See the :doc:`guide <../How-To-Guides/Working-with-multiple-RMW-implementations>` on how to work with multiple RMWs.


Setup environment
-----------------

Start a command shell and source the ROS 2 setup file to set up the workspace:

.. code-block:: bash

   call C:\dev\ros2_{DISTRO}\local_setup.bat

It is normal that the previous command, if nothing else went wrong, outputs ""The system cannot find the path specified."" exactly once.

Try some examples
-----------------

In a command shell, set up the ROS 2 environment as described above and then run a C++ ``talker``\ :

.. code-block:: bash

   ros2 run demo_nodes_cpp talker

Start another command shell and run a Python ``listener``\ :

.. code-block:: bash

   ros2 run demo_nodes_py listener

You should see the ``talker`` saying that it's ``Publishing`` messages and the ``listener`` saying ``I heard`` those messages.
This verifies both the C++ and Python APIs are working properly.
Hooray!


Next steps
----------

Continue with the :doc:`tutorials and demos <../../Tutorials>` to configure your environment, create your own workspace and packages, and learn ROS 2 core concepts.

Troubleshoot
------------

Troubleshooting techniques can be found :ref:`here <windows-troubleshooting>`.

Uninstall
---------

1. If you installed your workspace with colcon as instructed above, ""uninstalling"" could be just a matter of opening a new terminal and not sourcing the workspace's ``setup`` file.
   This way, your environment will behave as though there is no {DISTRO_TITLE} install on your system.

2. If you're also trying to free up space, you can delete the entire workspace directory with:

   .. code-block:: bash

      rmdir /s /q \ros2_{DISTRO}

Extra Stuff for Debug
---------------------

To download the ROS 2 debug libraries you'll need to download ``ros2-{DISTRO}-*-windows-debug-AMD64.zip``.
Please note that debug libraries require some more additional configuration/setup to work as given below.

Python installation may require modification to enable debugging symbols and debug binaries:

* Search in windows **Search Bar** and open **Apps and Features**.
* Search for the installed Python version.

* Click Modify.

      .. image:: images/python_installation_modify.png
         :width: 500 px

* Click Next to go to **Advanced Options**.

      .. image:: images/python_installation_next.png
         :width: 500 px

* Make sure **Download debugging symbols** and **Download debug binaries** are checked.

      .. image:: images/python_installation_enable_debug.png
         :width: 500 px

* Click Install.
",What additional configuration/setup might be required to work with ROS 2 debug libraries on Windows?
"RHEL (RPM packages)
===================

.. contents:: Table of Contents
   :depth: 2
   :local:

RPM packages for ROS 2 {DISTRO_TITLE_FULL} are currently available for RHEL 9.
The Rolling Ridley distribution will change target platforms from time to time as new platforms are selected for development.
The target platforms are defined in `REP 2000 <https://ros.org/reps/rep-2000.html>`__.
Most people will want to use a stable ROS distribution.

Resources
---------

* Status Page:

  * ROS 2 {DISTRO_TITLE} (RHEL 9): `amd64 <http://repo.ros2.org/status_page/ros_{DISTRO}_rhel.html>`__
* `Jenkins Instance <http://build.ros2.org/>`__
* `Repositories <http://repo.ros2.org>`__

System setup
------------

Set locale
^^^^^^^^^^

.. include:: _RHEL-Set-Locale.rst

Enable required repositories
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You will need to enable the EPEL repositories and the PowerTools repository:

.. code-block:: bash

   sudo dnf install 'dnf-command(config-manager)' epel-release -y
   sudo dnf config-manager --set-enabled crb

.. note:: This step may be slightly different depending on the distribution you are using. Check the EPEL documentation: https://docs.fedoraproject.org/en-US/epel/#_quickstart

Next, download the ROS 2 .repo file:

.. code-block:: bash

   sudo dnf install curl
   sudo curl --output /etc/yum.repos.d/ros2.repo http://packages.ros.org/ros2/rhel/ros2.repo

Then, update your metadata cache.
DNF may prompt you to verify the GPG key, which should match the location ``https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc``.

.. code-block:: bash

   sudo dnf makecache

Install development tools (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you are going to build ROS packages or otherwise do development, you can also install the development tools:

.. code-block:: bash

   sudo dnf install -y \
     cmake \
     gcc-c++ \
     git \
     make \
     patch \
     python3-colcon-common-extensions \
     python3-mypy \
     python3-pip \
     python3-pydocstyle \
     python3-pytest \
     python3-pytest-repeat \
     python3-pytest-rerunfailures \
     python3-rosdep \
     python3-setuptools \
     python3-vcstool \
     wget

   # install some pip packages needed for testing and
   # not available as RPMs
   python3 -m pip install -U --user \
     flake8-blind-except==0.1.1 \
     flake8-class-newline \
     flake8-deprecated

Install ROS 2
-------------

.. include:: _Dnf-Update-Admonition.rst

Desktop Install (Recommended): ROS, RViz, demos, tutorials.

.. code-block:: bash

   sudo dnf install ros-{DISTRO}-desktop

ROS-Base Install (Bare Bones): Communication libraries, message packages, command line tools.
No GUI tools.

.. code-block:: bash

   sudo dnf install ros-{DISTRO}-ros-base

Install additional RMW implementations (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default middleware that ROS 2 uses is ``Fast DDS``, but the middleware (RMW) can be replaced at runtime.
See the :doc:`guide <../How-To-Guides/Working-with-multiple-RMW-implementations>` on how to work with multiple RMWs.

Setup environment
-----------------

Set up your environment by sourcing the following file.

.. code-block:: bash

   # Replace "".bash"" with your shell if you're not using bash
   # Possible values are: setup.bash, setup.sh, setup.zsh
   source /opt/ros/{DISTRO}/setup.bash

Try some examples
-----------------

If you installed ``ros-{DISTRO}-desktop`` above you can try some examples.

In one terminal, source the setup file and then run a C++ ``talker``\ :

.. code-block:: bash

   source /opt/ros/{DISTRO}/setup.bash
   ros2 run demo_nodes_cpp talker

In another terminal source the setup file and then run a Python ``listener``\ :

.. code-block:: bash

   source /opt/ros/{DISTRO}/setup.bash
   ros2 run demo_nodes_py listener

You should see the ``talker`` saying that it's ``Publishing`` messages and the ``listener`` saying ``I heard`` those messages.
This verifies both the C++ and Python APIs are working properly.
Hooray!

Next steps
----------

Continue with the :doc:`tutorials and demos <../../Tutorials>` to configure your environment, create your own workspace and packages, and learn ROS 2 core concepts.

Troubleshoot
------------

Troubleshooting techniques can be found :doc:`here <../How-To-Guides/Installation-Troubleshooting>`.

Uninstall
---------

If you need to uninstall ROS 2 or switch to a source-based install once you
have already installed from binaries, run the following command:

.. code-block:: bash

   sudo dnf remove ros-{DISTRO}-*
",What are the steps to enable required repositories for installing ROS 2 on RHEL 9?
"**Note**: If you're using a distribution that is based on Ubuntu (like Linux Mint) but does not identify itself as such, you'll get an error message like ``Unsupported OS [mint]``. In this case append ``--os=ubuntu:noble`` to the above command.
","What is the command that should be appended in case of getting an error message ""Unsupported OS [mint]""?"
"System setup
------------

Install Chocolatey
^^^^^^^^^^^^^^^^^^

Chocolatey is a package manager for Windows, install it by following their installation instructions:

https://chocolatey.org/install

You'll use Chocolatey to install some other developer tools.

Install Python
^^^^^^^^^^^^^^

Open a Command Prompt and type the following to install Python via Chocolatey:

.. code-block:: bash

   choco install -y python --version 3.8.3

.. note::

   Chocolatey will install Python in ``C:\Python38``, and the rest of the installation expects it to be there.
   If you've installed Python somewhere else, you must copy or link it to that location.

Install Visual C++ Redistributables
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Open a Command Prompt and type the following to install them via Chocolatey:

.. code-block:: bash

   choco install -y vcredist2013 vcredist140

Install OpenSSL
^^^^^^^^^^^^^^^

Open a Command Prompt and type the following to install OpenSSL via Chocolatey:

.. code-block:: bash

  choco install -y openssl --version 1.1.1.2100

This command sets an environment variable that persists over sessions:

.. code-block:: bash

   setx /m OPENSSL_CONF ""C:\Program Files\OpenSSL-Win64\bin\openssl.cfg""

You will need to append the OpenSSL-Win64 bin folder to your PATH.
You can do this by clicking the Windows icon, typing ""Environment Variables"", then clicking on ""Edit the system environment variables"".
In the resulting dialog, click ""Environment Variables"", then click ""Path"" on the bottom pane, finally click ""Edit"" and add the path below.

* ``C:\Program Files\OpenSSL-Win64\bin\``

Install Visual Studio
^^^^^^^^^^^^^^^^^^^^^

Install Visual Studio 2019.

If you already have a paid version of Visual Studio 2019 (Professional, Enterprise), skip this step.

Microsoft provides a free of charge version of Visual Studio 2019, named Community, which can be used to build applications that use ROS 2.
`You can download the installer directly through this link. <https://aka.ms/vs/16/release/vs_community.exe>`_

Make sure that the Visual C++ features are installed.

An easy way to make sure they're installed is to select the ``Desktop development with C++`` workflow during the install.

   .. image:: /Installation/images/windows-vs-studio-install.png

Make sure that no C++ CMake tools are installed by unselecting them in the list of components to be installed.

Install OpenCV
^^^^^^^^^^^^^^

Some of the examples require OpenCV to be installed.

You can download a precompiled version of OpenCV 3.4.6 from https://github.com/ros2/ros2/releases/download/opencv-archives/opencv-3.4.6-vc16.VS2019.zip .

Assuming you unpacked it to ``C:\opencv``, type the following on a Command Prompt (requires Admin privileges):

.. code-block:: bash

   setx /m OpenCV_DIR C:\opencv

Since you are using a precompiled ROS version, we have to tell it where to find the OpenCV libraries.
You have to extend the ``PATH`` variable to ``C:\opencv\x64\vc16\bin``.

Install dependencies
^^^^^^^^^^^^^^^^^^^^

There are a few dependencies not available in the Chocolatey package database.
In order to ease the manual installation process, we provide the necessary Chocolatey packages.

As some chocolatey packages rely on it, we start by installing CMake

.. code-block:: bash

   choco install -y cmake

You will need to append the CMake bin folder ``C:\Program Files\CMake\bin`` to your PATH.

Please download these packages from `this <https://github.com/ros2/choco-packages/releases/latest>`__ GitHub repository.

* asio.1.12.1.nupkg
* bullet.3.17.nupkg
* cunit.2.1.3.nupkg
* eigen.3.3.4.nupkg
* tinyxml2.6.0.0.nupkg

Once these packages are downloaded, open an administrative shell and execute the following command:

.. code-block:: bash

   choco install -y -s <PATH\TO\DOWNLOADS\> asio cunit eigen tinyxml2 bullet

Please replace ``<PATH\TO\DOWNLOADS>`` with the folder you downloaded the packages to.

First upgrade pip and setuptools:

.. code-block:: bash

   python -m pip install -U pip setuptools==59.6.0

Now install some additional python dependencies:

.. code-block:: bash

   python -m pip install -U catkin_pkg cryptography empy fastjsonschema==2.19.0 importlib-metadata jsonschema lark==1.1.1 lxml matplotlib netifaces numpy opencv-python PyQt5 pillow psutil pycairo pydot pyparsing==2.4.7 pytest pyyaml rosdistro

Install miscellaneous prerequisites
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Next install xmllint:

* Download the `64 bit binary archives <https://www.zlatkovic.com/pub/libxml/64bit/>`__ of ``libxml2`` (and its dependencies ``iconv`` and ``zlib``) from https://www.zlatkovic.com/projects/libxml/
* Unpack all archives into e.g. ``C:\xmllint``
* Add ``C:\xmllint\bin`` to the ``PATH``.

Install Qt5
^^^^^^^^^^^

Download the `5.12.X offline installer <https://www.qt.io/offline-installers>`_ from Qt's website.
Run the installer.
Make sure to select the ``MSVC 2017 64-bit`` component under the ``Qt`` -> ``Qt 5.12.12`` tree.

Finally, in an administrator ``cmd.exe`` window set these environment variables.
The commands below assume you installed it to the default location of ``C:\Qt``.

.. code-block:: bash

   setx /m Qt5_DIR C:\Qt\Qt5.12.12\5.12.12\msvc2017_64
   setx /m QT_QPA_PLATFORM_PLUGIN_PATH C:\Qt\Qt5.12.12\5.12.12\msvc2017_64\plugins\platforms


.. note::

   This path might change based on the installed MSVC version, the directory Qt was installed to, and the version of Qt installed.

RQt dependencies
^^^^^^^^^^^^^^^^

To run rqt_graph you need to `download <https://graphviz.gitlab.io/_pages/Download/Download_windows.html>`__ and install `Graphviz <https://graphviz.gitlab.io/>`__.
The installer will ask if to add graphviz to PATH, choose to either add it to the current user or all users.
",What instructions should be followed to install Visual Studio 2019 for building applications using ROS 2?
"You will need to add the ROS 2 apt repository to your system.

First ensure that the `Ubuntu Universe repository <https://help.ubuntu.com/community/Repositories/Ubuntu>`_ is enabled.

.. code-block:: bash

   sudo apt install software-properties-common
   sudo add-apt-repository universe

Now add the ROS 2 GPG key with apt.

.. code-block:: bash

   sudo apt update && sudo apt install curl -y
   sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg

Then add the repository to your sources list.

.. code-block:: bash

   echo ""deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main"" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null
",How do you add the ROS 2 apt repository to your system?
".. _MaintainingSource:

Maintain source checkout
========================

.. ifconfig:: smv_current_version != '' and smv_current_version != 'rolling'

  .. note::

     For instructions on maintaining a source checkout of the **latest development version** of ROS 2, refer to
     `Maintaining a source checkout of ROS 2 Rolling <../../rolling/Installation/Maintaining-a-Source-Checkout.html>`__

.. contents::
   :depth: 2
   :local:

If you have installed ROS 2 from source, there may have been changes made to the source code since the time that you checked it out.
To keep your source checkout up to date, you will have to periodically update your ``ros2.repos`` file, download the latest sources, and rebuild your workspace.

Update your repository list
---------------------------

Each ROS 2 release includes a ``ros2.repos`` file that contains the list of repositories and their version for that release.


Latest ROS 2 {DISTRO_TITLE} branches
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you wish to checkout the latest code for ROS 2 {DISTRO_TITLE}, you can get the relevant repository list by running:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

       cd ~/ros2_{DISTRO}
       mv -i ros2.repos ros2.repos.old
       wget https://raw.githubusercontent.com/ros2/ros2/{REPOS_FILE_BRANCH}/ros2.repos

  .. group-tab:: macOS

    .. code-block:: bash

       cd ~/ros2_{DISTRO}
       mv -i ros2.repos ros2.repos.old
       wget https://raw.githubusercontent.com/ros2/ros2/{REPOS_FILE_BRANCH}/ros2.repos

  .. group-tab:: Windows

    .. code-block:: bash

       # CMD
       cd \dev\ros2_{DISTRO}
       curl -sk https://raw.githubusercontent.com/ros2/ros2/{REPOS_FILE_BRANCH}/ros2.repos -o ros2.repos

       # PowerShell
       cd \dev\ros2_{DISTRO}
       curl https://raw.githubusercontent.com/ros2/ros2/{REPOS_FILE_BRANCH}/ros2.repos -o ros2.repos


Update your repositories
------------------------

You will notice that in the `ros2.repos <https://raw.githubusercontent.com/ros2/ros2/{REPOS_FILE_BRANCH}/ros2.repos>`__ file, each repository has a ``version`` associated with it that points to a particular commit hash, tag, or branch name.
It is possible that these versions refer to new tags/branches that your local copy of the repositories will not recognize as they are out-of-date.
Because of this, you should update the repositories that you have already checked out with the following command:

.. code-block:: bash

   vcs custom --args remote update

Download the new source code
----------------------------

You should now be able to download the sources associated with the new repository list with:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

       vcs import src < ros2.repos
       vcs pull src

  .. group-tab:: macOS

    .. code-block:: bash

       vcs import src < ros2.repos
       vcs pull src

  .. group-tab:: Windows

    .. code-block:: bash

       # CMD
       vcs import src < ros2.repos
       vcs pull src

       # PowerShell
       vcs import --input ros2.repos src
       vcs pull src

Rebuild your workspace
----------------------

Now that the workspace is up to date with the latest sources, remove your previous install and rebuild your workspace with, for example:

.. code-block:: bash

   colcon build --symlink-install

Inspect your source checkout
----------------------------

During your development you may have deviated from the original state of your workspace from when you imported the repository list.
If you wish to know the versions of the set of repositories in your workspace, you can export the information using the following command:

.. tabs::

  .. group-tab:: Linux

    .. code-block:: bash

       cd ~/ros2_{DISTRO}
       vcs export src > my_ros2.repos

  .. group-tab:: macOS

    .. code-block:: bash

       cd ~/ros2_{DISTRO}
       vcs export src > my_ros2.repos

  .. group-tab:: Windows

    .. code-block:: bash

       cd \dev\ros2_{DISTRO}
       vcs export src > my_ros2.repos

This ``my_ros2.repos`` file can then be shared with others so that they can reproduce the state of the repositories in your workspace.
",What command should you use to update the repositories that you have already checked out in ROS 2 from source?
".. redirect-from::

   Installation/Prerelease-Testing

Testing with pre-release binaries
=================================

Many ROS packages are provided as pre-built binaries.
Usually, you will get the released version of binaries when following :doc:`../Installation`.
There are also pre-released versions of binaries that are useful for testing before making an official release.
This article describes several options if you would like to try out pre-released versions of ROS binaries.

deb testing repository
----------------------

When packages are released into a ROS distribution (using bloom), the buildfarm builds them into deb packages which are stored temporarily in the **building** apt repository.
As dependent packages are rebuilt, an automatic process periodically synchronizes the packages in **building** to a secondary repository called **ros-testing**.
**ros-testing** is intended as a soaking area where developers and bleeding-edge users may give the packages extra testing, before they are manually synced into the public ros repository from which users typically install packages.

Approximately every two weeks, the rosdistro's release manager manually synchronizes the contents of **ros-testing** into the **main** ROS repository.

For Debian-based operating systems, you can install binary packages from the **ros-testing** repository.

1. Make sure you have a working ROS 2 installation from deb packages (see :doc:`../Installation`).

2. Edit (with sudo) the file ``/etc/apt/sources.list.d/ros2.list`` and change ``ros2`` with ``ros2-testing``.
   For example, on Ubuntu Noble the contents should look like the following:

   .. code-block:: sh

      # deb http://packages.ros.org/ros2/ubuntu noble main
      deb http://packages.ros.org/ros2-testing/ubuntu noble main

3. Update the ``apt`` index:

   .. code-block:: sh

      sudo apt update

4. You can now install individual packages from the testing repository, for example:

   .. code-block:: sh

      sudo apt install ros-{DISTRO}-my-just-released-package

5. Alternatively, you can move your entire ROS 2 installation to the testing repository:

   .. code-block:: sh

      sudo apt dist-upgrade

6. Once you are finished testing, you can switch back to the normal repository by changing back the contents of ``/etc/apt/sources.list.d/ros2.list``:

   .. code-block:: sh

      deb http://packages.ros.org/ros2/ubuntu noble main
      # deb http://packages.ros.org/ros2-testing/ubuntu noble main

   and doing an update and upgrade:

   .. code-block:: sh

      sudo apt update
      sudo apt dist-upgrade

.. _Prerelease_binaries:

Binary archives
---------------

For core packages, we run nightly packaging jobs for Ubuntu Linux, RHEL, and Windows.
These packaging jobs produce archives with pre-built binaries that can be downloaded and extracted to your filesystem.

1. Make sure you have all dependencies installed according to the :doc:`latest development setup <Alternatives/Latest-Development-Setup>` for your platform.

2. Go to https://ci.ros2.org/view/packaging/ and select a packaging job from the list corresponding to your platform.

3. Under the heading ""Last Successful Artifacts"" you should see a download link (e.g. for Windows, ``ros2-package-windows-AMD64.zip``).

4. Download and extract the archive to your file system.

5. To use the binary archive installation, source the ``setup.*`` file that can be found in the root of the archive.

   .. tabs::

     .. group-tab:: Ubuntu Linux and RHEL

       .. code-block:: sh

          source path/to/extracted/archive/setup.bash

     .. group-tab:: Windows

       .. code-block:: sh

          call path\to\extracted\archive\setup.bat

Docker
------

For Ubuntu Linux, there is also a nightly Docker image based on the nightly binary archive.

1. Pull the Docker image:

   .. code-block:: sh

      docker pull osrf/ros2:nightly

2. Start an interactive container:

   .. code-block:: sh

      docker run -it osrf/ros2:nightly

For support on running GUI applications in Docker, take a look at the tutorial `User GUI's with Docker <https://wiki.ros.org/docker/Tutorials/GUI>`_ or the tool `rocker <https://github.com/osrf/rocker>`_.
",What steps are involved in installing individual packages from the **ros-testing** repository for Debian-based operating systems?
"RTI Connext DDS
===============

A libraries-only version of RTI Connext DDS 6.0.1 may be installed per the :doc:`installation instructions <../../Installation>` for
Debian/Ubuntu Linux (amd64) platforms only, under a `non-commercial license <https://www.rti.com/ncl>`__.

A full-suite installation of RTI Connext DDS is available for many additional platforms, for universities, evaluation, or purchase.
This installation includes diagnostic tools, layered services, and security.  See below for installation details.

RTI University Program
----------------------

University researchers and classroom users may be eligible for a free academic license through the `RTI University Program <https://www.rti.com/free-trial/university-program>`__.
This includes a one-year (renewable) license to the unabridged version of Connext DDS Secure, which includes diagnostic tools and layered services.
The university license application can be found `here <https://www.rti.com/free-trial/university-program>`__.


RTI Connext DDS Evaluation
--------------------------

To install RTI Connext DDS **version 6.0.1** Evalution:
 * Visit the `RTI Free Trial (6.0.1) site <https://www.rti.com/free-trial>`__.
 * Download the version(s) to match your environment.
 * Contact license@rti.com for an evaluation license.
 * Install RTI Connext 6.0.1 by running the installation program.  When finished, it will run the RTI Launcher.
 * Use the RTI Launcher to install the license file (rti_license.dat) if needed.  The launcher may also be used to launch the diagnostic tools and services.
",What steps are required to install RTI Connext DDS version 6.0.1 for evaluation purposes?
".. redirect-from::

   Working-with-GurumNetworks-GurumDDS

GurumNetworks GurumDDS
======================
``rmw_gurumdds`` is an implementation of the ROS middleware interface using GurumNetworks GurumDDS. For more information about GurumDDS, visit the `GurumNetworks website <https://gurum.cc/index_eng>`_.


Prerequisites
-------------
This guide assumes you have completed the ROS 2 environment setup process, either by :doc:`Installing ROS 2 via Deb Packages <../Ubuntu-Install-Debs>` or :doc:`Building ROS 2 from source on Ubuntu <../Alternatives/Ubuntu-Development-Setup>`.

Version Requirements (`see the README for details <https://github.com/ros2/rmw_gurumdds>`_):

================  ================
ROS 2 Distro      GurumDDS Version
================  ================
rolling           >= 3.2.0
jazzy             >= 3.2.0
humble            3.1.x
================  ================

Deb packages of GurumDDS are provided in the ROS 2 apt repositories on Ubuntu.
Windows binary installer of GurumDDS will be available soon.

You can obtain a free trial license from the `GurumDDS Free Trial page <https://gurum.cc/free_trial_eng.html>`_.

After acquiring a license, place it in the following location: ``/etc/gurumnet``


Installation
------------
Option 1: Install from the ROS 2 apt repository (Recommended)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: bash

   sudo apt install ros-{DISTRO}-rmw-gurumdds-cpp

This installs both ``rmw_gurumdds_cpp`` and ``gurumdds``.

Option 2: Build from source code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1. Clone the repository

.. code-block:: bash

   cd ros2_ws/src
   git clone https://github.com/ros2/rmw_gurumdds -b {DISTRO} ros2/rmw_gurumdds

2. Install dependencies:

.. code-block:: bash

   cd ..
   rosdep install --from src -i --rosdistro {DISTRO}

3. Build the worksapce using Colcon:

.. code-block:: bash

   colcon build --symlink-install


Switch to rmw_gurumdds
----------------------
Switch from other RMW implementations to rmw_gurumdds by setting the environment variable:

.. code-block:: bash

   export RMW_IMPLEMENTATION=rmw_gurumdds_cpp

For more information on working with multiple RMW implementations, see :doc:`Working with multiple RMW implementations <../../How-To-Guides/Working-with-multiple-RMW-implementations>`.


Testing the installation
------------------------
Run the ``talker`` and ``listener`` nodes to verify your installation:

.. code-block:: bash

   ros2 run demo_nodes_cpp talker

.. code-block:: bash

   ros2 run demo_nodes_cpp listener

If the nodes communicate successfully, your installation is working correctly.

.. note:: Remember to source your ROS 2 setup script before running these commands.
",What steps are recommended for installing GurumNetworks GurumDDS using the ROS 2 apt repository?
"eProsima Fast DDS
=================

eProsima Fast DDS is a complete open-source DDS implementation for real time embedded architectures and operating systems.
See also: https://www.eprosima.com/index.php/products-all/eprosima-fast-dds


Prerequisites
-------------

Have :doc:`rosdep installed <../../Tutorials/Intermediate/Rosdep>`.

Install packages
----------------

The easiest way is to install from ROS 2 apt repository.

.. code-block:: bash

   sudo apt install ros-{DISTRO}-rmw-fastrtps-cpp

Build from source code
----------------------

Building from source code is also another way to install.

First, clone Fast DDS and rmw_fastrtps in the ROS 2 workspace source directory.

.. code-block:: bash

   cd ros2_ws/src
   git clone https://github.com/ros2/rmw_fastrtps ros2/rmw_fastrtps -b {REPOS_FILE_BRANCH}
   git clone https://github.com/eProsima/Fast-DDS eProsima/fastrtps

Then, install necessary packages for Fast DDS.

.. code-block:: bash

   cd ..
   rosdep install --from src -i

Finally, run colcon build.

.. code-block:: bash

   colcon build --symlink-install

Switch to rmw_fastrtps
----------------------

The eProsima Fast DDS RMW can be selected by specifying the environment variable:

.. code-block:: bash

   export RMW_IMPLEMENTATION=rmw_fastrtps_cpp

See also: :doc:`Working with multiple RMW implementations <../../How-To-Guides/Working-with-multiple-RMW-implementations>`

Run the talker and listener
---------------------------

Now run ``talker`` and ``listener`` to test Fast DDS.

.. code-block:: bash

   ros2 run demo_nodes_cpp talker

.. code-block:: bash

   ros2 run demo_nodes_cpp listener

",What command is used to install eProsima Fast DDS from ROS 2 apt repository?
"Connext security plugins
========================

The Connext DDS Libraries are included with ROS 2 under a `non-commercial
license <https://www.rti.com/ncl>`__ and do not include the security
plug-in libraries. These libraries are available in the commercial,
university and research license versions of RTI Connext DDS Pro, which
is bundled with tools for system debugging, monitoring, record/replay,
etc.

The Connext DDS Evaluation Version (6.0.1) includes the security plugins, and can be downloaded via options available for :doc:`university, purchase or evaluation <Install-Connext-University-Eval>`.

A video walk-thru of this installation (tools and security plug-ins) is
available
`here <https://www.rti.com/gettingstarted/installwindows_secure>`__ at
the RTI website. The steps are:

**Install Connext DDS Pro (Host)**
This is a host-specific installer application (for Windows, Linux, MacOS) to install a 'Host' bundle which includes the Launcher, tools, and other software services.
At the end of the installation, the RTI 'Launcher' program will be started.
The Launcher is used to install target libraries, security plugins, and other layered services.

**Use the Package Installer in Launcher**

.. figure:: https://cdn2.hubspot.net/hub/1754418/file-3649043118-png/blog-files/launchermacos.png
   :alt: Launcher Image

   Launcher Image

The 'RTI Package Installer' is used to install '.rtipkg' files -- target
libraries, security plug-ins, etc. Open the Package Installer and select
all of the .rtipkg files that were included in the Connext DDS Secure
bundle for installation:

 * Target Libraries - such as: rti\_connext\_dds-[version]-pro-target-[toolchain].rtipkg
 * Security Plugin Host - such as: rti\_security\_plugins-[version]-host-[toolchain].rtipkg
 * Security Plugin Target - such as: rti\_security\_plugins-[version]-target-[toolchain].rtipkg
 * OpenSSL Host - such as: openssl-1.0.2x-[version]-host-[toolchain].rtipkg

**Extract and Install OpenSSL**
This is included as an archive (.zip or
otherwise) and can be simply extracted and copied to a convenient
location on your host computer. As a suggestion, this could also be
installed into the 'rti\_connext\_dds-[version]' directory in your home
directory space (this was created during installation of the RTI host
tools). Note: this directory location may need to be placed in your PATH
environment variable.
See the `RTI Security Plugins Getting Started Guide <https://community.rti.com/static/documentation/connext-dds/6.0.1/doc/manuals/connext_dds/dds_security/RTI_SecurityPlugins_GettingStarted.pdf>`__ for more information.

Installation complete.
",What steps are required to install the security plug-ins for Connext DDS Pro according to the text provided?
".. redirect-from::

    Working-with-Eclipse-CycloneDDS

Eclipse Cyclone DDS
===================

Eclipse Cyclone DDS is a very performant and robust open-source DDS implementation.
Cyclone DDS is developed completely in the open as an Eclipse IoT project.
See also: https://projects.eclipse.org/projects/iot.cyclonedds


Prerequisites
-------------

Have :doc:`rosdep installed <../../Tutorials/Intermediate/Rosdep>`.

Install packages
----------------

The easiest way is to install from ROS 2 apt repository.

.. code-block:: bash

   sudo apt install ros-{DISTRO}-rmw-cyclonedds-cpp

Build from source code
----------------------

Building from source code is also another way to install.

First, clone Cyclone DDS and rmw_cyclonedds in the ROS 2 workspace source directory.

.. code-block:: bash

   cd ros2_ws/src
   git clone https://github.com/ros2/rmw_cyclonedds ros2/rmw_cyclonedds -b {REPOS_FILE_BRANCH}
   git clone https://github.com/eclipse-cyclonedds/cyclonedds eclipse-cyclonedds/cyclonedds

Then, install necessary packages for Cyclone DDS.

.. code-block:: bash

   cd ..
   rosdep install --from src -i

Finally, run colcon build.

.. code-block:: bash

   colcon build --symlink-install

Switch to rmw_cyclonedds
------------------------

Switch from other rmw to rmw_cyclonedds by specifying the environment variable.

.. code-block:: bash

   export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp

See also: :doc:`Working with multiple RMW implementations <../../How-To-Guides/Working-with-multiple-RMW-implementations>`

Run the talker and listener
---------------------------

Now run ``talker`` and ``listener`` to test Cyclone DDS.

.. code-block:: bash

   ros2 run demo_nodes_cpp talker

.. code-block:: bash

   ros2 run demo_nodes_cpp listener
",What are the steps to install Eclipse Cyclone DDS in ROS 2 using the ROS 2 apt repository or building from the source code?
".. redirect-from::

   Installation/Linux-Development-Setup
   Installation/Ubuntu-Development-Setup

Ubuntu (source)
===============

.. contents:: Table of Contents
   :depth: 2
   :local:


System requirements
-------------------
The current Debian-based target platforms for {DISTRO_TITLE_FULL} are:

- Tier 1: Ubuntu Linux - Noble (24.04) 64-bit
- Tier 3: Ubuntu Linux - Jammy (22.04) 64-bit
- Tier 3: Debian Linux - Bookworm (12) 64-bit

As defined in `REP 2000 <https://www.ros.org/reps/rep-2000.html>`_.

System setup
------------

Set locale
^^^^^^^^^^

.. include:: ../_Ubuntu-Set-Locale.rst

Enable required repositories
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. include:: ../_Apt-Repositories.rst

Install development tools
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: bash

   sudo apt update && sudo apt install -y \
     python3-flake8-blind-except \
     python3-flake8-class-newline \
     python3-flake8-deprecated \
     python3-mypy \
     python3-pip \
     python3-pytest \
     python3-pytest-cov \
     python3-pytest-mock \
     python3-pytest-repeat \
     python3-pytest-rerunfailures \
     python3-pytest-runner \
     python3-pytest-timeout \
     ros-dev-tools

Build ROS 2
-----------

Get ROS 2 code
^^^^^^^^^^^^^^

Create a workspace and clone all repos:

.. code-block:: bash

   mkdir -p ~/ros2_{DISTRO}/src
   cd ~/ros2_{DISTRO}
   vcs import --input https://raw.githubusercontent.com/ros2/ros2/{REPOS_FILE_BRANCH}/ros2.repos src

.. _linux-development-setup-install-dependencies-using-rosdep:

Install dependencies using rosdep
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. include:: ../_Apt-Upgrade-Admonition.rst

.. code-block:: bash

   sudo rosdep init
   rosdep update
   rosdep install --from-paths src --ignore-src -y --skip-keys ""fastcdr rti-connext-dds-6.0.1 urdfdom_headers""

.. include:: ../_rosdep_Linux_Mint.rst

Install additional RMW implementations (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default middleware that ROS 2 uses is ``Fast DDS``, but the middleware (RMW) can be replaced at build or runtime.
See the :doc:`guide <../../How-To-Guides/Working-with-multiple-RMW-implementations>` on how to work with multiple RMWs.

Build the code in the workspace
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you have already installed ROS 2 another way (either via debs or the binary distribution), make sure that you run the below commands in a fresh environment that does not have those other installations sourced.
Also ensure that you do not have ``source /opt/ros/${ROS_DISTRO}/setup.bash`` in your ``.bashrc``.
You can make sure that ROS 2 is not sourced with the command ``printenv | grep -i ROS``.
The output should be empty.

More info on working with a ROS workspace can be found in :doc:`this tutorial <../../Tutorials/Beginner-Client-Libraries/Colcon-Tutorial>`.

.. code-block:: bash

   cd ~/ros2_{DISTRO}/
   colcon build --symlink-install

.. note::

   If you are having trouble compiling all examples and this is preventing you from completing a successful build, you can use the ``--packages-skip`` colcon flag to ignore the package that is causing problems.
   For instance, if you don't want to install the large OpenCV library, you could skip building the packages that depend on it using the command:

   .. code-block:: bash

      colcon build --symlink-install --packages-skip image_tools intra_process_demo

Setup environment
-----------------

Set up your environment by sourcing the following file.

.. code-block:: bash

   # Replace "".bash"" with your shell if you're not using bash
   # Possible values are: setup.bash, setup.sh, setup.zsh
   . ~/ros2_{DISTRO}/install/local_setup.bash

.. _talker-listener:

Try some examples
-----------------

In one terminal, source the setup file and then run a C++ ``talker``\ :

.. code-block:: bash

   . ~/ros2_{DISTRO}/install/local_setup.bash
   ros2 run demo_nodes_cpp talker

In another terminal source the setup file and then run a Python ``listener``\ :

.. code-block:: bash

   . ~/ros2_{DISTRO}/install/local_setup.bash
   ros2 run demo_nodes_py listener

You should see the ``talker`` saying that it's ``Publishing`` messages and the ``listener`` saying ``I heard`` those messages.
This verifies both the C++ and Python APIs are working properly.
Hooray!

Next steps
----------

Continue with the :doc:`tutorials and demos <../../Tutorials>` to configure your environment, create your own workspace and packages, and learn ROS 2 core concepts.

Alternate compilers
-------------------

Using a different compiler besides gcc to compile ROS 2 is easy.
If you set the environment variables ``CC`` and ``CXX`` to executables for a working C and C++ compiler, respectively, and retrigger CMake configuration (by using ``--cmake-force-configure`` or by deleting the packages you want to be affected), CMake will reconfigure and use the different compiler.

Clang
^^^^^

To configure CMake to detect and use Clang:

.. code-block:: bash

   sudo apt install clang
   export CC=clang
   export CXX=clang++
   colcon build --cmake-force-configure

Stay up to date
---------------

See :doc:`../Maintaining-a-Source-Checkout` to periodically refresh your source installation.

Troubleshoot
------------

Troubleshooting techniques can be found :ref:`here <linux-troubleshooting>`.

Uninstall
---------

1. If you installed your workspace with colcon as instructed above, ""uninstalling"" could be just a matter of opening a new terminal and not sourcing the workspace's ``setup`` file.
   This way, your environment will behave as though there is no {DISTRO_TITLE} install on your system.

2. If you're also trying to free up space, you can delete the entire workspace directory with:

   .. code-block:: bash

      rm -rf ~/ros2_{DISTRO}
",What are the Tier 1 and Tier 3 Debian-based target platforms for Ubuntu Linux as mentioned in the text document?
".. redirect-from::

  Installation/Rolling/OSX-Development-Setup
  Installation/macOS-Development-Setup

macOS (source)
==============

.. contents:: Table of Contents
   :depth: 2
   :local:

System requirements
-------------------

We currently support macOS Mojave (10.14).
The Rolling Ridley distribution will change target platforms from time to time as new platforms become available.
Most people will want to use a stable ROS distribution.

System setup
------------

Install prerequisites
^^^^^^^^^^^^^^^^^^^^^

You need the following things installed to build ROS 2:


#.
   **Xcode**

   * If you don't already have it installed, install [Xcode](https://apps.apple.com/app/xcode/id497799835).
   * Note: Versions of Xcode later than 11.3.1 can no longer be installed on macOS Mojave, so you will need to install an older version manually, see: https://stackoverflow.com/a/61046761
   * Also, if you don't already have it installed, install the Command Line Tools:

     .. code-block:: bash

        xcode-select --install
        # This command will not succeed if you have not installed Xcode.app
        sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer
        # If you installed Xcode.app manually, you need to either open it or run:
        sudo xcodebuild -license
        # To accept the Xcode.app license

#.
   **brew** *(needed to install more stuff; you probably already have this)*:


   * Follow installation instructions at http://brew.sh/
   *
     *Optional*: Check that ``brew`` is happy with your system configuration by running:

     .. code-block:: bash

        brew doctor

     Fix any problems that it identifies.

#.
   Use ``brew`` to install more stuff:

   .. code-block:: bash

      brew install asio assimp bison bullet cmake console_bridge cppcheck \
        cunit eigen freetype graphviz opencv openssl orocos-kdl pcre poco \
        pyqt@5 python qt@5 sip spdlog tinyxml2

#.
   Setup some environment variables:

   .. code-block:: bash

      # Add the openssl dir for DDS-Security
      # if you are using BASH, then replace '.zshrc' with '.bashrc'
      echo ""export OPENSSL_ROOT_DIR=$(brew --prefix openssl)"" >> ~/.zshrc

      # Add the Qt directory to the PATH and CMAKE_PREFIX_PATH
      export CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:$(brew --prefix qt@5)
      export PATH=$PATH:$(brew --prefix qt@5)/bin

#.
   Use ``python3 -m pip`` (just ``pip`` may install Python3 or Python2) to install more stuff:

   .. code-block:: bash

      python3 -m pip install --upgrade pip

      python3 -m pip install -U \
        --config-settings=""--global-option=build_ext"" \
        --config-settings=""--global-option=-I$(brew --prefix graphviz)/include/"" \
        --config-settings=""--global-option=-L$(brew --prefix graphviz)/lib/"" \
        argcomplete catkin_pkg colcon-common-extensions coverage \
        cryptography empy flake8 flake8-blind-except==0.1.1 flake8-builtins \
        flake8-class-newline flake8-comprehensions flake8-deprecated \
        flake8-docstrings flake8-import-order flake8-quotes \
        importlib-metadata jsonschema lark==1.1.1 lxml matplotlib mock mypy==0.931 netifaces \
        nose pep8 psutil pydocstyle pydot pygraphviz pyparsing==2.4.7 \
        pytest-mock rosdep rosdistro setuptools==59.6.0 vcstool

   Please ensure that the ``$PATH`` environment variable contains the install location of the binaries (``$(brew --prefix)/bin``)

#.
   *Optional*: if you want to build the ROS 1<->2 bridge, then you must also install ROS 1:


   * Start with the normal install instructions: http://wiki.ros.org/kinetic/Installation/OSX/Homebrew/Source
   *
     When you get to the step where you call ``rosinstall_generator`` to get the source code, here's an alternate invocation that brings in just the minimum required to produce a useful bridge:

     .. code-block:: bash

        rosinstall_generator catkin common_msgs roscpp rosmsg --rosdistro kinetic --deps --wet-only --tar > kinetic-ros2-bridge-deps.rosinstall
        wstool init -j8 src kinetic-ros2-bridge-deps.rosinstall


     Otherwise, just follow the normal instructions, then source the resulting ``install_isolated/setup.bash`` before proceeding here to build ROS 2.

Disable System Integrity Protection (SIP)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

macOS/OS X versions >=10.11 have System Integrity Protection enabled by default.
So that SIP doesn't prevent processes from inheriting dynamic linker environment variables, such as ``DYLD_LIBRARY_PATH``, you'll need to disable it `following these instructions <https://developer.apple.com/library/content/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html>`__.

Build ROS 2
-----------

Get ROS 2 code
^^^^^^^^^^^^^^

Create a workspace and clone all repos:

.. code-block:: bash

   mkdir -p ~/ros2_{DISTRO}/src
   cd ~/ros2_{DISTRO}
   vcs import --input https://raw.githubusercontent.com/ros2/ros2/{REPOS_FILE_BRANCH}/ros2.repos src

Install additional RMW implementations (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default middleware that ROS 2 uses is ``Fast DDS``, but the middleware (RMW) can be replaced at build or runtime.
See the :doc:`guide <../../How-To-Guides/Working-with-multiple-RMW-implementations>` on how to work with multiple RMWs.

Build the code in the workspace
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Run the ``colcon`` tool to build everything (more on using ``colcon`` in :doc:`this tutorial <../../Tutorials/Beginner-Client-Libraries/Colcon-Tutorial>`):

.. code-block:: bash

   cd ~/ros2_{DISTRO}/
   colcon build --symlink-install --packages-skip-by-dep python_qt_binding

Note: due to an unresolved issue with SIP, Qt@5, and PyQt5, we need to disable ``python_qt_binding`` to have the build succeed.
This will be removed when the issue is resolved, see: https://github.com/ros-visualization/python_qt_binding/issues/103

Setup environment
-----------------

Source the ROS 2 setup file:

.. code-block:: bash

   . ~/ros2_{DISTRO}/install/setup.zsh

This will automatically set up the environment for any DDS vendors that support was built for.

Try some examples
-----------------

In one terminal, set up the ROS 2 environment as described above and then run a C++ ``talker``:

.. code-block:: bash

   ros2 run demo_nodes_cpp talker

In another terminal source the setup file and then run a Python ``listener``:

.. code-block:: bash

   ros2 run demo_nodes_py listener

You should see the ``talker`` saying that it's ``Publishing`` messages and the ``listener`` saying ``I heard`` those messages.
This verifies both the C++ and Python APIs are working properly.
Hooray!

Next steps
----------

Continue with the `tutorials and demos <../../Tutorials>` to configure your environment, create your own workspace and packages, and learn ROS 2 core concepts.

Use the ROS 1 bridge (optional)
-------------------------------

The ROS 1 bridge can connect topics from ROS 1 to ROS 2 and vice-versa.
See the dedicated `documentation <https://github.com/ros2/ros1_bridge/blob/master/README.md>`__ on how to build and use the ROS 1 bridge.

Stay up to date
---------------

See :doc:`../Maintaining-a-Source-Checkout` to periodically refresh your source installation.

Troubleshoot
------------

Troubleshooting techniques can be found :ref:`here <macOS-troubleshooting>`.

Uninstall
---------

1. If you installed your workspace with colcon as instructed above, ""uninstalling"" could be just a matter of opening a new terminal and not sourcing the workspace's ``setup`` file.
   This way, your environment will behave as though there is no {DISTRO_TITLE} install on your system.

2. If you're also trying to free up space, you can delete the entire workspace directory with:

   .. code-block:: bash

      rm -rf ~/ros2_{DISTRO}
",What are the system requirements for installing ROS 2 on macOS Mojave (10.14)?
"Latest development (source)
===========================

If you plan to contribute directly to the latest ROS 2 development, you can install ROS 2 by building it from source or installing testing binaries.
This will give you the latest bug fixes and features.

Testing binaries
----------------

See :doc:`Testing <../Testing>`.

Build from source
-----------------

.. note::

   The latest development does not go through the same rigorous testing as releases and is not recommended if you are looking for a stable version of ROS 2.
   Instead, choose a :doc:`ROS distribution <../../Installation>` that has already been released.

Follow the links below for the latest setup instructions for your platform:

* :doc:`Ubuntu Linux <Ubuntu-Development-Setup>`
* :doc:`Windows <Windows-Development-Setup>`
* :doc:`RHEL <RHEL-Development-Setup>`
* :doc:`macOS <macOS-Development-Setup>`

For keeping your source code up-to-date, see :doc:`Maintain a source checkout <../Maintaining-a-Source-Checkout>`.
",What instructions are provided for building ROS 2 from source for the latest development?
".. redirect-from::

  Installation/Alternatives/Fedora-Development-Setup
  Installation/Fedora-Development-Setup
  Installation/RHEL-Development-Setup

RHEL (source)
=============

.. contents:: Table of Contents
   :depth: 2
   :local:


System requirements
-------------------
The current target Red Hat platforms for {DISTRO_TITLE_FULL} are:

- Tier 2: RHEL 9 64-bit

As defined in `REP 2000 <https://www.ros.org/reps/rep-2000.html>`_.

System setup
------------

Set locale
^^^^^^^^^^

.. include:: ../_RHEL-Set-Locale.rst

Enable required repositories
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. tabs::

  .. group-tab:: RHEL

    The rosdep database contains packages from the EPEL and PowerTools repositories, which are not enabled by default.
    They can be enabled by running:

    .. code-block:: bash

      sudo dnf install 'dnf-command(config-manager)' epel-release -y
      sudo dnf config-manager --set-enabled crb

    .. note:: This step may be slightly different depending on the distribution you are using. Check the EPEL documentation: https://docs.fedoraproject.org/en-US/epel/#_quickstart

  .. group-tab:: Fedora

    No additional setup required.


Install development tools
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: bash

   sudo dnf install -y \
     cmake \
     gcc-c++ \
     git \
     make \
     patch \
     python3-colcon-common-extensions \
     python3-mypy \
     python3-pip \
     python3-pydocstyle \
     python3-pytest \
     python3-pytest-cov \
     python3-pytest-mock \
     python3-pytest-repeat \
     python3-pytest-rerunfailures \
     python3-pytest-runner \
     python3-rosdep \
     python3-setuptools \
     python3-vcstool \
     wget

   # install some pip packages needed for testing and
   # not available as RPMs
   python3 -m pip install -U --user \
     flake8-blind-except==0.1.1 \
     flake8-class-newline \
     flake8-deprecated

Build ROS 2
-----------

Get ROS 2 code
^^^^^^^^^^^^^^

Create a workspace and clone all repos:

.. code-block:: bash

   mkdir -p ~/ros2_{DISTRO}/src
   cd ~/ros2_{DISTRO}
   vcs import --input https://raw.githubusercontent.com/ros2/ros2/{REPOS_FILE_BRANCH}/ros2.repos src

Install dependencies using rosdep
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. include:: ../_Dnf-Update-Admonition.rst

.. code-block:: bash

   sudo rosdep init
   rosdep update
   rosdep install --from-paths src --ignore-src -y --skip-keys ""fastcdr rti-connext-dds-6.0.1 urdfdom_headers""

Install additional RMW implementations (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default middleware that ROS 2 uses is ``Fast DDS``, but the middleware (RMW) can be replaced at build or runtime.
See the :doc:`guide <../../How-To-Guides/Working-with-multiple-RMW-implementations>` on how to work with multiple RMWs.

Build the code in the workspace
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you have already installed ROS 2 another way (either via RPMs or the binary distribution), make sure that you run the below commands in a fresh environment that does not have those other installations sourced.
Also ensure that you do not have ``source /opt/ros/${ROS_DISTRO}/setup.bash`` in your ``.bashrc``.
You can make sure that ROS 2 is not sourced with the command ``printenv | grep -i ROS``.
The output should be empty.

More info on working with a ROS workspace can be found in :doc:`this tutorial <../../Tutorials/Beginner-Client-Libraries/Colcon-Tutorial>`.

.. code-block:: bash

   cd ~/ros2_{DISTRO}/
   colcon build --symlink-install

.. note::

   If you are having trouble compiling all examples and this is preventing you from completing a successful build, you can use the ``--packages-skip`` colcon flag to ignore the package that is causing problems.
   For instance, if you don't want to install the large OpenCV library, you could skip building the packages that depend on it using the command:

   .. code-block:: bash

      colcon build --symlink-install --packages-skip image_tools intra_process_demo

Setup environment
-----------------

Set up your environment by sourcing the following file.

.. code-block:: bash

   # Replace "".bash"" with your shell if you're not using bash
   # Possible values are: setup.bash, setup.sh, setup.zsh
   . ~/ros2_{DISTRO}/install/local_setup.bash

Try some examples
-----------------

In one terminal, source the setup file and then run a C++ ``talker``\ :

.. code-block:: bash

   . ~/ros2_{DISTRO}/install/local_setup.bash
   ros2 run demo_nodes_cpp talker

In another terminal source the setup file and then run a Python ``listener``\ :

.. code-block:: bash

   . ~/ros2_{DISTRO}/install/local_setup.bash
   ros2 run demo_nodes_py listener

You should see the ``talker`` saying that it's ``Publishing`` messages and the ``listener`` saying ``I heard`` those messages.
This verifies both the C++ and Python APIs are working properly.
Hooray!

Next steps
----------

Continue with the :doc:`tutorials and demos <../../Tutorials>` to configure your environment, create your own workspace and packages, and learn ROS 2 core concepts.

Alternate compilers
-------------------

Using a different compiler besides gcc to compile ROS 2 is easy. If you set the environment variables ``CC`` and ``CXX`` to executables for a working C and C++ compiler, respectively, and retrigger CMake configuration (by using ``--force-cmake-config`` or by deleting the packages you want to be affected), CMake will reconfigure and use the different compiler.

Clang
^^^^^

To configure CMake to detect and use Clang:

.. code-block:: bash

   sudo dnf install clang
   export CC=clang
   export CXX=clang++
   colcon build --cmake-force-configure

Stay up to date
---------------

See :doc:`../Maintaining-a-Source-Checkout` to periodically refresh your source installation.

Troubleshoot
------------

Troubleshooting techniques can be found :ref:`here <linux-troubleshooting>`.

Uninstall
---------

1. If you installed your workspace with colcon as instructed above, ""uninstalling"" could be just a matter of opening a new terminal and not sourcing the workspace's ``setup`` file.
   This way, your environment will behave as though there is no {DISTRO_TITLE} install on your system.

2. If you're also trying to free up space, you can delete the entire workspace directory with:

   .. code-block:: bash

    rm -rf ~/ros2_{DISTRO}
",What steps are required to set up a RHEL development environment for ROS 2 based on the provided text?
".. redirect-from::

   Installation/Linux-Install-Binary

Ubuntu (binary)
===============

.. contents:: Table of Contents
   :depth: 2
   :local:

This page explains how to install ROS 2 on Ubuntu Linux from a pre-built binary package.

.. note::

    The pre-built binary does not include all ROS 2 packages.
    All packages in the `ROS base variant <https://ros.org/reps/rep-2001.html#ros-base>`_ are included, and only a subset of packages in the `ROS desktop variant <https://ros.org/reps/rep-2001.html#desktop-variants>`_ are included.
    The exact list of packages are described by the repositories listed in `this ros2.repos file <https://github.com/ros2/ros2/blob/{REPOS_FILE_BRANCH}/ros2.repos>`_.

There are also :doc:`deb packages <../Ubuntu-Install-Debs>` available.

System requirements
-------------------

We currently support Ubuntu Noble (24.04) 64-bit x86 and 64-bit ARM.
The Rolling Ridley distribution will change target platforms from time to time as new platforms are selected for development.
Most people will want to use a stable ROS distribution.

System setup
------------

Set locale
^^^^^^^^^^

.. include:: ../_Ubuntu-Set-Locale.rst

Enable required repositories
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. include:: ../_Apt-Repositories.rst

Install prerequisites
^^^^^^^^^^^^^^^^^^^^^

There are a few packages that must be installed in order to get and unpack the binary release.

.. code-block:: bash

   sudo apt install tar bzip2 wget -y

Install development tools (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you are going to build ROS packages or otherwise do development, you can also install the development tools:

.. code-block:: bash

   sudo apt update && sudo apt install ros-dev-tools

Install ROS 2
-------------

Binary releases of Rolling Ridley are not provided.
Instead you may download nightly :ref:`prerelease binaries <Prerelease_binaries>`.

* Download the latest package for Ubuntu; let's assume that it ends up at ``~/Downloads/ros2-package-linux-x86_64.tar.bz2``.

  * Note: there may be more than one binary download option which might cause the file name to differ.

*
  Unpack it:

  .. code-block:: bash

     mkdir -p ~/ros2_{DISTRO}
     cd ~/ros2_{DISTRO}
     tar xf ~/Downloads/ros2-package-linux-x86_64.tar.bz2

.. _linux-install-binary-install-missing-dependencies:

Install dependencies using rosdep
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. include:: ../_Apt-Upgrade-Admonition.rst

.. code-block:: bash

   sudo apt update
   sudo apt install -y python3-rosdep
   sudo rosdep init
   rosdep update
   rosdep install --from-paths ~/ros2_{DISTRO}/ros2-linux/share --ignore-src -y --skip-keys ""cyclonedds fastcdr fastrtps iceoryx_binding_c rmw_connextdds rti-connext-dds-6.0.1 urdfdom_headers""

.. include:: ../_rosdep_Linux_Mint.rst

Install additional RMW implementations (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default middleware that ROS 2 uses is ``Fast DDS``, but the middleware (RMW) can be replaced at runtime.
See the :doc:`guide <../../How-To-Guides/Working-with-multiple-RMW-implementations>` on how to work with multiple RMWs.

Setup environment
-----------------

Set up your environment by sourcing the following file.

.. code-block:: bash

   # Replace "".bash"" with your shell if you're not using bash
   # Possible values are: setup.bash, setup.sh, setup.zsh
   . ~/ros2_{DISTRO}/ros2-linux/setup.bash

Try some examples
-----------------

In one terminal, source the setup file and then run a C++ ``talker``:

.. code-block:: bash

   . ~/ros2_{DISTRO}/ros2-linux/setup.bash
   ros2 run demo_nodes_cpp talker

In another terminal source the setup file and then run a Python ``listener``:

.. code-block:: bash

   . ~/ros2_{DISTRO}/ros2-linux/setup.bash
   ros2 run demo_nodes_py listener

You should see the ``talker`` saying that it's ``Publishing`` messages and the ``listener`` saying ``I heard`` those messages.
This verifies both the C++ and Python APIs are working properly.
Hooray!

Next steps
----------

Continue with the :doc:`tutorials and demos <../../Tutorials>` to configure your environment, create your own workspace and packages, and learn ROS 2 core concepts.

Troubleshoot
------------

Troubleshooting techniques can be found :doc:`here <../../How-To-Guides/Installation-Troubleshooting>`.

Uninstall
---------

1. If you installed your workspace with colcon as instructed above, ""uninstalling"" could be just a matter of opening a new terminal and not sourcing the workspace's ``setup`` file.
   This way, your environment will behave as though there is no {DISTRO_TITLE} install on your system.

2. If you're also trying to free up space, you can delete the entire workspace directory with:

   .. code-block:: bash

      rm -rf ~/ros2_{DISTRO}
",What system requirements are needed to install ROS 2 on Ubuntu Linux from a pre-built binary package?
".. redirect-from::

   Installation/Windows-Development-Setup

Windows (source)
================

.. contents:: Table of Contents
   :depth: 2
   :local:

This guide is about how to setup a development environment for ROS 2 on Windows.

System requirements
-------------------

Only Windows 10 is supported.

Language support
^^^^^^^^^^^^^^^^

Make sure you have a locale which supports ``UTF-8``.
For example, for a Chinese-language Windows 10 installation, you may need to install an `English language pack <https://support.microsoft.com/en-us/windows/language-packs-for-windows-a5094319-a92d-18de-5b53-1cfc697cfca8>`_.

.. include:: ../_Windows-Install-Prerequisites.rst

Install additional prerequisites from Chocolatey
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: bash

   choco install -y cppcheck curl git winflexbison3

You will need to append the Git cmd folder ``C:\Program Files\Git\cmd`` to the PATH (you can do this by clicking the Windows icon, typing ""Environment Variables"", then clicking on ""Edit the system environment variables"".
In the resulting dialog, click ""Environment Variables"", the click ""Path"" on the bottom pane, then click ""Edit"" and add the path).

Install Python prerequisites
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Install additional Python dependencies:

.. code-block:: bash

   pip install -U colcon-common-extensions coverage flake8 flake8-blind-except flake8-builtins flake8-class-newline flake8-comprehensions flake8-deprecated flake8-docstrings flake8-import-order flake8-quotes mock mypy==0.931 pep8 pydocstyle pytest pytest-cov pytest-mock pytest-repeat pytest-rerunfailures pytest-runner vcstool

Build ROS 2
-----------

Get ROS 2 code
^^^^^^^^^^^^^^

Now that we have the development tools we can get the ROS 2 source code.

First setup a development folder, for example ``C:\{DISTRO}``:

.. note::

   It is very important that the chosen path is short, due to the short default Windows path limits (260 characters).
   To allow longer paths, see https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry.

.. code-block:: bash

   md \{DISTRO}\src
   cd \{DISTRO}

Get the ``ros2.repos`` file which defines the repositories to clone from:

.. code-block:: bash

   vcs import --input https://raw.githubusercontent.com/ros2/ros2/{REPOS_FILE_BRANCH}/ros2.repos src

Install additional RMW implementations (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default middleware that ROS 2 uses is ``Fast DDS``, but the middleware (RMW) can be replaced at build or runtime.
See the :doc:`guide <../../How-To-Guides/Working-with-multiple-RMW-implementations>` on how to work with multiple RMWs.

Build the code in the workspace
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _windows-dev-build-ros2:

To build ROS 2 you will need a Visual Studio Command Prompt (""x64 Native Tools Command Prompt for VS 2019"") running as Administrator.

To build the ``\{DISTRO}`` folder tree:

.. code-block:: bash

   colcon build --merge-install

.. note::

   We're using ``--merge-install`` here to avoid a ``PATH`` variable that is too long at the end of the build.
   If you're adapting these instructions to build a smaller workspace then you might be able to use the default behavior which is isolated install, i.e. where each package is installed to a different folder.

.. note::

   If you are doing a debug build use ``python_d path\to\colcon_executable`` ``colcon``.
   See `Extra stuff for debug mode`_ for more info on running Python code in debug builds on Windows.

Setup environment
-----------------

Start a command shell and source the ROS 2 setup file to set up the workspace:

.. code-block:: bash

   call C:\{DISTRO}\install\local_setup.bat

This will automatically set up the environment for any DDS vendors that support was built for.

It is normal that the previous command, if nothing else went wrong, outputs ""The system cannot find the path specified."" exactly once.

Try some examples
-----------------

Note that the first time you run any executable you will have to allow access to the network through a Windows Firewall popup.

You can run the tests using this command:

.. code-block:: bash

   colcon test --merge-install

.. note::

   ``--merge-install`` should only be used if it was also used in the build step.

Afterwards you can get a summary of the tests using this command:

.. code-block:: bash

   colcon test-result

To run the examples, first open a clean new ``cmd.exe`` and set up the workspace by sourcing the ``local_setup.bat`` file.
Then, run a C++ ``talker``\ :

.. code-block:: bash

   call install\local_setup.bat
   ros2 run demo_nodes_cpp talker

In a separate shell you can do the same, but instead run a Python ``listener``\ :

.. code-block:: bash

   call install\local_setup.bat
   ros2 run demo_nodes_py listener

You should see the ``talker`` saying that it's ``Publishing`` messages and the ``listener`` saying ``I heard`` those messages.
This verifies both the C++ and Python APIs are working properly.
Hooray!

.. note::

   It is not recommended to build in the same cmd prompt that you've sourced the ``local_setup.bat``.

Next steps
----------

Continue with the :doc:`tutorials and demos <../../Tutorials>` to configure your environment, create your own workspace and packages, and learn ROS 2 core concepts.

Extra stuff for Debug mode
--------------------------

If you want to be able to run all the tests in Debug mode, you'll need to install a few more things:

* To be able to extract the Python source tarball, you can use PeaZip:

.. code-block:: bash

   choco install -y peazip

* You'll also need SVN, since some of the Python source-build dependencies are checked out via SVN:

.. code-block:: bash

   choco install -y svn hg

* You'll need to quit and restart the command prompt after installing the above.
* Get and extract the Python 3.8.3 source from the ``tgz``:

  * https://www.python.org/ftp/python/3.8.3/Python-3.8.3.tgz
  * To keep these instructions concise, please extract it to ``C:\dev\Python-3.8.3``

* Now, build the Python source in debug mode from a Visual Studio command prompt:

.. code-block:: bash

   cd C:\dev\Python-3.8.3\PCbuild
   get_externals.bat
   build.bat -p x64 -d

* Finally, copy the build products into the Python38 installation directories, next to the Release-mode Python executable and DLL's:

.. code-block:: bash

   cd C:\dev\Python-3.8.3\PCbuild\amd64
   copy python_d.exe C:\Python38 /Y
   copy python38_d.dll C:\Python38 /Y
   copy python3_d.dll C:\Python38 /Y
   copy python38_d.lib C:\Python38\libs /Y
   copy python3_d.lib C:\Python38\libs /Y
   copy sqlite3_d.dll C:\Python38\DLLs /Y
   for %I in (*_d.pyd) do copy %I C:\Python38\DLLs /Y

* Now, from a fresh command prompt, make sure that ``python_d`` works:

.. code-block:: bash

   python_d -c ""import _ctypes ; import coverage""

* Once you have verified the operation of ``python_d``, it is necessary to reinstall a few dependencies with the debug-enabled libraries:

.. code-block:: bash

   python_d -m pip install --force-reinstall https://github.com/ros2/ros2/releases/download/numpy-archives/numpy-1.18.4-cp38-cp38d-win_amd64.whl
   python_d -m pip install --force-reinstall https://github.com/ros2/ros2/releases/download/lxml-archives/lxml-4.5.1-cp38-cp38d-win_amd64.whl

* To verify the installation of these dependencies:

.. code-block:: bash

   python_d -c ""from lxml import etree ; import numpy""

* When you wish to return to building release binaries, it is necessary to uninstall the debug variants and use the release variants:

.. code-block:: bash

   python -m pip uninstall numpy lxml
   python -m pip install numpy lxml

* To create executables python scripts(.exe), python_d should be used to invoke colcon

.. code-block:: bash

   python_d path\to\colcon_executable build

* Hooray, you're done!

Stay up to date
---------------

See :doc:`../Maintaining-a-Source-Checkout` to periodically refresh your source installation.

Troubleshoot
------------

Troubleshooting techniques can be found :ref:`here <windows-troubleshooting>`.

Uninstall
---------

1. If you installed your workspace with colcon as instructed above, ""uninstalling"" could be just a matter of opening a new terminal and not sourcing the workspace's ``setup`` file.
   This way, your environment will behave as though there is no {DISTRO_TITLE} install on your system.

2. If you're also trying to free up space, you can delete the entire workspace directory with:

   .. code-block:: bash

      rmdir /s /q \ros2_{DISTRO}
",What is the recommended step to take in order to uninstall a workspace created with colcon?
"RHEL (binary)
=============

.. contents:: Table of Contents
   :depth: 2
   :local:

This page explains how to install ROS 2 on RHEL from a pre-built binary package.

.. note::

   The pre-built binary does not include all ROS 2 packages.
   All packages in the `ROS base variant <https://ros.org/reps/rep-2001.html#ros-base>`_ are included, and only a subset of packages in the `ROS desktop variant <https://ros.org/reps/rep-2001.html#desktop-variants>`_ are included.
   The exact list of packages are described by the repositories listed in `this ros2.repos file <https://github.com/ros2/ros2/blob/{REPOS_FILE_BRANCH}/ros2.repos>`_.

There are also :doc:`RPM packages <../RHEL-Install-RPMs>` available.

System requirements
-------------------

We currently support RHEL 9 64-bit.
The Rolling Ridley distribution will change target platforms from time to time as new platforms are selected for development.
Most people will want to use a stable ROS distribution.

System setup
------------

Set locale
^^^^^^^^^^

.. include:: ../_RHEL-Set-Locale.rst

Enable required repositories
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The rosdep database contains packages from the EPEL and PowerTools repositories, which are not enabled by default.
They can be enabled by running:

.. code-block:: bash

   sudo dnf install 'dnf-command(config-manager)' epel-release -y
   sudo dnf config-manager --set-enabled crb

.. note:: This step may be slightly different depending on the distribution you are using. Check the EPEL documentation: https://docs.fedoraproject.org/en-US/epel/#_quickstart

Install prerequisites
^^^^^^^^^^^^^^^^^^^^^

There are a few packages that must be installed in order to get and unpack the binary release.

.. code-block:: bash

   sudo dnf install tar bzip2 wget -y

Install development tools (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you are going to build ROS packages or otherwise do development, you can also install the development tools:

.. code-block:: bash

   sudo dnf install -y \
     cmake \
     gcc-c++ \
     git \
     make \
     patch \
     python3-colcon-common-extensions \
     python3-mypy \
     python3-pip \
     python3-pydocstyle \
     python3-pytest \
     python3-pytest-repeat \
     python3-pytest-rerunfailures \
     python3-rosdep \
     python3-setuptools \
     python3-vcstool \
     wget

   # install some pip packages needed for testing and
   # not available as RPMs
   python3 -m pip install -U --user \
     flake8-blind-except==0.1.1 \
     flake8-class-newline \
     flake8-deprecated

Install ROS 2
-------------

Binary releases of Rolling Ridley are not provided.
Instead you may download nightly :ref:`prerelease binaries <Prerelease_binaries>`.

* Download the latest package for RHEL; let's assume that it ends up at ``~/Downloads/ros2-package-linux-x86_64.tar.bz2``.

  * Note: there may be more than one binary download option which might cause the file name to differ.

* Unpack it:

  .. code-block:: bash

     mkdir -p ~/ros2_{DISTRO}
     cd ~/ros2_{DISTRO}
     tar xf ~/Downloads/ros2-package-linux-x86_64.tar.bz2

Install dependencies using rosdep
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. include:: ../_Dnf-Update-Admonition.rst

.. code-block:: bash

   sudo rosdep init
   rosdep update
   rosdep install --from-paths ~/ros2_{DISTRO}/ros2-linux/share --ignore-src -y --skip-keys ""cyclonedds fastcdr fastrtps iceoryx_binding_c rti-connext-dds-6.0.1 urdfdom_headers""

Install additional RMW implementations (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default middleware that ROS 2 uses is ``Fast DDS``, but the middleware (RMW) can be replaced at runtime.
See the :doc:`guide <../../How-To-Guides/Working-with-multiple-RMW-implementations>` on how to work with multiple RMWs.

Setup environment
-----------------

Set up your environment by sourcing the following file.

.. code-block:: bash

   # Replace "".bash"" with your shell if you're not using bash
   # Possible values are: setup.bash, setup.sh, setup.zsh
   . ~/ros2_{DISTRO}/ros2-linux/setup.bash

Try some examples
-----------------

In one terminal, source the setup file and then run a C++ ``talker``:

.. code-block:: bash

   . ~/ros2_{DISTRO}/ros2-linux/setup.bash
   ros2 run demo_nodes_cpp talker

In another terminal source the setup file and then run a Python ``listener``:

.. code-block:: bash

   . ~/ros2_{DISTRO}/ros2-linux/setup.bash
   ros2 run demo_nodes_py listener

You should see the ``talker`` saying that it's ``Publishing`` messages and the ``listener`` saying ``I heard`` those messages.
This verifies both the C++ and Python APIs are working properly.
Hooray!

Next steps
----------

Continue with the :doc:`tutorials and demos <../../Tutorials>` to configure your environment, create your own workspace and packages, and learn ROS 2 core concepts.

Troubleshoot
------------

Troubleshooting techniques can be found :doc:`here <../../How-To-Guides/Installation-Troubleshooting>`.

Uninstall
---------

1. If you installed your workspace with colcon as instructed above, ""uninstalling"" could be just a matter of opening a new terminal and not sourcing the workspace's ``setup`` file.
   This way, your environment will behave as though there is no {DISTRO_TITLE} install on your system.

2. If you're also trying to free up space, you can delete the entire workspace directory with:

   .. code-block:: bash

      rm -rf ~/ros2_{DISTRO}
",What system requirements are needed to install ROS 2 on RHEL from a pre-built binary package?
